*** File C:\cygwin\workspace\_git_repos\CustomizeOgg_static\GprofCdt/../src/bitwise.c:
                /********************************************************************
                 *                                                                  *
                 * THIS FILE IS PART OF THE Ogg CONTAINER SOURCE CODE.              *
                 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
                 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
                 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
                 *                                                                  *
                 * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2010             *
                 * by the Xiph.Org Foundation http://www.xiph.org/                  *
                 *                                                                  *
                 ********************************************************************
                
                  function: packing variable sized words into an octet stream
                  last mod: $Id: bitwise.c 17287 2010-06-10 13:42:06Z tterribe $
                
                 ********************************************************************/
                
                /* We're 'LSb' endian; if we write a word but read individual bits,
                   then we'll read the lsb first */
                
                #include <string.h>
                #include <stdlib.h>
                #include <limits.h>
                #include <ogg/ogg.h>
                
                #define BUFFER_INCREMENT 256
                
                static const unsigned long mask[]=
                {0x00000000,0x00000001,0x00000003,0x00000007,0x0000000f,
                 0x0000001f,0x0000003f,0x0000007f,0x000000ff,0x000001ff,
                 0x000003ff,0x000007ff,0x00000fff,0x00001fff,0x00003fff,
                 0x00007fff,0x0000ffff,0x0001ffff,0x0003ffff,0x0007ffff,
                 0x000fffff,0x001fffff,0x003fffff,0x007fffff,0x00ffffff,
                 0x01ffffff,0x03ffffff,0x07ffffff,0x0fffffff,0x1fffffff,
                 0x3fffffff,0x7fffffff,0xffffffff };
                
                static const unsigned int mask8B[]=
                {0x00,0x80,0xc0,0xe0,0xf0,0xf8,0xfc,0xfe,0xff};
                
       ##### -> void oggpack_writeinit(oggpack_buffer *b){
                  memset(b,0,sizeof(*b));
                  b->ptr=b->buffer=_ogg_malloc(BUFFER_INCREMENT);
                  b->buffer[0]='\0';
                  b->storage=BUFFER_INCREMENT;
                }
                
       ##### -> void oggpackB_writeinit(oggpack_buffer *b){
                  oggpack_writeinit(b);
                }
                
       ##### -> int oggpack_writecheck(oggpack_buffer *b){
                  if(!b->ptr || !b->storage)return -1;
                  return 0;
                }
                
       ##### -> int oggpackB_writecheck(oggpack_buffer *b){
                  return oggpack_writecheck(b);
                }
                
       ##### -> void oggpack_writetrunc(oggpack_buffer *b,long bits){
                  long bytes=bits>>3;
                  if(b->ptr){
                    bits-=bytes*8;
                    b->ptr=b->buffer+bytes;
                    b->endbit=bits;
                    b->endbyte=bytes;
                    *b->ptr&=mask[bits];
                  }
                }
                
       ##### -> void oggpackB_writetrunc(oggpack_buffer *b,long bits){
                  long bytes=bits>>3;
                  if(b->ptr){
                    bits-=bytes*8;
                    b->ptr=b->buffer+bytes;
                    b->endbit=bits;
                    b->endbyte=bytes;
                    *b->ptr&=mask8B[bits];
                  }
                }
                
                /* Takes only up to 32 bits. */
       ##### -> void oggpack_write(oggpack_buffer *b,unsigned long value,int bits){
                  if(bits<0 || bits>32) goto err;
                  if(b->endbyte>=b->storage-4){
                    void *ret;
                    if(!b->ptr)return;
                    if(b->storage>LONG_MAX-BUFFER_INCREMENT) goto err;
                    ret=_ogg_realloc(b->buffer,b->storage+BUFFER_INCREMENT);
                    if(!ret) goto err;
                    b->buffer=ret;
                    b->storage+=BUFFER_INCREMENT;
                    b->ptr=b->buffer+b->endbyte;
                  }
                
                  value&=mask[bits]; 
                  bits+=b->endbit;
                
                  b->ptr[0]|=value<<b->endbit;  
                  
                  if(bits>=8){
                    b->ptr[1]=(unsigned char)(value>>(8-b->endbit));
                    if(bits>=16){
                      b->ptr[2]=(unsigned char)(value>>(16-b->endbit));
                      if(bits>=24){
                        b->ptr[3]=(unsigned char)(value>>(24-b->endbit));
                        if(bits>=32){
                          if(b->endbit)
                            b->ptr[4]=(unsigned char)(value>>(32-b->endbit));
                          else
                            b->ptr[4]=0;
                        }
                      }
                    }
                  }
                
                  b->endbyte+=bits/8;
                  b->ptr+=bits/8;
                  b->endbit=bits&7;
                  return;
                 err:
                  oggpack_writeclear(b);
                }
                
                /* Takes only up to 32 bits. */
       ##### -> void oggpackB_write(oggpack_buffer *b,unsigned long value,int bits){
                  if(bits<0 || bits>32) goto err;
                  if(b->endbyte>=b->storage-4){
                    void *ret;
                    if(!b->ptr)return;
                    if(b->storage>LONG_MAX-BUFFER_INCREMENT) goto err;
                    ret=_ogg_realloc(b->buffer,b->storage+BUFFER_INCREMENT);
                    if(!ret) goto err;
                    b->buffer=ret;
                    b->storage+=BUFFER_INCREMENT;
                    b->ptr=b->buffer+b->endbyte;
                  }
                
                  value=(value&mask[bits])<<(32-bits); 
                  bits+=b->endbit;
                
                  b->ptr[0]|=value>>(24+b->endbit);  
                  
                  if(bits>=8){
                    b->ptr[1]=(unsigned char)(value>>(16+b->endbit));
                    if(bits>=16){
                      b->ptr[2]=(unsigned char)(value>>(8+b->endbit));
                      if(bits>=24){
                        b->ptr[3]=(unsigned char)(value>>(b->endbit));
                        if(bits>=32){
                          if(b->endbit)
                            b->ptr[4]=(unsigned char)(value<<(8-b->endbit));
                          else
                            b->ptr[4]=0;
                        }
                      }
                    }
                  }
                
                  b->endbyte+=bits/8;
                  b->ptr+=bits/8;
                  b->endbit=bits&7;
                  return;
                 err:
                  oggpack_writeclear(b);
                }
                
       ##### -> void oggpack_writealign(oggpack_buffer *b){
                  int bits=8-b->endbit;
                  if(bits<8)
                    oggpack_write(b,0,bits);
                }
                
       ##### -> void oggpackB_writealign(oggpack_buffer *b){
                  int bits=8-b->endbit;
                  if(bits<8)
                    oggpackB_write(b,0,bits);
                }
                
                static void oggpack_writecopy_helper(oggpack_buffer *b,
                                                     void *source,
                                                     long bits,
                                                     void (*w)(oggpack_buffer *,
                                                               unsigned long,
                                                               int),
                                                     int msb){
                  unsigned char *ptr=(unsigned char *)source;
                
                  long bytes=bits/8;
                  bits-=bytes*8;
                
                  if(b->endbit){
                    int i;
                    /* unaligned copy.  Do it the hard way. */
                    for(i=0;i<bytes;i++)
                      w(b,(unsigned long)(ptr[i]),8);    
                  }else{
                    /* aligned block copy */
                    if(b->endbyte+bytes+1>=b->storage){
                      void *ret;
                      if(!b->ptr) goto err;
                      if(b->endbyte+bytes+BUFFER_INCREMENT>b->storage) goto err;
                      b->storage=b->endbyte+bytes+BUFFER_INCREMENT;
                      ret=_ogg_realloc(b->buffer,b->storage);
                      if(!ret) goto err;
                      b->buffer=ret;
                      b->ptr=b->buffer+b->endbyte;
                    }
                
                    memmove(b->ptr,source,bytes);
                    b->ptr+=bytes;
                    b->endbyte+=bytes;
                    *b->ptr=0;
                
                  }
                  if(bits){
                    if(msb)
                      w(b,(unsigned long)(ptr[bytes]>>(8-bits)),bits);    
                    else
                      w(b,(unsigned long)(ptr[bytes]),bits);    
                  }
                  return;
                 err:
                  oggpack_writeclear(b);
                }
                
       ##### -> void oggpack_writecopy(oggpack_buffer *b,void *source,long bits){
                  oggpack_writecopy_helper(b,source,bits,oggpack_write,0);
                }
                
       ##### -> void oggpackB_writecopy(oggpack_buffer *b,void *source,long bits){
                  oggpack_writecopy_helper(b,source,bits,oggpackB_write,1);
                }
                
       ##### -> void oggpack_reset(oggpack_buffer *b){
                  if(!b->ptr)return;
                  b->ptr=b->buffer;
                  b->buffer[0]=0;
                  b->endbit=b->endbyte=0;
                }
                
       ##### -> void oggpackB_reset(oggpack_buffer *b){
                  oggpack_reset(b);
                }
                
       ##### -> void oggpack_writeclear(oggpack_buffer *b){
                  if(b->buffer)_ogg_free(b->buffer);
                  memset(b,0,sizeof(*b));
                }
                
       ##### -> void oggpackB_writeclear(oggpack_buffer *b){
                  oggpack_writeclear(b);
                }
                
        4506 -> void oggpack_readinit(oggpack_buffer *b,unsigned char *buf,int bytes){
                  memset(b,0,sizeof(*b));
                  b->buffer=b->ptr=buf;
                  b->storage=bytes;
                }
                
       ##### -> void oggpackB_readinit(oggpack_buffer *b,unsigned char *buf,int bytes){
                  oggpack_readinit(b,buf,bytes);
                }
                
                /* Read in bits without advancing the bitptr; bits <= 32 */
     4480203 -> long oggpack_look(oggpack_buffer *b,int bits){
                  unsigned long ret;
                  unsigned long m;
                
                  if(bits<0 || bits>32) return -1;
                  m=mask[bits];
                  bits+=b->endbit;
                
                  if(b->endbyte >= b->storage-4){
                    /* not the main path */
                    if(b->endbyte > b->storage-((bits+7)>>3)) return -1;
                    /* special case to avoid reading b->ptr[0], which might be past the end of
                        the buffer; also skips some useless accounting */
                    else if(!bits)return(0L);
                  }
                
                  ret=b->ptr[0]>>b->endbit;
                  if(bits>8){
                    ret|=b->ptr[1]<<(8-b->endbit);  
                    if(bits>16){
                      ret|=b->ptr[2]<<(16-b->endbit);  
                      if(bits>24){
                        ret|=b->ptr[3]<<(24-b->endbit);  
                        if(bits>32 && b->endbit)
                          ret|=b->ptr[4]<<(32-b->endbit);
                      }
                    }
                  }
                  return(m&ret);
                }
                
                /* Read in bits without advancing the bitptr; bits <= 32 */
       ##### -> long oggpackB_look(oggpack_buffer *b,int bits){
                  unsigned long ret;
                  int m=32-bits;
                
                  if(m<0 || m>32) return -1;
                  bits+=b->endbit;
                
                  if(b->endbyte >= b->storage-4){
                    /* not the main path */
                    if(b->endbyte > b->storage-((bits+7)>>3)) return -1;
                    /* special case to avoid reading b->ptr[0], which might be past the end of
                        the buffer; also skips some useless accounting */
                    else if(!bits)return(0L);
                  }
                
                  ret=b->ptr[0]<<(24+b->endbit);
                  if(bits>8){
                    ret|=b->ptr[1]<<(16+b->endbit);  
                    if(bits>16){
                      ret|=b->ptr[2]<<(8+b->endbit);  
                      if(bits>24){
                        ret|=b->ptr[3]<<(b->endbit);  
                        if(bits>32 && b->endbit)
                          ret|=b->ptr[4]>>(8-b->endbit);
                      }
                    }
                  }
                  return ((ret&0xffffffff)>>(m>>1))>>((m+1)>>1);
                }
                
       ##### -> long oggpack_look1(oggpack_buffer *b){
                  if(b->endbyte>=b->storage)return(-1);
                  return((b->ptr[0]>>b->endbit)&1);
                }
                
       ##### -> long oggpackB_look1(oggpack_buffer *b){
                  if(b->endbyte>=b->storage)return(-1);
                  return((b->ptr[0]>>(7-b->endbit))&1);
                }
                
     2703783 -> void oggpack_adv(oggpack_buffer *b,int bits){
                  bits+=b->endbit;
                
                  if(b->endbyte > b->storage-((bits+7)>>3)) goto overflow;
                
                  b->ptr+=bits/8;
                  b->endbyte+=bits/8;
                  b->endbit=bits&7;
                  return;
                
                 overflow:
                  b->ptr=NULL;
                  b->endbyte=b->storage;
                  b->endbit=1;
                }
                
       ##### -> void oggpackB_adv(oggpack_buffer *b,int bits){
                  oggpack_adv(b,bits);
                }
                
       ##### -> void oggpack_adv1(oggpack_buffer *b){
                  if(++(b->endbit)>7){
                    b->endbit=0;
                    b->ptr++;
                    b->endbyte++;
                  }
                }
                
       ##### -> void oggpackB_adv1(oggpack_buffer *b){
                  oggpack_adv1(b);
                }
                
                /* bits <= 32 */
      127958 -> long oggpack_read(oggpack_buffer *b,int bits){
                  long ret;
                  unsigned long m;
                
                  if(bits<0 || bits>32) goto err;
                  m=mask[bits];
                  bits+=b->endbit;
                
                  if(b->endbyte >= b->storage-4){
                    /* not the main path */
                    if(b->endbyte > b->storage-((bits+7)>>3)) goto overflow;
                    /* special case to avoid reading b->ptr[0], which might be past the end of
                        the buffer; also skips some useless accounting */
                    else if(!bits)return(0L);
                  }
                
                  ret=b->ptr[0]>>b->endbit;
                  if(bits>8){
                    ret|=b->ptr[1]<<(8-b->endbit);  
                    if(bits>16){
                      ret|=b->ptr[2]<<(16-b->endbit);  
                      if(bits>24){
                        ret|=b->ptr[3]<<(24-b->endbit);  
                        if(bits>32 && b->endbit){
                          ret|=b->ptr[4]<<(32-b->endbit);
                        }
                      }
                    }
                  }
                  ret&=m;
                  b->ptr+=bits/8;
                  b->endbyte+=bits/8;
                  b->endbit=bits&7;
                  return ret;
                
                 overflow:
                 err:
                  b->ptr=NULL;
                  b->endbyte=b->storage;
                  b->endbit=1;
                  return -1L;
                }
                
                /* bits <= 32 */
       ##### -> long oggpackB_read(oggpack_buffer *b,int bits){
                  long ret;
                  long m=32-bits;
                
                  if(m<0 || m>32) goto err;
                  bits+=b->endbit;
                
                  if(b->endbyte+4>=b->storage){
                    /* not the main path */
                    if(b->endbyte > b->storage-((bits+7)>>3)) goto overflow;
                    /* special case to avoid reading b->ptr[0], which might be past the end of
                        the buffer; also skips some useless accounting */
                    else if(!bits)return(0L);
                  }
                
                  ret=b->ptr[0]<<(24+b->endbit);
                  if(bits>8){
                    ret|=b->ptr[1]<<(16+b->endbit);  
                    if(bits>16){
                      ret|=b->ptr[2]<<(8+b->endbit);  
                      if(bits>24){
                        ret|=b->ptr[3]<<(b->endbit);  
                        if(bits>32 && b->endbit)
                          ret|=b->ptr[4]>>(8-b->endbit);
                      }
                    }
                  }
                  ret=((ret&0xffffffffUL)>>(m>>1))>>((m+1)>>1);
                
                  b->ptr+=bits/8;
                  b->endbyte+=bits/8;
                  b->endbit=bits&7;
                  return ret;
                
                 overflow:
                 err:
                  b->ptr=NULL;
                  b->endbyte=b->storage;
                  b->endbit=1;
                  return -1L;
                }
                
       ##### -> long oggpack_read1(oggpack_buffer *b){
                  long ret;
                
                  if(b->endbyte >= b->storage) goto overflow;
                  ret=(b->ptr[0]>>b->endbit)&1;
                
                  b->endbit++;
                  if(b->endbit>7){
                    b->endbit=0;
                    b->ptr++;
                    b->endbyte++;
                  }
                  return ret;
                
                 overflow:
                  b->ptr=NULL;
                  b->endbyte=b->storage;
                  b->endbit=1;
                  return -1L;
                }
                
       ##### -> long oggpackB_read1(oggpack_buffer *b){
                  long ret;
                
                  if(b->endbyte >= b->storage) goto overflow;
                  ret=(b->ptr[0]>>(7-b->endbit))&1;
                
                  b->endbit++;
                  if(b->endbit>7){
                    b->endbit=0;
                    b->ptr++;
                    b->endbyte++;
                  }
                  return ret;
                
                 overflow:
                  b->ptr=NULL;
                  b->endbyte=b->storage;
                  b->endbit=1;
                  return -1L;
                }
                
         744 -> long oggpack_bytes(oggpack_buffer *b){
                  return(b->endbyte+(b->endbit+7)/8);
                }
                
       ##### -> long oggpack_bits(oggpack_buffer *b){
                  return(b->endbyte*8+b->endbit);
                }
                
       ##### -> long oggpackB_bytes(oggpack_buffer *b){
                  return oggpack_bytes(b);
                }
                
       ##### -> long oggpackB_bits(oggpack_buffer *b){
                  return oggpack_bits(b);
                }
                  
       ##### -> unsigned char *oggpack_get_buffer(oggpack_buffer *b){
                  return(b->buffer);
                }
                
       ##### -> unsigned char *oggpackB_get_buffer(oggpack_buffer *b){
                  return oggpack_get_buffer(b);
                }
                
                /* Self test of the bitwise routines; everything else is based on
                   them, so they damned well better be solid. */
                
                #ifdef _V_SELFTEST
                #include <stdio.h>
                
                static int ilog(unsigned int v){
                  int ret=0;
                  while(v){
                    ret++;
                    v>>=1;
                  }
                  return(ret);
                }
                      
                oggpack_buffer o;
                oggpack_buffer r;
                
                void report(char *in){
                  fprintf(stderr,"%s",in);
                  exit(1);
                }
                
                void cliptest(unsigned long *b,int vals,int bits,int *comp,int compsize){
                  long bytes,i;
                  unsigned char *buffer;
                
                  oggpack_reset(&o);
                  for(i=0;i<vals;i++)
                    oggpack_write(&o,b[i],bits?bits:ilog(b[i]));
                  buffer=oggpack_get_buffer(&o);
                  bytes=oggpack_bytes(&o);
                  if(bytes!=compsize)report("wrong number of bytes!\n");
                  for(i=0;i<bytes;i++)if(buffer[i]!=comp[i]){
                    for(i=0;i<bytes;i++)fprintf(stderr,"%x %x\n",(int)buffer[i],(int)comp[i]);
                    report("wrote incorrect value!\n");
                  }
                  oggpack_readinit(&r,buffer,bytes);
                  for(i=0;i<vals;i++){
                    int tbit=bits?bits:ilog(b[i]);
                    if(oggpack_look(&r,tbit)==-1)
                      report("out of data!\n");
                    if(oggpack_look(&r,tbit)!=(b[i]&mask[tbit]))
                      report("looked at incorrect value!\n");
                    if(tbit==1)
                      if(oggpack_look1(&r)!=(b[i]&mask[tbit]))
                        report("looked at single bit incorrect value!\n");
                    if(tbit==1){
                      if(oggpack_read1(&r)!=(b[i]&mask[tbit]))
                        report("read incorrect single bit value!\n");
                    }else{
                    if(oggpack_read(&r,tbit)!=(b[i]&mask[tbit]))
                      report("read incorrect value!\n");
                    }
                  }
                  if(oggpack_bytes(&r)!=bytes)report("leftover bytes after read!\n");
                }
                
                void cliptestB(unsigned long *b,int vals,int bits,int *comp,int compsize){
                  long bytes,i;
                  unsigned char *buffer;
                  
                  oggpackB_reset(&o);
                  for(i=0;i<vals;i++)
                    oggpackB_write(&o,b[i],bits?bits:ilog(b[i]));
                  buffer=oggpackB_get_buffer(&o);
                  bytes=oggpackB_bytes(&o);
                  if(bytes!=compsize)report("wrong number of bytes!\n");
                  for(i=0;i<bytes;i++)if(buffer[i]!=comp[i]){
                    for(i=0;i<bytes;i++)fprintf(stderr,"%x %x\n",(int)buffer[i],(int)comp[i]);
                    report("wrote incorrect value!\n");
                  }
                  oggpackB_readinit(&r,buffer,bytes);
                  for(i=0;i<vals;i++){
                    int tbit=bits?bits:ilog(b[i]);
                    if(oggpackB_look(&r,tbit)==-1)
                      report("out of data!\n");
                    if(oggpackB_look(&r,tbit)!=(b[i]&mask[tbit]))
                      report("looked at incorrect value!\n");
                    if(tbit==1)
                      if(oggpackB_look1(&r)!=(b[i]&mask[tbit]))
                        report("looked at single bit incorrect value!\n");
                    if(tbit==1){
                      if(oggpackB_read1(&r)!=(b[i]&mask[tbit]))
                        report("read incorrect single bit value!\n");
                    }else{
                    if(oggpackB_read(&r,tbit)!=(b[i]&mask[tbit]))
                      report("read incorrect value!\n");
                    }
                  }
                  if(oggpackB_bytes(&r)!=bytes)report("leftover bytes after read!\n");
                }
                
                int main(void){
                  unsigned char *buffer;
                  long bytes,i;
                  static unsigned long testbuffer1[]=
                    {18,12,103948,4325,543,76,432,52,3,65,4,56,32,42,34,21,1,23,32,546,456,7,
                       567,56,8,8,55,3,52,342,341,4,265,7,67,86,2199,21,7,1,5,1,4};
                  int test1size=43;
                
                  static unsigned long testbuffer2[]=
                    {216531625L,1237861823,56732452,131,3212421,12325343,34547562,12313212,
                       1233432,534,5,346435231,14436467,7869299,76326614,167548585,
                       85525151,0,12321,1,349528352};
                  int test2size=21;
                
                  static unsigned long testbuffer3[]=
                    {1,0,14,0,1,0,12,0,1,0,0,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,
                       0,1,30,1,1,1,0,0,1,0,0,0,12,0,11,0,1,0,0,1};
                  int test3size=56;
                
                  static unsigned long large[]=
                    {2136531625L,2137861823,56732452,131,3212421,12325343,34547562,12313212,
                       1233432,534,5,2146435231,14436467,7869299,76326614,167548585,
                       85525151,0,12321,1,2146528352};
                
                  int onesize=33;
                  static int one[33]={146,25,44,151,195,15,153,176,233,131,196,65,85,172,47,40,
                                    34,242,223,136,35,222,211,86,171,50,225,135,214,75,172,
                                    223,4};
                  static int oneB[33]={150,101,131,33,203,15,204,216,105,193,156,65,84,85,222,
                                       8,139,145,227,126,34,55,244,171,85,100,39,195,173,18,
                                       245,251,128};
                
                  int twosize=6;
                  static int two[6]={61,255,255,251,231,29};
                  static int twoB[6]={247,63,255,253,249,120};
                
                  int threesize=54;
                  static int three[54]={169,2,232,252,91,132,156,36,89,13,123,176,144,32,254,
                                      142,224,85,59,121,144,79,124,23,67,90,90,216,79,23,83,
                                      58,135,196,61,55,129,183,54,101,100,170,37,127,126,10,
                                      100,52,4,14,18,86,77,1};
                  static int threeB[54]={206,128,42,153,57,8,183,251,13,89,36,30,32,144,183,
                                         130,59,240,121,59,85,223,19,228,180,134,33,107,74,98,
                                         233,253,196,135,63,2,110,114,50,155,90,127,37,170,104,
                                         200,20,254,4,58,106,176,144,0};
                
                  int foursize=38;
                  static int four[38]={18,6,163,252,97,194,104,131,32,1,7,82,137,42,129,11,72,
                                     132,60,220,112,8,196,109,64,179,86,9,137,195,208,122,169,
                                     28,2,133,0,1};
                  static int fourB[38]={36,48,102,83,243,24,52,7,4,35,132,10,145,21,2,93,2,41,
                                        1,219,184,16,33,184,54,149,170,132,18,30,29,98,229,67,
                                        129,10,4,32};
                
                  int fivesize=45;
                  static int five[45]={169,2,126,139,144,172,30,4,80,72,240,59,130,218,73,62,
                                     241,24,210,44,4,20,0,248,116,49,135,100,110,130,181,169,
                                     84,75,159,2,1,0,132,192,8,0,0,18,22};
                  static int fiveB[45]={1,84,145,111,245,100,128,8,56,36,40,71,126,78,213,226,
                                        124,105,12,0,133,128,0,162,233,242,67,152,77,205,77,
                                        172,150,169,129,79,128,0,6,4,32,0,27,9,0};
                
                  int sixsize=7;
                  static int six[7]={17,177,170,242,169,19,148};
                  static int sixB[7]={136,141,85,79,149,200,41};
                
                  /* Test read/write together */
                  /* Later we test against pregenerated bitstreams */
                  oggpack_writeinit(&o);
                
                  fprintf(stderr,"\nSmall preclipped packing (LSb): ");
                  cliptest(testbuffer1,test1size,0,one,onesize);
                  fprintf(stderr,"ok.");
                
                  fprintf(stderr,"\nNull bit call (LSb): ");
                  cliptest(testbuffer3,test3size,0,two,twosize);
                  fprintf(stderr,"ok.");
                
                  fprintf(stderr,"\nLarge preclipped packing (LSb): ");
                  cliptest(testbuffer2,test2size,0,three,threesize);
                  fprintf(stderr,"ok.");
                
                  fprintf(stderr,"\n32 bit preclipped packing (LSb): ");
                  oggpack_reset(&o);
                  for(i=0;i<test2size;i++)
                    oggpack_write(&o,large[i],32);
                  buffer=oggpack_get_buffer(&o);
                  bytes=oggpack_bytes(&o);
                  oggpack_readinit(&r,buffer,bytes);
                  for(i=0;i<test2size;i++){
                    if(oggpack_look(&r,32)==-1)report("out of data. failed!");
                    if(oggpack_look(&r,32)!=large[i]){
                      fprintf(stderr,"%ld != %ld (%lx!=%lx):",oggpack_look(&r,32),large[i],
                              oggpack_look(&r,32),large[i]);
                      report("read incorrect value!\n");
                    }
                    oggpack_adv(&r,32);
                  }
                  if(oggpack_bytes(&r)!=bytes)report("leftover bytes after read!\n");
                  fprintf(stderr,"ok.");
                
                  fprintf(stderr,"\nSmall unclipped packing (LSb): ");
                  cliptest(testbuffer1,test1size,7,four,foursize);
                  fprintf(stderr,"ok.");
                
                  fprintf(stderr,"\nLarge unclipped packing (LSb): ");
                  cliptest(testbuffer2,test2size,17,five,fivesize);
                  fprintf(stderr,"ok.");
                
                  fprintf(stderr,"\nSingle bit unclipped packing (LSb): ");
                  cliptest(testbuffer3,test3size,1,six,sixsize);
                  fprintf(stderr,"ok.");
                
                  fprintf(stderr,"\nTesting read past end (LSb): ");
                  oggpack_readinit(&r,(unsigned char *)"\0\0\0\0\0\0\0\0",8);
                  for(i=0;i<64;i++){
                    if(oggpack_read(&r,1)!=0){
                      fprintf(stderr,"failed; got -1 prematurely.\n");
                      exit(1);
                    }
                  }
                  if(oggpack_look(&r,1)!=-1 ||
                     oggpack_read(&r,1)!=-1){
                      fprintf(stderr,"failed; read past end without -1.\n");
                      exit(1);
                  }
                  oggpack_readinit(&r,(unsigned char *)"\0\0\0\0\0\0\0\0",8);
                  if(oggpack_read(&r,30)!=0 || oggpack_read(&r,16)!=0){
                      fprintf(stderr,"failed 2; got -1 prematurely.\n");
                      exit(1);
                  }
                
                  if(oggpack_look(&r,18)!=0 ||
                     oggpack_look(&r,18)!=0){
                    fprintf(stderr,"failed 3; got -1 prematurely.\n");
                      exit(1);
                  }
                  if(oggpack_look(&r,19)!=-1 ||
                     oggpack_look(&r,19)!=-1){
                    fprintf(stderr,"failed; read past end without -1.\n");
                      exit(1);
                  }
                  if(oggpack_look(&r,32)!=-1 ||
                     oggpack_look(&r,32)!=-1){
                    fprintf(stderr,"failed; read past end without -1.\n");
                      exit(1);
                  }
                  oggpack_writeclear(&o);
                  fprintf(stderr,"ok.\n");
                
                  /********** lazy, cut-n-paste retest with MSb packing ***********/
                
                  /* Test read/write together */
                  /* Later we test against pregenerated bitstreams */
                  oggpackB_writeinit(&o);
                
                  fprintf(stderr,"\nSmall preclipped packing (MSb): ");
                  cliptestB(testbuffer1,test1size,0,oneB,onesize);
                  fprintf(stderr,"ok.");
                
                  fprintf(stderr,"\nNull bit call (MSb): ");
                  cliptestB(testbuffer3,test3size,0,twoB,twosize);
                  fprintf(stderr,"ok.");
                
                  fprintf(stderr,"\nLarge preclipped packing (MSb): ");
                  cliptestB(testbuffer2,test2size,0,threeB,threesize);
                  fprintf(stderr,"ok.");
                
                  fprintf(stderr,"\n32 bit preclipped packing (MSb): ");
                  oggpackB_reset(&o);
                  for(i=0;i<test2size;i++)
                    oggpackB_write(&o,large[i],32);
                  buffer=oggpackB_get_buffer(&o);
                  bytes=oggpackB_bytes(&o);
                  oggpackB_readinit(&r,buffer,bytes);
                  for(i=0;i<test2size;i++){
                    if(oggpackB_look(&r,32)==-1)report("out of data. failed!");
                    if(oggpackB_look(&r,32)!=large[i]){
                      fprintf(stderr,"%ld != %ld (%lx!=%lx):",oggpackB_look(&r,32),large[i],
                              oggpackB_look(&r,32),large[i]);
                      report("read incorrect value!\n");
                    }
                    oggpackB_adv(&r,32);
                  }
                  if(oggpackB_bytes(&r)!=bytes)report("leftover bytes after read!\n");
                  fprintf(stderr,"ok.");
                
                  fprintf(stderr,"\nSmall unclipped packing (MSb): ");
                  cliptestB(testbuffer1,test1size,7,fourB,foursize);
                  fprintf(stderr,"ok.");
                
                  fprintf(stderr,"\nLarge unclipped packing (MSb): ");
                  cliptestB(testbuffer2,test2size,17,fiveB,fivesize);
                  fprintf(stderr,"ok.");
                
                  fprintf(stderr,"\nSingle bit unclipped packing (MSb): ");
                  cliptestB(testbuffer3,test3size,1,sixB,sixsize);
                  fprintf(stderr,"ok.");
                
                  fprintf(stderr,"\nTesting read past end (MSb): ");
                  oggpackB_readinit(&r,(unsigned char *)"\0\0\0\0\0\0\0\0",8);
                  for(i=0;i<64;i++){
                    if(oggpackB_read(&r,1)!=0){
                      fprintf(stderr,"failed; got -1 prematurely.\n");
                      exit(1);
                    }
                  }
                  if(oggpackB_look(&r,1)!=-1 ||
                     oggpackB_read(&r,1)!=-1){
                      fprintf(stderr,"failed; read past end without -1.\n");
                      exit(1);
                  }
                  oggpackB_readinit(&r,(unsigned char *)"\0\0\0\0\0\0\0\0",8);
                  if(oggpackB_read(&r,30)!=0 || oggpackB_read(&r,16)!=0){
                      fprintf(stderr,"failed 2; got -1 prematurely.\n");
                      exit(1);
                  }
                
                  if(oggpackB_look(&r,18)!=0 ||
                     oggpackB_look(&r,18)!=0){
                    fprintf(stderr,"failed 3; got -1 prematurely.\n");
                      exit(1);
                  }
                  if(oggpackB_look(&r,19)!=-1 ||
                     oggpackB_look(&r,19)!=-1){
                    fprintf(stderr,"failed; read past end without -1.\n");
                      exit(1);
                  }
                  if(oggpackB_look(&r,32)!=-1 ||
                     oggpackB_look(&r,32)!=-1){
                    fprintf(stderr,"failed; read past end without -1.\n");
                      exit(1);
                  }
                  oggpackB_writeclear(&o);
                  fprintf(stderr,"ok.\n\n");
                
                
                  return(0);
                }  
                #endif  /* _V_SELFTEST */
                
                #undef BUFFER_INCREMENT


Top 10 Lines:

     Line      Count

      266    4480203
      338    2703783
      371     127958
      255       4506
      499        744

Execution Summary:

       37   Executable lines in this file
       36   Lines executed
    97.30   Percent of the file executed

  7317194   Total number of line executions
197762.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\CustomizeOgg_static\GprofCdt/../src/framing.c:
                /********************************************************************
                 *                                                                  *
                 * THIS FILE IS PART OF THE Ogg CONTAINER SOURCE CODE.              *
                 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
                 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
                 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
                 *                                                                  *
                 * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2010             *
                 * by the Xiph.Org Foundation http://www.xiph.org/                  *
                 *                                                                  *
                 ********************************************************************
                
                 function: code raw packets into framed OggSquish stream and
                           decode Ogg streams back into raw packets
                 last mod: $Id: framing.c 17592 2010-11-01 20:27:54Z xiphmont $
                
                 note: The CRC code is directly derived from public domain code by
                 Ross Williams (ross@guest.adelaide.edu.au).  See docs/framing.html
                 for details.
                
                 ********************************************************************/
                
                #include <stdlib.h>
                #include <string.h>
                #include <ogg/ogg.h>
                
                /* A complete description of Ogg framing exists in docs/framing.html */
                
         561 -> int ogg_page_version(const ogg_page *og){
                  return((int)(og->header[4]));
                }
                
         562 -> int ogg_page_continued(const ogg_page *og){
                  return((int)(og->header[5]&0x01));
                }
                
         592 -> int ogg_page_bos(const ogg_page *og){
                  return((int)(og->header[5]&0x02));
                }
                
         574 -> int ogg_page_eos(const ogg_page *og){
                  return((int)(og->header[5]&0x04));
                }
                
         770 -> ogg_int64_t ogg_page_granulepos(const ogg_page *og){
                  unsigned char *page=og->header;
                  ogg_int64_t granulepos=page[13]&(0xff);
                  granulepos= (granulepos<<8)|(page[12]&0xff);
                  granulepos= (granulepos<<8)|(page[11]&0xff);
                  granulepos= (granulepos<<8)|(page[10]&0xff);
                  granulepos= (granulepos<<8)|(page[9]&0xff);
                  granulepos= (granulepos<<8)|(page[8]&0xff);
                  granulepos= (granulepos<<8)|(page[7]&0xff);
                  granulepos= (granulepos<<8)|(page[6]&0xff);
                  return(granulepos);
                }
                
        1304 -> int ogg_page_serialno(const ogg_page *og){
                  return(og->header[14] |
                         (og->header[15]<<8) |
                         (og->header[16]<<16) |
                         (og->header[17]<<24));
                }
                 
         560 -> long ogg_page_pageno(const ogg_page *og){
                  return(og->header[18] |
                         (og->header[19]<<8) |
                         (og->header[20]<<16) |
                         (og->header[21]<<24));
                }
                
                
                
                /* returns the number of packets that are completed on this page (if
                   the leading packet is begun on a previous page, but ends on this
                   page, it's counted */
                
                /* NOTE:
                If a page consists of a packet begun on a previous page, and a new
                packet begun (but not completed) on this page, the return will be:
                  ogg_page_packets(page)   ==1, 
                  ogg_page_continued(page) !=0
                
                If a page happens to be a single packet that was begun on a
                previous page, and spans to the next page (in the case of a three or
                more page packet), the return will be: 
                  ogg_page_packets(page)   ==0, 
                  ogg_page_continued(page) !=0
                */
                
       ##### -> int ogg_page_packets(const ogg_page *og){
                  int i,n=og->header[26],count=0;
                  for(i=0;i<n;i++)
                    if(og->header[27+i]<255)count++;
                  return(count);
                }
                
                
                #if 0
                /* helper to initialize lookup for direct-table CRC (illustrative; we
                   use the static init below) */
                
                static ogg_uint32_t _ogg_crc_entry(unsigned long index){
                  int           i;
                  unsigned long r;
                
                  r = index << 24;
                  for (i=0; i<8; i++)
                    if (r & 0x80000000UL)
                      r = (r << 1) ^ 0x04c11db7; /* The same as the ethernet generator
                                                    polynomial, although we use an
                                                    unreflected alg and an init/final
                                                    of 0, not 0xffffffff */
                    else
                       r<<=1;
                 return (r & 0xffffffffUL);
                }
                #endif
                
                static const ogg_uint32_t crc_lookup[256]={
                  0x00000000,0x04c11db7,0x09823b6e,0x0d4326d9,
                  0x130476dc,0x17c56b6b,0x1a864db2,0x1e475005,
                  0x2608edb8,0x22c9f00f,0x2f8ad6d6,0x2b4bcb61,
                  0x350c9b64,0x31cd86d3,0x3c8ea00a,0x384fbdbd,
                  0x4c11db70,0x48d0c6c7,0x4593e01e,0x4152fda9,
                  0x5f15adac,0x5bd4b01b,0x569796c2,0x52568b75,
                  0x6a1936c8,0x6ed82b7f,0x639b0da6,0x675a1011,
                  0x791d4014,0x7ddc5da3,0x709f7b7a,0x745e66cd,
                  0x9823b6e0,0x9ce2ab57,0x91a18d8e,0x95609039,
                  0x8b27c03c,0x8fe6dd8b,0x82a5fb52,0x8664e6e5,
                  0xbe2b5b58,0xbaea46ef,0xb7a96036,0xb3687d81,
                  0xad2f2d84,0xa9ee3033,0xa4ad16ea,0xa06c0b5d,
                  0xd4326d90,0xd0f37027,0xddb056fe,0xd9714b49,
                  0xc7361b4c,0xc3f706fb,0xceb42022,0xca753d95,
                  0xf23a8028,0xf6fb9d9f,0xfbb8bb46,0xff79a6f1,
                  0xe13ef6f4,0xe5ffeb43,0xe8bccd9a,0xec7dd02d,
                  0x34867077,0x30476dc0,0x3d044b19,0x39c556ae,
                  0x278206ab,0x23431b1c,0x2e003dc5,0x2ac12072,
                  0x128e9dcf,0x164f8078,0x1b0ca6a1,0x1fcdbb16,
                  0x018aeb13,0x054bf6a4,0x0808d07d,0x0cc9cdca,
                  0x7897ab07,0x7c56b6b0,0x71159069,0x75d48dde,
                  0x6b93dddb,0x6f52c06c,0x6211e6b5,0x66d0fb02,
                  0x5e9f46bf,0x5a5e5b08,0x571d7dd1,0x53dc6066,
                  0x4d9b3063,0x495a2dd4,0x44190b0d,0x40d816ba,
                  0xaca5c697,0xa864db20,0xa527fdf9,0xa1e6e04e,
                  0xbfa1b04b,0xbb60adfc,0xb6238b25,0xb2e29692,
                  0x8aad2b2f,0x8e6c3698,0x832f1041,0x87ee0df6,
                  0x99a95df3,0x9d684044,0x902b669d,0x94ea7b2a,
                  0xe0b41de7,0xe4750050,0xe9362689,0xedf73b3e,
                  0xf3b06b3b,0xf771768c,0xfa325055,0xfef34de2,
                  0xc6bcf05f,0xc27dede8,0xcf3ecb31,0xcbffd686,
                  0xd5b88683,0xd1799b34,0xdc3abded,0xd8fba05a,
                  0x690ce0ee,0x6dcdfd59,0x608edb80,0x644fc637,
                  0x7a089632,0x7ec98b85,0x738aad5c,0x774bb0eb,
                  0x4f040d56,0x4bc510e1,0x46863638,0x42472b8f,
                  0x5c007b8a,0x58c1663d,0x558240e4,0x51435d53,
                  0x251d3b9e,0x21dc2629,0x2c9f00f0,0x285e1d47,
                  0x36194d42,0x32d850f5,0x3f9b762c,0x3b5a6b9b,
                  0x0315d626,0x07d4cb91,0x0a97ed48,0x0e56f0ff,
                  0x1011a0fa,0x14d0bd4d,0x19939b94,0x1d528623,
                  0xf12f560e,0xf5ee4bb9,0xf8ad6d60,0xfc6c70d7,
                  0xe22b20d2,0xe6ea3d65,0xeba91bbc,0xef68060b,
                  0xd727bbb6,0xd3e6a601,0xdea580d8,0xda649d6f,
                  0xc423cd6a,0xc0e2d0dd,0xcda1f604,0xc960ebb3,
                  0xbd3e8d7e,0xb9ff90c9,0xb4bcb610,0xb07daba7,
                  0xae3afba2,0xaafbe615,0xa7b8c0cc,0xa379dd7b,
                  0x9b3660c6,0x9ff77d71,0x92b45ba8,0x9675461f,
                  0x8832161a,0x8cf30bad,0x81b02d74,0x857130c3,
                  0x5d8a9099,0x594b8d2e,0x5408abf7,0x50c9b640,
                  0x4e8ee645,0x4a4ffbf2,0x470cdd2b,0x43cdc09c,
                  0x7b827d21,0x7f436096,0x7200464f,0x76c15bf8,
                  0x68860bfd,0x6c47164a,0x61043093,0x65c52d24,
                  0x119b4be9,0x155a565e,0x18197087,0x1cd86d30,
                  0x029f3d35,0x065e2082,0x0b1d065b,0x0fdc1bec,
                  0x3793a651,0x3352bbe6,0x3e119d3f,0x3ad08088,
                  0x2497d08d,0x2056cd3a,0x2d15ebe3,0x29d4f654,
                  0xc5a92679,0xc1683bce,0xcc2b1d17,0xc8ea00a0,
                  0xd6ad50a5,0xd26c4d12,0xdf2f6bcb,0xdbee767c,
                  0xe3a1cbc1,0xe760d676,0xea23f0af,0xeee2ed18,
                  0xf0a5bd1d,0xf464a0aa,0xf9278673,0xfde69bc4,
                  0x89b8fd09,0x8d79e0be,0x803ac667,0x84fbdbd0,
                  0x9abc8bd5,0x9e7d9662,0x933eb0bb,0x97ffad0c,
                  0xafb010b1,0xab710d06,0xa6322bdf,0xa2f33668,
                  0xbcb4666d,0xb8757bda,0xb5365d03,0xb1f740b4};
                
                /* init the encode/decode logical stream state */
                
          24 -> int ogg_stream_init(ogg_stream_state *os,int serialno){
                  if(os){
                    memset(os,0,sizeof(*os));
                    os->body_storage=16*1024;
                    os->lacing_storage=1024;
                
                    os->body_data=_ogg_malloc(os->body_storage*sizeof(*os->body_data));
                    os->lacing_vals=_ogg_malloc(os->lacing_storage*sizeof(*os->lacing_vals));
                    os->granule_vals=_ogg_malloc(os->lacing_storage*sizeof(*os->granule_vals));
                
                    if(!os->body_data || !os->lacing_vals || !os->granule_vals){
                      ogg_stream_clear(os);
                      return -1;
                    }
                
                    os->serialno=serialno;
                
                    return(0);
                  }
                  return(-1);
                } 
                
                /* async/delayed error detection for the ogg_stream_state */
        5701 -> int ogg_stream_check(ogg_stream_state *os){
                  if(!os || !os->body_data) return -1;
                  return 0;
                }
                
                /* _clear does not free os, only the non-flat storage within */
          36 -> int ogg_stream_clear(ogg_stream_state *os){
                  if(os){
                    if(os->body_data)_ogg_free(os->body_data);
                    if(os->lacing_vals)_ogg_free(os->lacing_vals);
                    if(os->granule_vals)_ogg_free(os->granule_vals);
                
                    memset(os,0,sizeof(*os));    
                  }
                  return(0);
                } 
                
        1121 -> int ogg_stream_destroy(ogg_stream_state *os){
                  if(os){
                    ogg_stream_clear(os);
                    _ogg_free(os);
                  }
                  return(0);
                } 
                
                /* Helpers for ogg_stream_encode; this keeps the structure and
                   what's happening fairly clear */
                
                static int _os_body_expand(ogg_stream_state *os,int needed){
                  if(os->body_storage<=os->body_fill+needed){
                    void *ret;
                    ret=_ogg_realloc(os->body_data,(os->body_storage+needed+1024)*
                                     sizeof(*os->body_data));
                    if(!ret){
                      ogg_stream_clear(os);
                      return -1;
                    }
                    os->body_storage+=(needed+1024);
                    os->body_data=ret;
                  }
                  return 0;
                }
                
                static int _os_lacing_expand(ogg_stream_state *os,int needed){
                  if(os->lacing_storage<=os->lacing_fill+needed){
                    void *ret;
                    ret=_ogg_realloc(os->lacing_vals,(os->lacing_storage+needed+32)*
                                     sizeof(*os->lacing_vals));
                    if(!ret){
                      ogg_stream_clear(os);
                      return -1;
                    }
                    os->lacing_vals=ret;
                    ret=_ogg_realloc(os->granule_vals,(os->lacing_storage+needed+32)*
                                     sizeof(*os->granule_vals));
                    if(!ret){
                      ogg_stream_clear(os);
                      return -1;
                    }
                    os->granule_vals=ret;
                    os->lacing_storage+=(needed+32);
                  }
                  return 0;
                }
                
                /* checksum the page */
                /* Direct table CRC; note that this will be faster in the future if we
                   perform the checksum simultaneously with other copies */
                
         734 -> void ogg_page_checksum_set(ogg_page *og){
                  if(og){
                    ogg_uint32_t crc_reg=0;
                    int i;
                
                    /* safety; needed for API behavior, but not framing code */
                    og->header[22]=0;
                    og->header[23]=0;
                    og->header[24]=0;
                    og->header[25]=0;
                    
                    for(i=0;i<og->header_len;i++)
                      crc_reg=(crc_reg<<8)^crc_lookup[((crc_reg >> 24)&0xff)^og->header[i]];
                    for(i=0;i<og->body_len;i++)
                      crc_reg=(crc_reg<<8)^crc_lookup[((crc_reg >> 24)&0xff)^og->body[i]];
                    
                    og->header[22]=(unsigned char)(crc_reg&0xff);
                    og->header[23]=(unsigned char)((crc_reg>>8)&0xff);
                    og->header[24]=(unsigned char)((crc_reg>>16)&0xff);
                    og->header[25]=(unsigned char)((crc_reg>>24)&0xff);
                  }
                }
                
                /* submit data to the internal buffer of the framing engine */
                int ogg_stream_iovecin(ogg_stream_state *os, ogg_iovec_t *iov, int count,
       ##### ->                        long e_o_s, ogg_int64_t granulepos){
                
                  int bytes = 0, lacing_vals, i;
                
                  if(ogg_stream_check(os)) return -1;
                  if(!iov) return 0;
                 
                  for (i = 0; i < count; ++i) bytes += (int)iov[i].iov_len;
                  lacing_vals=bytes/255+1;
                
                  if(os->body_returned){
                    /* advance packet data according to the body_returned pointer. We
                       had to keep it around to return a pointer into the buffer last
                       call */
                    
                    os->body_fill-=os->body_returned;
                    if(os->body_fill)
                      memmove(os->body_data,os->body_data+os->body_returned,
                              os->body_fill);
                    os->body_returned=0;
                  }
                 
                  /* make sure we have the buffer storage */
                  if(_os_body_expand(os,bytes) || _os_lacing_expand(os,lacing_vals))
                    return -1;
                
                  /* Copy in the submitted packet.  Yes, the copy is a waste; this is
                     the liability of overly clean abstraction for the time being.  It
                     will actually be fairly easy to eliminate the extra copy in the
                     future */
                
                  for (i = 0; i < count; ++i) {
                    memcpy(os->body_data+os->body_fill, iov[i].iov_base, iov[i].iov_len);
                    os->body_fill += (int)iov[i].iov_len;
                  }
                
                  /* Store lacing vals for this packet */
                  for(i=0;i<lacing_vals-1;i++){
                    os->lacing_vals[os->lacing_fill+i]=255;
                    os->granule_vals[os->lacing_fill+i]=os->granulepos;
                  }
                  os->lacing_vals[os->lacing_fill+i]=bytes%255;
                  os->granulepos=os->granule_vals[os->lacing_fill+i]=granulepos;
                
                  /* flag the first segment as the beginning of the packet */
                  os->lacing_vals[os->lacing_fill]|= 0x100;
                
                  os->lacing_fill+=lacing_vals;
                
                  /* for the sake of completeness */
                  os->packetno++;
                
                  if(e_o_s)os->e_o_s=1;
                
                  return(0);
                }
                
       ##### -> int ogg_stream_packetin(ogg_stream_state *os,ogg_packet *op){
                  ogg_iovec_t iov;
                  iov.iov_base = op->packet;
                  iov.iov_len = op->bytes;
                  return ogg_stream_iovecin(os, &iov, 1, op->e_o_s, op->granulepos);
                }
                
                /* Conditionally flush a page; force==0 will only flush nominal-size
                   pages, force==1 forces us to flush a page regardless of page size
                   so long as there's any data available at all. */
                static int ogg_stream_flush_i(ogg_stream_state *os,ogg_page *og, int force, int nfill){
                  int i;
                  int vals=0;
                  int maxvals=(os->lacing_fill>255?255:os->lacing_fill);
                  int bytes=0;
                  long acc=0;
                  ogg_int64_t granule_pos=-1;
                
                  if(ogg_stream_check(os)) return(0);
                  if(maxvals==0) return(0);
                
                  /* construct a page */
                  /* decide how many segments to include */
                
                  /* If this is the initial header case, the first page must only include
                     the initial header packet */
                  if(os->b_o_s==0){  /* 'initial header page' case */
                    granule_pos=0;
                    for(vals=0;vals<maxvals;vals++){
                      if((os->lacing_vals[vals]&0x0ff)<255){
                        vals++;
                        break;
                      }
                    }
                  }else{
                
                    /* The extra packets_done, packet_just_done logic here attempts to do two things:
                       1) Don't unneccessarily span pages.
                       2) Unless necessary, don't flush pages if there are less than four packets on
                          them; this expands page size to reduce unneccessary overhead if incoming packets
                          are large.
                       These are not necessary behaviors, just 'always better than naive flushing'
                       without requiring an application to explicitly request a specific optimized
                       behavior. We'll want an explicit behavior setup pathway eventually as well. */
                
                    int packets_done=0;
                    int packet_just_done=0;
                    for(vals=0;vals<maxvals;vals++){
                      if(acc>nfill && packet_just_done>=4){
                        force=1;
                        break;
                      }
                      acc+=os->lacing_vals[vals]&0x0ff;
                      if((os->lacing_vals[vals]&0xff)<255){
                        granule_pos=os->granule_vals[vals];
                        packet_just_done=++packets_done;
                      }else
                        packet_just_done=0;
                    }
                    if(vals==255)force=1;
                  }
                
                  if(!force) return(0);
                
                  /* construct the header in temp storage */
                  memcpy(os->header,"OggS",4);
                
                  /* stream structure version */
                  os->header[4]=0x00;
                
                  /* continued packet flag? */
                  os->header[5]=0x00;
                  if((os->lacing_vals[0]&0x100)==0)os->header[5]|=0x01;
                  /* first page flag? */
                  if(os->b_o_s==0)os->header[5]|=0x02;
                  /* last page flag? */
                  if(os->e_o_s && os->lacing_fill==vals)os->header[5]|=0x04;
                  os->b_o_s=1;
                
                  /* 64 bits of PCM position */
                  for(i=6;i<14;i++){
                    os->header[i]=(unsigned char)(granule_pos&0xff);
                    granule_pos>>=8;
                  }
                
                  /* 32 bits of stream serial number */
                  {
                    long serialno=os->serialno;
                    for(i=14;i<18;i++){
                      os->header[i]=(unsigned char)(serialno&0xff);
                      serialno>>=8;
                    }
                  }
                
                  /* 32 bits of page counter (we have both counter and page header
                     because this val can roll over) */
                  if(os->pageno==-1)os->pageno=0; /* because someone called
                                                     stream_reset; this would be a
                                                     strange thing to do in an
                                                     encode stream, but it has
                                                     plausible uses */
                  {
                    long pageno=os->pageno++;
                    for(i=18;i<22;i++){
                      os->header[i]=(unsigned char)(pageno&0xff);
                      pageno>>=8;
                    }
                  }
                  
                  /* zero for computation; filled in later */
                  os->header[22]=0;
                  os->header[23]=0;
                  os->header[24]=0;
                  os->header[25]=0;
                  
                  /* segment table */
                  os->header[26]=(unsigned char)(vals&0xff);
                  for(i=0;i<vals;i++)
                    bytes+=os->header[i+27]=(unsigned char)(os->lacing_vals[i]&0xff);
                  
                  /* set pointers in the ogg_page struct */
                  og->header=os->header;
                  og->header_len=os->header_fill=vals+27;
                  og->body=os->body_data+os->body_returned;
                  og->body_len=bytes;
                  
                  /* advance the lacing data and set the body_returned pointer */
                  
                  os->lacing_fill-=vals;
                  memmove(os->lacing_vals,os->lacing_vals+vals,os->lacing_fill*sizeof(*os->lacing_vals));
                  memmove(os->granule_vals,os->granule_vals+vals,os->lacing_fill*sizeof(*os->granule_vals));
                  os->body_returned+=bytes;
                  
                  /* calculate the checksum */
                  
                  ogg_page_checksum_set(og);
                
                  /* done */
                  return(1);
                }
                
                /* This will flush remaining packets into a page (returning nonzero),
                   even if there is not enough data to trigger a flush normally
                   (undersized page). If there are no packets or partial packets to
                   flush, ogg_stream_flush returns 0.  Note that ogg_stream_flush will
                   try to flush a normal sized page like ogg_stream_pageout; a call to
                   ogg_stream_flush does not guarantee that all packets have flushed.
                   Only a return value of 0 from ogg_stream_flush indicates all packet
                   data is flushed into pages.
                
                   since ogg_stream_flush will flush the last page in a stream even if
                   it's undersized, you almost certainly want to use ogg_stream_pageout
                   (and *not* ogg_stream_flush) unless you specifically need to flush
                   an page regardless of size in the middle of a stream. */
                
       ##### -> int ogg_stream_flush(ogg_stream_state *os,ogg_page *og){
                  return ogg_stream_flush_i(os,og,1,4096);
                }
                
                /* This constructs pages from buffered packet segments.  The pointers
                returned are to static buffers; do not free. The returned buffers are
                good only until the next call (using the same ogg_stream_state) */
                
       ##### -> int ogg_stream_pageout(ogg_stream_state *os, ogg_page *og){
                  int force=0;
                  if(ogg_stream_check(os)) return 0;
                
                  if((os->e_o_s&&os->lacing_fill) ||          /* 'were done, now flush' case */
                     (os->lacing_fill&&!os->b_o_s))           /* 'initial header page' case */
                    force=1;
                
                  return(ogg_stream_flush_i(os,og,force,4096));
                }
                
                /* Like the above, but an argument is provided to adjust the nominal 
                page size for applications which are smart enough to provide their
                own delay based flushing */
                   
       ##### -> int ogg_stream_pageout_fill(ogg_stream_state *os, ogg_page *og, int nfill){
                  int force=0;
                  if(ogg_stream_check(os)) return 0;
                
                  if((os->e_o_s&&os->lacing_fill) ||          /* 'were done, now flush' case */
                     (os->lacing_fill&&!os->b_o_s))           /* 'initial header page' case */
                    force=1;
                
                  return(ogg_stream_flush_i(os,og,force,nfill));
                }
                
       ##### -> int ogg_stream_eos(ogg_stream_state *os){
                  if(ogg_stream_check(os)) return 1;
                  return os->e_o_s;
                }
                
                /* DECODING PRIMITIVES: packet streaming layer **********************/
                
                /* This has two layers to place more of the multi-serialno and paging
                   control in the application's hands.  First, we expose a data buffer
                   using ogg_sync_buffer().  The app either copies into the
                   buffer, or passes it directly to read(), etc.  We then call
                   ogg_sync_wrote() to tell how many bytes we just added.
                
                   Pages are returned (pointers into the buffer in ogg_sync_state)
                   by ogg_sync_pageout().  The page is then submitted to
                   ogg_stream_pagein() along with the appropriate
                   ogg_stream_state* (ie, matching serialno).  We then get raw
                   packets out calling ogg_stream_packetout() with a
                   ogg_stream_state. */
                
                /* initialize the struct to a known state */
          12 -> int ogg_sync_init(ogg_sync_state *oy){
                  if(oy){
                    oy->storage = -1; /* used as a readiness flag */
                    memset(oy,0,sizeof(*oy));
                  }
                  return(0);
                }
                
                /* clear non-flat storage within */
          24 -> int ogg_sync_clear(ogg_sync_state *oy){
                  if(oy){
                    if(oy->data)_ogg_free(oy->data);
                    memset(oy,0,sizeof(*oy));
                  }
                  return(0);
                }
                
       ##### -> int ogg_sync_destroy(ogg_sync_state *oy){
                  if(oy){
                    ogg_sync_clear(oy);
                    _ogg_free(oy);
                  }
                  return(0);
                }
                
        5430 -> int ogg_sync_check(ogg_sync_state *oy){
                  if(oy->storage<0) return -1;
                  return 0;
                }
                
        1516 -> char *ogg_sync_buffer(ogg_sync_state *oy, long size){
                  if(ogg_sync_check(oy)) return NULL;
                
                  /* first, clear out any space that has been previously returned */
                  if(oy->returned){
                    oy->fill-=oy->returned;
                    if(oy->fill>0)
                      memmove(oy->data,oy->data+oy->returned,oy->fill);
                    oy->returned=0;
                  }
                
                  if(size>oy->storage-oy->fill){
                    /* We need to extend the internal buffer */
                    long newsize=size+oy->fill+4096; /* an extra page to be nice */
                    void *ret;
                
                    if(oy->data)
                      ret=_ogg_realloc(oy->data,newsize);
                    else
                      ret=_ogg_malloc(newsize);
                    if(!ret){
                      ogg_sync_clear(oy);
                      return NULL;
                    }
                    oy->data=ret;
                    oy->storage=newsize;
                  }
                
                  /* expose a segment at least as large as requested at the fill mark */
                  return((char *)oy->data+oy->fill);
                }
                
        1518 -> int ogg_sync_wrote(ogg_sync_state *oy, long bytes){
                  if(ogg_sync_check(oy))return -1;
                  if(oy->fill+bytes>oy->storage)return -1;
                  oy->fill+=bytes;
                  return(0);
                }
                
                /* sync the stream.  This is meant to be useful for finding page
                   boundaries.
                
                   return values for this:
                  -n) skipped n bytes
                   0) page not ready; more data (no bytes skipped)
                   n) page synced at current location; page length n bytes
                   
                */
                
        2365 -> long ogg_sync_pageseek(ogg_sync_state *oy,ogg_page *og){
                  unsigned char *page=oy->data+oy->returned;
                  unsigned char *next;
                  long bytes=oy->fill-oy->returned;
                
                  if(ogg_sync_check(oy))return 0;
                  
                  if(oy->headerbytes==0){
                    int headerbytes,i;
                    if(bytes<27)return(0); /* not enough for a header */
                    
                    /* verify capture pattern */
                    if(memcmp(page,"OggS",4))goto sync_fail;
                    
                    headerbytes=page[26]+27;
                    if(bytes<headerbytes)return(0); /* not enough for header + seg table */
                    
                    /* count up body length in the segment table */
                    
                    for(i=0;i<page[26];i++)
                      oy->bodybytes+=page[27+i];
                    oy->headerbytes=headerbytes;
                  }
                  
                  if(oy->bodybytes+oy->headerbytes>bytes)return(0);
                  
                  /* The whole test page is buffered.  Verify the checksum */
                  {
                    /* Grab the checksum bytes, set the header field to zero */
                    char chksum[4];
                    ogg_page log;
                    
                    memcpy(chksum,page+22,4);
                    memset(page+22,0,4);
                    
                    /* set up a temp page struct and recompute the checksum */
                    log.header=page;
                    log.header_len=oy->headerbytes;
                    log.body=page+oy->headerbytes;
                    log.body_len=oy->bodybytes;
                    ogg_page_checksum_set(&log);
                    
                    /* Compare */
                    if(memcmp(chksum,page+22,4)){
                      /* D'oh.  Mismatch! Corrupt page (or miscapture and not a page
                         at all) */
                      /* replace the computed checksum with the one actually read in */
                      memcpy(page+22,chksum,4);
                      
                      /* Bad checksum. Lose sync */
                      goto sync_fail;
                    }
                  }
                  
                  /* yes, have a whole page all ready to go */
                  {
                    unsigned char *page=oy->data+oy->returned;
                    long bytes;
                
                    if(og){
                      og->header=page;
                      og->header_len=oy->headerbytes;
                      og->body=page+oy->headerbytes;
                      og->body_len=oy->bodybytes;
                    }
                
                    oy->unsynced=0;
                    oy->returned+=(bytes=oy->headerbytes+oy->bodybytes);
                    oy->headerbytes=0;
                    oy->bodybytes=0;
                    return(bytes);
                  }
                  
                 sync_fail:
                  
                  oy->headerbytes=0;
                  oy->bodybytes=0;
                  
                  /* search for possible capture */
                  next=memchr(page+1,'O',bytes-1);
                  if(!next)
                    next=oy->data+oy->fill;
                
                  oy->returned=(int)(next-oy->data);
                  return((long)-(next-page));
                }
                
                /* sync the stream and get a page.  Keep trying until we find a page.
                   Suppress 'sync errors' after reporting the first.
                
                   return values:
                   -1) recapture (hole in data)
                    0) need more data
                    1) page returned
                
                   Returns pointers into buffered data; invalidated by next call to
                   _stream, _clear, _init, or _buffer */
                
       ##### -> int ogg_sync_pageout(ogg_sync_state *oy, ogg_page *og){
                
                  if(ogg_sync_check(oy))return 0;
                
                  /* all we need to do is verify a page at the head of the stream
                     buffer.  If it doesn't verify, we look for the next potential
                     frame */
                
                  for(;;){
                    long ret=ogg_sync_pageseek(oy,og);
                    if(ret>0){
                      /* have a page */
                      return(1);
                    }
                    if(ret==0){
                      /* need more data */
                      return(0);
                    }
                    
                    /* head did not start a synced page... skipped some bytes */
                    if(!oy->unsynced){
                      oy->unsynced=1;
                      return(-1);
                    }
                
                    /* loop. keep looking */
                
                  }
                }
                
                /* add the incoming page to the stream state; we decompose the page
                   into packet segments here as well. */
                
         561 -> int ogg_stream_pagein(ogg_stream_state *os, ogg_page *og){
                  unsigned char *header=og->header;
                  unsigned char *body=og->body;
                  long           bodysize=og->body_len;
                  int            segptr=0;
                
                  int version=ogg_page_version(og);
                  int continued=ogg_page_continued(og);
                  int bos=ogg_page_bos(og);
                  int eos=ogg_page_eos(og);
                  ogg_int64_t granulepos=ogg_page_granulepos(og);
                  int serialno=ogg_page_serialno(og);
                  long pageno=ogg_page_pageno(og);
                  int segments=header[26];
                  
                  if(ogg_stream_check(os)) return -1;
                
                  /* clean up 'returned data' */
                  {
                    long lr=os->lacing_returned;
                    long br=os->body_returned;
                
                    /* body data */
                    if(br){
                      os->body_fill-=br;
                      if(os->body_fill)
                        memmove(os->body_data,os->body_data+br,os->body_fill);
                      os->body_returned=0;
                    }
                
                    if(lr){
                      /* segment table */
                      if(os->lacing_fill-lr){
                        memmove(os->lacing_vals,os->lacing_vals+lr,
                                (os->lacing_fill-lr)*sizeof(*os->lacing_vals));
                        memmove(os->granule_vals,os->granule_vals+lr,
                                (os->lacing_fill-lr)*sizeof(*os->granule_vals));
                      }
                      os->lacing_fill-=lr;
                      os->lacing_packet-=lr;
                      os->lacing_returned=0;
                    }
                  }
                
                  /* check the serial number */
                  if(serialno!=os->serialno)return(-1);
                  if(version>0)return(-1);
                
                  if(_os_lacing_expand(os,segments+1)) return -1;
                
                  /* are we in sequence? */
                  if(pageno!=os->pageno){
                    int i;
                
                    /* unroll previous partial packet (if any) */
                    for(i=os->lacing_packet;i<os->lacing_fill;i++)
                      os->body_fill-=os->lacing_vals[i]&0xff;
                    os->lacing_fill=os->lacing_packet;
                
                    /* make a note of dropped data in segment table */
                    if(os->pageno!=-1){
                      os->lacing_vals[os->lacing_fill++]=0x400;
                      os->lacing_packet++;
                    }
                  }
                
                  /* are we a 'continued packet' page?  If so, we may need to skip
                     some segments */
                  if(continued){
                    if(os->lacing_fill<1 || 
                       os->lacing_vals[os->lacing_fill-1]==0x400){
                      bos=0;
                      for(;segptr<segments;segptr++){
                        int val=header[27+segptr];
                        body+=val;
                        bodysize-=val;
                        if(val<255){
                          segptr++;
                          break;
                        }
                      }
                    }
                  }
                  
                  if(bodysize){
                    if(_os_body_expand(os,bodysize)) return -1;
                    memcpy(os->body_data+os->body_fill,body,bodysize);
                    os->body_fill+=bodysize;
                  }
                
                  {
                    int saved=-1;
                    while(segptr<segments){
                      int val=header[27+segptr];
                      os->lacing_vals[os->lacing_fill]=val;
                      os->granule_vals[os->lacing_fill]=-1;
                      
                      if(bos){
                        os->lacing_vals[os->lacing_fill]|=0x100;
                        bos=0;
                      }
                      
                      if(val<255)saved=os->lacing_fill;
                      
                      os->lacing_fill++;
                      segptr++;
                      
                      if(val<255)os->lacing_packet=os->lacing_fill;
                    }
                  
                    /* set the granulepos on the last granuleval of the last full packet */
                    if(saved!=-1){
                      os->granule_vals[saved]=granulepos;
                    }
                
                  }
                
                  if(eos){
                    os->e_o_s=1;
                    if(os->lacing_fill>0)
                      os->lacing_vals[os->lacing_fill-1]|=0x200;
                  }
                
                  os->pageno=pageno+1;
                
                  return(0);
                }
                
                /* clear things to an initial state.  Good to call, eg, before seeking */
          32 -> int ogg_sync_reset(ogg_sync_state *oy){
                  if(ogg_sync_check(oy))return -1;
                
                  oy->fill=0;
                  oy->returned=0;
                  oy->unsynced=0;
                  oy->headerbytes=0;
                  oy->bodybytes=0;
                  return(0);
                }
                
          64 -> int ogg_stream_reset(ogg_stream_state *os){
                  if(ogg_stream_check(os)) return -1;
                
                  os->body_fill=0;
                  os->body_returned=0;
                
                  os->lacing_fill=0;
                  os->lacing_packet=0;
                  os->lacing_returned=0;
                
                  os->header_fill=0;
                
                  os->e_o_s=0;
                  os->b_o_s=0;
                  os->pageno=-1;
                  os->packetno=0;
                  os->granulepos=0;
                
                  return(0);
                }
                
        5078 -> int ogg_stream_reset_serialno(ogg_stream_state *os,int serialno){
                  if(ogg_stream_check(os)) return -1;
                  ogg_stream_reset(os);
                  os->serialno=serialno;
                  return(0);
                }
                
                static int _packetout(ogg_stream_state *os,ogg_packet *op,int adv){
                
                  /* The last part of decode. We have the stream broken into packet
                     segments.  Now we need to group them into packets (or return the
                     out of sync markers) */
                
                  int ptr=os->lacing_returned;
                
                  if(os->lacing_packet<=ptr)return(0);
                
                  if(os->lacing_vals[ptr]&0x400){
                    /* we need to tell the codec there's a gap; it might need to
                       handle previous packet dependencies. */
                    os->lacing_returned++;
                    os->packetno++;
                    return(-1);
                  }
                
                  if(!op && !adv)return(1); /* just using peek as an inexpensive way
                                               to ask if there's a whole packet
                                               waiting */
                
                  /* Gather the whole packet. We'll have no holes or a partial packet */
                  {
                    int size=os->lacing_vals[ptr]&0xff;
                    long bytes=size;
                    int eos=os->lacing_vals[ptr]&0x200; /* last packet of the stream? */
                    int bos=os->lacing_vals[ptr]&0x100; /* first packet of the stream? */
                
                    while(size==255){
                      int val=os->lacing_vals[++ptr];
                      size=val&0xff;
                      if(val&0x200)eos=0x200;
                      bytes+=size;
                    }
                
                    if(op){
                      op->e_o_s=eos;
                      op->b_o_s=bos;
                      op->packet=os->body_data+os->body_returned;
                      op->packetno=os->packetno;
                      op->granulepos=os->granule_vals[ptr];
                      op->bytes=bytes;
                    }
                
                    if(adv){
                      os->body_returned+=bytes;
                      os->lacing_returned=ptr+1;
                      os->packetno++;
                    }
                  }
                  return(1);
                }
                
        4998 -> int ogg_stream_packetout(ogg_stream_state *os,ogg_packet *op){
                  if(ogg_stream_check(os)) return 0;
                  return _packetout(os,op,1);
                }
                
          28 -> int ogg_stream_packetpeek(ogg_stream_state *os,ogg_packet *op){
                  if(ogg_stream_check(os)) return 0;
                  return _packetout(os,op,0);
                }
                
       ##### -> void ogg_packet_clear(ogg_packet *op) {
                  _ogg_free(op->packet);
                  memset(op, 0, sizeof(*op));
                }
                
                #ifdef _V_SELFTEST
                #include <stdio.h>
                
                ogg_stream_state os_en, os_de;
                ogg_sync_state oy;
                
                void checkpacket(ogg_packet *op,long len, int no, long pos){
                  long j;
                  static int sequence=0;
                  static int lastno=0;
                
                  if(op->bytes!=len){
                    fprintf(stderr,"incorrect packet length (%ld != %ld)!\n",op->bytes,len);
                    exit(1);
                  }
                  if(op->granulepos!=pos){
                    fprintf(stderr,"incorrect packet granpos (%ld != %ld)!\n",(long)op->granulepos,pos);
                    exit(1);
                  }
                
                  /* packet number just follows sequence/gap; adjust the input number
                     for that */
                  if(no==0){
                    sequence=0;
                  }else{
                    sequence++;
                    if(no>lastno+1)
                      sequence++;
                  }
                  lastno=no;
                  if(op->packetno!=sequence){
                    fprintf(stderr,"incorrect packet sequence %ld != %d\n",
                            (long)(op->packetno),sequence);
                    exit(1);
                  }
                
                  /* Test data */
                  for(j=0;j<op->bytes;j++)
                    if(op->packet[j]!=((j+no)&0xff)){
                      fprintf(stderr,"body data mismatch (1) at pos %ld: %x!=%lx!\n\n",
                              j,op->packet[j],(j+no)&0xff);
                      exit(1);
                    }
                }
                
                void check_page(unsigned char *data,const int *header,ogg_page *og){
                  long j;
                  /* Test data */
                  for(j=0;j<og->body_len;j++)
                    if(og->body[j]!=data[j]){
                      fprintf(stderr,"body data mismatch (2) at pos %ld: %x!=%x!\n\n",
                              j,data[j],og->body[j]);
                      exit(1);
                    }
                
                  /* Test header */
                  for(j=0;j<og->header_len;j++){
                    if(og->header[j]!=header[j]){
                      fprintf(stderr,"header content mismatch at pos %ld:\n",j);
                      for(j=0;j<header[26]+27;j++)
                        fprintf(stderr," (%ld)%02x:%02x",j,header[j],og->header[j]);
                      fprintf(stderr,"\n");
                      exit(1);
                    }
                  }
                  if(og->header_len!=header[26]+27){
                    fprintf(stderr,"header length incorrect! (%ld!=%d)\n",
                            og->header_len,header[26]+27);
                    exit(1);
                  }
                }
                
                void print_header(ogg_page *og){
                  int j;
                  fprintf(stderr,"\nHEADER:\n");
                  fprintf(stderr,"  capture: %c %c %c %c  version: %d  flags: %x\n",
                          og->header[0],og->header[1],og->header[2],og->header[3],
                          (int)og->header[4],(int)og->header[5]);
                
                  fprintf(stderr,"  granulepos: %d  serialno: %d  pageno: %ld\n",
                          (og->header[9]<<24)|(og->header[8]<<16)|
                          (og->header[7]<<8)|og->header[6],
                          (og->header[17]<<24)|(og->header[16]<<16)|
                          (og->header[15]<<8)|og->header[14],
                          ((long)(og->header[21])<<24)|(og->header[20]<<16)|
                          (og->header[19]<<8)|og->header[18]);
                
                  fprintf(stderr,"  checksum: %02x:%02x:%02x:%02x\n  segments: %d (",
                          (int)og->header[22],(int)og->header[23],
                          (int)og->header[24],(int)og->header[25],
                          (int)og->header[26]);
                
                  for(j=27;j<og->header_len;j++)
                    fprintf(stderr,"%d ",(int)og->header[j]);
                  fprintf(stderr,")\n\n");
                }
                
                void copy_page(ogg_page *og){
                  unsigned char *temp=_ogg_malloc(og->header_len);
                  memcpy(temp,og->header,og->header_len);
                  og->header=temp;
                
                  temp=_ogg_malloc(og->body_len);
                  memcpy(temp,og->body,og->body_len);
                  og->body=temp;
                }
                
                void free_page(ogg_page *og){
                  _ogg_free (og->header);
                  _ogg_free (og->body);
                }
                
                void error(void){
                  fprintf(stderr,"error!\n");
                  exit(1);
                }
                
                /* 17 only */
                const int head1_0[] = {0x4f,0x67,0x67,0x53,0,0x06,
                                       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                       0x01,0x02,0x03,0x04,0,0,0,0,
                                       0x15,0xed,0xec,0x91,
                                       1,
                                       17};
                
                /* 17, 254, 255, 256, 500, 510, 600 byte, pad */
                const int head1_1[] = {0x4f,0x67,0x67,0x53,0,0x02,
                                       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                       0x01,0x02,0x03,0x04,0,0,0,0,
                                       0x59,0x10,0x6c,0x2c,
                                       1,
                                       17};
                const int head2_1[] = {0x4f,0x67,0x67,0x53,0,0x04,
                                       0x07,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
                                       0x01,0x02,0x03,0x04,1,0,0,0,
                                       0x89,0x33,0x85,0xce,
                                       13,
                                       254,255,0,255,1,255,245,255,255,0,
                                       255,255,90};
                
                /* nil packets; beginning,middle,end */
                const int head1_2[] = {0x4f,0x67,0x67,0x53,0,0x02,
                                       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                       0x01,0x02,0x03,0x04,0,0,0,0,
                                       0xff,0x7b,0x23,0x17,
                                       1,
                                       0};
                const int head2_2[] = {0x4f,0x67,0x67,0x53,0,0x04,
                                       0x07,0x28,0x00,0x00,0x00,0x00,0x00,0x00,
                                       0x01,0x02,0x03,0x04,1,0,0,0,
                                       0x5c,0x3f,0x66,0xcb,
                                       17,
                                       17,254,255,0,0,255,1,0,255,245,255,255,0,
                                       255,255,90,0};
                
                /* large initial packet */
                const int head1_3[] = {0x4f,0x67,0x67,0x53,0,0x02,
                                       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                       0x01,0x02,0x03,0x04,0,0,0,0,
                                       0x01,0x27,0x31,0xaa,
                                       18,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,255,10};
                
                const int head2_3[] = {0x4f,0x67,0x67,0x53,0,0x04,
                                       0x07,0x08,0x00,0x00,0x00,0x00,0x00,0x00,
                                       0x01,0x02,0x03,0x04,1,0,0,0,
                                       0x7f,0x4e,0x8a,0xd2,
                                       4,
                                       255,4,255,0};
                
                
                /* continuing packet test */
                const int head1_4[] = {0x4f,0x67,0x67,0x53,0,0x02,
                                       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                       0x01,0x02,0x03,0x04,0,0,0,0,
                                       0xff,0x7b,0x23,0x17,
                                       1,
                                       0};
                
                const int head2_4[] = {0x4f,0x67,0x67,0x53,0,0x00,
                                       0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                                       0x01,0x02,0x03,0x04,1,0,0,0,
                                       0xf8,0x3c,0x19,0x79,
                                       255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255};
                
                const int head3_4[] = {0x4f,0x67,0x67,0x53,0,0x05,
                                       0x07,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,
                                       0x01,0x02,0x03,0x04,2,0,0,0,
                                       0x38,0xe6,0xb6,0x28,
                                       6,
                                       255,220,255,4,255,0};
                
                
                /* spill expansion test */
                const int head1_4b[] = {0x4f,0x67,0x67,0x53,0,0x02,
                                        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                        0x01,0x02,0x03,0x04,0,0,0,0,
                                        0xff,0x7b,0x23,0x17,
                                        1,
                                        0};
                
                const int head2_4b[] = {0x4f,0x67,0x67,0x53,0,0x00,
                                        0x07,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
                                        0x01,0x02,0x03,0x04,1,0,0,0,
                                        0xce,0x8f,0x17,0x1a,
                                        23,
                                        255,255,255,255,255,255,255,255,
                                        255,255,255,255,255,255,255,255,255,10,255,4,255,0,0};
                
                
                const int head3_4b[] = {0x4f,0x67,0x67,0x53,0,0x04,
                                        0x07,0x14,0x00,0x00,0x00,0x00,0x00,0x00,
                                        0x01,0x02,0x03,0x04,2,0,0,0,
                                        0x9b,0xb2,0x50,0xa1,
                                        1,
                                        0};
                
                /* page with the 255 segment limit */
                const int head1_5[] = {0x4f,0x67,0x67,0x53,0,0x02,
                                       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                       0x01,0x02,0x03,0x04,0,0,0,0,
                                       0xff,0x7b,0x23,0x17,
                                       1,
                                       0};
                
                const int head2_5[] = {0x4f,0x67,0x67,0x53,0,0x00,
                                       0x07,0xfc,0x03,0x00,0x00,0x00,0x00,0x00,
                                       0x01,0x02,0x03,0x04,1,0,0,0,
                                       0xed,0x2a,0x2e,0xa7,
                                       255,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10,10,
                                       10,10,10,10,10,10,10};
                
                const int head3_5[] = {0x4f,0x67,0x67,0x53,0,0x04,
                                       0x07,0x00,0x04,0x00,0x00,0x00,0x00,0x00,
                                       0x01,0x02,0x03,0x04,2,0,0,0,
                                       0x6c,0x3b,0x82,0x3d,
                                       1,
                                       50};
                
                
                /* packet that overspans over an entire page */
                const int head1_6[] = {0x4f,0x67,0x67,0x53,0,0x02,
                                       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                       0x01,0x02,0x03,0x04,0,0,0,0,
                                       0xff,0x7b,0x23,0x17,
                                       1,
                                       0};
                
                const int head2_6[] = {0x4f,0x67,0x67,0x53,0,0x00,
                                       0x07,0x04,0x00,0x00,0x00,0x00,0x00,0x00,
                                       0x01,0x02,0x03,0x04,1,0,0,0,
                                       0x68,0x22,0x7c,0x3d,
                                       255,
                                       100,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255};
                
                const int head3_6[] = {0x4f,0x67,0x67,0x53,0,0x01,
                                       0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                                       0x01,0x02,0x03,0x04,2,0,0,0,
                                       0xf4,0x87,0xba,0xf3,
                                       255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255};
                
                const int head4_6[] = {0x4f,0x67,0x67,0x53,0,0x05,
                                       0x07,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
                                       0x01,0x02,0x03,0x04,3,0,0,0,
                                       0xf7,0x2f,0x6c,0x60,
                                       5,
                                       254,255,4,255,0};
                
                /* packet that overspans over an entire page */
                const int head1_7[] = {0x4f,0x67,0x67,0x53,0,0x02,
                                       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                       0x01,0x02,0x03,0x04,0,0,0,0,
                                       0xff,0x7b,0x23,0x17,
                                       1,
                                       0};
                
                const int head2_7[] = {0x4f,0x67,0x67,0x53,0,0x00,
                                       0x07,0x04,0x00,0x00,0x00,0x00,0x00,0x00,
                                       0x01,0x02,0x03,0x04,1,0,0,0,
                                       0x68,0x22,0x7c,0x3d,
                                       255,
                                       100,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255,255,255,
                                       255,255,255,255,255,255};
                
                const int head3_7[] = {0x4f,0x67,0x67,0x53,0,0x05,
                                       0x07,0x08,0x00,0x00,0x00,0x00,0x00,0x00,
                                       0x01,0x02,0x03,0x04,2,0,0,0,
                                       0xd4,0xe0,0x60,0xe5,
                                       1,
                                       0};
                
                void test_pack(const int *pl, const int **headers, int byteskip,
                               int pageskip, int packetskip){
                  unsigned char *data=_ogg_malloc(1024*1024); /* for scripted test cases only */
                  long inptr=0;
                  long outptr=0;
                  long deptr=0;
                  long depacket=0;
                  long granule_pos=7,pageno=0;
                  int i,j,packets,pageout=pageskip;
                  int eosflag=0;
                  int bosflag=0;
                
                  int byteskipcount=0;
                
                  ogg_stream_reset(&os_en);
                  ogg_stream_reset(&os_de);
                  ogg_sync_reset(&oy);
                
                  for(packets=0;packets<packetskip;packets++)
                    depacket+=pl[packets];
                
                  for(packets=0;;packets++)if(pl[packets]==-1)break;
                
                  for(i=0;i<packets;i++){
                    /* construct a test packet */
                    ogg_packet op;
                    int len=pl[i];
                    
                    op.packet=data+inptr;
                    op.bytes=len;
                    op.e_o_s=(pl[i+1]<0?1:0);
                    op.granulepos=granule_pos;
                
                    granule_pos+=1024;
                
                    for(j=0;j<len;j++)data[inptr++]=i+j;
                
                    /* submit the test packet */
                    ogg_stream_packetin(&os_en,&op);
                
                    /* retrieve any finished pages */
                    {
                      ogg_page og;
                      
                      while(ogg_stream_pageout(&os_en,&og)){
                        /* We have a page.  Check it carefully */
                
                        fprintf(stderr,"%ld, ",pageno);
                
                        if(headers[pageno]==NULL){
                          fprintf(stderr,"coded too many pages!\n");
                          exit(1);
                        }
                
                        check_page(data+outptr,headers[pageno],&og);
                
                        outptr+=og.body_len;
                        pageno++;
                        if(pageskip){
                          bosflag=1;
                          pageskip--;
                          deptr+=og.body_len;
                        }
                
                        /* have a complete page; submit it to sync/decode */
                
                        {
                          ogg_page og_de;
                          ogg_packet op_de,op_de2;
                          char *buf=ogg_sync_buffer(&oy,og.header_len+og.body_len);
                          char *next=buf;
                          byteskipcount+=og.header_len;
                          if(byteskipcount>byteskip){
                            memcpy(next,og.header,byteskipcount-byteskip);
                            next+=byteskipcount-byteskip;
                            byteskipcount=byteskip;
                          }
                
                          byteskipcount+=og.body_len;
                          if(byteskipcount>byteskip){
                            memcpy(next,og.body,byteskipcount-byteskip);
                            next+=byteskipcount-byteskip;
                            byteskipcount=byteskip;
                          }
                
                          ogg_sync_wrote(&oy,next-buf);
                
                          while(1){
                            int ret=ogg_sync_pageout(&oy,&og_de);
                            if(ret==0)break;
                            if(ret<0)continue;
                            /* got a page.  Happy happy.  Verify that it's good. */
                            
                            fprintf(stderr,"(%d), ",pageout);
                
                            check_page(data+deptr,headers[pageout],&og_de);
                            deptr+=og_de.body_len;
                            pageout++;
                
                            /* submit it to deconstitution */
                            ogg_stream_pagein(&os_de,&og_de);
                
                            /* packets out? */
                            while(ogg_stream_packetpeek(&os_de,&op_de2)>0){
                              ogg_stream_packetpeek(&os_de,NULL);
                              ogg_stream_packetout(&os_de,&op_de); /* just catching them all */
                              
                              /* verify peek and out match */
                              if(memcmp(&op_de,&op_de2,sizeof(op_de))){
                                fprintf(stderr,"packetout != packetpeek! pos=%ld\n",
                                        depacket);
                                exit(1);
                              }
                
                              /* verify the packet! */
                              /* check data */
                              if(memcmp(data+depacket,op_de.packet,op_de.bytes)){
                                fprintf(stderr,"packet data mismatch in decode! pos=%ld\n",
                                        depacket);
                                exit(1);
                              }
                              /* check bos flag */
                              if(bosflag==0 && op_de.b_o_s==0){
                                fprintf(stderr,"b_o_s flag not set on packet!\n");
                                exit(1);
                              }
                              if(bosflag && op_de.b_o_s){
                                fprintf(stderr,"b_o_s flag incorrectly set on packet!\n");
                                exit(1);
                              }
                              bosflag=1;
                              depacket+=op_de.bytes;
                              
                              /* check eos flag */
                              if(eosflag){
                                fprintf(stderr,"Multiple decoded packets with eos flag!\n");
                                exit(1);
                              }
                
                              if(op_de.e_o_s)eosflag=1;
                
                              /* check granulepos flag */
                              if(op_de.granulepos!=-1){
                                fprintf(stderr," granule:%ld ",(long)op_de.granulepos);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  _ogg_free(data);
                  if(headers[pageno]!=NULL){
                    fprintf(stderr,"did not write last page!\n");
                    exit(1);
                  }
                  if(headers[pageout]!=NULL){
                    fprintf(stderr,"did not decode last page!\n");
                    exit(1);
                  }
                  if(inptr!=outptr){
                    fprintf(stderr,"encoded page data incomplete!\n");
                    exit(1);
                  }
                  if(inptr!=deptr){
                    fprintf(stderr,"decoded page data incomplete!\n");
                    exit(1);
                  }
                  if(inptr!=depacket){
                    fprintf(stderr,"decoded packet data incomplete!\n");
                    exit(1);
                  }
                  if(!eosflag){
                    fprintf(stderr,"Never got a packet with EOS set!\n");
                    exit(1);
                  }
                  fprintf(stderr,"ok.\n");
                }
                
                int main(void){
                
                  ogg_stream_init(&os_en,0x04030201);
                  ogg_stream_init(&os_de,0x04030201);
                  ogg_sync_init(&oy);
                
                  /* Exercise each code path in the framing code.  Also verify that
                     the checksums are working.  */
                
                  {
                    /* 17 only */
                    const int packets[]={17, -1};
                    const int *headret[]={head1_0,NULL};
                
                    fprintf(stderr,"testing single page encoding... ");
                    test_pack(packets,headret,0,0,0);
                  }
                
                  {
                    /* 17, 254, 255, 256, 500, 510, 600 byte, pad */
                    const int packets[]={17, 254, 255, 256, 500, 510, 600, -1};
                    const int *headret[]={head1_1,head2_1,NULL};
                
                    fprintf(stderr,"testing basic page encoding... ");
                    test_pack(packets,headret,0,0,0);
                  }
                
                  {
                    /* nil packets; beginning,middle,end */
                    const int packets[]={0,17, 254, 255, 0, 256, 0, 500, 510, 600, 0, -1};
                    const int *headret[]={head1_2,head2_2,NULL};
                
                    fprintf(stderr,"testing basic nil packets... ");
                    test_pack(packets,headret,0,0,0);
                  }
                
                  {
                    /* large initial packet */
                    const int packets[]={4345,259,255,-1};
                    const int *headret[]={head1_3,head2_3,NULL};
                
                    fprintf(stderr,"testing initial-packet lacing > 4k... ");
                    test_pack(packets,headret,0,0,0);
                  }
                
                  {
                    /* continuing packet test; with page spill expansion, we have to
                       overflow the lacing table. */
                    const int packets[]={0,65500,259,255,-1};
                    const int *headret[]={head1_4,head2_4,head3_4,NULL};
                
                    fprintf(stderr,"testing single packet page span... ");
                    test_pack(packets,headret,0,0,0);
                  }
                
                  {
                    /* spill expand packet test */
                    const int packets[]={0,4345,259,255,0,0,-1};
                    const int *headret[]={head1_4b,head2_4b,head3_4b,NULL};
                
                    fprintf(stderr,"testing page spill expansion... ");
                    test_pack(packets,headret,0,0,0);
                  }
                
                  /* page with the 255 segment limit */
                  {
                
                    const int packets[]={0,10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,10,
                                   10,10,10,10,10,10,10,50,-1};
                    const int *headret[]={head1_5,head2_5,head3_5,NULL};
                    
                    fprintf(stderr,"testing max packet segments... ");
                    test_pack(packets,headret,0,0,0);
                  }
                
                  {
                    /* packet that overspans over an entire page */
                    const int packets[]={0,100,130049,259,255,-1};
                    const int *headret[]={head1_6,head2_6,head3_6,head4_6,NULL};
                    
                    fprintf(stderr,"testing very large packets... ");
                    test_pack(packets,headret,0,0,0);
                  }
                
                  {
                    /* test for the libogg 1.1.1 resync in large continuation bug
                       found by Josh Coalson)  */
                    const int packets[]={0,100,130049,259,255,-1};
                    const int *headret[]={head1_6,head2_6,head3_6,head4_6,NULL};
                    
                    fprintf(stderr,"testing continuation resync in very large packets... ");
                    test_pack(packets,headret,100,2,3);
                  }
                
                  {
                    /* term only page.  why not? */
                    const int packets[]={0,100,64770,-1};
                    const int *headret[]={head1_7,head2_7,head3_7,NULL};
                    
                    fprintf(stderr,"testing zero data page (1 nil packet)... ");
                    test_pack(packets,headret,0,0,0);
                  }
                
                
                
                  {
                    /* build a bunch of pages for testing */
                    unsigned char *data=_ogg_malloc(1024*1024);
                    int pl[]={0, 1,1,98,4079, 1,1,2954,2057, 76,34,912,0,234,1000,1000, 1000,300,-1};
                    int inptr=0,i,j;
                    ogg_page og[5];
                    
                    ogg_stream_reset(&os_en);
                
                    for(i=0;pl[i]!=-1;i++){
                      ogg_packet op;
                      int len=pl[i];
                      
                      op.packet=data+inptr;
                      op.bytes=len;
                      op.e_o_s=(pl[i+1]<0?1:0);
                      op.granulepos=(i+1)*1000;
                
                      for(j=0;j<len;j++)data[inptr++]=i+j;
                      ogg_stream_packetin(&os_en,&op);
                    }
                
                    _ogg_free(data);
                
                    /* retrieve finished pages */
                    for(i=0;i<5;i++){
                      if(ogg_stream_pageout(&os_en,&og[i])==0){
                        fprintf(stderr,"Too few pages output building sync tests!\n");
                        exit(1);
                      }
                      copy_page(&og[i]);
                    }
                
                    /* Test lost pages on pagein/packetout: no rollback */
                    {
                      ogg_page temp;
                      ogg_packet test;
                
                      fprintf(stderr,"Testing loss of pages... ");
                
                      ogg_sync_reset(&oy);
                      ogg_stream_reset(&os_de);
                      for(i=0;i<5;i++){
                        memcpy(ogg_sync_buffer(&oy,og[i].header_len),og[i].header,
                               og[i].header_len);
                        ogg_sync_wrote(&oy,og[i].header_len);
                        memcpy(ogg_sync_buffer(&oy,og[i].body_len),og[i].body,og[i].body_len);
                        ogg_sync_wrote(&oy,og[i].body_len);
                      }
                
                      ogg_sync_pageout(&oy,&temp);
                      ogg_stream_pagein(&os_de,&temp);
                      ogg_sync_pageout(&oy,&temp);
                      ogg_stream_pagein(&os_de,&temp);
                      ogg_sync_pageout(&oy,&temp);
                      /* skip */
                      ogg_sync_pageout(&oy,&temp);
                      ogg_stream_pagein(&os_de,&temp);
                
                      /* do we get the expected results/packets? */
                      
                      if(ogg_stream_packetout(&os_de,&test)!=1)error();
                      checkpacket(&test,0,0,0);
                      if(ogg_stream_packetout(&os_de,&test)!=1)error();
                      checkpacket(&test,1,1,-1);
                      if(ogg_stream_packetout(&os_de,&test)!=1)error();
                      checkpacket(&test,1,2,-1);
                      if(ogg_stream_packetout(&os_de,&test)!=1)error();
                      checkpacket(&test,98,3,-1);
                      if(ogg_stream_packetout(&os_de,&test)!=1)error();
                      checkpacket(&test,4079,4,5000);
                      if(ogg_stream_packetout(&os_de,&test)!=-1){
                        fprintf(stderr,"Error: loss of page did not return error\n");
                        exit(1);
                      }
                      if(ogg_stream_packetout(&os_de,&test)!=1)error();
                      checkpacket(&test,76,9,-1);
                      if(ogg_stream_packetout(&os_de,&test)!=1)error();
                      checkpacket(&test,34,10,-1);
                      fprintf(stderr,"ok.\n");
                    }
                
                    /* Test lost pages on pagein/packetout: rollback with continuation */
                    {
                      ogg_page temp;
                      ogg_packet test;
                
                      fprintf(stderr,"Testing loss of pages (rollback required)... ");
                
                      ogg_sync_reset(&oy);
                      ogg_stream_reset(&os_de);
                      for(i=0;i<5;i++){
                        memcpy(ogg_sync_buffer(&oy,og[i].header_len),og[i].header,
                               og[i].header_len);
                        ogg_sync_wrote(&oy,og[i].header_len);
                        memcpy(ogg_sync_buffer(&oy,og[i].body_len),og[i].body,og[i].body_len);
                        ogg_sync_wrote(&oy,og[i].body_len);
                      }
                
                      ogg_sync_pageout(&oy,&temp);
                      ogg_stream_pagein(&os_de,&temp);
                      ogg_sync_pageout(&oy,&temp);
                      ogg_stream_pagein(&os_de,&temp);
                      ogg_sync_pageout(&oy,&temp);
                      ogg_stream_pagein(&os_de,&temp);
                      ogg_sync_pageout(&oy,&temp);
                      /* skip */
                      ogg_sync_pageout(&oy,&temp);
                      ogg_stream_pagein(&os_de,&temp);
                
                      /* do we get the expected results/packets? */
                
                      if(ogg_stream_packetout(&os_de,&test)!=1)error();
                      checkpacket(&test,0,0,0);
                      if(ogg_stream_packetout(&os_de,&test)!=1)error();
                      checkpacket(&test,1,1,-1);
                      if(ogg_stream_packetout(&os_de,&test)!=1)error();
                      checkpacket(&test,1,2,-1);
                      if(ogg_stream_packetout(&os_de,&test)!=1)error();
                      checkpacket(&test,98,3,-1);
                      if(ogg_stream_packetout(&os_de,&test)!=1)error();
                      checkpacket(&test,4079,4,5000);
                      if(ogg_stream_packetout(&os_de,&test)!=1)error();
                      checkpacket(&test,1,5,-1);
                      if(ogg_stream_packetout(&os_de,&test)!=1)error();
                      checkpacket(&test,1,6,-1);
                      if(ogg_stream_packetout(&os_de,&test)!=1)error();
                      checkpacket(&test,2954,7,-1);
                      if(ogg_stream_packetout(&os_de,&test)!=1)error();
                      checkpacket(&test,2057,8,9000);
                      if(ogg_stream_packetout(&os_de,&test)!=-1){
                        fprintf(stderr,"Error: loss of page did not return error\n");
                        exit(1);
                      }
                      if(ogg_stream_packetout(&os_de,&test)!=1)error();
                      checkpacket(&test,300,17,18000);
                      fprintf(stderr,"ok.\n");
                    }
                
                    /* the rest only test sync */
                    {
                      ogg_page og_de;
                      /* Test fractional page inputs: incomplete capture */
                      fprintf(stderr,"Testing sync on partial inputs... ");
                      ogg_sync_reset(&oy);
                      memcpy(ogg_sync_buffer(&oy,og[1].header_len),og[1].header,
                             3);
                      ogg_sync_wrote(&oy,3);
                      if(ogg_sync_pageout(&oy,&og_de)>0)error();
                
                      /* Test fractional page inputs: incomplete fixed header */
                      memcpy(ogg_sync_buffer(&oy,og[1].header_len),og[1].header+3,
                             20);
                      ogg_sync_wrote(&oy,20);
                      if(ogg_sync_pageout(&oy,&og_de)>0)error();
                
                      /* Test fractional page inputs: incomplete header */
                      memcpy(ogg_sync_buffer(&oy,og[1].header_len),og[1].header+23,
                             5);
                      ogg_sync_wrote(&oy,5);
                      if(ogg_sync_pageout(&oy,&og_de)>0)error();
                
                      /* Test fractional page inputs: incomplete body */
                
                      memcpy(ogg_sync_buffer(&oy,og[1].header_len),og[1].header+28,
                             og[1].header_len-28);
                      ogg_sync_wrote(&oy,og[1].header_len-28);
                      if(ogg_sync_pageout(&oy,&og_de)>0)error();
                
                      memcpy(ogg_sync_buffer(&oy,og[1].body_len),og[1].body,1000);
                      ogg_sync_wrote(&oy,1000);
                      if(ogg_sync_pageout(&oy,&og_de)>0)error();
                
                      memcpy(ogg_sync_buffer(&oy,og[1].body_len),og[1].body+1000,
                             og[1].body_len-1000);
                      ogg_sync_wrote(&oy,og[1].body_len-1000);
                      if(ogg_sync_pageout(&oy,&og_de)<=0)error();
                
                      fprintf(stderr,"ok.\n");
                    }
                
                    /* Test fractional page inputs: page + incomplete capture */
                    {
                      ogg_page og_de;
                      fprintf(stderr,"Testing sync on 1+partial inputs... ");
                      ogg_sync_reset(&oy);
                
                      memcpy(ogg_sync_buffer(&oy,og[1].header_len),og[1].header,
                             og[1].header_len);
                      ogg_sync_wrote(&oy,og[1].header_len);
                
                      memcpy(ogg_sync_buffer(&oy,og[1].body_len),og[1].body,
                             og[1].body_len);
                      ogg_sync_wrote(&oy,og[1].body_len);
                
                      memcpy(ogg_sync_buffer(&oy,og[1].header_len),og[1].header,
                             20);
                      ogg_sync_wrote(&oy,20);
                      if(ogg_sync_pageout(&oy,&og_de)<=0)error();
                      if(ogg_sync_pageout(&oy,&og_de)>0)error();
                
                      memcpy(ogg_sync_buffer(&oy,og[1].header_len),og[1].header+20,
                             og[1].header_len-20);
                      ogg_sync_wrote(&oy,og[1].header_len-20);
                      memcpy(ogg_sync_buffer(&oy,og[1].body_len),og[1].body,
                             og[1].body_len);
                      ogg_sync_wrote(&oy,og[1].body_len);
                      if(ogg_sync_pageout(&oy,&og_de)<=0)error();
                
                      fprintf(stderr,"ok.\n");
                    }
                    
                    /* Test recapture: garbage + page */
                    {
                      ogg_page og_de;
                      fprintf(stderr,"Testing search for capture... ");
                      ogg_sync_reset(&oy); 
                      
                      /* 'garbage' */
                      memcpy(ogg_sync_buffer(&oy,og[1].body_len),og[1].body,
                             og[1].body_len);
                      ogg_sync_wrote(&oy,og[1].body_len);
                
                      memcpy(ogg_sync_buffer(&oy,og[1].header_len),og[1].header,
                             og[1].header_len);
                      ogg_sync_wrote(&oy,og[1].header_len);
                
                      memcpy(ogg_sync_buffer(&oy,og[1].body_len),og[1].body,
                             og[1].body_len);
                      ogg_sync_wrote(&oy,og[1].body_len);
                
                      memcpy(ogg_sync_buffer(&oy,og[2].header_len),og[2].header,
                             20);
                      ogg_sync_wrote(&oy,20);
                      if(ogg_sync_pageout(&oy,&og_de)>0)error();
                      if(ogg_sync_pageout(&oy,&og_de)<=0)error();
                      if(ogg_sync_pageout(&oy,&og_de)>0)error();
                
                      memcpy(ogg_sync_buffer(&oy,og[2].header_len),og[2].header+20,
                             og[2].header_len-20);
                      ogg_sync_wrote(&oy,og[2].header_len-20);
                      memcpy(ogg_sync_buffer(&oy,og[2].body_len),og[2].body,
                             og[2].body_len);
                      ogg_sync_wrote(&oy,og[2].body_len);
                      if(ogg_sync_pageout(&oy,&og_de)<=0)error();
                
                      fprintf(stderr,"ok.\n");
                    }
                
                    /* Test recapture: page + garbage + page */
                    {
                      ogg_page og_de;
                      fprintf(stderr,"Testing recapture... ");
                      ogg_sync_reset(&oy); 
                
                      memcpy(ogg_sync_buffer(&oy,og[1].header_len),og[1].header,
                             og[1].header_len);
                      ogg_sync_wrote(&oy,og[1].header_len);
                
                      memcpy(ogg_sync_buffer(&oy,og[1].body_len),og[1].body,
                             og[1].body_len);
                      ogg_sync_wrote(&oy,og[1].body_len);
                
                      memcpy(ogg_sync_buffer(&oy,og[2].header_len),og[2].header,
                             og[2].header_len);
                      ogg_sync_wrote(&oy,og[2].header_len);
                
                      memcpy(ogg_sync_buffer(&oy,og[2].header_len),og[2].header,
                             og[2].header_len);
                      ogg_sync_wrote(&oy,og[2].header_len);
                
                      if(ogg_sync_pageout(&oy,&og_de)<=0)error();
                
                      memcpy(ogg_sync_buffer(&oy,og[2].body_len),og[2].body,
                             og[2].body_len-5);
                      ogg_sync_wrote(&oy,og[2].body_len-5);
                
                      memcpy(ogg_sync_buffer(&oy,og[3].header_len),og[3].header,
                             og[3].header_len);
                      ogg_sync_wrote(&oy,og[3].header_len);
                
                      memcpy(ogg_sync_buffer(&oy,og[3].body_len),og[3].body,
                             og[3].body_len);
                      ogg_sync_wrote(&oy,og[3].body_len);
                
                      if(ogg_sync_pageout(&oy,&og_de)>0)error();
                      if(ogg_sync_pageout(&oy,&og_de)<=0)error();
                
                      fprintf(stderr,"ok.\n");
                    }
                
                    /* Free page data that was previously copied */
                    {
                      for(i=0;i<5;i++){
                        free_page(&og[i]);
                      }
                    }
                  }    
                
                  return(0);
                }
                
                #endif
                
                
                
                


Top 10 Lines:

     Line      Count

      211       5701
      597       5430
      943       5078
     1004       4998
      651       2365
      634       1518
      602       1516
       58       1304
      228       1121
       45        770

Execution Summary:

       38   Executable lines in this file
       34   Lines executed
    89.47   Percent of the file executed

    34165   Total number of line executions
   899.08   Average executions per line


*** File C:\cygwin\workspace\_git_repos\CustomizeVorbis_static\GprofCdt/../lib/res0.c:
                /********************************************************************
                 *                                                                  *
                 * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
                 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
                 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
                 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
                 *                                                                  *
                 * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2010             *
                 * by the Xiph.Org Foundation http://www.xiph.org/                  *
                 *                                                                  *
                 ********************************************************************
                
                 function: residue backend 0, 1 and 2 implementation
                 last mod: $Id: res0.c 17556 2010-10-21 18:25:19Z tterribe $
                
                 ********************************************************************/
                
                /* Slow, slow, slow, simpleminded and did I mention it was slow?  The
                   encode/decode loops are coded for clarity and performance is not
                   yet even a nagging little idea lurking in the shadows.  Oh and BTW,
                   it's slow. */
                
                #include <stdlib.h>
                #include <string.h>
                #include <math.h>
                #include <ogg/ogg.h>
                #include "vorbis/codec.h"
                #include "codec_internal.h"
                #include "registry.h"
                #include "codebook.h"
                #include "misc.h"
                #include "os.h"
                
                //#define TRAIN_RES 1
                //#define TRAIN_RESAUX 1
                
                #if defined(TRAIN_RES) || defined (TRAIN_RESAUX)
                #include <stdio.h>
                #endif
                
                typedef struct {
                  vorbis_info_residue0 *info;
                
                  int         parts;
                  int         stages;
                  codebook   *fullbooks;
                  codebook   *phrasebook;
                  codebook ***partbooks;
                
                  int         partvals;
                  int       **decodemap;
                
                  long      postbits;
                  long      phrasebits;
                  long      frames;
                
                #if defined(TRAIN_RES) || defined(TRAIN_RESAUX)
                  int        train_seq;
                  long      *training_data[8][64];
                  float      training_max[8][64];
                  float      training_min[8][64];
                  float     tmin;
                  float     tmax;
                  int       submap;
                #endif
                
                } vorbis_look_residue0;
                
          24 -> void res0_free_info(vorbis_info_residue *i){
                  vorbis_info_residue0 *info=(vorbis_info_residue0 *)i;
                  if(info){
                    memset(info,0,sizeof(*info));
                    _ogg_free(info);
                  }
                }
                
         328 -> void res0_free_look(vorbis_look_residue *i){
                  int j;
                  if(i){
                
                    vorbis_look_residue0 *look=(vorbis_look_residue0 *)i;
                
                #ifdef TRAIN_RES
                    {
                      int j,k,l;
                      for(j=0;j<look->parts;j++){
                        /*fprintf(stderr,"partition %d: ",j);*/
                        for(k=0;k<8;k++)
                          if(look->training_data[k][j]){
                            char buffer[80];
                            FILE *of;
                            codebook *statebook=look->partbooks[j][k];
                
                            /* long and short into the same bucket by current convention */
                            sprintf(buffer,"res_sub%d_part%d_pass%d.vqd",look->submap,j,k);
                            of=fopen(buffer,"a");
                
                            for(l=0;l<statebook->entries;l++)
                              fprintf(of,"%d:%ld\n",l,look->training_data[k][j][l]);
                
                            fclose(of);
                
                            /*fprintf(stderr,"%d(%.2f|%.2f) ",k,
                              look->training_min[k][j],look->training_max[k][j]);*/
                
                            _ogg_free(look->training_data[k][j]);
                            look->training_data[k][j]=NULL;
                          }
                        /*fprintf(stderr,"\n");*/
                      }
                    }
                    fprintf(stderr,"min/max residue: %g::%g\n",look->tmin,look->tmax);
                
                    /*fprintf(stderr,"residue bit usage %f:%f (%f total)\n",
                            (float)look->phrasebits/look->frames,
                            (float)look->postbits/look->frames,
                            (float)(look->postbits+look->phrasebits)/look->frames);*/
                #endif
                
                
                    /*vorbis_info_residue0 *info=look->info;
                
                    fprintf(stderr,
                            "%ld frames encoded in %ld phrasebits and %ld residue bits "
                            "(%g/frame) \n",look->frames,look->phrasebits,
                            look->resbitsflat,
                            (look->phrasebits+look->resbitsflat)/(float)look->frames);
                
                    for(j=0;j<look->parts;j++){
                      long acc=0;
                      fprintf(stderr,"\t[%d] == ",j);
                      for(k=0;k<look->stages;k++)
                        if((info->secondstages[j]>>k)&1){
                          fprintf(stderr,"%ld,",look->resbits[j][k]);
                          acc+=look->resbits[j][k];
                        }
                
                      fprintf(stderr,":: (%ld vals) %1.2fbits/sample\n",look->resvals[j],
                              acc?(float)acc/(look->resvals[j]*info->grouping):0);
                    }
                    fprintf(stderr,"\n");*/
                
                    for(j=0;j<look->parts;j++)
                      if(look->partbooks[j])_ogg_free(look->partbooks[j]);
                    _ogg_free(look->partbooks);
                    for(j=0;j<look->partvals;j++)
                      _ogg_free(look->decodemap[j]);
                    _ogg_free(look->decodemap);
                
                    memset(look,0,sizeof(*look));
                    _ogg_free(look);
                  }
                }
                
                static int ilog(unsigned int v){
                  int ret=0;
                  while(v){
                    ret++;
                    v>>=1;
                  }
                  return(ret);
                }
                
                static int icount(unsigned int v){
                  int ret=0;
                  while(v){
                    ret+=v&1;
                    v>>=1;
                  }
                  return(ret);
                }
                
                
       ##### -> void res0_pack(vorbis_info_residue *vr,oggpack_buffer *opb){
                  vorbis_info_residue0 *info=(vorbis_info_residue0 *)vr;
                  int j,acc=0;
                  oggpack_write(opb,info->begin,24);
                  oggpack_write(opb,info->end,24);
                
                  oggpack_write(opb,info->grouping-1,24);  /* residue vectors to group and
                                                             code with a partitioned book */
                  oggpack_write(opb,info->partitions-1,6); /* possible partition choices */
                  oggpack_write(opb,info->groupbook,8);  /* group huffman book */
                
                  /* secondstages is a bitmask; as encoding progresses pass by pass, a
                     bitmask of one indicates this partition class has bits to write
                     this pass */
                  for(j=0;j<info->partitions;j++){
                    if(ilog(info->secondstages[j])>3){
                      /* yes, this is a minor hack due to not thinking ahead */
                      oggpack_write(opb,info->secondstages[j],3);
                      oggpack_write(opb,1,1);
                      oggpack_write(opb,info->secondstages[j]>>3,5);
                    }else
                      oggpack_write(opb,info->secondstages[j],4); /* trailing zero */
                    acc+=icount(info->secondstages[j]);
                  }
                  for(j=0;j<acc;j++)
                    oggpack_write(opb,info->booklist[j],8);
                
                }
                
                /* vorbis_info is for range checking */
          24 -> vorbis_info_residue *res0_unpack(vorbis_info *vi,oggpack_buffer *opb){
                  int j,acc=0;
                  vorbis_info_residue0 *info=_ogg_calloc(1,sizeof(*info));
                  codec_setup_info     *ci=vi->codec_setup;
                
                  info->begin=oggpack_read(opb,24);
                  info->end=oggpack_read(opb,24);
                  info->grouping=oggpack_read(opb,24)+1;
                  info->partitions=oggpack_read(opb,6)+1;
                  info->groupbook=oggpack_read(opb,8);
                
                  /* check for premature EOP */
                  if(info->groupbook<0)goto errout;
                
                  for(j=0;j<info->partitions;j++){
                    int cascade=oggpack_read(opb,3);
                    int cflag=oggpack_read(opb,1);
                    if(cflag<0) goto errout;
                    if(cflag){
                      int c=oggpack_read(opb,5);
                      if(c<0) goto errout;
                      cascade|=(c<<3);
                    }
                    info->secondstages[j]=cascade;
                
                    acc+=icount(cascade);
                  }
                  for(j=0;j<acc;j++){
                    int book=oggpack_read(opb,8);
                    if(book<0) goto errout;
                    info->booklist[j]=book;
                  }
                
                  if(info->groupbook>=ci->books)goto errout;
                  for(j=0;j<acc;j++){
                    if(info->booklist[j]>=ci->books)goto errout;
                    if(ci->book_param[info->booklist[j]]->maptype==0)goto errout;
                  }
                
                  /* verify the phrasebook is not specifying an impossible or
                     inconsistent partitioning scheme. */
                  /* modify the phrasebook ranging check from r16327; an early beta
                     encoder had a bug where it used an oversized phrasebook by
                     accident.  These files should continue to be playable, but don't
                     allow an exploit */
                  {
                    int entries = ci->book_param[info->groupbook]->entries;
                    int dim = ci->book_param[info->groupbook]->dim;
                    int partvals = 1;
                    if (dim<1) goto errout;
                    while(dim>0){
                      partvals *= info->partitions;
                      if(partvals > entries) goto errout;
                      dim--;
                    }
                    info->partvals = partvals;
                  }
                
                  return(info);
                 errout:
                  res0_free_info(info);
                  return(NULL);
                }
                
                vorbis_look_residue *res0_look(vorbis_dsp_state *vd,
           8 ->                                vorbis_info_residue *vr){
                  vorbis_info_residue0 *info=(vorbis_info_residue0 *)vr;
                  vorbis_look_residue0 *look=_ogg_calloc(1,sizeof(*look));
                  codec_setup_info     *ci=vd->vi->codec_setup;
                
                  int j,k,acc=0;
                  int dim;
                  int maxstage=0;
                  look->info=info;
                
                  look->parts=info->partitions;
                  look->fullbooks=ci->fullbooks;
                  look->phrasebook=ci->fullbooks+info->groupbook;
                  dim=look->phrasebook->dim;
                
                  look->partbooks=_ogg_calloc(look->parts,sizeof(*look->partbooks));
                
                  for(j=0;j<look->parts;j++){
                    int stages=ilog(info->secondstages[j]);
                    if(stages){
                      if(stages>maxstage)maxstage=stages;
                      look->partbooks[j]=_ogg_calloc(stages,sizeof(*look->partbooks[j]));
                      for(k=0;k<stages;k++)
                        if(info->secondstages[j]&(1<<k)){
                          look->partbooks[j][k]=ci->fullbooks+info->booklist[acc++];
                #ifdef TRAIN_RES
                          look->training_data[k][j]=_ogg_calloc(look->partbooks[j][k]->entries,
                                                           sizeof(***look->training_data));
                #endif
                        }
                    }
                  }
                
                  look->partvals=1;
                  for(j=0;j<dim;j++)
                      look->partvals*=look->parts;
                
                  look->stages=maxstage;
                  look->decodemap=_ogg_malloc(look->partvals*sizeof(*look->decodemap));
                  for(j=0;j<look->partvals;j++){
                    long val=j;
                    long mult=look->partvals/look->parts;
                    look->decodemap[j]=_ogg_malloc(dim*sizeof(*look->decodemap[j]));
                    for(k=0;k<dim;k++){
                      long deco=val/mult;
                      val-=deco*mult;
                      mult/=look->parts;
                      look->decodemap[j][k]=deco;
                    }
                  }
                #if defined(TRAIN_RES) || defined (TRAIN_RESAUX)
                  {
                    static int train_seq=0;
                    look->train_seq=train_seq++;
                  }
                #endif
                  return(look);
                }
                
                /* break an abstraction and copy some code for performance purposes */
                static int local_book_besterror(codebook *book,int *a){
                  int dim=book->dim;
                  int i,j,o;
                  int minval=book->minval;
                  int del=book->delta;
                  int qv=book->quantvals;
                  int ze=(qv>>1);
                  int index=0;
                  /* assumes integer/centered encoder codebook maptype 1 no more than dim 8 */
                  int p[8]={0,0,0,0,0,0,0,0};
                
                  if(del!=1){
                    for(i=0,o=dim;i<dim;i++){
                      int v = (a[--o]-minval+(del>>1))/del;
                      int m = (v<ze ? ((ze-v)<<1)-1 : ((v-ze)<<1));
                      index = index*qv+ (m<0?0:(m>=qv?qv-1:m));
                      p[o]=v*del+minval;
                    }
                  }else{
                    for(i=0,o=dim;i<dim;i++){
                      int v = a[--o]-minval;
                      int m = (v<ze ? ((ze-v)<<1)-1 : ((v-ze)<<1));
                      index = index*qv+ (m<0?0:(m>=qv?qv-1:m));
                      p[o]=v*del+minval;
                    }
                  }
                
                  if(book->c->lengthlist[index]<=0){
                    const static_codebook *c=book->c;
                    int best=-1;
                    /* assumes integer/centered encoder codebook maptype 1 no more than dim 8 */
                    int e[8]={0,0,0,0,0,0,0,0};
                    int maxval = book->minval + book->delta*(book->quantvals-1);
                    for(i=0;i<book->entries;i++){
                      if(c->lengthlist[i]>0){
                        int this=0;
                        for(j=0;j<dim;j++){
                          int val=(e[j]-a[j]);
                          this+=val*val;
                        }
                        if(best==-1 || this<best){
                          memcpy(p,e,sizeof(p));
                          best=this;
                          index=i;
                        }
                      }
                      /* assumes the value patterning created by the tools in vq/ */
                      j=0;
                      while(e[j]>=maxval)
                        e[j++]=0;
                      if(e[j]>=0)
                        e[j]+=book->delta;
                      e[j]= -e[j];
                    }
                  }
                
                  if(index>-1){
                    for(i=0;i<dim;i++)
                      *a++ -= p[i];
                  }
                
                  return(index);
                }
                
                static int _encodepart(oggpack_buffer *opb,int *vec, int n,
                                       codebook *book,long *acc){
                  int i,bits=0;
                  int dim=book->dim;
                  int step=n/dim;
                
                  for(i=0;i<step;i++){
                    int entry=local_book_besterror(book,vec+i*dim);
                
                #ifdef TRAIN_RES
                    if(entry>=0)
                      acc[entry]++;
                #endif
                
                    bits+=vorbis_book_encode(book,entry,opb);
                
                  }
                
                  return(bits);
                }
                
                static long **_01class(vorbis_block *vb,vorbis_look_residue *vl,
                                       int **in,int ch){
                  long i,j,k;
                  vorbis_look_residue0 *look=(vorbis_look_residue0 *)vl;
                  vorbis_info_residue0 *info=look->info;
                
                  /* move all this setup out later */
                  int samples_per_partition=info->grouping;
                  int possible_partitions=info->partitions;
                  int n=info->end-info->begin;
                
                  int partvals=n/samples_per_partition;
                  long **partword=_vorbis_block_alloc(vb,ch*sizeof(*partword));
                  float scale=100./samples_per_partition;
                
                  /* we find the partition type for each partition of each
                     channel.  We'll go back and do the interleaved encoding in a
                     bit.  For now, clarity */
                
                  for(i=0;i<ch;i++){
                    partword[i]=_vorbis_block_alloc(vb,n/samples_per_partition*sizeof(*partword[i]));
                    memset(partword[i],0,n/samples_per_partition*sizeof(*partword[i]));
                  }
                
                  for(i=0;i<partvals;i++){
                    int offset=i*samples_per_partition+info->begin;
                    for(j=0;j<ch;j++){
                      int max=0;
                      int ent=0;
                      for(k=0;k<samples_per_partition;k++){
                        if(abs(in[j][offset+k])>max)max=abs(in[j][offset+k]);
                        ent+=abs(in[j][offset+k]);
                      }
                      ent*=scale;
                
                      for(k=0;k<possible_partitions-1;k++)
                        if(max<=info->classmetric1[k] &&
                           (info->classmetric2[k]<0 || ent<info->classmetric2[k]))
                          break;
                
                      partword[j][i]=k;
                    }
                  }
                
                #ifdef TRAIN_RESAUX
                  {
                    FILE *of;
                    char buffer[80];
                
                    for(i=0;i<ch;i++){
                      sprintf(buffer,"resaux_%d.vqd",look->train_seq);
                      of=fopen(buffer,"a");
                      for(j=0;j<partvals;j++)
                        fprintf(of,"%ld, ",partword[i][j]);
                      fprintf(of,"\n");
                      fclose(of);
                    }
                  }
                #endif
                  look->frames++;
                
                  return(partword);
                }
                
                /* designed for stereo or other modes where the partition size is an
                   integer multiple of the number of channels encoded in the current
                   submap */
                static long **_2class(vorbis_block *vb,vorbis_look_residue *vl,int **in,
                                      int ch){
                  long i,j,k,l;
                  vorbis_look_residue0 *look=(vorbis_look_residue0 *)vl;
                  vorbis_info_residue0 *info=look->info;
                
                  /* move all this setup out later */
                  int samples_per_partition=info->grouping;
                  int possible_partitions=info->partitions;
                  int n=info->end-info->begin;
                
                  int partvals=n/samples_per_partition;
                  long **partword=_vorbis_block_alloc(vb,sizeof(*partword));
                
                #if defined(TRAIN_RES) || defined (TRAIN_RESAUX)
                  FILE *of;
                  char buffer[80];
                #endif
                
                  partword[0]=_vorbis_block_alloc(vb,partvals*sizeof(*partword[0]));
                  memset(partword[0],0,partvals*sizeof(*partword[0]));
                
                  for(i=0,l=info->begin/ch;i<partvals;i++){
                    int magmax=0;
                    int angmax=0;
                    for(j=0;j<samples_per_partition;j+=ch){
                      if(abs(in[0][l])>magmax)magmax=abs(in[0][l]);
                      for(k=1;k<ch;k++)
                        if(abs(in[k][l])>angmax)angmax=abs(in[k][l]);
                      l++;
                    }
                
                    for(j=0;j<possible_partitions-1;j++)
                      if(magmax<=info->classmetric1[j] &&
                         angmax<=info->classmetric2[j])
                        break;
                
                    partword[0][i]=j;
                
                  }
                
                #ifdef TRAIN_RESAUX
                  sprintf(buffer,"resaux_%d.vqd",look->train_seq);
                  of=fopen(buffer,"a");
                  for(i=0;i<partvals;i++)
                    fprintf(of,"%ld, ",partword[0][i]);
                  fprintf(of,"\n");
                  fclose(of);
                #endif
                
                  look->frames++;
                
                  return(partword);
                }
                
                static int _01forward(oggpack_buffer *opb,
                                      vorbis_block *vb,vorbis_look_residue *vl,
                                      int **in,int ch,
                                      long **partword,
                                      int (*encode)(oggpack_buffer *,int *,int,
                                                    codebook *,long *),
                                      int submap){
                  long i,j,k,s;
                  vorbis_look_residue0 *look=(vorbis_look_residue0 *)vl;
                  vorbis_info_residue0 *info=look->info;
                
                #ifdef TRAIN_RES
                  look->submap=submap;
                #endif
                
                  /* move all this setup out later */
                  int samples_per_partition=info->grouping;
                  int possible_partitions=info->partitions;
                  int partitions_per_word=look->phrasebook->dim;
                  int n=info->end-info->begin;
                
                  int partvals=n/samples_per_partition;
                  long resbits[128];
                  long resvals[128];
                
                #ifdef TRAIN_RES
                  for(i=0;i<ch;i++)
                    for(j=info->begin;j<info->end;j++){
                      if(in[i][j]>look->tmax)look->tmax=in[i][j];
                      if(in[i][j]<look->tmin)look->tmin=in[i][j];
                    }
                #endif
                
                  memset(resbits,0,sizeof(resbits));
                  memset(resvals,0,sizeof(resvals));
                
                  /* we code the partition words for each channel, then the residual
                     words for a partition per channel until we've written all the
                     residual words for that partition word.  Then write the next
                     partition channel words... */
                
                  for(s=0;s<look->stages;s++){
                
                    for(i=0;i<partvals;){
                
                      /* first we encode a partition codeword for each channel */
                      if(s==0){
                        for(j=0;j<ch;j++){
                          long val=partword[j][i];
                          for(k=1;k<partitions_per_word;k++){
                            val*=possible_partitions;
                            if(i+k<partvals)
                              val+=partword[j][i+k];
                          }
                
                          /* training hack */
                          if(val<look->phrasebook->entries)
                            look->phrasebits+=vorbis_book_encode(look->phrasebook,val,opb);
                #if 0 /*def TRAIN_RES*/
                          else
                            fprintf(stderr,"!");
                #endif
                
                        }
                      }
                
                      /* now we encode interleaved residual values for the partitions */
                      for(k=0;k<partitions_per_word && i<partvals;k++,i++){
                        long offset=i*samples_per_partition+info->begin;
                
                        for(j=0;j<ch;j++){
                          if(s==0)resvals[partword[j][i]]+=samples_per_partition;
                          if(info->secondstages[partword[j][i]]&(1<<s)){
                            codebook *statebook=look->partbooks[partword[j][i]][s];
                            if(statebook){
                              int ret;
                              long *accumulator=NULL;
                
                #ifdef TRAIN_RES
                              accumulator=look->training_data[s][partword[j][i]];
                              {
                                int l;
                                int *samples=in[j]+offset;
                                for(l=0;l<samples_per_partition;l++){
                                  if(samples[l]<look->training_min[s][partword[j][i]])
                                    look->training_min[s][partword[j][i]]=samples[l];
                                  if(samples[l]>look->training_max[s][partword[j][i]])
                                    look->training_max[s][partword[j][i]]=samples[l];
                                }
                              }
                #endif
                
                              ret=encode(opb,in[j]+offset,samples_per_partition,
                                         statebook,accumulator);
                
                              look->postbits+=ret;
                              resbits[partword[j][i]]+=ret;
                            }
                          }
                        }
                      }
                    }
                  }
                
                  /*{
                    long total=0;
                    long totalbits=0;
                    fprintf(stderr,"%d :: ",vb->mode);
                    for(k=0;k<possible_partitions;k++){
                    fprintf(stderr,"%ld/%1.2g, ",resvals[k],(float)resbits[k]/resvals[k]);
                    total+=resvals[k];
                    totalbits+=resbits[k];
                    }
                
                    fprintf(stderr,":: %ld:%1.2g\n",total,(double)totalbits/total);
                    }*/
                
                  return(0);
                }
                
                /* a truncated packet here just means 'stop working'; it's not an error */
                static int _01inverse(vorbis_block *vb,vorbis_look_residue *vl,
                                      float **in,int ch,
                                      long (*decodepart)(codebook *, float *,
                                                         oggpack_buffer *,int)){
                
                  long i,j,k,l,s;
                  vorbis_look_residue0 *look=(vorbis_look_residue0 *)vl;
                  vorbis_info_residue0 *info=look->info;
                
                  /* move all this setup out later */
                  int samples_per_partition=info->grouping;
                  int partitions_per_word=look->phrasebook->dim;
                  int max=vb->pcmend>>1;
                  int end=(info->end<max?info->end:max);
                  int n=end-info->begin;
                
                  if(n>0){
                    int partvals=n/samples_per_partition;
                    int partwords=(partvals+partitions_per_word-1)/partitions_per_word;
                    int ***partword=alloca(ch*sizeof(*partword));
                
                    for(j=0;j<ch;j++)
                      partword[j]=_vorbis_block_alloc(vb,partwords*sizeof(*partword[j]));
                
                    for(s=0;s<look->stages;s++){
                
                      /* each loop decodes on partition codeword containing
                         partitions_per_word partitions */
                      for(i=0,l=0;i<partvals;l++){
                        if(s==0){
                          /* fetch the partition word for each channel */
                          for(j=0;j<ch;j++){
                            int temp=vorbis_book_decode(look->phrasebook,&vb->opb);
                
                            if(temp==-1 || temp>=info->partvals)goto eopbreak;
                            partword[j][l]=look->decodemap[temp];
                            if(partword[j][l]==NULL)goto errout;
                          }
                        }
                
                        /* now we decode residual values for the partitions */
                        for(k=0;k<partitions_per_word && i<partvals;k++,i++)
                          for(j=0;j<ch;j++){
                            long offset=info->begin+i*samples_per_partition;
                            if(info->secondstages[partword[j][l][k]]&(1<<s)){
                              codebook *stagebook=look->partbooks[partword[j][l][k]][s];
                              if(stagebook){
                                if(decodepart(stagebook,in[j]+offset,&vb->opb,
                                              samples_per_partition)==-1)goto eopbreak;
                              }
                            }
                          }
                      }
                    }
                  }
                 errout:
                 eopbreak:
                  return(0);
                }
                
                int res0_inverse(vorbis_block *vb,vorbis_look_residue *vl,
       ##### ->                  float **in,int *nonzero,int ch){
                  int i,used=0;
                  for(i=0;i<ch;i++)
                    if(nonzero[i])
                      in[used++]=in[i];
                  if(used)
                    return(_01inverse(vb,vl,in,used,vorbis_book_decodevs_add));
                  else
                    return(0);
                }
                
                int res1_forward(oggpack_buffer *opb,vorbis_block *vb,vorbis_look_residue *vl,
       ##### ->                  int **in,int *nonzero,int ch, long **partword, int submap){
                  int i,used=0;
                  for(i=0;i<ch;i++)
                    if(nonzero[i])
                      in[used++]=in[i];
                
                  if(used){
                    return _01forward(opb,vb,vl,in,used,partword,_encodepart,submap);
                  }else{
                    return(0);
                  }
                }
                
                long **res1_class(vorbis_block *vb,vorbis_look_residue *vl,
       ##### ->                   int **in,int *nonzero,int ch){
                  int i,used=0;
                  for(i=0;i<ch;i++)
                    if(nonzero[i])
                      in[used++]=in[i];
                  if(used)
                    return(_01class(vb,vl,in,used));
                  else
                    return(0);
                }
                
                int res1_inverse(vorbis_block *vb,vorbis_look_residue *vl,
       ##### ->                  float **in,int *nonzero,int ch){
                  int i,used=0;
                  for(i=0;i<ch;i++)
                    if(nonzero[i])
                      in[used++]=in[i];
                  if(used)
                    return(_01inverse(vb,vl,in,used,vorbis_book_decodev_add));
                  else
                    return(0);
                }
                
                long **res2_class(vorbis_block *vb,vorbis_look_residue *vl,
       ##### ->                   int **in,int *nonzero,int ch){
                  int i,used=0;
                  for(i=0;i<ch;i++)
                    if(nonzero[i])used++;
                  if(used)
                    return(_2class(vb,vl,in,ch));
                  else
                    return(0);
                }
                
                /* res2 is slightly more different; all the channels are interleaved
                   into a single vector and encoded. */
                
                int res2_forward(oggpack_buffer *opb,
                                 vorbis_block *vb,vorbis_look_residue *vl,
       ##### ->                  int **in,int *nonzero,int ch, long **partword,int submap){
                  long i,j,k,n=vb->pcmend/2,used=0;
                
                  /* don't duplicate the code; use a working vector hack for now and
                     reshape ourselves into a single channel res1 */
                  /* ugly; reallocs for each coupling pass :-( */
                  int *work=_vorbis_block_alloc(vb,ch*n*sizeof(*work));
                  for(i=0;i<ch;i++){
                    int *pcm=in[i];
                    if(nonzero[i])used++;
                    for(j=0,k=i;j<n;j++,k+=ch)
                      work[k]=pcm[j];
                  }
                
                  if(used){
                    return _01forward(opb,vb,vl,&work,1,partword,_encodepart,submap);
                  }else{
                    return(0);
                  }
                }
                
                /* duplicate code here as speed is somewhat more important */
                int res2_inverse(vorbis_block *vb,vorbis_look_residue *vl,
        7887 ->                  float **in,int *nonzero,int ch){
                  long i,k,l,s;
                  vorbis_look_residue0 *look=(vorbis_look_residue0 *)vl;
                  vorbis_info_residue0 *info=look->info;
                
                  /* move all this setup out later */
                  int samples_per_partition=info->grouping;
                  int partitions_per_word=look->phrasebook->dim;
                  int max=(vb->pcmend*ch)>>1;
                  int end=(info->end<max?info->end:max);
                  int n=end-info->begin;
                
                  if(n>0){
                    int partvals=n/samples_per_partition;
                    int partwords=(partvals+partitions_per_word-1)/partitions_per_word;
                    int **partword=_vorbis_block_alloc(vb,partwords*sizeof(*partword));
                
                    for(i=0;i<ch;i++)if(nonzero[i])break;
                    if(i==ch)return(0); /* no nonzero vectors */
                
                    for(s=0;s<look->stages;s++){
                      for(i=0,l=0;i<partvals;l++){
                
                        if(s==0){
                          /* fetch the partition word */
                          int temp=vorbis_book_decode(look->phrasebook,&vb->opb);
                          if(temp==-1 || temp>=info->partvals)goto eopbreak;
                          partword[l]=look->decodemap[temp];
                          if(partword[l]==NULL)goto errout;
                        }
                
                        /* now we decode residual values for the partitions */
                        for(k=0;k<partitions_per_word && i<partvals;k++,i++)
                          if(info->secondstages[partword[l][k]]&(1<<s)){
                            codebook *stagebook=look->partbooks[partword[l][k]][s];
                
                            if(stagebook){
                              if(vorbis_book_decodevv_add(stagebook,in,
                                                          i*samples_per_partition+info->begin,ch,
                                                          &vb->opb,samples_per_partition)==-1)
                                goto eopbreak;
                            }
                          }
                      }
                    }
                  }
                 errout:
                 eopbreak:
                  return(0);
                }
                
                
                const vorbis_func_residue residue0_exportbundle={
                  NULL,
                  &res0_unpack,
                  &res0_look,
                  &res0_free_info,
                  &res0_free_look,
                  NULL,
                  NULL,
                  &res0_inverse
                };
                
                const vorbis_func_residue residue1_exportbundle={
                  &res0_pack,
                  &res0_unpack,
                  &res0_look,
                  &res0_free_info,
                  &res0_free_look,
                  &res1_class,
                  &res1_forward,
                  &res1_inverse
                };
                
                const vorbis_func_residue residue2_exportbundle={
                  &res0_pack,
                  &res0_unpack,
                  &res0_look,
                  &res0_free_info,
                  &res0_free_look,
                  &res2_class,
                  &res2_forward,
                  &res2_inverse
                };


Top 10 Lines:

     Line      Count

      806       7887
       77        328
       69         24
      204         24
      269          8

Execution Summary:

       20   Executable lines in this file
       12   Lines executed
    60.00   Percent of the file executed

     8271   Total number of line executions
   413.55   Average executions per line


*** File C:\cygwin\workspace\_git_repos\CustomizeVorbis_static\GprofCdt/../lib/floor1.c:
                /********************************************************************
                 *                                                                  *
                 * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
                 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
                 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
                 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
                 *                                                                  *
                 * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
                 * by the Xiph.Org Foundation http://www.xiph.org/                  *
                 *                                                                  *
                 ********************************************************************
                
                 function: floor backend 1 implementation
                 last mod: $Id: floor1.c 17555 2010-10-21 18:14:51Z tterribe $
                
                 ********************************************************************/
                
                #include <stdlib.h>
                #include <string.h>
                #include <math.h>
                #include <ogg/ogg.h>
                #include "vorbis/codec.h"
                #include "codec_internal.h"
                #include "registry.h"
                #include "codebook.h"
                #include "misc.h"
                #include "scales.h"
                
                #include <stdio.h>
                
                #define floor1_rangedB 140 /* floor 1 fixed at -140dB to 0dB range */
                
                typedef struct lsfit_acc{
                  int x0;
                  int x1;
                
                  int xa;
                  int ya;
                  int x2a;
                  int y2a;
                  int xya;
                  int an;
                
                  int xb;
                  int yb;
                  int x2b;
                  int y2b;
                  int xyb;
                  int bn;
                } lsfit_acc;
                
                /***********************************************/
                
                static void floor1_free_info(vorbis_info_floor *i){
                  vorbis_info_floor1 *info=(vorbis_info_floor1 *)i;
                  if(info){
                    memset(info,0,sizeof(*info));
                    _ogg_free(info);
                  }
                }
                
                static void floor1_free_look(vorbis_look_floor *i){
                  vorbis_look_floor1 *look=(vorbis_look_floor1 *)i;
                  if(look){
                    /*fprintf(stderr,"floor 1 bit usage %f:%f (%f total)\n",
                            (float)look->phrasebits/look->frames,
                            (float)look->postbits/look->frames,
                            (float)(look->postbits+look->phrasebits)/look->frames);*/
                
                    memset(look,0,sizeof(*look));
                    _ogg_free(look);
                  }
                }
                
                static int ilog(unsigned int v){
                  int ret=0;
                  while(v){
                    ret++;
                    v>>=1;
                  }
                  return(ret);
                }
                
                static int ilog2(unsigned int v){
                  int ret=0;
                  if(v)--v;
                  while(v){
                    ret++;
                    v>>=1;
                  }
                  return(ret);
                }
                
                static void floor1_pack (vorbis_info_floor *i,oggpack_buffer *opb){
                  vorbis_info_floor1 *info=(vorbis_info_floor1 *)i;
                  int j,k;
                  int count=0;
                  int rangebits;
                  int maxposit=info->postlist[1];
                  int maxclass=-1;
                
                  /* save out partitions */
                  oggpack_write(opb,info->partitions,5); /* only 0 to 31 legal */
                  for(j=0;j<info->partitions;j++){
                    oggpack_write(opb,info->partitionclass[j],4); /* only 0 to 15 legal */
                    if(maxclass<info->partitionclass[j])maxclass=info->partitionclass[j];
                  }
                
                  /* save out partition classes */
                  for(j=0;j<maxclass+1;j++){
                    oggpack_write(opb,info->class_dim[j]-1,3); /* 1 to 8 */
                    oggpack_write(opb,info->class_subs[j],2); /* 0 to 3 */
                    if(info->class_subs[j])oggpack_write(opb,info->class_book[j],8);
                    for(k=0;k<(1<<info->class_subs[j]);k++)
                      oggpack_write(opb,info->class_subbook[j][k]+1,8);
                  }
                
                  /* save out the post list */
                  oggpack_write(opb,info->mult-1,2);     /* only 1,2,3,4 legal now */
                  oggpack_write(opb,ilog2(maxposit),4);
                  rangebits=ilog2(maxposit);
                
                  for(j=0,k=0;j<info->partitions;j++){
                    count+=info->class_dim[info->partitionclass[j]];
                    for(;k<count;k++)
                      oggpack_write(opb,info->postlist[k+2],rangebits);
                  }
                }
                
                static int icomp(const void *a,const void *b){
                  return(**(int **)a-**(int **)b);
                }
                
                static vorbis_info_floor *floor1_unpack (vorbis_info *vi,oggpack_buffer *opb){
                  codec_setup_info     *ci=vi->codec_setup;
                  int j,k,count=0,maxclass=-1,rangebits;
                
                  vorbis_info_floor1 *info=_ogg_calloc(1,sizeof(*info));
                  /* read partitions */
                  info->partitions=oggpack_read(opb,5); /* only 0 to 31 legal */
                  for(j=0;j<info->partitions;j++){
                    info->partitionclass[j]=oggpack_read(opb,4); /* only 0 to 15 legal */
                    if(info->partitionclass[j]<0)goto err_out;
                    if(maxclass<info->partitionclass[j])maxclass=info->partitionclass[j];
                  }
                
                  /* read partition classes */
                  for(j=0;j<maxclass+1;j++){
                    info->class_dim[j]=oggpack_read(opb,3)+1; /* 1 to 8 */
                    info->class_subs[j]=oggpack_read(opb,2); /* 0,1,2,3 bits */
                    if(info->class_subs[j]<0)
                      goto err_out;
                    if(info->class_subs[j])info->class_book[j]=oggpack_read(opb,8);
                    if(info->class_book[j]<0 || info->class_book[j]>=ci->books)
                      goto err_out;
                    for(k=0;k<(1<<info->class_subs[j]);k++){
                      info->class_subbook[j][k]=oggpack_read(opb,8)-1;
                      if(info->class_subbook[j][k]<-1 || info->class_subbook[j][k]>=ci->books)
                        goto err_out;
                    }
                  }
                
                  /* read the post list */
                  info->mult=oggpack_read(opb,2)+1;     /* only 1,2,3,4 legal now */
                  rangebits=oggpack_read(opb,4);
                  if(rangebits<0)goto err_out;
                
                  for(j=0,k=0;j<info->partitions;j++){
                    count+=info->class_dim[info->partitionclass[j]];
                    for(;k<count;k++){
                      int t=info->postlist[k+2]=oggpack_read(opb,rangebits);
                      if(t<0 || t>=(1<<rangebits))
                        goto err_out;
                    }
                  }
                  info->postlist[0]=0;
                  info->postlist[1]=1<<rangebits;
                
                  /* don't allow repeated values in post list as they'd result in
                     zero-length segments */
                  {
                    int *sortpointer[VIF_POSIT+2];
                    for(j=0;j<count+2;j++)sortpointer[j]=info->postlist+j;
                    qsort(sortpointer,count+2,sizeof(*sortpointer),icomp);
                
                    for(j=1;j<count+2;j++)
                      if(*sortpointer[j-1]==*sortpointer[j])goto err_out;
                  }
                
                  return(info);
                
                 err_out:
                  floor1_free_info(info);
                  return(NULL);
                }
                
                static vorbis_look_floor *floor1_look(vorbis_dsp_state *vd,
                                                      vorbis_info_floor *in){
                
                  int *sortpointer[VIF_POSIT+2];
                  vorbis_info_floor1 *info=(vorbis_info_floor1 *)in;
                  vorbis_look_floor1 *look=_ogg_calloc(1,sizeof(*look));
                  int i,j,n=0;
                
                  look->vi=info;
                  look->n=info->postlist[1];
                
                  /* we drop each position value in-between already decoded values,
                     and use linear interpolation to predict each new value past the
                     edges.  The positions are read in the order of the position
                     list... we precompute the bounding positions in the lookup.  Of
                     course, the neighbors can change (if a position is declined), but
                     this is an initial mapping */
                
                  for(i=0;i<info->partitions;i++)n+=info->class_dim[info->partitionclass[i]];
                  n+=2;
                  look->posts=n;
                
                  /* also store a sorted position index */
                  for(i=0;i<n;i++)sortpointer[i]=info->postlist+i;
                  qsort(sortpointer,n,sizeof(*sortpointer),icomp);
                
                  /* points from sort order back to range number */
                  for(i=0;i<n;i++)look->forward_index[i]=sortpointer[i]-info->postlist;
                  /* points from range order to sorted position */
                  for(i=0;i<n;i++)look->reverse_index[look->forward_index[i]]=i;
                  /* we actually need the post values too */
                  for(i=0;i<n;i++)look->sorted_index[i]=info->postlist[look->forward_index[i]];
                
                  /* quantize values to multiplier spec */
                  switch(info->mult){
                  case 1: /* 1024 -> 256 */
                    look->quant_q=256;
                    break;
                  case 2: /* 1024 -> 128 */
                    look->quant_q=128;
                    break;
                  case 3: /* 1024 -> 86 */
                    look->quant_q=86;
                    break;
                  case 4: /* 1024 -> 64 */
                    look->quant_q=64;
                    break;
                  }
                
                  /* discover our neighbors for decode where we don't use fit flags
                     (that would push the neighbors outward) */
                  for(i=0;i<n-2;i++){
                    int lo=0;
                    int hi=1;
                    int lx=0;
                    int hx=look->n;
                    int currentx=info->postlist[i+2];
                    for(j=0;j<i+2;j++){
                      int x=info->postlist[j];
                      if(x>lx && x<currentx){
                        lo=j;
                        lx=x;
                      }
                      if(x<hx && x>currentx){
                        hi=j;
                        hx=x;
                      }
                    }
                    look->loneighbor[i]=lo;
                    look->hineighbor[i]=hi;
                  }
                
                  return(look);
                }
                
                static int render_point(int x0,int x1,int y0,int y1,int x){
                  y0&=0x7fff; /* mask off flag */
                  y1&=0x7fff;
                
                  {
                    int dy=y1-y0;
                    int adx=x1-x0;
                    int ady=abs(dy);
                    int err=ady*(x-x0);
                
                    int off=err/adx;
                    if(dy<0)return(y0-off);
                    return(y0+off);
                  }
                }
                
                static int vorbis_dBquant(const float *x){
                  int i= *x*7.3142857f+1023.5f;
                  if(i>1023)return(1023);
                  if(i<0)return(0);
                  return i;
                }
                
                static const float FLOOR1_fromdB_LOOKUP[256]={
                  1.0649863e-07F, 1.1341951e-07F, 1.2079015e-07F, 1.2863978e-07F,
                  1.3699951e-07F, 1.4590251e-07F, 1.5538408e-07F, 1.6548181e-07F,
                  1.7623575e-07F, 1.8768855e-07F, 1.9988561e-07F, 2.128753e-07F,
                  2.2670913e-07F, 2.4144197e-07F, 2.5713223e-07F, 2.7384213e-07F,
                  2.9163793e-07F, 3.1059021e-07F, 3.3077411e-07F, 3.5226968e-07F,
                  3.7516214e-07F, 3.9954229e-07F, 4.2550680e-07F, 4.5315863e-07F,
                  4.8260743e-07F, 5.1396998e-07F, 5.4737065e-07F, 5.8294187e-07F,
                  6.2082472e-07F, 6.6116941e-07F, 7.0413592e-07F, 7.4989464e-07F,
                  7.9862701e-07F, 8.5052630e-07F, 9.0579828e-07F, 9.6466216e-07F,
                  1.0273513e-06F, 1.0941144e-06F, 1.1652161e-06F, 1.2409384e-06F,
                  1.3215816e-06F, 1.4074654e-06F, 1.4989305e-06F, 1.5963394e-06F,
                  1.7000785e-06F, 1.8105592e-06F, 1.9282195e-06F, 2.0535261e-06F,
                  2.1869758e-06F, 2.3290978e-06F, 2.4804557e-06F, 2.6416497e-06F,
                  2.8133190e-06F, 2.9961443e-06F, 3.1908506e-06F, 3.3982101e-06F,
                  3.6190449e-06F, 3.8542308e-06F, 4.1047004e-06F, 4.3714470e-06F,
                  4.6555282e-06F, 4.9580707e-06F, 5.2802740e-06F, 5.6234160e-06F,
                  5.9888572e-06F, 6.3780469e-06F, 6.7925283e-06F, 7.2339451e-06F,
                  7.7040476e-06F, 8.2047000e-06F, 8.7378876e-06F, 9.3057248e-06F,
                  9.9104632e-06F, 1.0554501e-05F, 1.1240392e-05F, 1.1970856e-05F,
                  1.2748789e-05F, 1.3577278e-05F, 1.4459606e-05F, 1.5399272e-05F,
                  1.6400004e-05F, 1.7465768e-05F, 1.8600792e-05F, 1.9809576e-05F,
                  2.1096914e-05F, 2.2467911e-05F, 2.3928002e-05F, 2.5482978e-05F,
                  2.7139006e-05F, 2.8902651e-05F, 3.0780908e-05F, 3.2781225e-05F,
                  3.4911534e-05F, 3.7180282e-05F, 3.9596466e-05F, 4.2169667e-05F,
                  4.4910090e-05F, 4.7828601e-05F, 5.0936773e-05F, 5.4246931e-05F,
                  5.7772202e-05F, 6.1526565e-05F, 6.5524908e-05F, 6.9783085e-05F,
                  7.4317983e-05F, 7.9147585e-05F, 8.4291040e-05F, 8.9768747e-05F,
                  9.5602426e-05F, 0.00010181521F, 0.00010843174F, 0.00011547824F,
                  0.00012298267F, 0.00013097477F, 0.00013948625F, 0.00014855085F,
                  0.00015820453F, 0.00016848555F, 0.00017943469F, 0.00019109536F,
                  0.00020351382F, 0.00021673929F, 0.00023082423F, 0.00024582449F,
                  0.00026179955F, 0.00027881276F, 0.00029693158F, 0.00031622787F,
                  0.00033677814F, 0.00035866388F, 0.00038197188F, 0.00040679456F,
                  0.00043323036F, 0.00046138411F, 0.00049136745F, 0.00052329927F,
                  0.00055730621F, 0.00059352311F, 0.00063209358F, 0.00067317058F,
                  0.00071691700F, 0.00076350630F, 0.00081312324F, 0.00086596457F,
                  0.00092223983F, 0.00098217216F, 0.0010459992F, 0.0011139742F,
                  0.0011863665F, 0.0012634633F, 0.0013455702F, 0.0014330129F,
                  0.0015261382F, 0.0016253153F, 0.0017309374F, 0.0018434235F,
                  0.0019632195F, 0.0020908006F, 0.0022266726F, 0.0023713743F,
                  0.0025254795F, 0.0026895994F, 0.0028643847F, 0.0030505286F,
                  0.0032487691F, 0.0034598925F, 0.0036847358F, 0.0039241906F,
                  0.0041792066F, 0.0044507950F, 0.0047400328F, 0.0050480668F,
                  0.0053761186F, 0.0057254891F, 0.0060975636F, 0.0064938176F,
                  0.0069158225F, 0.0073652516F, 0.0078438871F, 0.0083536271F,
                  0.0088964928F, 0.009474637F, 0.010090352F, 0.010746080F,
                  0.011444421F, 0.012188144F, 0.012980198F, 0.013823725F,
                  0.014722068F, 0.015678791F, 0.016697687F, 0.017782797F,
                  0.018938423F, 0.020169149F, 0.021479854F, 0.022875735F,
                  0.024362330F, 0.025945531F, 0.027631618F, 0.029427276F,
                  0.031339626F, 0.033376252F, 0.035545228F, 0.037855157F,
                  0.040315199F, 0.042935108F, 0.045725273F, 0.048696758F,
                  0.051861348F, 0.055231591F, 0.058820850F, 0.062643361F,
                  0.066714279F, 0.071049749F, 0.075666962F, 0.080584227F,
                  0.085821044F, 0.091398179F, 0.097337747F, 0.10366330F,
                  0.11039993F, 0.11757434F, 0.12521498F, 0.13335215F,
                  0.14201813F, 0.15124727F, 0.16107617F, 0.17154380F,
                  0.18269168F, 0.19456402F, 0.20720788F, 0.22067342F,
                  0.23501402F, 0.25028656F, 0.26655159F, 0.28387361F,
                  0.30232132F, 0.32196786F, 0.34289114F, 0.36517414F,
                  0.38890521F, 0.41417847F, 0.44109412F, 0.46975890F,
                  0.50028648F, 0.53279791F, 0.56742212F, 0.60429640F,
                  0.64356699F, 0.68538959F, 0.72993007F, 0.77736504F,
                  0.82788260F, 0.88168307F, 0.9389798F, 1.F,
                };
                
                static void render_line(int n, int x0,int x1,int y0,int y1,float *d){
                  int dy=y1-y0;
                  int adx=x1-x0;
                  int ady=abs(dy);
                  int base=dy/adx;
                  int sy=(dy<0?base-1:base+1);
                  int x=x0;
                  int y=y0;
                  int err=0;
                
                  ady-=abs(base*adx);
                
                  if(n>x1)n=x1;
                
                  if(x<n)
                    d[x]*=FLOOR1_fromdB_LOOKUP[y];
                
                  while(++x<n){
                    err=err+ady;
                    if(err>=adx){
                      err-=adx;
                      y+=sy;
                    }else{
                      y+=base;
                    }
                    d[x]*=FLOOR1_fromdB_LOOKUP[y];
                  }
                }
                
                static void render_line0(int n, int x0,int x1,int y0,int y1,int *d){
                  int dy=y1-y0;
                  int adx=x1-x0;
                  int ady=abs(dy);
                  int base=dy/adx;
                  int sy=(dy<0?base-1:base+1);
                  int x=x0;
                  int y=y0;
                  int err=0;
                
                  ady-=abs(base*adx);
                
                  if(n>x1)n=x1;
                
                  if(x<n)
                    d[x]=y;
                
                  while(++x<n){
                    err=err+ady;
                    if(err>=adx){
                      err-=adx;
                      y+=sy;
                    }else{
                      y+=base;
                    }
                    d[x]=y;
                  }
                }
                
                /* the floor has already been filtered to only include relevant sections */
                static int accumulate_fit(const float *flr,const float *mdct,
                                          int x0, int x1,lsfit_acc *a,
                                          int n,vorbis_info_floor1 *info){
                  long i;
                
                  int xa=0,ya=0,x2a=0,y2a=0,xya=0,na=0, xb=0,yb=0,x2b=0,y2b=0,xyb=0,nb=0;
                
                  memset(a,0,sizeof(*a));
                  a->x0=x0;
                  a->x1=x1;
                  if(x1>=n)x1=n-1;
                
                  for(i=x0;i<=x1;i++){
                    int quantized=vorbis_dBquant(flr+i);
                    if(quantized){
                      if(mdct[i]+info->twofitatten>=flr[i]){
                        xa  += i;
                        ya  += quantized;
                        x2a += i*i;
                        y2a += quantized*quantized;
                        xya += i*quantized;
                        na++;
                      }else{
                        xb  += i;
                        yb  += quantized;
                        x2b += i*i;
                        y2b += quantized*quantized;
                        xyb += i*quantized;
                        nb++;
                      }
                    }
                  }
                
                  a->xa=xa;
                  a->ya=ya;
                  a->x2a=x2a;
                  a->y2a=y2a;
                  a->xya=xya;
                  a->an=na;
                
                  a->xb=xb;
                  a->yb=yb;
                  a->x2b=x2b;
                  a->y2b=y2b;
                  a->xyb=xyb;
                  a->bn=nb;
                
                  return(na);
                }
                
                static int fit_line(lsfit_acc *a,int fits,int *y0,int *y1,
                                    vorbis_info_floor1 *info){
                  double xb=0,yb=0,x2b=0,y2b=0,xyb=0,bn=0;
                  int i;
                  int x0=a[0].x0;
                  int x1=a[fits-1].x1;
                
                  for(i=0;i<fits;i++){
                    double weight = (a[i].bn+a[i].an)*info->twofitweight/(a[i].an+1)+1.;
                
                    xb+=a[i].xb + a[i].xa * weight;
                    yb+=a[i].yb + a[i].ya * weight;
                    x2b+=a[i].x2b + a[i].x2a * weight;
                    y2b+=a[i].y2b + a[i].y2a * weight;
                    xyb+=a[i].xyb + a[i].xya * weight;
                    bn+=a[i].bn + a[i].an * weight;
                  }
                
                  if(*y0>=0){
                    xb+=   x0;
                    yb+=  *y0;
                    x2b+=  x0 *  x0;
                    y2b+= *y0 * *y0;
                    xyb+= *y0 *  x0;
                    bn++;
                  }
                
                  if(*y1>=0){
                    xb+=   x1;
                    yb+=  *y1;
                    x2b+=  x1 *  x1;
                    y2b+= *y1 * *y1;
                    xyb+= *y1 *  x1;
                    bn++;
                  }
                
                  {
                    double denom=(bn*x2b-xb*xb);
                
                    if(denom>0.){
                      double a=(yb*x2b-xyb*xb)/denom;
                      double b=(bn*xyb-xb*yb)/denom;
                      *y0=rint(a+b*x0);
                      *y1=rint(a+b*x1);
                
                      /* limit to our range! */
                      if(*y0>1023)*y0=1023;
                      if(*y1>1023)*y1=1023;
                      if(*y0<0)*y0=0;
                      if(*y1<0)*y1=0;
                
                      return 0;
                    }else{
                      *y0=0;
                      *y1=0;
                      return 1;
                    }
                  }
                }
                
                static int inspect_error(int x0,int x1,int y0,int y1,const float *mask,
                                         const float *mdct,
                                         vorbis_info_floor1 *info){
                  int dy=y1-y0;
                  int adx=x1-x0;
                  int ady=abs(dy);
                  int base=dy/adx;
                  int sy=(dy<0?base-1:base+1);
                  int x=x0;
                  int y=y0;
                  int err=0;
                  int val=vorbis_dBquant(mask+x);
                  int mse=0;
                  int n=0;
                
                  ady-=abs(base*adx);
                
                  mse=(y-val);
                  mse*=mse;
                  n++;
                  if(mdct[x]+info->twofitatten>=mask[x]){
                    if(y+info->maxover<val)return(1);
                    if(y-info->maxunder>val)return(1);
                  }
                
                  while(++x<x1){
                    err=err+ady;
                    if(err>=adx){
                      err-=adx;
                      y+=sy;
                    }else{
                      y+=base;
                    }
                
                    val=vorbis_dBquant(mask+x);
                    mse+=((y-val)*(y-val));
                    n++;
                    if(mdct[x]+info->twofitatten>=mask[x]){
                      if(val){
                        if(y+info->maxover<val)return(1);
                        if(y-info->maxunder>val)return(1);
                      }
                    }
                  }
                
                  if(info->maxover*info->maxover/n>info->maxerr)return(0);
                  if(info->maxunder*info->maxunder/n>info->maxerr)return(0);
                  if(mse/n>info->maxerr)return(1);
                  return(0);
                }
                
                static int post_Y(int *A,int *B,int pos){
                  if(A[pos]<0)
                    return B[pos];
                  if(B[pos]<0)
                    return A[pos];
                
                  return (A[pos]+B[pos])>>1;
                }
                
                int *floor1_fit(vorbis_block *vb,vorbis_look_floor1 *look,
                                          const float *logmdct,   /* in */
       ##### ->                           const float *logmask){
                  long i,j;
                  vorbis_info_floor1 *info=look->vi;
                  long n=look->n;
                  long posts=look->posts;
                  long nonzero=0;
                  lsfit_acc fits[VIF_POSIT+1];
                  int fit_valueA[VIF_POSIT+2]; /* index by range list position */
                  int fit_valueB[VIF_POSIT+2]; /* index by range list position */
                
                  int loneighbor[VIF_POSIT+2]; /* sorted index of range list position (+2) */
                  int hineighbor[VIF_POSIT+2];
                  int *output=NULL;
                  int memo[VIF_POSIT+2];
                
                  for(i=0;i<posts;i++)fit_valueA[i]=-200; /* mark all unused */
                  for(i=0;i<posts;i++)fit_valueB[i]=-200; /* mark all unused */
                  for(i=0;i<posts;i++)loneighbor[i]=0; /* 0 for the implicit 0 post */
                  for(i=0;i<posts;i++)hineighbor[i]=1; /* 1 for the implicit post at n */
                  for(i=0;i<posts;i++)memo[i]=-1;      /* no neighbor yet */
                
                  /* quantize the relevant floor points and collect them into line fit
                     structures (one per minimal division) at the same time */
                  if(posts==0){
                    nonzero+=accumulate_fit(logmask,logmdct,0,n,fits,n,info);
                  }else{
                    for(i=0;i<posts-1;i++)
                      nonzero+=accumulate_fit(logmask,logmdct,look->sorted_index[i],
                                              look->sorted_index[i+1],fits+i,
                                              n,info);
                  }
                
                  if(nonzero){
                    /* start by fitting the implicit base case.... */
                    int y0=-200;
                    int y1=-200;
                    fit_line(fits,posts-1,&y0,&y1,info);
                
                    fit_valueA[0]=y0;
                    fit_valueB[0]=y0;
                    fit_valueB[1]=y1;
                    fit_valueA[1]=y1;
                
                    /* Non degenerate case */
                    /* start progressive splitting.  This is a greedy, non-optimal
                       algorithm, but simple and close enough to the best
                       answer. */
                    for(i=2;i<posts;i++){
                      int sortpos=look->reverse_index[i];
                      int ln=loneighbor[sortpos];
                      int hn=hineighbor[sortpos];
                
                      /* eliminate repeat searches of a particular range with a memo */
                      if(memo[ln]!=hn){
                        /* haven't performed this error search yet */
                        int lsortpos=look->reverse_index[ln];
                        int hsortpos=look->reverse_index[hn];
                        memo[ln]=hn;
                
                        {
                          /* A note: we want to bound/minimize *local*, not global, error */
                          int lx=info->postlist[ln];
                          int hx=info->postlist[hn];
                          int ly=post_Y(fit_valueA,fit_valueB,ln);
                          int hy=post_Y(fit_valueA,fit_valueB,hn);
                
                          if(ly==-1 || hy==-1){
                            exit(1);
                          }
                
                          if(inspect_error(lx,hx,ly,hy,logmask,logmdct,info)){
                            /* outside error bounds/begin search area.  Split it. */
                            int ly0=-200;
                            int ly1=-200;
                            int hy0=-200;
                            int hy1=-200;
                            int ret0=fit_line(fits+lsortpos,sortpos-lsortpos,&ly0,&ly1,info);
                            int ret1=fit_line(fits+sortpos,hsortpos-sortpos,&hy0,&hy1,info);
                
                            if(ret0){
                              ly0=ly;
                              ly1=hy0;
                            }
                            if(ret1){
                              hy0=ly1;
                              hy1=hy;
                            }
                
                            if(ret0 && ret1){
                              fit_valueA[i]=-200;
                              fit_valueB[i]=-200;
                            }else{
                              /* store new edge values */
                              fit_valueB[ln]=ly0;
                              if(ln==0)fit_valueA[ln]=ly0;
                              fit_valueA[i]=ly1;
                              fit_valueB[i]=hy0;
                              fit_valueA[hn]=hy1;
                              if(hn==1)fit_valueB[hn]=hy1;
                
                              if(ly1>=0 || hy0>=0){
                                /* store new neighbor values */
                                for(j=sortpos-1;j>=0;j--)
                                  if(hineighbor[j]==hn)
                                    hineighbor[j]=i;
                                  else
                                    break;
                                for(j=sortpos+1;j<posts;j++)
                                  if(loneighbor[j]==ln)
                                    loneighbor[j]=i;
                                  else
                                    break;
                              }
                            }
                          }else{
                            fit_valueA[i]=-200;
                            fit_valueB[i]=-200;
                          }
                        }
                      }
                    }
                
                    output=_vorbis_block_alloc(vb,sizeof(*output)*posts);
                
                    output[0]=post_Y(fit_valueA,fit_valueB,0);
                    output[1]=post_Y(fit_valueA,fit_valueB,1);
                
                    /* fill in posts marked as not using a fit; we will zero
                       back out to 'unused' when encoding them so long as curve
                       interpolation doesn't force them into use */
                    for(i=2;i<posts;i++){
                      int ln=look->loneighbor[i-2];
                      int hn=look->hineighbor[i-2];
                      int x0=info->postlist[ln];
                      int x1=info->postlist[hn];
                      int y0=output[ln];
                      int y1=output[hn];
                
                      int predicted=render_point(x0,x1,y0,y1,info->postlist[i]);
                      int vx=post_Y(fit_valueA,fit_valueB,i);
                
                      if(vx>=0 && predicted!=vx){
                        output[i]=vx;
                      }else{
                        output[i]= predicted|0x8000;
                      }
                    }
                  }
                
                  return(output);
                
                }
                
                int *floor1_interpolate_fit(vorbis_block *vb,vorbis_look_floor1 *look,
                                          int *A,int *B,
       ##### ->                           int del){
                
                  long i;
                  long posts=look->posts;
                  int *output=NULL;
                
                  if(A && B){
                    output=_vorbis_block_alloc(vb,sizeof(*output)*posts);
                
                    /* overly simpleminded--- look again post 1.2 */
                    for(i=0;i<posts;i++){
                      output[i]=((65536-del)*(A[i]&0x7fff)+del*(B[i]&0x7fff)+32768)>>16;
                      if(A[i]&0x8000 && B[i]&0x8000)output[i]|=0x8000;
                    }
                  }
                
                  return(output);
                }
                
                
                int floor1_encode(oggpack_buffer *opb,vorbis_block *vb,
                                  vorbis_look_floor1 *look,
       15558 ->                   int *post,int *ilogmask){
                
                  long i,j;
                  vorbis_info_floor1 *info=look->vi;
                  long posts=look->posts;
                  codec_setup_info *ci=vb->vd->vi->codec_setup;
                  int out[VIF_POSIT+2];
                  static_codebook **sbooks=ci->book_param;
                  codebook *books=ci->fullbooks;
                
                  /* quantize values to multiplier spec */
                  if(post){
                    for(i=0;i<posts;i++){
                      int val=post[i]&0x7fff;
                      switch(info->mult){
                      case 1: /* 1024 -> 256 */
                        val>>=2;
                        break;
                      case 2: /* 1024 -> 128 */
                        val>>=3;
                        break;
                      case 3: /* 1024 -> 86 */
                        val/=12;
                        break;
                      case 4: /* 1024 -> 64 */
                        val>>=4;
                        break;
                      }
                      post[i]=val | (post[i]&0x8000);
                    }
                
                    out[0]=post[0];
                    out[1]=post[1];
                
                    /* find prediction values for each post and subtract them */
                    for(i=2;i<posts;i++){
                      int ln=look->loneighbor[i-2];
                      int hn=look->hineighbor[i-2];
                      int x0=info->postlist[ln];
                      int x1=info->postlist[hn];
                      int y0=post[ln];
                      int y1=post[hn];
                
                      int predicted=render_point(x0,x1,y0,y1,info->postlist[i]);
                
                      if((post[i]&0x8000) || (predicted==post[i])){
                        post[i]=predicted|0x8000; /* in case there was roundoff jitter
                                                     in interpolation */
                        out[i]=0;
                      }else{
                        int headroom=(look->quant_q-predicted<predicted?
                                      look->quant_q-predicted:predicted);
                
                        int val=post[i]-predicted;
                
                        /* at this point the 'deviation' value is in the range +/- max
                           range, but the real, unique range can always be mapped to
                           only [0-maxrange).  So we want to wrap the deviation into
                           this limited range, but do it in the way that least screws
                           an essentially gaussian probability distribution. */
                
                        if(val<0)
                          if(val<-headroom)
                            val=headroom-val-1;
                          else
                            val=-1-(val<<1);
                        else
                          if(val>=headroom)
                            val= val+headroom;
                          else
                            val<<=1;
                
                        out[i]=val;
                        post[ln]&=0x7fff;
                        post[hn]&=0x7fff;
                      }
                    }
                
                    /* we have everything we need. pack it out */
                    /* mark nontrivial floor */
                    oggpack_write(opb,1,1);
                
                    /* beginning/end post */
                    look->frames++;
                    look->postbits+=ilog(look->quant_q-1)*2;
                    oggpack_write(opb,out[0],ilog(look->quant_q-1));
                    oggpack_write(opb,out[1],ilog(look->quant_q-1));
                
                
                    /* partition by partition */
                    for(i=0,j=2;i<info->partitions;i++){
                      int class=info->partitionclass[i];
                      int cdim=info->class_dim[class];
                      int csubbits=info->class_subs[class];
                      int csub=1<<csubbits;
                      int bookas[8]={0,0,0,0,0,0,0,0};
                      int cval=0;
                      int cshift=0;
                      int k,l;
                
                      /* generate the partition's first stage cascade value */
                      if(csubbits){
                        int maxval[8];
                        for(k=0;k<csub;k++){
                          int booknum=info->class_subbook[class][k];
                          if(booknum<0){
                            maxval[k]=1;
                          }else{
                            maxval[k]=sbooks[info->class_subbook[class][k]]->entries;
                          }
                        }
                        for(k=0;k<cdim;k++){
                          for(l=0;l<csub;l++){
                            int val=out[j+k];
                            if(val<maxval[l]){
                              bookas[k]=l;
                              break;
                            }
                          }
                          cval|= bookas[k]<<cshift;
                          cshift+=csubbits;
                        }
                        /* write it */
                        look->phrasebits+=
                          vorbis_book_encode(books+info->class_book[class],cval,opb);
                
                #ifdef TRAIN_FLOOR1
                        {
                          FILE *of;
                          char buffer[80];
                          sprintf(buffer,"line_%dx%ld_class%d.vqd",
                                  vb->pcmend/2,posts-2,class);
                          of=fopen(buffer,"a");
                          fprintf(of,"%d\n",cval);
                          fclose(of);
                        }
                #endif
                      }
                
                      /* write post values */
                      for(k=0;k<cdim;k++){
                        int book=info->class_subbook[class][bookas[k]];
                        if(book>=0){
                          /* hack to allow training with 'bad' books */
                          if(out[j+k]<(books+book)->entries)
                            look->postbits+=vorbis_book_encode(books+book,
                                                               out[j+k],opb);
                          /*else
                            fprintf(stderr,"+!");*/
                
                #ifdef TRAIN_FLOOR1
                          {
                            FILE *of;
                            char buffer[80];
                            sprintf(buffer,"line_%dx%ld_%dsub%d.vqd",
                                    vb->pcmend/2,posts-2,class,bookas[k]);
                            of=fopen(buffer,"a");
                            fprintf(of,"%d\n",out[j+k]);
                            fclose(of);
                          }
                #endif
                        }
                      }
                      j+=cdim;
                    }
                
                    {
                      /* generate quantized floor equivalent to what we'd unpack in decode */
                      /* render the lines */
                      int hx=0;
                      int lx=0;
                      int ly=post[0]*info->mult;
                      int n=ci->blocksizes[vb->W]/2;
                
                      for(j=1;j<look->posts;j++){
                        int current=look->forward_index[j];
                        int hy=post[current]&0x7fff;
                        if(hy==post[current]){
                
                          hy*=info->mult;
                          hx=info->postlist[current];
                
                          render_line0(n,lx,hx,ly,hy,ilogmask);
                
                          lx=hx;
                          ly=hy;
                        }
                      }
                      for(j=hx;j<vb->pcmend/2;j++)ilogmask[j]=ly; /* be certain */
                      return(1);
                    }
                  }else{
                    oggpack_write(opb,0,1);
                    memset(ilogmask,0,vb->pcmend/2*sizeof(*ilogmask));
                    return(0);
                  }
                }
                
                static void *floor1_inverse1(vorbis_block *vb,vorbis_look_floor *in){
                  vorbis_look_floor1 *look=(vorbis_look_floor1 *)in;
                  vorbis_info_floor1 *info=look->vi;
                  codec_setup_info   *ci=vb->vd->vi->codec_setup;
                
                  int i,j,k;
                  codebook *books=ci->fullbooks;
                
                  /* unpack wrapped/predicted values from stream */
                  if(oggpack_read(&vb->opb,1)==1){
                    int *fit_value=_vorbis_block_alloc(vb,(look->posts)*sizeof(*fit_value));
                
                    fit_value[0]=oggpack_read(&vb->opb,ilog(look->quant_q-1));
                    fit_value[1]=oggpack_read(&vb->opb,ilog(look->quant_q-1));
                
                    /* partition by partition */
                    for(i=0,j=2;i<info->partitions;i++){
                      int class=info->partitionclass[i];
                      int cdim=info->class_dim[class];
                      int csubbits=info->class_subs[class];
                      int csub=1<<csubbits;
                      int cval=0;
                
                      /* decode the partition's first stage cascade value */
                      if(csubbits){
                        cval=vorbis_book_decode(books+info->class_book[class],&vb->opb);
                
                        if(cval==-1)goto eop;
                      }
                
                      for(k=0;k<cdim;k++){
                        int book=info->class_subbook[class][cval&(csub-1)];
                        cval>>=csubbits;
                        if(book>=0){
                          if((fit_value[j+k]=vorbis_book_decode(books+book,&vb->opb))==-1)
                            goto eop;
                        }else{
                          fit_value[j+k]=0;
                        }
                      }
                      j+=cdim;
                    }
                
                    /* unwrap positive values and reconsitute via linear interpolation */
                    for(i=2;i<look->posts;i++){
                      int predicted=render_point(info->postlist[look->loneighbor[i-2]],
                                                 info->postlist[look->hineighbor[i-2]],
                                                 fit_value[look->loneighbor[i-2]],
                                                 fit_value[look->hineighbor[i-2]],
                                                 info->postlist[i]);
                      int hiroom=look->quant_q-predicted;
                      int loroom=predicted;
                      int room=(hiroom<loroom?hiroom:loroom)<<1;
                      int val=fit_value[i];
                
                      if(val){
                        if(val>=room){
                          if(hiroom>loroom){
                            val = val-loroom;
                          }else{
                            val = -1-(val-hiroom);
                          }
                        }else{
                          if(val&1){
                            val= -((val+1)>>1);
                          }else{
                            val>>=1;
                          }
                        }
                
                        fit_value[i]=val+predicted&0x7fff;
                        fit_value[look->loneighbor[i-2]]&=0x7fff;
                        fit_value[look->hineighbor[i-2]]&=0x7fff;
                
                      }else{
                        fit_value[i]=predicted|0x8000;
                      }
                
                    }
                
                    return(fit_value);
                  }
                 eop:
                  return(NULL);
                }
                
                static int floor1_inverse2(vorbis_block *vb,vorbis_look_floor *in,void *memo,
                                          float *out){
                  vorbis_look_floor1 *look=(vorbis_look_floor1 *)in;
                  vorbis_info_floor1 *info=look->vi;
                
                  codec_setup_info   *ci=vb->vd->vi->codec_setup;
                  int                  n=ci->blocksizes[vb->W]/2;
                  int j;
                
                  if(memo){
                    /* render the lines */
                    int *fit_value=(int *)memo;
                    int hx=0;
                    int lx=0;
                    int ly=fit_value[0]*info->mult;
                    /* guard lookup against out-of-range values */
                    ly=(ly<0?0:ly>255?255:ly);
                
                    for(j=1;j<look->posts;j++){
                      int current=look->forward_index[j];
                      int hy=fit_value[current]&0x7fff;
                      if(hy==fit_value[current]){
                
                        hx=info->postlist[current];
                        hy*=info->mult;
                        /* guard lookup against out-of-range values */
                        hy=(hy<0?0:hy>255?255:hy);
                
                        render_line(n,lx,hx,ly,hy,out);
                
                        lx=hx;
                        ly=hy;
                      }
                    }
                    for(j=hx;j<n;j++)out[j]*=FLOOR1_fromdB_LOOKUP[ly]; /* be certain */
                    return(1);
                  }
                  memset(out,0,sizeof(*out)*n);
                  return(0);
                }
                
                /* export hooks */
                const vorbis_func_floor floor1_exportbundle={
                  &floor1_pack,&floor1_unpack,&floor1_look,&floor1_free_info,
                  &floor1_free_look,&floor1_inverse1,&floor1_inverse2
                };


Top 10 Lines:

     Line      Count

      770      15558

Execution Summary:

       21   Executable lines in this file
        3   Lines executed
    14.29   Percent of the file executed

    15558   Total number of line executions
   740.86   Average executions per line


*** File C:\cygwin\workspace\_git_repos\CustomizeVorbis_static\GprofCdt/../lib/window.c:
                /********************************************************************
                 *                                                                  *
                 * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
                 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
                 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
                 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
                 *                                                                  *
                 * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
                 * by the Xiph.Org Foundation http://www.xiph.org/                  *
                 *                                                                  *
                 ********************************************************************
                
                 function: window functions
                 last mod: $Id: window.c 16227 2009-07-08 06:58:46Z xiphmont $
                
                 ********************************************************************/
                
                #include <stdlib.h>
                #include <math.h>
                #include "os.h"
                #include "misc.h"
                
                static const float vwin64[32] = {
                  0.0009460463F, 0.0085006468F, 0.0235352254F, 0.0458950567F,
                  0.0753351908F, 0.1115073077F, 0.1539457973F, 0.2020557475F,
                  0.2551056759F, 0.3122276645F, 0.3724270287F, 0.4346027792F,
                  0.4975789974F, 0.5601459521F, 0.6211085051F, 0.6793382689F,
                  0.7338252629F, 0.7837245849F, 0.8283939355F, 0.8674186656F,
                  0.9006222429F, 0.9280614787F, 0.9500073081F, 0.9669131782F,
                  0.9793740220F, 0.9880792941F, 0.9937636139F, 0.9971582668F,
                  0.9989462667F, 0.9997230082F, 0.9999638688F, 0.9999995525F,
                };
                
                static const float vwin128[64] = {
                  0.0002365472F, 0.0021280687F, 0.0059065254F, 0.0115626550F,
                  0.0190823442F, 0.0284463735F, 0.0396300935F, 0.0526030430F,
                  0.0673285281F, 0.0837631763F, 0.1018564887F, 0.1215504095F,
                  0.1427789367F, 0.1654677960F, 0.1895342001F, 0.2148867160F,
                  0.2414252576F, 0.2690412240F, 0.2976177952F, 0.3270303960F,
                  0.3571473350F, 0.3878306189F, 0.4189369387F, 0.4503188188F,
                  0.4818259135F, 0.5133064334F, 0.5446086751F, 0.5755826278F,
                  0.6060816248F, 0.6359640047F, 0.6650947483F, 0.6933470543F,
                  0.7206038179F, 0.7467589810F, 0.7717187213F, 0.7954024542F,
                  0.8177436264F, 0.8386902831F, 0.8582053981F, 0.8762669622F,
                  0.8928678298F, 0.9080153310F, 0.9217306608F, 0.9340480615F,
                  0.9450138200F, 0.9546851041F, 0.9631286621F, 0.9704194171F,
                  0.9766389810F, 0.9818741197F, 0.9862151938F, 0.9897546035F,
                  0.9925852598F, 0.9947991032F, 0.9964856900F, 0.9977308602F,
                  0.9986155015F, 0.9992144193F, 0.9995953200F, 0.9998179155F,
                  0.9999331503F, 0.9999825563F, 0.9999977357F, 0.9999999720F,
                };
                
                static const float vwin256[128] = {
                  0.0000591390F, 0.0005321979F, 0.0014780301F, 0.0028960636F,
                  0.0047854363F, 0.0071449926F, 0.0099732775F, 0.0132685298F,
                  0.0170286741F, 0.0212513119F, 0.0259337111F, 0.0310727950F,
                  0.0366651302F, 0.0427069140F, 0.0491939614F, 0.0561216907F,
                  0.0634851102F, 0.0712788035F, 0.0794969160F, 0.0881331402F,
                  0.0971807028F, 0.1066323515F, 0.1164803426F, 0.1267164297F,
                  0.1373318534F, 0.1483173323F, 0.1596630553F, 0.1713586755F,
                  0.1833933062F, 0.1957555184F, 0.2084333404F, 0.2214142599F,
                  0.2346852280F, 0.2482326664F, 0.2620424757F, 0.2761000481F,
                  0.2903902813F, 0.3048975959F, 0.3196059553F, 0.3344988887F,
                  0.3495595160F, 0.3647705766F, 0.3801144597F, 0.3955732382F,
                  0.4111287047F, 0.4267624093F, 0.4424557009F, 0.4581897696F,
                  0.4739456913F, 0.4897044744F, 0.5054471075F, 0.5211546088F,
                  0.5368080763F, 0.5523887395F, 0.5678780103F, 0.5832575361F,
                  0.5985092508F, 0.6136154277F, 0.6285587300F, 0.6433222619F,
                  0.6578896175F, 0.6722449294F, 0.6863729144F, 0.7002589187F,
                  0.7138889597F, 0.7272497662F, 0.7403288154F, 0.7531143679F,
                  0.7655954985F, 0.7777621249F, 0.7896050322F, 0.8011158947F,
                  0.8122872932F, 0.8231127294F, 0.8335866365F, 0.8437043850F,
                  0.8534622861F, 0.8628575905F, 0.8718884835F, 0.8805540765F,
                  0.8888543947F, 0.8967903616F, 0.9043637797F, 0.9115773078F,
                  0.9184344360F, 0.9249394562F, 0.9310974312F, 0.9369141608F,
                  0.9423961446F, 0.9475505439F, 0.9523851406F, 0.9569082947F,
                  0.9611289005F, 0.9650563408F, 0.9687004405F, 0.9720714191F,
                  0.9751798427F, 0.9780365753F, 0.9806527301F, 0.9830396204F,
                  0.9852087111F, 0.9871715701F, 0.9889398207F, 0.9905250941F,
                  0.9919389832F, 0.9931929973F, 0.9942985174F, 0.9952667537F,
                  0.9961087037F, 0.9968351119F, 0.9974564312F, 0.9979827858F,
                  0.9984239359F, 0.9987892441F, 0.9990876435F, 0.9993276081F,
                  0.9995171241F, 0.9996636648F, 0.9997741654F, 0.9998550016F,
                  0.9999119692F, 0.9999502656F, 0.9999744742F, 0.9999885497F,
                  0.9999958064F, 0.9999989077F, 0.9999998584F, 0.9999999983F,
                };
                
                static const float vwin512[256] = {
                  0.0000147849F, 0.0001330607F, 0.0003695946F, 0.0007243509F,
                  0.0011972759F, 0.0017882983F, 0.0024973285F, 0.0033242588F,
                  0.0042689632F, 0.0053312973F, 0.0065110982F, 0.0078081841F,
                  0.0092223540F, 0.0107533880F, 0.0124010466F, 0.0141650703F,
                  0.0160451800F, 0.0180410758F, 0.0201524373F, 0.0223789233F,
                  0.0247201710F, 0.0271757958F, 0.0297453914F, 0.0324285286F,
                  0.0352247556F, 0.0381335972F, 0.0411545545F, 0.0442871045F,
                  0.0475306997F, 0.0508847676F, 0.0543487103F, 0.0579219038F,
                  0.0616036982F, 0.0653934164F, 0.0692903546F, 0.0732937809F,
                  0.0774029356F, 0.0816170305F, 0.0859352485F, 0.0903567428F,
                  0.0948806375F, 0.0995060259F, 0.1042319712F, 0.1090575056F,
                  0.1139816300F, 0.1190033137F, 0.1241214941F, 0.1293350764F,
                  0.1346429333F, 0.1400439046F, 0.1455367974F, 0.1511203852F,
                  0.1567934083F, 0.1625545735F, 0.1684025537F, 0.1743359881F,
                  0.1803534820F, 0.1864536069F, 0.1926349000F, 0.1988958650F,
                  0.2052349715F, 0.2116506555F, 0.2181413191F, 0.2247053313F,
                  0.2313410275F, 0.2380467105F, 0.2448206500F, 0.2516610835F,
                  0.2585662164F, 0.2655342226F, 0.2725632448F, 0.2796513950F,
                  0.2867967551F, 0.2939973773F, 0.3012512852F, 0.3085564739F,
                  0.3159109111F, 0.3233125375F, 0.3307592680F, 0.3382489922F,
                  0.3457795756F, 0.3533488602F, 0.3609546657F, 0.3685947904F,
                  0.3762670121F, 0.3839690896F, 0.3916987634F, 0.3994537572F,
                  0.4072317788F, 0.4150305215F, 0.4228476653F, 0.4306808783F,
                  0.4385278181F, 0.4463861329F, 0.4542534630F, 0.4621274424F,
                  0.4700057001F, 0.4778858615F, 0.4857655502F, 0.4936423891F,
                  0.5015140023F, 0.5093780165F, 0.5172320626F, 0.5250737772F,
                  0.5329008043F, 0.5407107971F, 0.5485014192F, 0.5562703465F,
                  0.5640152688F, 0.5717338914F, 0.5794239366F, 0.5870831457F,
                  0.5947092801F, 0.6023001235F, 0.6098534829F, 0.6173671907F,
                  0.6248391059F, 0.6322671161F, 0.6396491384F, 0.6469831217F,
                  0.6542670475F, 0.6614989319F, 0.6686768267F, 0.6757988210F,
                  0.6828630426F, 0.6898676592F, 0.6968108799F, 0.7036909564F,
                  0.7105061843F, 0.7172549043F, 0.7239355032F, 0.7305464154F,
                  0.7370861235F, 0.7435531598F, 0.7499461068F, 0.7562635986F,
                  0.7625043214F, 0.7686670148F, 0.7747504721F, 0.7807535410F,
                  0.7866751247F, 0.7925141825F, 0.7982697296F, 0.8039408387F,
                  0.8095266395F, 0.8150263196F, 0.8204391248F, 0.8257643590F,
                  0.8310013848F, 0.8361496236F, 0.8412085555F, 0.8461777194F,
                  0.8510567129F, 0.8558451924F, 0.8605428730F, 0.8651495278F,
                  0.8696649882F, 0.8740891432F, 0.8784219392F, 0.8826633797F,
                  0.8868135244F, 0.8908724888F, 0.8948404441F, 0.8987176157F,
                  0.9025042831F, 0.9062007791F, 0.9098074886F, 0.9133248482F,
                  0.9167533451F, 0.9200935163F, 0.9233459472F, 0.9265112712F,
                  0.9295901680F, 0.9325833632F, 0.9354916263F, 0.9383157705F,
                  0.9410566504F, 0.9437151618F, 0.9462922398F, 0.9487888576F,
                  0.9512060252F, 0.9535447882F, 0.9558062262F, 0.9579914516F,
                  0.9601016078F, 0.9621378683F, 0.9641014348F, 0.9659935361F,
                  0.9678154261F, 0.9695683830F, 0.9712537071F, 0.9728727198F,
                  0.9744267618F, 0.9759171916F, 0.9773453842F, 0.9787127293F,
                  0.9800206298F, 0.9812705006F, 0.9824637665F, 0.9836018613F,
                  0.9846862258F, 0.9857183066F, 0.9866995544F, 0.9876314227F,
                  0.9885153662F, 0.9893528393F, 0.9901452948F, 0.9908941823F,
                  0.9916009470F, 0.9922670279F, 0.9928938570F, 0.9934828574F,
                  0.9940354423F, 0.9945530133F, 0.9950369595F, 0.9954886562F,
                  0.9959094633F, 0.9963007242F, 0.9966637649F, 0.9969998925F,
                  0.9973103939F, 0.9975965351F, 0.9978595598F, 0.9981006885F,
                  0.9983211172F, 0.9985220166F, 0.9987045311F, 0.9988697776F,
                  0.9990188449F, 0.9991527924F, 0.9992726499F, 0.9993794157F,
                  0.9994740570F, 0.9995575079F, 0.9996306699F, 0.9996944099F,
                  0.9997495605F, 0.9997969190F, 0.9998372465F, 0.9998712678F,
                  0.9998996704F, 0.9999231041F, 0.9999421807F, 0.9999574732F,
                  0.9999695157F, 0.9999788026F, 0.9999857885F, 0.9999908879F,
                  0.9999944746F, 0.9999968817F, 0.9999984010F, 0.9999992833F,
                  0.9999997377F, 0.9999999317F, 0.9999999911F, 0.9999999999F,
                };
                
                static const float vwin1024[512] = {
                  0.0000036962F, 0.0000332659F, 0.0000924041F, 0.0001811086F,
                  0.0002993761F, 0.0004472021F, 0.0006245811F, 0.0008315063F,
                  0.0010679699F, 0.0013339631F, 0.0016294757F, 0.0019544965F,
                  0.0023090133F, 0.0026930125F, 0.0031064797F, 0.0035493989F,
                  0.0040217533F, 0.0045235250F, 0.0050546946F, 0.0056152418F,
                  0.0062051451F, 0.0068243817F, 0.0074729278F, 0.0081507582F,
                  0.0088578466F, 0.0095941655F, 0.0103596863F, 0.0111543789F,
                  0.0119782122F, 0.0128311538F, 0.0137131701F, 0.0146242260F,
                  0.0155642855F, 0.0165333111F, 0.0175312640F, 0.0185581042F,
                  0.0196137903F, 0.0206982797F, 0.0218115284F, 0.0229534910F,
                  0.0241241208F, 0.0253233698F, 0.0265511886F, 0.0278075263F,
                  0.0290923308F, 0.0304055484F, 0.0317471241F, 0.0331170013F,
                  0.0345151222F, 0.0359414274F, 0.0373958560F, 0.0388783456F,
                  0.0403888325F, 0.0419272511F, 0.0434935347F, 0.0450876148F,
                  0.0467094213F, 0.0483588828F, 0.0500359261F, 0.0517404765F,
                  0.0534724575F, 0.0552317913F, 0.0570183983F, 0.0588321971F,
                  0.0606731048F, 0.0625410369F, 0.0644359070F, 0.0663576272F,
                  0.0683061077F, 0.0702812571F, 0.0722829821F, 0.0743111878F,
                  0.0763657775F, 0.0784466526F, 0.0805537129F, 0.0826868561F,
                  0.0848459782F, 0.0870309736F, 0.0892417345F, 0.0914781514F,
                  0.0937401128F, 0.0960275056F, 0.0983402145F, 0.1006781223F,
                  0.1030411101F, 0.1054290568F, 0.1078418397F, 0.1102793336F,
                  0.1127414119F, 0.1152279457F, 0.1177388042F, 0.1202738544F,
                  0.1228329618F, 0.1254159892F, 0.1280227980F, 0.1306532471F,
                  0.1333071937F, 0.1359844927F, 0.1386849970F, 0.1414085575F,
                  0.1441550230F, 0.1469242403F, 0.1497160539F, 0.1525303063F,
                  0.1553668381F, 0.1582254875F, 0.1611060909F, 0.1640084822F,
                  0.1669324936F, 0.1698779549F, 0.1728446939F, 0.1758325362F,
                  0.1788413055F, 0.1818708232F, 0.1849209084F, 0.1879913785F,
                  0.1910820485F, 0.1941927312F, 0.1973232376F, 0.2004733764F,
                  0.2036429541F, 0.2068317752F, 0.2100396421F, 0.2132663552F,
                  0.2165117125F, 0.2197755102F, 0.2230575422F, 0.2263576007F,
                  0.2296754753F, 0.2330109540F, 0.2363638225F, 0.2397338646F,
                  0.2431208619F, 0.2465245941F, 0.2499448389F, 0.2533813719F,
                  0.2568339669F, 0.2603023956F, 0.2637864277F, 0.2672858312F,
                  0.2708003718F, 0.2743298135F, 0.2778739186F, 0.2814324472F,
                  0.2850051576F, 0.2885918065F, 0.2921921485F, 0.2958059366F,
                  0.2994329219F, 0.3030728538F, 0.3067254799F, 0.3103905462F,
                  0.3140677969F, 0.3177569747F, 0.3214578205F, 0.3251700736F,
                  0.3288934718F, 0.3326277513F, 0.3363726468F, 0.3401278914F,
                  0.3438932168F, 0.3476683533F, 0.3514530297F, 0.3552469734F,
                  0.3590499106F, 0.3628615659F, 0.3666816630F, 0.3705099239F,
                  0.3743460698F, 0.3781898204F, 0.3820408945F, 0.3858990095F,
                  0.3897638820F, 0.3936352274F, 0.3975127601F, 0.4013961936F,
                  0.4052852405F, 0.4091796123F, 0.4130790198F, 0.4169831732F,
                  0.4208917815F, 0.4248045534F, 0.4287211965F, 0.4326414181F,
                  0.4365649248F, 0.4404914225F, 0.4444206167F, 0.4483522125F,
                  0.4522859146F, 0.4562214270F, 0.4601584538F, 0.4640966984F,
                  0.4680358644F, 0.4719756548F, 0.4759157726F, 0.4798559209F,
                  0.4837958024F, 0.4877351199F, 0.4916735765F, 0.4956108751F,
                  0.4995467188F, 0.5034808109F, 0.5074128550F, 0.5113425550F,
                  0.5152696149F, 0.5191937395F, 0.5231146336F, 0.5270320028F,
                  0.5309455530F, 0.5348549910F, 0.5387600239F, 0.5426603597F,
                  0.5465557070F, 0.5504457754F, 0.5543302752F, 0.5582089175F,
                  0.5620814145F, 0.5659474793F, 0.5698068262F, 0.5736591704F,
                  0.5775042283F, 0.5813417176F, 0.5851713571F, 0.5889928670F,
                  0.5928059689F, 0.5966103856F, 0.6004058415F, 0.6041920626F,
                  0.6079687761F, 0.6117357113F, 0.6154925986F, 0.6192391705F,
                  0.6229751612F, 0.6267003064F, 0.6304143441F, 0.6341170137F,
                  0.6378080569F, 0.6414872173F, 0.6451542405F, 0.6488088741F,
                  0.6524508681F, 0.6560799742F, 0.6596959469F, 0.6632985424F,
                  0.6668875197F, 0.6704626398F, 0.6740236662F, 0.6775703649F,
                  0.6811025043F, 0.6846198554F, 0.6881221916F, 0.6916092892F,
                  0.6950809269F, 0.6985368861F, 0.7019769510F, 0.7054009085F,
                  0.7088085484F, 0.7121996632F, 0.7155740484F, 0.7189315023F,
                  0.7222718263F, 0.7255948245F, 0.7289003043F, 0.7321880760F,
                  0.7354579530F, 0.7387097518F, 0.7419432921F, 0.7451583966F,
                  0.7483548915F, 0.7515326059F, 0.7546913723F, 0.7578310265F,
                  0.7609514077F, 0.7640523581F, 0.7671337237F, 0.7701953535F,
                  0.7732371001F, 0.7762588195F, 0.7792603711F, 0.7822416178F,
                  0.7852024259F, 0.7881426654F, 0.7910622097F, 0.7939609356F,
                  0.7968387237F, 0.7996954579F, 0.8025310261F, 0.8053453193F,
                  0.8081382324F, 0.8109096638F, 0.8136595156F, 0.8163876936F,
                  0.8190941071F, 0.8217786690F, 0.8244412960F, 0.8270819086F,
                  0.8297004305F, 0.8322967896F, 0.8348709171F, 0.8374227481F,
                  0.8399522213F, 0.8424592789F, 0.8449438672F, 0.8474059356F,
                  0.8498454378F, 0.8522623306F, 0.8546565748F, 0.8570281348F,
                  0.8593769787F, 0.8617030779F, 0.8640064080F, 0.8662869477F,
                  0.8685446796F, 0.8707795899F, 0.8729916682F, 0.8751809079F,
                  0.8773473059F, 0.8794908626F, 0.8816115819F, 0.8837094713F,
                  0.8857845418F, 0.8878368079F, 0.8898662874F, 0.8918730019F,
                  0.8938569760F, 0.8958182380F, 0.8977568194F, 0.8996727552F,
                  0.9015660837F, 0.9034368465F, 0.9052850885F, 0.9071108577F,
                  0.9089142057F, 0.9106951869F, 0.9124538591F, 0.9141902832F,
                  0.9159045233F, 0.9175966464F, 0.9192667228F, 0.9209148257F,
                  0.9225410313F, 0.9241454187F, 0.9257280701F, 0.9272890704F,
                  0.9288285075F, 0.9303464720F, 0.9318430576F, 0.9333183603F,
                  0.9347724792F, 0.9362055158F, 0.9376175745F, 0.9390087622F,
                  0.9403791881F, 0.9417289644F, 0.9430582055F, 0.9443670283F,
                  0.9456555521F, 0.9469238986F, 0.9481721917F, 0.9494005577F,
                  0.9506091252F, 0.9517980248F, 0.9529673894F, 0.9541173540F,
                  0.9552480557F, 0.9563596334F, 0.9574522282F, 0.9585259830F,
                  0.9595810428F, 0.9606175542F, 0.9616356656F, 0.9626355274F,
                  0.9636172915F, 0.9645811114F, 0.9655271425F, 0.9664555414F,
                  0.9673664664F, 0.9682600774F, 0.9691365355F, 0.9699960034F,
                  0.9708386448F, 0.9716646250F, 0.9724741103F, 0.9732672685F,
                  0.9740442683F, 0.9748052795F, 0.9755504729F, 0.9762800205F,
                  0.9769940950F, 0.9776928703F, 0.9783765210F, 0.9790452223F,
                  0.9796991504F, 0.9803384823F, 0.9809633954F, 0.9815740679F,
                  0.9821706784F, 0.9827534063F, 0.9833224312F, 0.9838779332F,
                  0.9844200928F, 0.9849490910F, 0.9854651087F, 0.9859683274F,
                  0.9864589286F, 0.9869370940F, 0.9874030054F, 0.9878568447F,
                  0.9882987937F, 0.9887290343F, 0.9891477481F, 0.9895551169F,
                  0.9899513220F, 0.9903365446F, 0.9907109658F, 0.9910747662F,
                  0.9914281260F, 0.9917712252F, 0.9921042433F, 0.9924273593F,
                  0.9927407516F, 0.9930445982F, 0.9933390763F, 0.9936243626F,
                  0.9939006331F, 0.9941680631F, 0.9944268269F, 0.9946770982F,
                  0.9949190498F, 0.9951528537F, 0.9953786808F, 0.9955967011F,
                  0.9958070836F, 0.9960099963F, 0.9962056061F, 0.9963940787F,
                  0.9965755786F, 0.9967502693F, 0.9969183129F, 0.9970798704F,
                  0.9972351013F, 0.9973841640F, 0.9975272151F, 0.9976644103F,
                  0.9977959036F, 0.9979218476F, 0.9980423932F, 0.9981576901F,
                  0.9982678862F, 0.9983731278F, 0.9984735596F, 0.9985693247F,
                  0.9986605645F, 0.9987474186F, 0.9988300248F, 0.9989085193F,
                  0.9989830364F, 0.9990537085F, 0.9991206662F, 0.9991840382F,
                  0.9992439513F, 0.9993005303F, 0.9993538982F, 0.9994041757F,
                  0.9994514817F, 0.9994959330F, 0.9995376444F, 0.9995767286F,
                  0.9996132960F, 0.9996474550F, 0.9996793121F, 0.9997089710F,
                  0.9997365339F, 0.9997621003F, 0.9997857677F, 0.9998076311F,
                  0.9998277836F, 0.9998463156F, 0.9998633155F, 0.9998788692F,
                  0.9998930603F, 0.9999059701F, 0.9999176774F, 0.9999282586F,
                  0.9999377880F, 0.9999463370F, 0.9999539749F, 0.9999607685F,
                  0.9999667820F, 0.9999720773F, 0.9999767136F, 0.9999807479F,
                  0.9999842344F, 0.9999872249F, 0.9999897688F, 0.9999919127F,
                  0.9999937009F, 0.9999951749F, 0.9999963738F, 0.9999973342F,
                  0.9999980900F, 0.9999986724F, 0.9999991103F, 0.9999994297F,
                  0.9999996543F, 0.9999998049F, 0.9999999000F, 0.9999999552F,
                  0.9999999836F, 0.9999999957F, 0.9999999994F, 1.0000000000F,
                };
                
                static const float vwin2048[1024] = {
                  0.0000009241F, 0.0000083165F, 0.0000231014F, 0.0000452785F,
                  0.0000748476F, 0.0001118085F, 0.0001561608F, 0.0002079041F,
                  0.0002670379F, 0.0003335617F, 0.0004074748F, 0.0004887765F,
                  0.0005774661F, 0.0006735427F, 0.0007770054F, 0.0008878533F,
                  0.0010060853F, 0.0011317002F, 0.0012646969F, 0.0014050742F,
                  0.0015528307F, 0.0017079650F, 0.0018704756F, 0.0020403610F,
                  0.0022176196F, 0.0024022497F, 0.0025942495F, 0.0027936173F,
                  0.0030003511F, 0.0032144490F, 0.0034359088F, 0.0036647286F,
                  0.0039009061F, 0.0041444391F, 0.0043953253F, 0.0046535621F,
                  0.0049191472F, 0.0051920781F, 0.0054723520F, 0.0057599664F,
                  0.0060549184F, 0.0063572052F, 0.0066668239F, 0.0069837715F,
                  0.0073080449F, 0.0076396410F, 0.0079785566F, 0.0083247884F,
                  0.0086783330F, 0.0090391871F, 0.0094073470F, 0.0097828092F,
                  0.0101655700F, 0.0105556258F, 0.0109529726F, 0.0113576065F,
                  0.0117695237F, 0.0121887200F, 0.0126151913F, 0.0130489335F,
                  0.0134899422F, 0.0139382130F, 0.0143937415F, 0.0148565233F,
                  0.0153265536F, 0.0158038279F, 0.0162883413F, 0.0167800889F,
                  0.0172790660F, 0.0177852675F, 0.0182986882F, 0.0188193231F,
                  0.0193471668F, 0.0198822141F, 0.0204244594F, 0.0209738974F,
                  0.0215305225F, 0.0220943289F, 0.0226653109F, 0.0232434627F,
                  0.0238287784F, 0.0244212519F, 0.0250208772F, 0.0256276481F,
                  0.0262415582F, 0.0268626014F, 0.0274907711F, 0.0281260608F,
                  0.0287684638F, 0.0294179736F, 0.0300745833F, 0.0307382859F,
                  0.0314090747F, 0.0320869424F, 0.0327718819F, 0.0334638860F,
                  0.0341629474F, 0.0348690586F, 0.0355822122F, 0.0363024004F,
                  0.0370296157F, 0.0377638502F, 0.0385050960F, 0.0392533451F,
                  0.0400085896F, 0.0407708211F, 0.0415400315F, 0.0423162123F,
                  0.0430993552F, 0.0438894515F, 0.0446864926F, 0.0454904698F,
                  0.0463013742F, 0.0471191969F, 0.0479439288F, 0.0487755607F,
                  0.0496140836F, 0.0504594879F, 0.0513117642F, 0.0521709031F,
                  0.0530368949F, 0.0539097297F, 0.0547893979F, 0.0556758894F,
                  0.0565691941F, 0.0574693019F, 0.0583762026F, 0.0592898858F,
                  0.0602103410F, 0.0611375576F, 0.0620715250F, 0.0630122324F,
                  0.0639596688F, 0.0649138234F, 0.0658746848F, 0.0668422421F,
                  0.0678164838F, 0.0687973985F, 0.0697849746F, 0.0707792005F,
                  0.0717800645F, 0.0727875547F, 0.0738016591F, 0.0748223656F,
                  0.0758496620F, 0.0768835359F, 0.0779239751F, 0.0789709668F,
                  0.0800244985F, 0.0810845574F, 0.0821511306F, 0.0832242052F,
                  0.0843037679F, 0.0853898056F, 0.0864823050F, 0.0875812525F,
                  0.0886866347F, 0.0897984378F, 0.0909166480F, 0.0920412513F,
                  0.0931722338F, 0.0943095813F, 0.0954532795F, 0.0966033140F,
                  0.0977596702F, 0.0989223336F, 0.1000912894F, 0.1012665227F,
                  0.1024480185F, 0.1036357616F, 0.1048297369F, 0.1060299290F,
                  0.1072363224F, 0.1084489014F, 0.1096676504F, 0.1108925534F,
                  0.1121235946F, 0.1133607577F, 0.1146040267F, 0.1158533850F,
                  0.1171088163F, 0.1183703040F, 0.1196378312F, 0.1209113812F,
                  0.1221909370F, 0.1234764815F, 0.1247679974F, 0.1260654674F,
                  0.1273688740F, 0.1286781995F, 0.1299934263F, 0.1313145365F,
                  0.1326415121F, 0.1339743349F, 0.1353129866F, 0.1366574490F,
                  0.1380077035F, 0.1393637315F, 0.1407255141F, 0.1420930325F,
                  0.1434662677F, 0.1448452004F, 0.1462298115F, 0.1476200814F,
                  0.1490159906F, 0.1504175195F, 0.1518246482F, 0.1532373569F,
                  0.1546556253F, 0.1560794333F, 0.1575087606F, 0.1589435866F,
                  0.1603838909F, 0.1618296526F, 0.1632808509F, 0.1647374648F,
                  0.1661994731F, 0.1676668546F, 0.1691395880F, 0.1706176516F,
                  0.1721010238F, 0.1735896829F, 0.1750836068F, 0.1765827736F,
                  0.1780871610F, 0.1795967468F, 0.1811115084F, 0.1826314234F,
                  0.1841564689F, 0.1856866221F, 0.1872218600F, 0.1887621595F,
                  0.1903074974F, 0.1918578503F, 0.1934131947F, 0.1949735068F,
                  0.1965387630F, 0.1981089393F, 0.1996840117F, 0.2012639560F,
                  0.2028487479F, 0.2044383630F, 0.2060327766F, 0.2076319642F,
                  0.2092359007F, 0.2108445614F, 0.2124579211F, 0.2140759545F,
                  0.2156986364F, 0.2173259411F, 0.2189578432F, 0.2205943168F,
                  0.2222353361F, 0.2238808751F, 0.2255309076F, 0.2271854073F,
                  0.2288443480F, 0.2305077030F, 0.2321754457F, 0.2338475493F,
                  0.2355239869F, 0.2372047315F, 0.2388897560F, 0.2405790329F,
                  0.2422725350F, 0.2439702347F, 0.2456721043F, 0.2473781159F,
                  0.2490882418F, 0.2508024539F, 0.2525207240F, 0.2542430237F,
                  0.2559693248F, 0.2576995986F, 0.2594338166F, 0.2611719498F,
                  0.2629139695F, 0.2646598466F, 0.2664095520F, 0.2681630564F,
                  0.2699203304F, 0.2716813445F, 0.2734460691F, 0.2752144744F,
                  0.2769865307F, 0.2787622079F, 0.2805414760F, 0.2823243047F,
                  0.2841106637F, 0.2859005227F, 0.2876938509F, 0.2894906179F,
                  0.2912907928F, 0.2930943447F, 0.2949012426F, 0.2967114554F,
                  0.2985249520F, 0.3003417009F, 0.3021616708F, 0.3039848301F,
                  0.3058111471F, 0.3076405901F, 0.3094731273F, 0.3113087266F,
                  0.3131473560F, 0.3149889833F, 0.3168335762F, 0.3186811024F,
                  0.3205315294F, 0.3223848245F, 0.3242409552F, 0.3260998886F,
                  0.3279615918F, 0.3298260319F, 0.3316931758F, 0.3335629903F,
                  0.3354354423F, 0.3373104982F, 0.3391881247F, 0.3410682882F,
                  0.3429509551F, 0.3448360917F, 0.3467236642F, 0.3486136387F,
                  0.3505059811F, 0.3524006575F, 0.3542976336F, 0.3561968753F,
                  0.3580983482F, 0.3600020179F, 0.3619078499F, 0.3638158096F,
                  0.3657258625F, 0.3676379737F, 0.3695521086F, 0.3714682321F,
                  0.3733863094F, 0.3753063055F, 0.3772281852F, 0.3791519134F,
                  0.3810774548F, 0.3830047742F, 0.3849338362F, 0.3868646053F,
                  0.3887970459F, 0.3907311227F, 0.3926667998F, 0.3946040417F,
                  0.3965428125F, 0.3984830765F, 0.4004247978F, 0.4023679403F,
                  0.4043124683F, 0.4062583455F, 0.4082055359F, 0.4101540034F,
                  0.4121037117F, 0.4140546246F, 0.4160067058F, 0.4179599190F,
                  0.4199142277F, 0.4218695956F, 0.4238259861F, 0.4257833627F,
                  0.4277416888F, 0.4297009279F, 0.4316610433F, 0.4336219983F,
                  0.4355837562F, 0.4375462803F, 0.4395095337F, 0.4414734797F,
                  0.4434380815F, 0.4454033021F, 0.4473691046F, 0.4493354521F,
                  0.4513023078F, 0.4532696345F, 0.4552373954F, 0.4572055533F,
                  0.4591740713F, 0.4611429123F, 0.4631120393F, 0.4650814151F,
                  0.4670510028F, 0.4690207650F, 0.4709906649F, 0.4729606651F,
                  0.4749307287F, 0.4769008185F, 0.4788708972F, 0.4808409279F,
                  0.4828108732F, 0.4847806962F, 0.4867503597F, 0.4887198264F,
                  0.4906890593F, 0.4926580213F, 0.4946266753F, 0.4965949840F,
                  0.4985629105F, 0.5005304176F, 0.5024974683F, 0.5044640255F,
                  0.5064300522F, 0.5083955114F, 0.5103603659F, 0.5123245790F,
                  0.5142881136F, 0.5162509328F, 0.5182129997F, 0.5201742774F,
                  0.5221347290F, 0.5240943178F, 0.5260530070F, 0.5280107598F,
                  0.5299675395F, 0.5319233095F, 0.5338780330F, 0.5358316736F,
                  0.5377841946F, 0.5397355596F, 0.5416857320F, 0.5436346755F,
                  0.5455823538F, 0.5475287304F, 0.5494737691F, 0.5514174337F,
                  0.5533596881F, 0.5553004962F, 0.5572398218F, 0.5591776291F,
                  0.5611138821F, 0.5630485449F, 0.5649815818F, 0.5669129570F,
                  0.5688426349F, 0.5707705799F, 0.5726967564F, 0.5746211290F,
                  0.5765436624F, 0.5784643212F, 0.5803830702F, 0.5822998743F,
                  0.5842146984F, 0.5861275076F, 0.5880382669F, 0.5899469416F,
                  0.5918534968F, 0.5937578981F, 0.5956601107F, 0.5975601004F,
                  0.5994578326F, 0.6013532732F, 0.6032463880F, 0.6051371429F,
                  0.6070255039F, 0.6089114372F, 0.6107949090F, 0.6126758856F,
                  0.6145543334F, 0.6164302191F, 0.6183035092F, 0.6201741706F,
                  0.6220421700F, 0.6239074745F, 0.6257700513F, 0.6276298674F,
                  0.6294868903F, 0.6313410873F, 0.6331924262F, 0.6350408745F,
                  0.6368864001F, 0.6387289710F, 0.6405685552F, 0.6424051209F,
                  0.6442386364F, 0.6460690702F, 0.6478963910F, 0.6497205673F,
                  0.6515415682F, 0.6533593625F, 0.6551739194F, 0.6569852082F,
                  0.6587931984F, 0.6605978593F, 0.6623991609F, 0.6641970728F,
                  0.6659915652F, 0.6677826081F, 0.6695701718F, 0.6713542268F,
                  0.6731347437F, 0.6749116932F, 0.6766850461F, 0.6784547736F,
                  0.6802208469F, 0.6819832374F, 0.6837419164F, 0.6854968559F,
                  0.6872480275F, 0.6889954034F, 0.6907389556F, 0.6924786566F,
                  0.6942144788F, 0.6959463950F, 0.6976743780F, 0.6993984008F,
                  0.7011184365F, 0.7028344587F, 0.7045464407F, 0.7062543564F,
                  0.7079581796F, 0.7096578844F, 0.7113534450F, 0.7130448359F,
                  0.7147320316F, 0.7164150070F, 0.7180937371F, 0.7197681970F,
                  0.7214383620F, 0.7231042077F, 0.7247657098F, 0.7264228443F,
                  0.7280755871F, 0.7297239147F, 0.7313678035F, 0.7330072301F,
                  0.7346421715F, 0.7362726046F, 0.7378985069F, 0.7395198556F,
                  0.7411366285F, 0.7427488034F, 0.7443563584F, 0.7459592717F,
                  0.7475575218F, 0.7491510873F, 0.7507399471F, 0.7523240803F,
                  0.7539034661F, 0.7554780839F, 0.7570479136F, 0.7586129349F,
                  0.7601731279F, 0.7617284730F, 0.7632789506F, 0.7648245416F,
                  0.7663652267F, 0.7679009872F, 0.7694318044F, 0.7709576599F,
                  0.7724785354F, 0.7739944130F, 0.7755052749F, 0.7770111035F,
                  0.7785118815F, 0.7800075916F, 0.7814982170F, 0.7829837410F,
                  0.7844641472F, 0.7859394191F, 0.7874095408F, 0.7888744965F,
                  0.7903342706F, 0.7917888476F, 0.7932382124F, 0.7946823501F,
                  0.7961212460F, 0.7975548855F, 0.7989832544F, 0.8004063386F,
                  0.8018241244F, 0.8032365981F, 0.8046437463F, 0.8060455560F,
                  0.8074420141F, 0.8088331080F, 0.8102188253F, 0.8115991536F,
                  0.8129740810F, 0.8143435957F, 0.8157076861F, 0.8170663409F,
                  0.8184195489F, 0.8197672994F, 0.8211095817F, 0.8224463853F,
                  0.8237777001F, 0.8251035161F, 0.8264238235F, 0.8277386129F,
                  0.8290478750F, 0.8303516008F, 0.8316497814F, 0.8329424083F,
                  0.8342294731F, 0.8355109677F, 0.8367868841F, 0.8380572148F,
                  0.8393219523F, 0.8405810893F, 0.8418346190F, 0.8430825345F,
                  0.8443248294F, 0.8455614974F, 0.8467925323F, 0.8480179285F,
                  0.8492376802F, 0.8504517822F, 0.8516602292F, 0.8528630164F,
                  0.8540601391F, 0.8552515928F, 0.8564373733F, 0.8576174766F,
                  0.8587918990F, 0.8599606368F, 0.8611236868F, 0.8622810460F,
                  0.8634327113F, 0.8645786802F, 0.8657189504F, 0.8668535195F,
                  0.8679823857F, 0.8691055472F, 0.8702230025F, 0.8713347503F,
                  0.8724407896F, 0.8735411194F, 0.8746357394F, 0.8757246489F,
                  0.8768078479F, 0.8778853364F, 0.8789571146F, 0.8800231832F,
                  0.8810835427F, 0.8821381942F, 0.8831871387F, 0.8842303777F,
                  0.8852679127F, 0.8862997456F, 0.8873258784F, 0.8883463132F,
                  0.8893610527F, 0.8903700994F, 0.8913734562F, 0.8923711263F,
                  0.8933631129F, 0.8943494196F, 0.8953300500F, 0.8963050083F,
                  0.8972742985F, 0.8982379249F, 0.8991958922F, 0.9001482052F,
                  0.9010948688F, 0.9020358883F, 0.9029712690F, 0.9039010165F,
                  0.9048251367F, 0.9057436357F, 0.9066565195F, 0.9075637946F,
                  0.9084654678F, 0.9093615456F, 0.9102520353F, 0.9111369440F,
                  0.9120162792F, 0.9128900484F, 0.9137582595F, 0.9146209204F,
                  0.9154780394F, 0.9163296248F, 0.9171756853F, 0.9180162296F,
                  0.9188512667F, 0.9196808057F, 0.9205048559F, 0.9213234270F,
                  0.9221365285F, 0.9229441704F, 0.9237463629F, 0.9245431160F,
                  0.9253344404F, 0.9261203465F, 0.9269008453F, 0.9276759477F,
                  0.9284456648F, 0.9292100080F, 0.9299689889F, 0.9307226190F,
                  0.9314709103F, 0.9322138747F, 0.9329515245F, 0.9336838721F,
                  0.9344109300F, 0.9351327108F, 0.9358492275F, 0.9365604931F,
                  0.9372665208F, 0.9379673239F, 0.9386629160F, 0.9393533107F,
                  0.9400385220F, 0.9407185637F, 0.9413934501F, 0.9420631954F,
                  0.9427278141F, 0.9433873208F, 0.9440417304F, 0.9446910576F,
                  0.9453353176F, 0.9459745255F, 0.9466086968F, 0.9472378469F,
                  0.9478619915F, 0.9484811463F, 0.9490953274F, 0.9497045506F,
                  0.9503088323F, 0.9509081888F, 0.9515026365F, 0.9520921921F,
                  0.9526768723F, 0.9532566940F, 0.9538316742F, 0.9544018300F,
                  0.9549671786F, 0.9555277375F, 0.9560835241F, 0.9566345562F,
                  0.9571808513F, 0.9577224275F, 0.9582593027F, 0.9587914949F,
                  0.9593190225F, 0.9598419038F, 0.9603601571F, 0.9608738012F,
                  0.9613828546F, 0.9618873361F, 0.9623872646F, 0.9628826591F,
                  0.9633735388F, 0.9638599227F, 0.9643418303F, 0.9648192808F,
                  0.9652922939F, 0.9657608890F, 0.9662250860F, 0.9666849046F,
                  0.9671403646F, 0.9675914861F, 0.9680382891F, 0.9684807937F,
                  0.9689190202F, 0.9693529890F, 0.9697827203F, 0.9702082347F,
                  0.9706295529F, 0.9710466953F, 0.9714596828F, 0.9718685362F,
                  0.9722732762F, 0.9726739240F, 0.9730705005F, 0.9734630267F,
                  0.9738515239F, 0.9742360134F, 0.9746165163F, 0.9749930540F,
                  0.9753656481F, 0.9757343198F, 0.9760990909F, 0.9764599829F,
                  0.9768170175F, 0.9771702164F, 0.9775196013F, 0.9778651941F,
                  0.9782070167F, 0.9785450909F, 0.9788794388F, 0.9792100824F,
                  0.9795370437F, 0.9798603449F, 0.9801800080F, 0.9804960554F,
                  0.9808085092F, 0.9811173916F, 0.9814227251F, 0.9817245318F,
                  0.9820228343F, 0.9823176549F, 0.9826090160F, 0.9828969402F,
                  0.9831814498F, 0.9834625674F, 0.9837403156F, 0.9840147169F,
                  0.9842857939F, 0.9845535692F, 0.9848180654F, 0.9850793052F,
                  0.9853373113F, 0.9855921062F, 0.9858437127F, 0.9860921535F,
                  0.9863374512F, 0.9865796287F, 0.9868187085F, 0.9870547136F,
                  0.9872876664F, 0.9875175899F, 0.9877445067F, 0.9879684396F,
                  0.9881894112F, 0.9884074444F, 0.9886225619F, 0.9888347863F,
                  0.9890441404F, 0.9892506468F, 0.9894543284F, 0.9896552077F,
                  0.9898533074F, 0.9900486502F, 0.9902412587F, 0.9904311555F,
                  0.9906183633F, 0.9908029045F, 0.9909848019F, 0.9911640779F,
                  0.9913407550F, 0.9915148557F, 0.9916864025F, 0.9918554179F,
                  0.9920219241F, 0.9921859437F, 0.9923474989F, 0.9925066120F,
                  0.9926633054F, 0.9928176012F, 0.9929695218F, 0.9931190891F,
                  0.9932663254F, 0.9934112527F, 0.9935538932F, 0.9936942686F,
                  0.9938324012F, 0.9939683126F, 0.9941020248F, 0.9942335597F,
                  0.9943629388F, 0.9944901841F, 0.9946153170F, 0.9947383593F,
                  0.9948593325F, 0.9949782579F, 0.9950951572F, 0.9952100516F,
                  0.9953229625F, 0.9954339111F, 0.9955429186F, 0.9956500062F,
                  0.9957551948F, 0.9958585056F, 0.9959599593F, 0.9960595769F,
                  0.9961573792F, 0.9962533869F, 0.9963476206F, 0.9964401009F,
                  0.9965308483F, 0.9966198833F, 0.9967072261F, 0.9967928971F,
                  0.9968769164F, 0.9969593041F, 0.9970400804F, 0.9971192651F,
                  0.9971968781F, 0.9972729391F, 0.9973474680F, 0.9974204842F,
                  0.9974920074F, 0.9975620569F, 0.9976306521F, 0.9976978122F,
                  0.9977635565F, 0.9978279039F, 0.9978908736F, 0.9979524842F,
                  0.9980127547F, 0.9980717037F, 0.9981293499F, 0.9981857116F,
                  0.9982408073F, 0.9982946554F, 0.9983472739F, 0.9983986810F,
                  0.9984488947F, 0.9984979328F, 0.9985458132F, 0.9985925534F,
                  0.9986381711F, 0.9986826838F, 0.9987261086F, 0.9987684630F,
                  0.9988097640F, 0.9988500286F, 0.9988892738F, 0.9989275163F,
                  0.9989647727F, 0.9990010597F, 0.9990363938F, 0.9990707911F,
                  0.9991042679F, 0.9991368404F, 0.9991685244F, 0.9991993358F,
                  0.9992292905F, 0.9992584038F, 0.9992866914F, 0.9993141686F,
                  0.9993408506F, 0.9993667526F, 0.9993918895F, 0.9994162761F,
                  0.9994399273F, 0.9994628576F, 0.9994850815F, 0.9995066133F,
                  0.9995274672F, 0.9995476574F, 0.9995671978F, 0.9995861021F,
                  0.9996043841F, 0.9996220573F, 0.9996391352F, 0.9996556310F,
                  0.9996715579F, 0.9996869288F, 0.9997017568F, 0.9997160543F,
                  0.9997298342F, 0.9997431088F, 0.9997558905F, 0.9997681914F,
                  0.9997800236F, 0.9997913990F, 0.9998023292F, 0.9998128261F,
                  0.9998229009F, 0.9998325650F, 0.9998418296F, 0.9998507058F,
                  0.9998592044F, 0.9998673362F, 0.9998751117F, 0.9998825415F,
                  0.9998896358F, 0.9998964047F, 0.9999028584F, 0.9999090066F,
                  0.9999148590F, 0.9999204253F, 0.9999257148F, 0.9999307368F,
                  0.9999355003F, 0.9999400144F, 0.9999442878F, 0.9999483293F,
                  0.9999521472F, 0.9999557499F, 0.9999591457F, 0.9999623426F,
                  0.9999653483F, 0.9999681708F, 0.9999708175F, 0.9999732959F,
                  0.9999756132F, 0.9999777765F, 0.9999797928F, 0.9999816688F,
                  0.9999834113F, 0.9999850266F, 0.9999865211F, 0.9999879009F,
                  0.9999891721F, 0.9999903405F, 0.9999914118F, 0.9999923914F,
                  0.9999932849F, 0.9999940972F, 0.9999948336F, 0.9999954989F,
                  0.9999960978F, 0.9999966349F, 0.9999971146F, 0.9999975411F,
                  0.9999979185F, 0.9999982507F, 0.9999985414F, 0.9999987944F,
                  0.9999990129F, 0.9999992003F, 0.9999993596F, 0.9999994939F,
                  0.9999996059F, 0.9999996981F, 0.9999997732F, 0.9999998333F,
                  0.9999998805F, 0.9999999170F, 0.9999999444F, 0.9999999643F,
                  0.9999999784F, 0.9999999878F, 0.9999999937F, 0.9999999972F,
                  0.9999999990F, 0.9999999997F, 1.0000000000F, 1.0000000000F,
                };
                
                static const float vwin4096[2048] = {
                  0.0000002310F, 0.0000020791F, 0.0000057754F, 0.0000113197F,
                  0.0000187121F, 0.0000279526F, 0.0000390412F, 0.0000519777F,
                  0.0000667623F, 0.0000833949F, 0.0001018753F, 0.0001222036F,
                  0.0001443798F, 0.0001684037F, 0.0001942754F, 0.0002219947F,
                  0.0002515616F, 0.0002829761F, 0.0003162380F, 0.0003513472F,
                  0.0003883038F, 0.0004271076F, 0.0004677584F, 0.0005102563F,
                  0.0005546011F, 0.0006007928F, 0.0006488311F, 0.0006987160F,
                  0.0007504474F, 0.0008040251F, 0.0008594490F, 0.0009167191F,
                  0.0009758351F, 0.0010367969F, 0.0010996044F, 0.0011642574F,
                  0.0012307558F, 0.0012990994F, 0.0013692880F, 0.0014413216F,
                  0.0015151998F, 0.0015909226F, 0.0016684898F, 0.0017479011F,
                  0.0018291565F, 0.0019122556F, 0.0019971983F, 0.0020839845F,
                  0.0021726138F, 0.0022630861F, 0.0023554012F, 0.0024495588F,
                  0.0025455588F, 0.0026434008F, 0.0027430847F, 0.0028446103F,
                  0.0029479772F, 0.0030531853F, 0.0031602342F, 0.0032691238F,
                  0.0033798538F, 0.0034924239F, 0.0036068338F, 0.0037230833F,
                  0.0038411721F, 0.0039610999F, 0.0040828664F, 0.0042064714F,
                  0.0043319145F, 0.0044591954F, 0.0045883139F, 0.0047192696F,
                  0.0048520622F, 0.0049866914F, 0.0051231569F, 0.0052614583F,
                  0.0054015953F, 0.0055435676F, 0.0056873748F, 0.0058330166F,
                  0.0059804926F, 0.0061298026F, 0.0062809460F, 0.0064339226F,
                  0.0065887320F, 0.0067453738F, 0.0069038476F, 0.0070641531F,
                  0.0072262899F, 0.0073902575F, 0.0075560556F, 0.0077236838F,
                  0.0078931417F, 0.0080644288F, 0.0082375447F, 0.0084124891F,
                  0.0085892615F, 0.0087678614F, 0.0089482885F, 0.0091305422F,
                  0.0093146223F, 0.0095005281F, 0.0096882592F, 0.0098778153F,
                  0.0100691958F, 0.0102624002F, 0.0104574281F, 0.0106542791F,
                  0.0108529525F, 0.0110534480F, 0.0112557651F, 0.0114599032F,
                  0.0116658618F, 0.0118736405F, 0.0120832387F, 0.0122946560F,
                  0.0125078917F, 0.0127229454F, 0.0129398166F, 0.0131585046F,
                  0.0133790090F, 0.0136013292F, 0.0138254647F, 0.0140514149F,
                  0.0142791792F, 0.0145087572F, 0.0147401481F, 0.0149733515F,
                  0.0152083667F, 0.0154451932F, 0.0156838304F, 0.0159242777F,
                  0.0161665345F, 0.0164106001F, 0.0166564741F, 0.0169041557F,
                  0.0171536443F, 0.0174049393F, 0.0176580401F, 0.0179129461F,
                  0.0181696565F, 0.0184281708F, 0.0186884883F, 0.0189506084F,
                  0.0192145303F, 0.0194802535F, 0.0197477772F, 0.0200171008F,
                  0.0202882236F, 0.0205611449F, 0.0208358639F, 0.0211123801F,
                  0.0213906927F, 0.0216708011F, 0.0219527043F, 0.0222364019F,
                  0.0225218930F, 0.0228091769F, 0.0230982529F, 0.0233891203F,
                  0.0236817782F, 0.0239762259F, 0.0242724628F, 0.0245704880F,
                  0.0248703007F, 0.0251719002F, 0.0254752858F, 0.0257804565F,
                  0.0260874117F, 0.0263961506F, 0.0267066722F, 0.0270189760F,
                  0.0273330609F, 0.0276489263F, 0.0279665712F, 0.0282859949F,
                  0.0286071966F, 0.0289301753F, 0.0292549303F, 0.0295814607F,
                  0.0299097656F, 0.0302398442F, 0.0305716957F, 0.0309053191F,
                  0.0312407135F, 0.0315778782F, 0.0319168122F, 0.0322575145F,
                  0.0325999844F, 0.0329442209F, 0.0332902231F, 0.0336379900F,
                  0.0339875208F, 0.0343388146F, 0.0346918703F, 0.0350466871F,
                  0.0354032640F, 0.0357616000F, 0.0361216943F, 0.0364835458F,
                  0.0368471535F, 0.0372125166F, 0.0375796339F, 0.0379485046F,
                  0.0383191276F, 0.0386915020F, 0.0390656267F, 0.0394415008F,
                  0.0398191231F, 0.0401984927F, 0.0405796086F, 0.0409624698F,
                  0.0413470751F, 0.0417334235F, 0.0421215141F, 0.0425113457F,
                  0.0429029172F, 0.0432962277F, 0.0436912760F, 0.0440880610F,
                  0.0444865817F, 0.0448868370F, 0.0452888257F, 0.0456925468F,
                  0.0460979992F, 0.0465051816F, 0.0469140931F, 0.0473247325F,
                  0.0477370986F, 0.0481511902F, 0.0485670064F, 0.0489845458F,
                  0.0494038074F, 0.0498247899F, 0.0502474922F, 0.0506719131F,
                  0.0510980514F, 0.0515259060F, 0.0519554756F, 0.0523867590F,
                  0.0528197550F, 0.0532544624F, 0.0536908800F, 0.0541290066F,
                  0.0545688408F, 0.0550103815F, 0.0554536274F, 0.0558985772F,
                  0.0563452297F, 0.0567935837F, 0.0572436377F, 0.0576953907F,
                  0.0581488412F, 0.0586039880F, 0.0590608297F, 0.0595193651F,
                  0.0599795929F, 0.0604415117F, 0.0609051202F, 0.0613704170F,
                  0.0618374009F, 0.0623060704F, 0.0627764243F, 0.0632484611F,
                  0.0637221795F, 0.0641975781F, 0.0646746555F, 0.0651534104F,
                  0.0656338413F, 0.0661159469F, 0.0665997257F, 0.0670851763F,
                  0.0675722973F, 0.0680610873F, 0.0685515448F, 0.0690436684F,
                  0.0695374567F, 0.0700329081F, 0.0705300213F, 0.0710287947F,
                  0.0715292269F, 0.0720313163F, 0.0725350616F, 0.0730404612F,
                  0.0735475136F, 0.0740562172F, 0.0745665707F, 0.0750785723F,
                  0.0755922207F, 0.0761075143F, 0.0766244515F, 0.0771430307F,
                  0.0776632505F, 0.0781851092F, 0.0787086052F, 0.0792337371F,
                  0.0797605032F, 0.0802889018F, 0.0808189315F, 0.0813505905F,
                  0.0818838773F, 0.0824187903F, 0.0829553277F, 0.0834934881F,
                  0.0840332697F, 0.0845746708F, 0.0851176899F, 0.0856623252F,
                  0.0862085751F, 0.0867564379F, 0.0873059119F, 0.0878569954F,
                  0.0884096867F, 0.0889639840F, 0.0895198858F, 0.0900773902F,
                  0.0906364955F, 0.0911972000F, 0.0917595019F, 0.0923233995F,
                  0.0928888909F, 0.0934559745F, 0.0940246485F, 0.0945949110F,
                  0.0951667604F, 0.0957401946F, 0.0963152121F, 0.0968918109F,
                  0.0974699893F, 0.0980497454F, 0.0986310773F, 0.0992139832F,
                  0.0997984614F, 0.1003845098F, 0.1009721267F, 0.1015613101F,
                  0.1021520582F, 0.1027443692F, 0.1033382410F, 0.1039336718F,
                  0.1045306597F, 0.1051292027F, 0.1057292990F, 0.1063309466F,
                  0.1069341435F, 0.1075388878F, 0.1081451776F, 0.1087530108F,
                  0.1093623856F, 0.1099732998F, 0.1105857516F, 0.1111997389F,
                  0.1118152597F, 0.1124323121F, 0.1130508939F, 0.1136710032F,
                  0.1142926379F, 0.1149157960F, 0.1155404755F, 0.1161666742F,
                  0.1167943901F, 0.1174236211F, 0.1180543652F, 0.1186866202F,
                  0.1193203841F, 0.1199556548F, 0.1205924300F, 0.1212307078F,
                  0.1218704860F, 0.1225117624F, 0.1231545349F, 0.1237988013F,
                  0.1244445596F, 0.1250918074F, 0.1257405427F, 0.1263907632F,
                  0.1270424667F, 0.1276956512F, 0.1283503142F, 0.1290064537F,
                  0.1296640674F, 0.1303231530F, 0.1309837084F, 0.1316457312F,
                  0.1323092193F, 0.1329741703F, 0.1336405820F, 0.1343084520F,
                  0.1349777782F, 0.1356485582F, 0.1363207897F, 0.1369944704F,
                  0.1376695979F, 0.1383461700F, 0.1390241842F, 0.1397036384F,
                  0.1403845300F, 0.1410668567F, 0.1417506162F, 0.1424358061F,
                  0.1431224240F, 0.1438104674F, 0.1444999341F, 0.1451908216F,
                  0.1458831274F, 0.1465768492F, 0.1472719844F, 0.1479685308F,
                  0.1486664857F, 0.1493658468F, 0.1500666115F, 0.1507687775F,
                  0.1514723422F, 0.1521773031F, 0.1528836577F, 0.1535914035F,
                  0.1543005380F, 0.1550110587F, 0.1557229631F, 0.1564362485F,
                  0.1571509124F, 0.1578669524F, 0.1585843657F, 0.1593031499F,
                  0.1600233024F, 0.1607448205F, 0.1614677017F, 0.1621919433F,
                  0.1629175428F, 0.1636444975F, 0.1643728047F, 0.1651024619F,
                  0.1658334665F, 0.1665658156F, 0.1672995067F, 0.1680345371F,
                  0.1687709041F, 0.1695086050F, 0.1702476372F, 0.1709879978F,
                  0.1717296843F, 0.1724726938F, 0.1732170237F, 0.1739626711F,
                  0.1747096335F, 0.1754579079F, 0.1762074916F, 0.1769583819F,
                  0.1777105760F, 0.1784640710F, 0.1792188642F, 0.1799749529F,
                  0.1807323340F, 0.1814910049F, 0.1822509628F, 0.1830122046F,
                  0.1837747277F, 0.1845385292F, 0.1853036062F, 0.1860699558F,
                  0.1868375751F, 0.1876064613F, 0.1883766114F, 0.1891480226F,
                  0.1899206919F, 0.1906946164F, 0.1914697932F, 0.1922462194F,
                  0.1930238919F, 0.1938028079F, 0.1945829643F, 0.1953643583F,
                  0.1961469868F, 0.1969308468F, 0.1977159353F, 0.1985022494F,
                  0.1992897859F, 0.2000785420F, 0.2008685145F, 0.2016597005F,
                  0.2024520968F, 0.2032457005F, 0.2040405084F, 0.2048365175F,
                  0.2056337247F, 0.2064321269F, 0.2072317211F, 0.2080325041F,
                  0.2088344727F, 0.2096376240F, 0.2104419547F, 0.2112474618F,
                  0.2120541420F, 0.2128619923F, 0.2136710094F, 0.2144811902F,
                  0.2152925315F, 0.2161050301F, 0.2169186829F, 0.2177334866F,
                  0.2185494381F, 0.2193665340F, 0.2201847712F, 0.2210041465F,
                  0.2218246565F, 0.2226462981F, 0.2234690680F, 0.2242929629F,
                  0.2251179796F, 0.2259441147F, 0.2267713650F, 0.2275997272F,
                  0.2284291979F, 0.2292597739F, 0.2300914518F, 0.2309242283F,
                  0.2317581001F, 0.2325930638F, 0.2334291160F, 0.2342662534F,
                  0.2351044727F, 0.2359437703F, 0.2367841431F, 0.2376255875F,
                  0.2384681001F, 0.2393116776F, 0.2401563165F, 0.2410020134F,
                  0.2418487649F, 0.2426965675F, 0.2435454178F, 0.2443953122F,
                  0.2452462474F, 0.2460982199F, 0.2469512262F, 0.2478052628F,
                  0.2486603262F, 0.2495164129F, 0.2503735194F, 0.2512316421F,
                  0.2520907776F, 0.2529509222F, 0.2538120726F, 0.2546742250F,
                  0.2555373760F, 0.2564015219F, 0.2572666593F, 0.2581327845F,
                  0.2589998939F, 0.2598679840F, 0.2607370510F, 0.2616070916F,
                  0.2624781019F, 0.2633500783F, 0.2642230173F, 0.2650969152F,
                  0.2659717684F, 0.2668475731F, 0.2677243257F, 0.2686020226F,
                  0.2694806601F, 0.2703602344F, 0.2712407419F, 0.2721221789F,
                  0.2730045417F, 0.2738878265F, 0.2747720297F, 0.2756571474F,
                  0.2765431760F, 0.2774301117F, 0.2783179508F, 0.2792066895F,
                  0.2800963240F, 0.2809868505F, 0.2818782654F, 0.2827705647F,
                  0.2836637447F, 0.2845578016F, 0.2854527315F, 0.2863485307F,
                  0.2872451953F, 0.2881427215F, 0.2890411055F, 0.2899403433F,
                  0.2908404312F, 0.2917413654F, 0.2926431418F, 0.2935457567F,
                  0.2944492061F, 0.2953534863F, 0.2962585932F, 0.2971645230F,
                  0.2980712717F, 0.2989788356F, 0.2998872105F, 0.3007963927F,
                  0.3017063781F, 0.3026171629F, 0.3035287430F, 0.3044411145F,
                  0.3053542736F, 0.3062682161F, 0.3071829381F, 0.3080984356F,
                  0.3090147047F, 0.3099317413F, 0.3108495414F, 0.3117681011F,
                  0.3126874163F, 0.3136074830F, 0.3145282972F, 0.3154498548F,
                  0.3163721517F, 0.3172951841F, 0.3182189477F, 0.3191434385F,
                  0.3200686525F, 0.3209945856F, 0.3219212336F, 0.3228485927F,
                  0.3237766585F, 0.3247054271F, 0.3256348943F, 0.3265650560F,
                  0.3274959081F, 0.3284274465F, 0.3293596671F, 0.3302925657F,
                  0.3312261382F, 0.3321603804F, 0.3330952882F, 0.3340308574F,
                  0.3349670838F, 0.3359039634F, 0.3368414919F, 0.3377796651F,
                  0.3387184789F, 0.3396579290F, 0.3405980113F, 0.3415387216F,
                  0.3424800556F, 0.3434220091F, 0.3443645779F, 0.3453077578F,
                  0.3462515446F, 0.3471959340F, 0.3481409217F, 0.3490865036F,
                  0.3500326754F, 0.3509794328F, 0.3519267715F, 0.3528746873F,
                  0.3538231759F, 0.3547722330F, 0.3557218544F, 0.3566720357F,
                  0.3576227727F, 0.3585740610F, 0.3595258964F, 0.3604782745F,
                  0.3614311910F, 0.3623846417F, 0.3633386221F, 0.3642931280F,
                  0.3652481549F, 0.3662036987F, 0.3671597548F, 0.3681163191F,
                  0.3690733870F, 0.3700309544F, 0.3709890167F, 0.3719475696F,
                  0.3729066089F, 0.3738661299F, 0.3748261285F, 0.3757866002F,
                  0.3767475406F, 0.3777089453F, 0.3786708100F, 0.3796331302F,
                  0.3805959014F, 0.3815591194F, 0.3825227796F, 0.3834868777F,
                  0.3844514093F, 0.3854163698F, 0.3863817549F, 0.3873475601F,
                  0.3883137810F, 0.3892804131F, 0.3902474521F, 0.3912148933F,
                  0.3921827325F, 0.3931509650F, 0.3941195865F, 0.3950885925F,
                  0.3960579785F, 0.3970277400F, 0.3979978725F, 0.3989683716F,
                  0.3999392328F, 0.4009104516F, 0.4018820234F, 0.4028539438F,
                  0.4038262084F, 0.4047988125F, 0.4057717516F, 0.4067450214F,
                  0.4077186172F, 0.4086925345F, 0.4096667688F, 0.4106413155F,
                  0.4116161703F, 0.4125913284F, 0.4135667854F, 0.4145425368F,
                  0.4155185780F, 0.4164949044F, 0.4174715116F, 0.4184483949F,
                  0.4194255498F, 0.4204029718F, 0.4213806563F, 0.4223585987F,
                  0.4233367946F, 0.4243152392F, 0.4252939281F, 0.4262728566F,
                  0.4272520202F, 0.4282314144F, 0.4292110345F, 0.4301908760F,
                  0.4311709343F, 0.4321512047F, 0.4331316828F, 0.4341123639F,
                  0.4350932435F, 0.4360743168F, 0.4370555794F, 0.4380370267F,
                  0.4390186540F, 0.4400004567F, 0.4409824303F, 0.4419645701F,
                  0.4429468716F, 0.4439293300F, 0.4449119409F, 0.4458946996F,
                  0.4468776014F, 0.4478606418F, 0.4488438162F, 0.4498271199F,
                  0.4508105483F, 0.4517940967F, 0.4527777607F, 0.4537615355F,
                  0.4547454165F, 0.4557293991F, 0.4567134786F, 0.4576976505F,
                  0.4586819101F, 0.4596662527F, 0.4606506738F, 0.4616351687F,
                  0.4626197328F, 0.4636043614F, 0.4645890499F, 0.4655737936F,
                  0.4665585880F, 0.4675434284F, 0.4685283101F, 0.4695132286F,
                  0.4704981791F, 0.4714831570F, 0.4724681577F, 0.4734531766F,
                  0.4744382089F, 0.4754232501F, 0.4764082956F, 0.4773933406F,
                  0.4783783806F, 0.4793634108F, 0.4803484267F, 0.4813334237F,
                  0.4823183969F, 0.4833033419F, 0.4842882540F, 0.4852731285F,
                  0.4862579608F, 0.4872427462F, 0.4882274802F, 0.4892121580F,
                  0.4901967751F, 0.4911813267F, 0.4921658083F, 0.4931502151F,
                  0.4941345427F, 0.4951187863F, 0.4961029412F, 0.4970870029F,
                  0.4980709667F, 0.4990548280F, 0.5000385822F, 0.5010222245F,
                  0.5020057505F, 0.5029891553F, 0.5039724345F, 0.5049555834F,
                  0.5059385973F, 0.5069214716F, 0.5079042018F, 0.5088867831F,
                  0.5098692110F, 0.5108514808F, 0.5118335879F, 0.5128155277F,
                  0.5137972956F, 0.5147788869F, 0.5157602971F, 0.5167415215F,
                  0.5177225555F, 0.5187033945F, 0.5196840339F, 0.5206644692F,
                  0.5216446956F, 0.5226247086F, 0.5236045035F, 0.5245840759F,
                  0.5255634211F, 0.5265425344F, 0.5275214114F, 0.5285000474F,
                  0.5294784378F, 0.5304565781F, 0.5314344637F, 0.5324120899F,
                  0.5333894522F, 0.5343665461F, 0.5353433670F, 0.5363199102F,
                  0.5372961713F, 0.5382721457F, 0.5392478287F, 0.5402232159F,
                  0.5411983027F, 0.5421730845F, 0.5431475569F, 0.5441217151F,
                  0.5450955548F, 0.5460690714F, 0.5470422602F, 0.5480151169F,
                  0.5489876368F, 0.5499598155F, 0.5509316484F, 0.5519031310F,
                  0.5528742587F, 0.5538450271F, 0.5548154317F, 0.5557854680F,
                  0.5567551314F, 0.5577244174F, 0.5586933216F, 0.5596618395F,
                  0.5606299665F, 0.5615976983F, 0.5625650302F, 0.5635319580F,
                  0.5644984770F, 0.5654645828F, 0.5664302709F, 0.5673955370F,
                  0.5683603765F, 0.5693247850F, 0.5702887580F, 0.5712522912F,
                  0.5722153800F, 0.5731780200F, 0.5741402069F, 0.5751019362F,
                  0.5760632034F, 0.5770240042F, 0.5779843341F, 0.5789441889F,
                  0.5799035639F, 0.5808624549F, 0.5818208575F, 0.5827787673F,
                  0.5837361800F, 0.5846930910F, 0.5856494961F, 0.5866053910F,
                  0.5875607712F, 0.5885156324F, 0.5894699703F, 0.5904237804F,
                  0.5913770586F, 0.5923298004F, 0.5932820016F, 0.5942336578F,
                  0.5951847646F, 0.5961353179F, 0.5970853132F, 0.5980347464F,
                  0.5989836131F, 0.5999319090F, 0.6008796298F, 0.6018267713F,
                  0.6027733292F, 0.6037192993F, 0.6046646773F, 0.6056094589F,
                  0.6065536400F, 0.6074972162F, 0.6084401833F, 0.6093825372F,
                  0.6103242736F, 0.6112653884F, 0.6122058772F, 0.6131457359F,
                  0.6140849604F, 0.6150235464F, 0.6159614897F, 0.6168987862F,
                  0.6178354318F, 0.6187714223F, 0.6197067535F, 0.6206414213F,
                  0.6215754215F, 0.6225087501F, 0.6234414028F, 0.6243733757F,
                  0.6253046646F, 0.6262352654F, 0.6271651739F, 0.6280943862F,
                  0.6290228982F, 0.6299507057F, 0.6308778048F, 0.6318041913F,
                  0.6327298612F, 0.6336548105F, 0.6345790352F, 0.6355025312F,
                  0.6364252945F, 0.6373473211F, 0.6382686070F, 0.6391891483F,
                  0.6401089409F, 0.6410279808F, 0.6419462642F, 0.6428637869F,
                  0.6437805452F, 0.6446965350F, 0.6456117524F, 0.6465261935F,
                  0.6474398544F, 0.6483527311F, 0.6492648197F, 0.6501761165F,
                  0.6510866174F, 0.6519963186F, 0.6529052162F, 0.6538133064F,
                  0.6547205854F, 0.6556270492F, 0.6565326941F, 0.6574375162F,
                  0.6583415117F, 0.6592446769F, 0.6601470079F, 0.6610485009F,
                  0.6619491521F, 0.6628489578F, 0.6637479143F, 0.6646460177F,
                  0.6655432643F, 0.6664396505F, 0.6673351724F, 0.6682298264F,
                  0.6691236087F, 0.6700165157F, 0.6709085436F, 0.6717996889F,
                  0.6726899478F, 0.6735793167F, 0.6744677918F, 0.6753553697F,
                  0.6762420466F, 0.6771278190F, 0.6780126832F, 0.6788966357F,
                  0.6797796728F, 0.6806617909F, 0.6815429866F, 0.6824232562F,
                  0.6833025961F, 0.6841810030F, 0.6850584731F, 0.6859350031F,
                  0.6868105894F, 0.6876852284F, 0.6885589168F, 0.6894316510F,
                  0.6903034275F, 0.6911742430F, 0.6920440939F, 0.6929129769F,
                  0.6937808884F, 0.6946478251F, 0.6955137837F, 0.6963787606F,
                  0.6972427525F, 0.6981057560F, 0.6989677678F, 0.6998287845F,
                  0.7006888028F, 0.7015478194F, 0.7024058309F, 0.7032628340F,
                  0.7041188254F, 0.7049738019F, 0.7058277601F, 0.7066806969F,
                  0.7075326089F, 0.7083834929F, 0.7092333457F, 0.7100821640F,
                  0.7109299447F, 0.7117766846F, 0.7126223804F, 0.7134670291F,
                  0.7143106273F, 0.7151531721F, 0.7159946602F, 0.7168350885F,
                  0.7176744539F, 0.7185127534F, 0.7193499837F, 0.7201861418F,
                  0.7210212247F, 0.7218552293F, 0.7226881526F, 0.7235199914F,
                  0.7243507428F, 0.7251804039F, 0.7260089715F, 0.7268364426F,
                  0.7276628144F, 0.7284880839F, 0.7293122481F, 0.7301353040F,
                  0.7309572487F, 0.7317780794F, 0.7325977930F, 0.7334163868F,
                  0.7342338579F, 0.7350502033F, 0.7358654202F, 0.7366795059F,
                  0.7374924573F, 0.7383042718F, 0.7391149465F, 0.7399244787F,
                  0.7407328655F, 0.7415401041F, 0.7423461920F, 0.7431511261F,
                  0.7439549040F, 0.7447575227F, 0.7455589797F, 0.7463592723F,
                  0.7471583976F, 0.7479563532F, 0.7487531363F, 0.7495487443F,
                  0.7503431745F, 0.7511364244F, 0.7519284913F, 0.7527193726F,
                  0.7535090658F, 0.7542975683F, 0.7550848776F, 0.7558709910F,
                  0.7566559062F, 0.7574396205F, 0.7582221314F, 0.7590034366F,
                  0.7597835334F, 0.7605624194F, 0.7613400923F, 0.7621165495F,
                  0.7628917886F, 0.7636658072F, 0.7644386030F, 0.7652101735F,
                  0.7659805164F, 0.7667496292F, 0.7675175098F, 0.7682841556F,
                  0.7690495645F, 0.7698137341F, 0.7705766622F, 0.7713383463F,
                  0.7720987844F, 0.7728579741F, 0.7736159132F, 0.7743725994F,
                  0.7751280306F, 0.7758822046F, 0.7766351192F, 0.7773867722F,
                  0.7781371614F, 0.7788862848F, 0.7796341401F, 0.7803807253F,
                  0.7811260383F, 0.7818700769F, 0.7826128392F, 0.7833543230F,
                  0.7840945263F, 0.7848334471F, 0.7855710833F, 0.7863074330F,
                  0.7870424941F, 0.7877762647F, 0.7885087428F, 0.7892399264F,
                  0.7899698137F, 0.7906984026F, 0.7914256914F, 0.7921516780F,
                  0.7928763607F, 0.7935997375F, 0.7943218065F, 0.7950425661F,
                  0.7957620142F, 0.7964801492F, 0.7971969692F, 0.7979124724F,
                  0.7986266570F, 0.7993395214F, 0.8000510638F, 0.8007612823F,
                  0.8014701754F, 0.8021777413F, 0.8028839784F, 0.8035888849F,
                  0.8042924592F, 0.8049946997F, 0.8056956048F, 0.8063951727F,
                  0.8070934020F, 0.8077902910F, 0.8084858381F, 0.8091800419F,
                  0.8098729007F, 0.8105644130F, 0.8112545774F, 0.8119433922F,
                  0.8126308561F, 0.8133169676F, 0.8140017251F, 0.8146851272F,
                  0.8153671726F, 0.8160478598F, 0.8167271874F, 0.8174051539F,
                  0.8180817582F, 0.8187569986F, 0.8194308741F, 0.8201033831F,
                  0.8207745244F, 0.8214442966F, 0.8221126986F, 0.8227797290F,
                  0.8234453865F, 0.8241096700F, 0.8247725781F, 0.8254341097F,
                  0.8260942636F, 0.8267530385F, 0.8274104334F, 0.8280664470F,
                  0.8287210782F, 0.8293743259F, 0.8300261889F, 0.8306766662F,
                  0.8313257566F, 0.8319734591F, 0.8326197727F, 0.8332646963F,
                  0.8339082288F, 0.8345503692F, 0.8351911167F, 0.8358304700F,
                  0.8364684284F, 0.8371049907F, 0.8377401562F, 0.8383739238F,
                  0.8390062927F, 0.8396372618F, 0.8402668305F, 0.8408949977F,
                  0.8415217626F, 0.8421471245F, 0.8427710823F, 0.8433936354F,
                  0.8440147830F, 0.8446345242F, 0.8452528582F, 0.8458697844F,
                  0.8464853020F, 0.8470994102F, 0.8477121084F, 0.8483233958F,
                  0.8489332718F, 0.8495417356F, 0.8501487866F, 0.8507544243F,
                  0.8513586479F, 0.8519614568F, 0.8525628505F, 0.8531628283F,
                  0.8537613897F, 0.8543585341F, 0.8549542611F, 0.8555485699F,
                  0.8561414603F, 0.8567329315F, 0.8573229832F, 0.8579116149F,
                  0.8584988262F, 0.8590846165F, 0.8596689855F, 0.8602519327F,
                  0.8608334577F, 0.8614135603F, 0.8619922399F, 0.8625694962F,
                  0.8631453289F, 0.8637197377F, 0.8642927222F, 0.8648642821F,
                  0.8654344172F, 0.8660031272F, 0.8665704118F, 0.8671362708F,
                  0.8677007039F, 0.8682637109F, 0.8688252917F, 0.8693854460F,
                  0.8699441737F, 0.8705014745F, 0.8710573485F, 0.8716117953F,
                  0.8721648150F, 0.8727164073F, 0.8732665723F, 0.8738153098F,
                  0.8743626197F, 0.8749085021F, 0.8754529569F, 0.8759959840F,
                  0.8765375835F, 0.8770777553F, 0.8776164996F, 0.8781538162F,
                  0.8786897054F, 0.8792241670F, 0.8797572013F, 0.8802888082F,
                  0.8808189880F, 0.8813477407F, 0.8818750664F, 0.8824009653F,
                  0.8829254375F, 0.8834484833F, 0.8839701028F, 0.8844902961F,
                  0.8850090636F, 0.8855264054F, 0.8860423218F, 0.8865568131F,
                  0.8870698794F, 0.8875815212F, 0.8880917386F, 0.8886005319F,
                  0.8891079016F, 0.8896138479F, 0.8901183712F, 0.8906214719F,
                  0.8911231503F, 0.8916234067F, 0.8921222417F, 0.8926196556F,
                  0.8931156489F, 0.8936102219F, 0.8941033752F, 0.8945951092F,
                  0.8950854244F, 0.8955743212F, 0.8960618003F, 0.8965478621F,
                  0.8970325071F, 0.8975157359F, 0.8979975490F, 0.8984779471F,
                  0.8989569307F, 0.8994345004F, 0.8999106568F, 0.9003854005F,
                  0.9008587323F, 0.9013306526F, 0.9018011623F, 0.9022702619F,
                  0.9027379521F, 0.9032042337F, 0.9036691074F, 0.9041325739F,
                  0.9045946339F, 0.9050552882F, 0.9055145376F, 0.9059723828F,
                  0.9064288246F, 0.9068838638F, 0.9073375013F, 0.9077897379F,
                  0.9082405743F, 0.9086900115F, 0.9091380503F, 0.9095846917F,
                  0.9100299364F, 0.9104737854F, 0.9109162397F, 0.9113573001F,
                  0.9117969675F, 0.9122352430F, 0.9126721275F, 0.9131076219F,
                  0.9135417273F, 0.9139744447F, 0.9144057750F, 0.9148357194F,
                  0.9152642787F, 0.9156914542F, 0.9161172468F, 0.9165416576F,
                  0.9169646877F, 0.9173863382F, 0.9178066102F, 0.9182255048F,
                  0.9186430232F, 0.9190591665F, 0.9194739359F, 0.9198873324F,
                  0.9202993574F, 0.9207100120F, 0.9211192973F, 0.9215272147F,
                  0.9219337653F, 0.9223389504F, 0.9227427713F, 0.9231452290F,
                  0.9235463251F, 0.9239460607F, 0.9243444371F, 0.9247414557F,
                  0.9251371177F, 0.9255314245F, 0.9259243774F, 0.9263159778F,
                  0.9267062270F, 0.9270951264F, 0.9274826774F, 0.9278688814F,
                  0.9282537398F, 0.9286372540F, 0.9290194254F, 0.9294002555F,
                  0.9297797458F, 0.9301578976F, 0.9305347125F, 0.9309101919F,
                  0.9312843373F, 0.9316571503F, 0.9320286323F, 0.9323987849F,
                  0.9327676097F, 0.9331351080F, 0.9335012816F, 0.9338661320F,
                  0.9342296607F, 0.9345918694F, 0.9349527596F, 0.9353123330F,
                  0.9356705911F, 0.9360275357F, 0.9363831683F, 0.9367374905F,
                  0.9370905042F, 0.9374422108F, 0.9377926122F, 0.9381417099F,
                  0.9384895057F, 0.9388360014F, 0.9391811985F, 0.9395250989F,
                  0.9398677043F, 0.9402090165F, 0.9405490371F, 0.9408877680F,
                  0.9412252110F, 0.9415613678F, 0.9418962402F, 0.9422298301F,
                  0.9425621392F, 0.9428931695F, 0.9432229226F, 0.9435514005F,
                  0.9438786050F, 0.9442045381F, 0.9445292014F, 0.9448525971F,
                  0.9451747268F, 0.9454955926F, 0.9458151963F, 0.9461335399F,
                  0.9464506253F, 0.9467664545F, 0.9470810293F, 0.9473943517F,
                  0.9477064238F, 0.9480172474F, 0.9483268246F, 0.9486351573F,
                  0.9489422475F, 0.9492480973F, 0.9495527087F, 0.9498560837F,
                  0.9501582243F, 0.9504591325F, 0.9507588105F, 0.9510572603F,
                  0.9513544839F, 0.9516504834F, 0.9519452609F, 0.9522388186F,
                  0.9525311584F, 0.9528222826F, 0.9531121932F, 0.9534008923F,
                  0.9536883821F, 0.9539746647F, 0.9542597424F, 0.9545436171F,
                  0.9548262912F, 0.9551077667F, 0.9553880459F, 0.9556671309F,
                  0.9559450239F, 0.9562217272F, 0.9564972429F, 0.9567715733F,
                  0.9570447206F, 0.9573166871F, 0.9575874749F, 0.9578570863F,
                  0.9581255236F, 0.9583927890F, 0.9586588849F, 0.9589238134F,
                  0.9591875769F, 0.9594501777F, 0.9597116180F, 0.9599719003F,
                  0.9602310267F, 0.9604889995F, 0.9607458213F, 0.9610014942F,
                  0.9612560206F, 0.9615094028F, 0.9617616433F, 0.9620127443F,
                  0.9622627083F, 0.9625115376F, 0.9627592345F, 0.9630058016F,
                  0.9632512411F, 0.9634955555F, 0.9637387471F, 0.9639808185F,
                  0.9642217720F, 0.9644616100F, 0.9647003349F, 0.9649379493F,
                  0.9651744556F, 0.9654098561F, 0.9656441534F, 0.9658773499F,
                  0.9661094480F, 0.9663404504F, 0.9665703593F, 0.9667991774F,
                  0.9670269071F, 0.9672535509F, 0.9674791114F, 0.9677035909F,
                  0.9679269921F, 0.9681493174F, 0.9683705694F, 0.9685907506F,
                  0.9688098636F, 0.9690279108F, 0.9692448948F, 0.9694608182F,
                  0.9696756836F, 0.9698894934F, 0.9701022503F, 0.9703139569F,
                  0.9705246156F, 0.9707342291F, 0.9709428000F, 0.9711503309F,
                  0.9713568243F, 0.9715622829F, 0.9717667093F, 0.9719701060F,
                  0.9721724757F, 0.9723738210F, 0.9725741446F, 0.9727734490F,
                  0.9729717369F, 0.9731690109F, 0.9733652737F, 0.9735605279F,
                  0.9737547762F, 0.9739480212F, 0.9741402656F, 0.9743315120F,
                  0.9745217631F, 0.9747110216F, 0.9748992901F, 0.9750865714F,
                  0.9752728681F, 0.9754581829F, 0.9756425184F, 0.9758258775F,
                  0.9760082627F, 0.9761896768F, 0.9763701224F, 0.9765496024F,
                  0.9767281193F, 0.9769056760F, 0.9770822751F, 0.9772579193F,
                  0.9774326114F, 0.9776063542F, 0.9777791502F, 0.9779510023F,
                  0.9781219133F, 0.9782918858F, 0.9784609226F, 0.9786290264F,
                  0.9787962000F, 0.9789624461F, 0.9791277676F, 0.9792921671F,
                  0.9794556474F, 0.9796182113F, 0.9797798615F, 0.9799406009F,
                  0.9801004321F, 0.9802593580F, 0.9804173813F, 0.9805745049F,
                  0.9807307314F, 0.9808860637F, 0.9810405046F, 0.9811940568F,
                  0.9813467232F, 0.9814985065F, 0.9816494095F, 0.9817994351F,
                  0.9819485860F, 0.9820968650F, 0.9822442750F, 0.9823908186F,
                  0.9825364988F, 0.9826813184F, 0.9828252801F, 0.9829683868F,
                  0.9831106413F, 0.9832520463F, 0.9833926048F, 0.9835323195F,
                  0.9836711932F, 0.9838092288F, 0.9839464291F, 0.9840827969F,
                  0.9842183351F, 0.9843530464F, 0.9844869337F, 0.9846199998F,
                  0.9847522475F, 0.9848836798F, 0.9850142993F, 0.9851441090F,
                  0.9852731117F, 0.9854013101F, 0.9855287073F, 0.9856553058F,
                  0.9857811087F, 0.9859061188F, 0.9860303388F, 0.9861537717F,
                  0.9862764202F, 0.9863982872F, 0.9865193756F, 0.9866396882F,
                  0.9867592277F, 0.9868779972F, 0.9869959993F, 0.9871132370F,
                  0.9872297131F, 0.9873454304F, 0.9874603918F, 0.9875746001F,
                  0.9876880581F, 0.9878007688F, 0.9879127348F, 0.9880239592F,
                  0.9881344447F, 0.9882441941F, 0.9883532104F, 0.9884614962F,
                  0.9885690546F, 0.9886758883F, 0.9887820001F, 0.9888873930F,
                  0.9889920697F, 0.9890960331F, 0.9891992859F, 0.9893018312F,
                  0.9894036716F, 0.9895048100F, 0.9896052493F, 0.9897049923F,
                  0.9898040418F, 0.9899024006F, 0.9900000717F, 0.9900970577F,
                  0.9901933616F, 0.9902889862F, 0.9903839343F, 0.9904782087F,
                  0.9905718122F, 0.9906647477F, 0.9907570180F, 0.9908486259F,
                  0.9909395742F, 0.9910298658F, 0.9911195034F, 0.9912084899F,
                  0.9912968281F, 0.9913845208F, 0.9914715708F, 0.9915579810F,
                  0.9916437540F, 0.9917288928F, 0.9918134001F, 0.9918972788F,
                  0.9919805316F, 0.9920631613F, 0.9921451707F, 0.9922265626F,
                  0.9923073399F, 0.9923875052F, 0.9924670615F, 0.9925460114F,
                  0.9926243577F, 0.9927021033F, 0.9927792508F, 0.9928558032F,
                  0.9929317631F, 0.9930071333F, 0.9930819167F, 0.9931561158F,
                  0.9932297337F, 0.9933027728F, 0.9933752362F, 0.9934471264F,
                  0.9935184462F, 0.9935891985F, 0.9936593859F, 0.9937290112F,
                  0.9937980771F, 0.9938665864F, 0.9939345418F, 0.9940019460F,
                  0.9940688018F, 0.9941351118F, 0.9942008789F, 0.9942661057F,
                  0.9943307950F, 0.9943949494F, 0.9944585717F, 0.9945216645F,
                  0.9945842307F, 0.9946462728F, 0.9947077936F, 0.9947687957F,
                  0.9948292820F, 0.9948892550F, 0.9949487174F, 0.9950076719F,
                  0.9950661212F, 0.9951240679F, 0.9951815148F, 0.9952384645F,
                  0.9952949196F, 0.9953508828F, 0.9954063568F, 0.9954613442F,
                  0.9955158476F, 0.9955698697F, 0.9956234132F, 0.9956764806F,
                  0.9957290746F, 0.9957811978F, 0.9958328528F, 0.9958840423F,
                  0.9959347688F, 0.9959850351F, 0.9960348435F, 0.9960841969F,
                  0.9961330977F, 0.9961815486F, 0.9962295521F, 0.9962771108F,
                  0.9963242274F, 0.9963709043F, 0.9964171441F, 0.9964629494F,
                  0.9965083228F, 0.9965532668F, 0.9965977840F, 0.9966418768F,
                  0.9966855479F, 0.9967287998F, 0.9967716350F, 0.9968140559F,
                  0.9968560653F, 0.9968976655F, 0.9969388591F, 0.9969796485F,
                  0.9970200363F, 0.9970600250F, 0.9970996170F, 0.9971388149F,
                  0.9971776211F, 0.9972160380F, 0.9972540683F, 0.9972917142F,
                  0.9973289783F, 0.9973658631F, 0.9974023709F, 0.9974385042F,
                  0.9974742655F, 0.9975096571F, 0.9975446816F, 0.9975793413F,
                  0.9976136386F, 0.9976475759F, 0.9976811557F, 0.9977143803F,
                  0.9977472521F, 0.9977797736F, 0.9978119470F, 0.9978437748F,
                  0.9978752593F, 0.9979064029F, 0.9979372079F, 0.9979676768F,
                  0.9979978117F, 0.9980276151F, 0.9980570893F, 0.9980862367F,
                  0.9981150595F, 0.9981435600F, 0.9981717406F, 0.9981996035F,
                  0.9982271511F, 0.9982543856F, 0.9982813093F, 0.9983079246F,
                  0.9983342336F, 0.9983602386F, 0.9983859418F, 0.9984113456F,
                  0.9984364522F, 0.9984612638F, 0.9984857825F, 0.9985100108F,
                  0.9985339507F, 0.9985576044F, 0.9985809743F, 0.9986040624F,
                  0.9986268710F, 0.9986494022F, 0.9986716583F, 0.9986936413F,
                  0.9987153535F, 0.9987367969F, 0.9987579738F, 0.9987788864F,
                  0.9987995366F, 0.9988199267F, 0.9988400587F, 0.9988599348F,
                  0.9988795572F, 0.9988989278F, 0.9989180487F, 0.9989369222F,
                  0.9989555501F, 0.9989739347F, 0.9989920780F, 0.9990099820F,
                  0.9990276487F, 0.9990450803F, 0.9990622787F, 0.9990792460F,
                  0.9990959841F, 0.9991124952F, 0.9991287812F, 0.9991448440F,
                  0.9991606858F, 0.9991763084F, 0.9991917139F, 0.9992069042F,
                  0.9992218813F, 0.9992366471F, 0.9992512035F, 0.9992655525F,
                  0.9992796961F, 0.9992936361F, 0.9993073744F, 0.9993209131F,
                  0.9993342538F, 0.9993473987F, 0.9993603494F, 0.9993731080F,
                  0.9993856762F, 0.9993980559F, 0.9994102490F, 0.9994222573F,
                  0.9994340827F, 0.9994457269F, 0.9994571918F, 0.9994684793F,
                  0.9994795910F, 0.9994905288F, 0.9995012945F, 0.9995118898F,
                  0.9995223165F, 0.9995325765F, 0.9995426713F, 0.9995526029F,
                  0.9995623728F, 0.9995719829F, 0.9995814349F, 0.9995907304F,
                  0.9995998712F, 0.9996088590F, 0.9996176954F, 0.9996263821F,
                  0.9996349208F, 0.9996433132F, 0.9996515609F, 0.9996596656F,
                  0.9996676288F, 0.9996754522F, 0.9996831375F, 0.9996906862F,
                  0.9996981000F, 0.9997053804F, 0.9997125290F, 0.9997195474F,
                  0.9997264371F, 0.9997331998F, 0.9997398369F, 0.9997463500F,
                  0.9997527406F, 0.9997590103F, 0.9997651606F, 0.9997711930F,
                  0.9997771089F, 0.9997829098F, 0.9997885973F, 0.9997941728F,
                  0.9997996378F, 0.9998049936F, 0.9998102419F, 0.9998153839F,
                  0.9998204211F, 0.9998253550F, 0.9998301868F, 0.9998349182F,
                  0.9998395503F, 0.9998440847F, 0.9998485226F, 0.9998528654F,
                  0.9998571146F, 0.9998612713F, 0.9998653370F, 0.9998693130F,
                  0.9998732007F, 0.9998770012F, 0.9998807159F, 0.9998843461F,
                  0.9998878931F, 0.9998913581F, 0.9998947424F, 0.9998980473F,
                  0.9999012740F, 0.9999044237F, 0.9999074976F, 0.9999104971F,
                  0.9999134231F, 0.9999162771F, 0.9999190601F, 0.9999217733F,
                  0.9999244179F, 0.9999269950F, 0.9999295058F, 0.9999319515F,
                  0.9999343332F, 0.9999366519F, 0.9999389088F, 0.9999411050F,
                  0.9999432416F, 0.9999453196F, 0.9999473402F, 0.9999493044F,
                  0.9999512132F, 0.9999530677F, 0.9999548690F, 0.9999566180F,
                  0.9999583157F, 0.9999599633F, 0.9999615616F, 0.9999631116F,
                  0.9999646144F, 0.9999660709F, 0.9999674820F, 0.9999688487F,
                  0.9999701719F, 0.9999714526F, 0.9999726917F, 0.9999738900F,
                  0.9999750486F, 0.9999761682F, 0.9999772497F, 0.9999782941F,
                  0.9999793021F, 0.9999802747F, 0.9999812126F, 0.9999821167F,
                  0.9999829878F, 0.9999838268F, 0.9999846343F, 0.9999854113F,
                  0.9999861584F, 0.9999868765F, 0.9999875664F, 0.9999882287F,
                  0.9999888642F, 0.9999894736F, 0.9999900577F, 0.9999906172F,
                  0.9999911528F, 0.9999916651F, 0.9999921548F, 0.9999926227F,
                  0.9999930693F, 0.9999934954F, 0.9999939015F, 0.9999942883F,
                  0.9999946564F, 0.9999950064F, 0.9999953390F, 0.9999956547F,
                  0.9999959541F, 0.9999962377F, 0.9999965062F, 0.9999967601F,
                  0.9999969998F, 0.9999972260F, 0.9999974392F, 0.9999976399F,
                  0.9999978285F, 0.9999980056F, 0.9999981716F, 0.9999983271F,
                  0.9999984724F, 0.9999986081F, 0.9999987345F, 0.9999988521F,
                  0.9999989613F, 0.9999990625F, 0.9999991562F, 0.9999992426F,
                  0.9999993223F, 0.9999993954F, 0.9999994625F, 0.9999995239F,
                  0.9999995798F, 0.9999996307F, 0.9999996768F, 0.9999997184F,
                  0.9999997559F, 0.9999997895F, 0.9999998195F, 0.9999998462F,
                  0.9999998698F, 0.9999998906F, 0.9999999088F, 0.9999999246F,
                  0.9999999383F, 0.9999999500F, 0.9999999600F, 0.9999999684F,
                  0.9999999754F, 0.9999999811F, 0.9999999858F, 0.9999999896F,
                  0.9999999925F, 0.9999999948F, 0.9999999965F, 0.9999999978F,
                  0.9999999986F, 0.9999999992F, 0.9999999996F, 0.9999999998F,
                  0.9999999999F, 1.0000000000F, 1.0000000000F, 1.0000000000F,
                };
                
                static const float vwin8192[4096] = {
                  0.0000000578F, 0.0000005198F, 0.0000014438F, 0.0000028299F,
                  0.0000046780F, 0.0000069882F, 0.0000097604F, 0.0000129945F,
                  0.0000166908F, 0.0000208490F, 0.0000254692F, 0.0000305515F,
                  0.0000360958F, 0.0000421021F, 0.0000485704F, 0.0000555006F,
                  0.0000628929F, 0.0000707472F, 0.0000790635F, 0.0000878417F,
                  0.0000970820F, 0.0001067842F, 0.0001169483F, 0.0001275744F,
                  0.0001386625F, 0.0001502126F, 0.0001622245F, 0.0001746984F,
                  0.0001876343F, 0.0002010320F, 0.0002148917F, 0.0002292132F,
                  0.0002439967F, 0.0002592421F, 0.0002749493F, 0.0002911184F,
                  0.0003077493F, 0.0003248421F, 0.0003423967F, 0.0003604132F,
                  0.0003788915F, 0.0003978316F, 0.0004172335F, 0.0004370971F,
                  0.0004574226F, 0.0004782098F, 0.0004994587F, 0.0005211694F,
                  0.0005433418F, 0.0005659759F, 0.0005890717F, 0.0006126292F,
                  0.0006366484F, 0.0006611292F, 0.0006860716F, 0.0007114757F,
                  0.0007373414F, 0.0007636687F, 0.0007904576F, 0.0008177080F,
                  0.0008454200F, 0.0008735935F, 0.0009022285F, 0.0009313250F,
                  0.0009608830F, 0.0009909025F, 0.0010213834F, 0.0010523257F,
                  0.0010837295F, 0.0011155946F, 0.0011479211F, 0.0011807090F,
                  0.0012139582F, 0.0012476687F, 0.0012818405F, 0.0013164736F,
                  0.0013515679F, 0.0013871235F, 0.0014231402F, 0.0014596182F,
                  0.0014965573F, 0.0015339576F, 0.0015718190F, 0.0016101415F,
                  0.0016489251F, 0.0016881698F, 0.0017278754F, 0.0017680421F,
                  0.0018086698F, 0.0018497584F, 0.0018913080F, 0.0019333185F,
                  0.0019757898F, 0.0020187221F, 0.0020621151F, 0.0021059690F,
                  0.0021502837F, 0.0021950591F, 0.0022402953F, 0.0022859921F,
                  0.0023321497F, 0.0023787679F, 0.0024258467F, 0.0024733861F,
                  0.0025213861F, 0.0025698466F, 0.0026187676F, 0.0026681491F,
                  0.0027179911F, 0.0027682935F, 0.0028190562F, 0.0028702794F,
                  0.0029219628F, 0.0029741066F, 0.0030267107F, 0.0030797749F,
                  0.0031332994F, 0.0031872841F, 0.0032417289F, 0.0032966338F,
                  0.0033519988F, 0.0034078238F, 0.0034641089F, 0.0035208539F,
                  0.0035780589F, 0.0036357237F, 0.0036938485F, 0.0037524331F,
                  0.0038114775F, 0.0038709817F, 0.0039309456F, 0.0039913692F,
                  0.0040522524F, 0.0041135953F, 0.0041753978F, 0.0042376599F,
                  0.0043003814F, 0.0043635624F, 0.0044272029F, 0.0044913028F,
                  0.0045558620F, 0.0046208806F, 0.0046863585F, 0.0047522955F,
                  0.0048186919F, 0.0048855473F, 0.0049528619F, 0.0050206356F,
                  0.0050888684F, 0.0051575601F, 0.0052267108F, 0.0052963204F,
                  0.0053663890F, 0.0054369163F, 0.0055079025F, 0.0055793474F,
                  0.0056512510F, 0.0057236133F, 0.0057964342F, 0.0058697137F,
                  0.0059434517F, 0.0060176482F, 0.0060923032F, 0.0061674166F,
                  0.0062429883F, 0.0063190183F, 0.0063955066F, 0.0064724532F,
                  0.0065498579F, 0.0066277207F, 0.0067060416F, 0.0067848205F,
                  0.0068640575F, 0.0069437523F, 0.0070239051F, 0.0071045157F,
                  0.0071855840F, 0.0072671102F, 0.0073490940F, 0.0074315355F,
                  0.0075144345F, 0.0075977911F, 0.0076816052F, 0.0077658768F,
                  0.0078506057F, 0.0079357920F, 0.0080214355F, 0.0081075363F,
                  0.0081940943F, 0.0082811094F, 0.0083685816F, 0.0084565108F,
                  0.0085448970F, 0.0086337401F, 0.0087230401F, 0.0088127969F,
                  0.0089030104F, 0.0089936807F, 0.0090848076F, 0.0091763911F,
                  0.0092684311F, 0.0093609276F, 0.0094538805F, 0.0095472898F,
                  0.0096411554F, 0.0097354772F, 0.0098302552F, 0.0099254894F,
                  0.0100211796F, 0.0101173259F, 0.0102139281F, 0.0103109863F,
                  0.0104085002F, 0.0105064700F, 0.0106048955F, 0.0107037766F,
                  0.0108031133F, 0.0109029056F, 0.0110031534F, 0.0111038565F,
                  0.0112050151F, 0.0113066289F, 0.0114086980F, 0.0115112222F,
                  0.0116142015F, 0.0117176359F, 0.0118215252F, 0.0119258695F,
                  0.0120306686F, 0.0121359225F, 0.0122416312F, 0.0123477944F,
                  0.0124544123F, 0.0125614847F, 0.0126690116F, 0.0127769928F,
                  0.0128854284F, 0.0129943182F, 0.0131036623F, 0.0132134604F,
                  0.0133237126F, 0.0134344188F, 0.0135455790F, 0.0136571929F,
                  0.0137692607F, 0.0138817821F, 0.0139947572F, 0.0141081859F,
                  0.0142220681F, 0.0143364037F, 0.0144511927F, 0.0145664350F,
                  0.0146821304F, 0.0147982791F, 0.0149148808F, 0.0150319355F,
                  0.0151494431F, 0.0152674036F, 0.0153858168F, 0.0155046828F,
                  0.0156240014F, 0.0157437726F, 0.0158639962F, 0.0159846723F,
                  0.0161058007F, 0.0162273814F, 0.0163494142F, 0.0164718991F,
                  0.0165948361F, 0.0167182250F, 0.0168420658F, 0.0169663584F,
                  0.0170911027F, 0.0172162987F, 0.0173419462F, 0.0174680452F,
                  0.0175945956F, 0.0177215974F, 0.0178490504F, 0.0179769545F,
                  0.0181053098F, 0.0182341160F, 0.0183633732F, 0.0184930812F,
                  0.0186232399F, 0.0187538494F, 0.0188849094F, 0.0190164200F,
                  0.0191483809F, 0.0192807923F, 0.0194136539F, 0.0195469656F,
                  0.0196807275F, 0.0198149394F, 0.0199496012F, 0.0200847128F,
                  0.0202202742F, 0.0203562853F, 0.0204927460F, 0.0206296561F,
                  0.0207670157F, 0.0209048245F, 0.0210430826F, 0.0211817899F,
                  0.0213209462F, 0.0214605515F, 0.0216006057F, 0.0217411086F,
                  0.0218820603F, 0.0220234605F, 0.0221653093F, 0.0223076066F,
                  0.0224503521F, 0.0225935459F, 0.0227371879F, 0.0228812779F,
                  0.0230258160F, 0.0231708018F, 0.0233162355F, 0.0234621169F,
                  0.0236084459F, 0.0237552224F, 0.0239024462F, 0.0240501175F,
                  0.0241982359F, 0.0243468015F, 0.0244958141F, 0.0246452736F,
                  0.0247951800F, 0.0249455331F, 0.0250963329F, 0.0252475792F,
                  0.0253992720F, 0.0255514111F, 0.0257039965F, 0.0258570281F,
                  0.0260105057F, 0.0261644293F, 0.0263187987F, 0.0264736139F,
                  0.0266288747F, 0.0267845811F, 0.0269407330F, 0.0270973302F,
                  0.0272543727F, 0.0274118604F, 0.0275697930F, 0.0277281707F,
                  0.0278869932F, 0.0280462604F, 0.0282059723F, 0.0283661287F,
                  0.0285267295F, 0.0286877747F, 0.0288492641F, 0.0290111976F,
                  0.0291735751F, 0.0293363965F, 0.0294996617F, 0.0296633706F,
                  0.0298275231F, 0.0299921190F, 0.0301571583F, 0.0303226409F,
                  0.0304885667F, 0.0306549354F, 0.0308217472F, 0.0309890017F,
                  0.0311566989F, 0.0313248388F, 0.0314934211F, 0.0316624459F,
                  0.0318319128F, 0.0320018220F, 0.0321721732F, 0.0323429663F,
                  0.0325142013F, 0.0326858779F, 0.0328579962F, 0.0330305559F,
                  0.0332035570F, 0.0333769994F, 0.0335508829F, 0.0337252074F,
                  0.0338999728F, 0.0340751790F, 0.0342508259F, 0.0344269134F,
                  0.0346034412F, 0.0347804094F, 0.0349578178F, 0.0351356663F,
                  0.0353139548F, 0.0354926831F, 0.0356718511F, 0.0358514588F,
                  0.0360315059F, 0.0362119924F, 0.0363929182F, 0.0365742831F,
                  0.0367560870F, 0.0369383297F, 0.0371210113F, 0.0373041315F,
                  0.0374876902F, 0.0376716873F, 0.0378561226F, 0.0380409961F,
                  0.0382263077F, 0.0384120571F, 0.0385982443F, 0.0387848691F,
                  0.0389719315F, 0.0391594313F, 0.0393473683F, 0.0395357425F,
                  0.0397245537F, 0.0399138017F, 0.0401034866F, 0.0402936080F,
                  0.0404841660F, 0.0406751603F, 0.0408665909F, 0.0410584576F,
                  0.0412507603F, 0.0414434988F, 0.0416366731F, 0.0418302829F,
                  0.0420243282F, 0.0422188088F, 0.0424137246F, 0.0426090755F,
                  0.0428048613F, 0.0430010819F, 0.0431977371F, 0.0433948269F,
                  0.0435923511F, 0.0437903095F, 0.0439887020F, 0.0441875285F,
                  0.0443867889F, 0.0445864830F, 0.0447866106F, 0.0449871717F,
                  0.0451881661F, 0.0453895936F, 0.0455914542F, 0.0457937477F,
                  0.0459964738F, 0.0461996326F, 0.0464032239F, 0.0466072475F,
                  0.0468117032F, 0.0470165910F, 0.0472219107F, 0.0474276622F,
                  0.0476338452F, 0.0478404597F, 0.0480475056F, 0.0482549827F,
                  0.0484628907F, 0.0486712297F, 0.0488799994F, 0.0490891998F,
                  0.0492988306F, 0.0495088917F, 0.0497193830F, 0.0499303043F,
                  0.0501416554F, 0.0503534363F, 0.0505656468F, 0.0507782867F,
                  0.0509913559F, 0.0512048542F, 0.0514187815F, 0.0516331376F,
                  0.0518479225F, 0.0520631358F, 0.0522787775F, 0.0524948475F,
                  0.0527113455F, 0.0529282715F, 0.0531456252F, 0.0533634066F,
                  0.0535816154F, 0.0538002515F, 0.0540193148F, 0.0542388051F,
                  0.0544587222F, 0.0546790660F, 0.0548998364F, 0.0551210331F,
                  0.0553426561F, 0.0555647051F, 0.0557871801F, 0.0560100807F,
                  0.0562334070F, 0.0564571587F, 0.0566813357F, 0.0569059378F,
                  0.0571309649F, 0.0573564168F, 0.0575822933F, 0.0578085942F,
                  0.0580353195F, 0.0582624689F, 0.0584900423F, 0.0587180396F,
                  0.0589464605F, 0.0591753049F, 0.0594045726F, 0.0596342635F,
                  0.0598643774F, 0.0600949141F, 0.0603258735F, 0.0605572555F,
                  0.0607890597F, 0.0610212862F, 0.0612539346F, 0.0614870049F,
                  0.0617204968F, 0.0619544103F, 0.0621887451F, 0.0624235010F,
                  0.0626586780F, 0.0628942758F, 0.0631302942F, 0.0633667331F,
                  0.0636035923F, 0.0638408717F, 0.0640785710F, 0.0643166901F,
                  0.0645552288F, 0.0647941870F, 0.0650335645F, 0.0652733610F,
                  0.0655135765F, 0.0657542108F, 0.0659952636F, 0.0662367348F,
                  0.0664786242F, 0.0667209316F, 0.0669636570F, 0.0672068000F,
                  0.0674503605F, 0.0676943384F, 0.0679387334F, 0.0681835454F,
                  0.0684287742F, 0.0686744196F, 0.0689204814F, 0.0691669595F,
                  0.0694138536F, 0.0696611637F, 0.0699088894F, 0.0701570307F,
                  0.0704055873F, 0.0706545590F, 0.0709039458F, 0.0711537473F,
                  0.0714039634F, 0.0716545939F, 0.0719056387F, 0.0721570975F,
                  0.0724089702F, 0.0726612565F, 0.0729139563F, 0.0731670694F,
                  0.0734205956F, 0.0736745347F, 0.0739288866F, 0.0741836510F,
                  0.0744388277F, 0.0746944166F, 0.0749504175F, 0.0752068301F,
                  0.0754636543F, 0.0757208899F, 0.0759785367F, 0.0762365946F,
                  0.0764950632F, 0.0767539424F, 0.0770132320F, 0.0772729319F,
                  0.0775330418F, 0.0777935616F, 0.0780544909F, 0.0783158298F,
                  0.0785775778F, 0.0788397349F, 0.0791023009F, 0.0793652755F,
                  0.0796286585F, 0.0798924498F, 0.0801566492F, 0.0804212564F,
                  0.0806862712F, 0.0809516935F, 0.0812175231F, 0.0814837597F,
                  0.0817504031F, 0.0820174532F, 0.0822849097F, 0.0825527724F,
                  0.0828210412F, 0.0830897158F, 0.0833587960F, 0.0836282816F,
                  0.0838981724F, 0.0841684682F, 0.0844391688F, 0.0847102740F,
                  0.0849817835F, 0.0852536973F, 0.0855260150F, 0.0857987364F,
                  0.0860718614F, 0.0863453897F, 0.0866193211F, 0.0868936554F,
                  0.0871683924F, 0.0874435319F, 0.0877190737F, 0.0879950175F,
                  0.0882713632F, 0.0885481105F, 0.0888252592F, 0.0891028091F,
                  0.0893807600F, 0.0896591117F, 0.0899378639F, 0.0902170165F,
                  0.0904965692F, 0.0907765218F, 0.0910568740F, 0.0913376258F,
                  0.0916187767F, 0.0919003268F, 0.0921822756F, 0.0924646230F,
                  0.0927473687F, 0.0930305126F, 0.0933140545F, 0.0935979940F,
                  0.0938823310F, 0.0941670653F, 0.0944521966F, 0.0947377247F,
                  0.0950236494F, 0.0953099704F, 0.0955966876F, 0.0958838007F,
                  0.0961713094F, 0.0964592136F, 0.0967475131F, 0.0970362075F,
                  0.0973252967F, 0.0976147805F, 0.0979046585F, 0.0981949307F,
                  0.0984855967F, 0.0987766563F, 0.0990681093F, 0.0993599555F,
                  0.0996521945F, 0.0999448263F, 0.1002378506F, 0.1005312671F,
                  0.1008250755F, 0.1011192757F, 0.1014138675F, 0.1017088505F,
                  0.1020042246F, 0.1022999895F, 0.1025961450F, 0.1028926909F,
                  0.1031896268F, 0.1034869526F, 0.1037846680F, 0.1040827729F,
                  0.1043812668F, 0.1046801497F, 0.1049794213F, 0.1052790813F,
                  0.1055791294F, 0.1058795656F, 0.1061803894F, 0.1064816006F,
                  0.1067831991F, 0.1070851846F, 0.1073875568F, 0.1076903155F,
                  0.1079934604F, 0.1082969913F, 0.1086009079F, 0.1089052101F,
                  0.1092098975F, 0.1095149699F, 0.1098204270F, 0.1101262687F,
                  0.1104324946F, 0.1107391045F, 0.1110460982F, 0.1113534754F,
                  0.1116612359F, 0.1119693793F, 0.1122779055F, 0.1125868142F,
                  0.1128961052F, 0.1132057781F, 0.1135158328F, 0.1138262690F,
                  0.1141370863F, 0.1144482847F, 0.1147598638F, 0.1150718233F,
                  0.1153841631F, 0.1156968828F, 0.1160099822F, 0.1163234610F,
                  0.1166373190F, 0.1169515559F, 0.1172661714F, 0.1175811654F,
                  0.1178965374F, 0.1182122874F, 0.1185284149F, 0.1188449198F,
                  0.1191618018F, 0.1194790606F, 0.1197966960F, 0.1201147076F,
                  0.1204330953F, 0.1207518587F, 0.1210709976F, 0.1213905118F,
                  0.1217104009F, 0.1220306647F, 0.1223513029F, 0.1226723153F,
                  0.1229937016F, 0.1233154615F, 0.1236375948F, 0.1239601011F,
                  0.1242829803F, 0.1246062319F, 0.1249298559F, 0.1252538518F,
                  0.1255782195F, 0.1259029586F, 0.1262280689F, 0.1265535501F,
                  0.1268794019F, 0.1272056241F, 0.1275322163F, 0.1278591784F,
                  0.1281865099F, 0.1285142108F, 0.1288422805F, 0.1291707190F,
                  0.1294995259F, 0.1298287009F, 0.1301582437F, 0.1304881542F,
                  0.1308184319F, 0.1311490766F, 0.1314800881F, 0.1318114660F,
                  0.1321432100F, 0.1324753200F, 0.1328077955F, 0.1331406364F,
                  0.1334738422F, 0.1338074129F, 0.1341413479F, 0.1344756472F,
                  0.1348103103F, 0.1351453370F, 0.1354807270F, 0.1358164801F,
                  0.1361525959F, 0.1364890741F, 0.1368259145F, 0.1371631167F,
                  0.1375006805F, 0.1378386056F, 0.1381768917F, 0.1385155384F,
                  0.1388545456F, 0.1391939129F, 0.1395336400F, 0.1398737266F,
                  0.1402141724F, 0.1405549772F, 0.1408961406F, 0.1412376623F,
                  0.1415795421F, 0.1419217797F, 0.1422643746F, 0.1426073268F,
                  0.1429506358F, 0.1432943013F, 0.1436383231F, 0.1439827008F,
                  0.1443274342F, 0.1446725229F, 0.1450179667F, 0.1453637652F,
                  0.1457099181F, 0.1460564252F, 0.1464032861F, 0.1467505006F,
                  0.1470980682F, 0.1474459888F, 0.1477942620F, 0.1481428875F,
                  0.1484918651F, 0.1488411942F, 0.1491908748F, 0.1495409065F,
                  0.1498912889F, 0.1502420218F, 0.1505931048F, 0.1509445376F,
                  0.1512963200F, 0.1516484516F, 0.1520009321F, 0.1523537612F,
                  0.1527069385F, 0.1530604638F, 0.1534143368F, 0.1537685571F,
                  0.1541231244F, 0.1544780384F, 0.1548332987F, 0.1551889052F,
                  0.1555448574F, 0.1559011550F, 0.1562577978F, 0.1566147853F,
                  0.1569721173F, 0.1573297935F, 0.1576878135F, 0.1580461771F,
                  0.1584048838F, 0.1587639334F, 0.1591233255F, 0.1594830599F,
                  0.1598431361F, 0.1602035540F, 0.1605643131F, 0.1609254131F,
                  0.1612868537F, 0.1616486346F, 0.1620107555F, 0.1623732160F,
                  0.1627360158F, 0.1630991545F, 0.1634626319F, 0.1638264476F,
                  0.1641906013F, 0.1645550926F, 0.1649199212F, 0.1652850869F,
                  0.1656505892F, 0.1660164278F, 0.1663826024F, 0.1667491127F,
                  0.1671159583F, 0.1674831388F, 0.1678506541F, 0.1682185036F,
                  0.1685866872F, 0.1689552044F, 0.1693240549F, 0.1696932384F,
                  0.1700627545F, 0.1704326029F, 0.1708027833F, 0.1711732952F,
                  0.1715441385F, 0.1719153127F, 0.1722868175F, 0.1726586526F,
                  0.1730308176F, 0.1734033121F, 0.1737761359F, 0.1741492886F,
                  0.1745227698F, 0.1748965792F, 0.1752707164F, 0.1756451812F,
                  0.1760199731F, 0.1763950918F, 0.1767705370F, 0.1771463083F,
                  0.1775224054F, 0.1778988279F, 0.1782755754F, 0.1786526477F,
                  0.1790300444F, 0.1794077651F, 0.1797858094F, 0.1801641771F,
                  0.1805428677F, 0.1809218810F, 0.1813012165F, 0.1816808739F,
                  0.1820608528F, 0.1824411530F, 0.1828217739F, 0.1832027154F,
                  0.1835839770F, 0.1839655584F, 0.1843474592F, 0.1847296790F,
                  0.1851122175F, 0.1854950744F, 0.1858782492F, 0.1862617417F,
                  0.1866455514F, 0.1870296780F, 0.1874141211F, 0.1877988804F,
                  0.1881839555F, 0.1885693461F, 0.1889550517F, 0.1893410721F,
                  0.1897274068F, 0.1901140555F, 0.1905010178F, 0.1908882933F,
                  0.1912758818F, 0.1916637828F, 0.1920519959F, 0.1924405208F,
                  0.1928293571F, 0.1932185044F, 0.1936079625F, 0.1939977308F,
                  0.1943878091F, 0.1947781969F, 0.1951688939F, 0.1955598998F,
                  0.1959512141F, 0.1963428364F, 0.1967347665F, 0.1971270038F,
                  0.1975195482F, 0.1979123990F, 0.1983055561F, 0.1986990190F,
                  0.1990927873F, 0.1994868607F, 0.1998812388F, 0.2002759212F,
                  0.2006709075F, 0.2010661974F, 0.2014617904F, 0.2018576862F,
                  0.2022538844F, 0.2026503847F, 0.2030471865F, 0.2034442897F,
                  0.2038416937F, 0.2042393982F, 0.2046374028F, 0.2050357071F,
                  0.2054343107F, 0.2058332133F, 0.2062324145F, 0.2066319138F,
                  0.2070317110F, 0.2074318055F, 0.2078321970F, 0.2082328852F,
                  0.2086338696F, 0.2090351498F, 0.2094367255F, 0.2098385962F,
                  0.2102407617F, 0.2106432213F, 0.2110459749F, 0.2114490220F,
                  0.2118523621F, 0.2122559950F, 0.2126599202F, 0.2130641373F,
                  0.2134686459F, 0.2138734456F, 0.2142785361F, 0.2146839168F,
                  0.2150895875F, 0.2154955478F, 0.2159017972F, 0.2163083353F,
                  0.2167151617F, 0.2171222761F, 0.2175296780F, 0.2179373670F,
                  0.2183453428F, 0.2187536049F, 0.2191621529F, 0.2195709864F,
                  0.2199801051F, 0.2203895085F, 0.2207991961F, 0.2212091677F,
                  0.2216194228F, 0.2220299610F, 0.2224407818F, 0.2228518850F,
                  0.2232632699F, 0.2236749364F, 0.2240868839F, 0.2244991121F,
                  0.2249116204F, 0.2253244086F, 0.2257374763F, 0.2261508229F,
                  0.2265644481F, 0.2269783514F, 0.2273925326F, 0.2278069911F,
                  0.2282217265F, 0.2286367384F, 0.2290520265F, 0.2294675902F,
                  0.2298834292F, 0.2302995431F, 0.2307159314F, 0.2311325937F,
                  0.2315495297F, 0.2319667388F, 0.2323842207F, 0.2328019749F,
                  0.2332200011F, 0.2336382988F, 0.2340568675F, 0.2344757070F,
                  0.2348948166F, 0.2353141961F, 0.2357338450F, 0.2361537629F,
                  0.2365739493F, 0.2369944038F, 0.2374151261F, 0.2378361156F,
                  0.2382573720F, 0.2386788948F, 0.2391006836F, 0.2395227380F,
                  0.2399450575F, 0.2403676417F, 0.2407904902F, 0.2412136026F,
                  0.2416369783F, 0.2420606171F, 0.2424845185F, 0.2429086820F,
                  0.2433331072F, 0.2437577936F, 0.2441827409F, 0.2446079486F,
                  0.2450334163F, 0.2454591435F, 0.2458851298F, 0.2463113747F,
                  0.2467378779F, 0.2471646389F, 0.2475916573F, 0.2480189325F,
                  0.2484464643F, 0.2488742521F, 0.2493022955F, 0.2497305940F,
                  0.2501591473F, 0.2505879549F, 0.2510170163F, 0.2514463311F,
                  0.2518758989F, 0.2523057193F, 0.2527357916F, 0.2531661157F,
                  0.2535966909F, 0.2540275169F, 0.2544585931F, 0.2548899193F,
                  0.2553214948F, 0.2557533193F, 0.2561853924F, 0.2566177135F,
                  0.2570502822F, 0.2574830981F, 0.2579161608F, 0.2583494697F,
                  0.2587830245F, 0.2592168246F, 0.2596508697F, 0.2600851593F,
                  0.2605196929F, 0.2609544701F, 0.2613894904F, 0.2618247534F,
                  0.2622602586F, 0.2626960055F, 0.2631319938F, 0.2635682230F,
                  0.2640046925F, 0.2644414021F, 0.2648783511F, 0.2653155391F,
                  0.2657529657F, 0.2661906305F, 0.2666285329F, 0.2670666725F,
                  0.2675050489F, 0.2679436616F, 0.2683825101F, 0.2688215940F,
                  0.2692609127F, 0.2697004660F, 0.2701402532F, 0.2705802739F,
                  0.2710205278F, 0.2714610142F, 0.2719017327F, 0.2723426830F,
                  0.2727838644F, 0.2732252766F, 0.2736669191F, 0.2741087914F,
                  0.2745508930F, 0.2749932235F, 0.2754357824F, 0.2758785693F,
                  0.2763215837F, 0.2767648251F, 0.2772082930F, 0.2776519870F,
                  0.2780959066F, 0.2785400513F, 0.2789844207F, 0.2794290143F,
                  0.2798738316F, 0.2803188722F, 0.2807641355F, 0.2812096211F,
                  0.2816553286F, 0.2821012574F, 0.2825474071F, 0.2829937773F,
                  0.2834403673F, 0.2838871768F, 0.2843342053F, 0.2847814523F,
                  0.2852289174F, 0.2856765999F, 0.2861244996F, 0.2865726159F,
                  0.2870209482F, 0.2874694962F, 0.2879182594F, 0.2883672372F,
                  0.2888164293F, 0.2892658350F, 0.2897154540F, 0.2901652858F,
                  0.2906153298F, 0.2910655856F, 0.2915160527F, 0.2919667306F,
                  0.2924176189F, 0.2928687171F, 0.2933200246F, 0.2937715409F,
                  0.2942232657F, 0.2946751984F, 0.2951273386F, 0.2955796856F,
                  0.2960322391F, 0.2964849986F, 0.2969379636F, 0.2973911335F,
                  0.2978445080F, 0.2982980864F, 0.2987518684F, 0.2992058534F,
                  0.2996600409F, 0.3001144305F, 0.3005690217F, 0.3010238139F,
                  0.3014788067F, 0.3019339995F, 0.3023893920F, 0.3028449835F,
                  0.3033007736F, 0.3037567618F, 0.3042129477F, 0.3046693306F,
                  0.3051259102F, 0.3055826859F, 0.3060396572F, 0.3064968236F,
                  0.3069541847F, 0.3074117399F, 0.3078694887F, 0.3083274307F,
                  0.3087855653F, 0.3092438920F, 0.3097024104F, 0.3101611199F,
                  0.3106200200F, 0.3110791103F, 0.3115383902F, 0.3119978592F,
                  0.3124575169F, 0.3129173627F, 0.3133773961F, 0.3138376166F,
                  0.3142980238F, 0.3147586170F, 0.3152193959F, 0.3156803598F,
                  0.3161415084F, 0.3166028410F, 0.3170643573F, 0.3175260566F,
                  0.3179879384F, 0.3184500023F, 0.3189122478F, 0.3193746743F,
                  0.3198372814F, 0.3203000685F, 0.3207630351F, 0.3212261807F,
                  0.3216895048F, 0.3221530069F, 0.3226166865F, 0.3230805430F,
                  0.3235445760F, 0.3240087849F, 0.3244731693F, 0.3249377285F,
                  0.3254024622F, 0.3258673698F, 0.3263324507F, 0.3267977045F,
                  0.3272631306F, 0.3277287286F, 0.3281944978F, 0.3286604379F,
                  0.3291265482F, 0.3295928284F, 0.3300592777F, 0.3305258958F,
                  0.3309926821F, 0.3314596361F, 0.3319267573F, 0.3323940451F,
                  0.3328614990F, 0.3333291186F, 0.3337969033F, 0.3342648525F,
                  0.3347329658F, 0.3352012427F, 0.3356696825F, 0.3361382849F,
                  0.3366070492F, 0.3370759749F, 0.3375450616F, 0.3380143087F,
                  0.3384837156F, 0.3389532819F, 0.3394230071F, 0.3398928905F,
                  0.3403629317F, 0.3408331302F, 0.3413034854F, 0.3417739967F,
                  0.3422446638F, 0.3427154860F, 0.3431864628F, 0.3436575938F,
                  0.3441288782F, 0.3446003158F, 0.3450719058F, 0.3455436478F,
                  0.3460155412F, 0.3464875856F, 0.3469597804F, 0.3474321250F,
                  0.3479046189F, 0.3483772617F, 0.3488500527F, 0.3493229914F,
                  0.3497960774F, 0.3502693100F, 0.3507426887F, 0.3512162131F,
                  0.3516898825F, 0.3521636965F, 0.3526376545F, 0.3531117559F,
                  0.3535860003F, 0.3540603870F, 0.3545349157F, 0.3550095856F,
                  0.3554843964F, 0.3559593474F, 0.3564344381F, 0.3569096680F,
                  0.3573850366F, 0.3578605432F, 0.3583361875F, 0.3588119687F,
                  0.3592878865F, 0.3597639402F, 0.3602401293F, 0.3607164533F,
                  0.3611929117F, 0.3616695038F, 0.3621462292F, 0.3626230873F,
                  0.3631000776F, 0.3635771995F, 0.3640544525F, 0.3645318360F,
                  0.3650093496F, 0.3654869926F, 0.3659647645F, 0.3664426648F,
                  0.3669206930F, 0.3673988484F, 0.3678771306F, 0.3683555390F,
                  0.3688340731F, 0.3693127322F, 0.3697915160F, 0.3702704237F,
                  0.3707494549F, 0.3712286091F, 0.3717078857F, 0.3721872840F,
                  0.3726668037F, 0.3731464441F, 0.3736262047F, 0.3741060850F,
                  0.3745860843F, 0.3750662023F, 0.3755464382F, 0.3760267915F,
                  0.3765072618F, 0.3769878484F, 0.3774685509F, 0.3779493686F,
                  0.3784303010F, 0.3789113475F, 0.3793925076F, 0.3798737809F,
                  0.3803551666F, 0.3808366642F, 0.3813182733F, 0.3817999932F,
                  0.3822818234F, 0.3827637633F, 0.3832458124F, 0.3837279702F,
                  0.3842102360F, 0.3846926093F, 0.3851750897F, 0.3856576764F,
                  0.3861403690F, 0.3866231670F, 0.3871060696F, 0.3875890765F,
                  0.3880721870F, 0.3885554007F, 0.3890387168F, 0.3895221349F,
                  0.3900056544F, 0.3904892748F, 0.3909729955F, 0.3914568160F,
                  0.3919407356F, 0.3924247539F, 0.3929088702F, 0.3933930841F,
                  0.3938773949F, 0.3943618021F, 0.3948463052F, 0.3953309035F,
                  0.3958155966F, 0.3963003838F, 0.3967852646F, 0.3972702385F,
                  0.3977553048F, 0.3982404631F, 0.3987257127F, 0.3992110531F,
                  0.3996964838F, 0.4001820041F, 0.4006676136F, 0.4011533116F,
                  0.4016390976F, 0.4021249710F, 0.4026109313F, 0.4030969779F,
                  0.4035831102F, 0.4040693277F, 0.4045556299F, 0.4050420160F,
                  0.4055284857F, 0.4060150383F, 0.4065016732F, 0.4069883899F,
                  0.4074751879F, 0.4079620665F, 0.4084490252F, 0.4089360635F,
                  0.4094231807F, 0.4099103763F, 0.4103976498F, 0.4108850005F,
                  0.4113724280F, 0.4118599315F, 0.4123475107F, 0.4128351648F,
                  0.4133228934F, 0.4138106959F, 0.4142985716F, 0.4147865201F,
                  0.4152745408F, 0.4157626330F, 0.4162507963F, 0.4167390301F,
                  0.4172273337F, 0.4177157067F, 0.4182041484F, 0.4186926583F,
                  0.4191812359F, 0.4196698805F, 0.4201585915F, 0.4206473685F,
                  0.4211362108F, 0.4216251179F, 0.4221140892F, 0.4226031241F,
                  0.4230922221F, 0.4235813826F, 0.4240706050F, 0.4245598887F,
                  0.4250492332F, 0.4255386379F, 0.4260281022F, 0.4265176256F,
                  0.4270072075F, 0.4274968473F, 0.4279865445F, 0.4284762984F,
                  0.4289661086F, 0.4294559743F, 0.4299458951F, 0.4304358704F,
                  0.4309258996F, 0.4314159822F, 0.4319061175F, 0.4323963050F,
                  0.4328865441F, 0.4333768342F, 0.4338671749F, 0.4343575654F,
                  0.4348480052F, 0.4353384938F, 0.4358290306F, 0.4363196149F,
                  0.4368102463F, 0.4373009241F, 0.4377916478F, 0.4382824168F,
                  0.4387732305F, 0.4392640884F, 0.4397549899F, 0.4402459343F,
                  0.4407369212F, 0.4412279499F, 0.4417190198F, 0.4422101305F,
                  0.4427012813F, 0.4431924717F, 0.4436837010F, 0.4441749686F,
                  0.4446662742F, 0.4451576169F, 0.4456489963F, 0.4461404118F,
                  0.4466318628F, 0.4471233487F, 0.4476148690F, 0.4481064230F,
                  0.4485980103F, 0.4490896302F, 0.4495812821F, 0.4500729654F,
                  0.4505646797F, 0.4510564243F, 0.4515481986F, 0.4520400021F,
                  0.4525318341F, 0.4530236942F, 0.4535155816F, 0.4540074959F,
                  0.4544994365F, 0.4549914028F, 0.4554833941F, 0.4559754100F,
                  0.4564674499F, 0.4569595131F, 0.4574515991F, 0.4579437074F,
                  0.4584358372F, 0.4589279881F, 0.4594201595F, 0.4599123508F,
                  0.4604045615F, 0.4608967908F, 0.4613890383F, 0.4618813034F,
                  0.4623735855F, 0.4628658841F, 0.4633581984F, 0.4638505281F,
                  0.4643428724F, 0.4648352308F, 0.4653276028F, 0.4658199877F,
                  0.4663123849F, 0.4668047940F, 0.4672972143F, 0.4677896451F,
                  0.4682820861F, 0.4687745365F, 0.4692669958F, 0.4697594634F,
                  0.4702519387F, 0.4707444211F, 0.4712369102F, 0.4717294052F,
                  0.4722219056F, 0.4727144109F, 0.4732069204F, 0.4736994336F,
                  0.4741919498F, 0.4746844686F, 0.4751769893F, 0.4756695113F,
                  0.4761620341F, 0.4766545571F, 0.4771470797F, 0.4776396013F,
                  0.4781321213F, 0.4786246392F, 0.4791171544F, 0.4796096663F,
                  0.4801021744F, 0.4805946779F, 0.4810871765F, 0.4815796694F,
                  0.4820721561F, 0.4825646360F, 0.4830571086F, 0.4835495732F,
                  0.4840420293F, 0.4845344763F, 0.4850269136F, 0.4855193407F,
                  0.4860117569F, 0.4865041617F, 0.4869965545F, 0.4874889347F,
                  0.4879813018F, 0.4884736551F, 0.4889659941F, 0.4894583182F,
                  0.4899506268F, 0.4904429193F, 0.4909351952F, 0.4914274538F,
                  0.4919196947F, 0.4924119172F, 0.4929041207F, 0.4933963046F,
                  0.4938884685F, 0.4943806116F, 0.4948727335F, 0.4953648335F,
                  0.4958569110F, 0.4963489656F, 0.4968409965F, 0.4973330032F,
                  0.4978249852F, 0.4983169419F, 0.4988088726F, 0.4993007768F,
                  0.4997926539F, 0.5002845034F, 0.5007763247F, 0.5012681171F,
                  0.5017598801F, 0.5022516132F, 0.5027433157F, 0.5032349871F,
                  0.5037266268F, 0.5042182341F, 0.5047098086F, 0.5052013497F,
                  0.5056928567F, 0.5061843292F, 0.5066757664F, 0.5071671679F,
                  0.5076585330F, 0.5081498613F, 0.5086411520F, 0.5091324047F,
                  0.5096236187F, 0.5101147934F, 0.5106059284F, 0.5110970230F,
                  0.5115880766F, 0.5120790887F, 0.5125700587F, 0.5130609860F,
                  0.5135518700F, 0.5140427102F, 0.5145335059F, 0.5150242566F,
                  0.5155149618F, 0.5160056208F, 0.5164962331F, 0.5169867980F,
                  0.5174773151F, 0.5179677837F, 0.5184582033F, 0.5189485733F,
                  0.5194388931F, 0.5199291621F, 0.5204193798F, 0.5209095455F,
                  0.5213996588F, 0.5218897190F, 0.5223797256F, 0.5228696779F,
                  0.5233595755F, 0.5238494177F, 0.5243392039F, 0.5248289337F,
                  0.5253186063F, 0.5258082213F, 0.5262977781F, 0.5267872760F,
                  0.5272767146F, 0.5277660932F, 0.5282554112F, 0.5287446682F,
                  0.5292338635F, 0.5297229965F, 0.5302120667F, 0.5307010736F,
                  0.5311900164F, 0.5316788947F, 0.5321677079F, 0.5326564554F,
                  0.5331451366F, 0.5336337511F, 0.5341222981F, 0.5346107771F,
                  0.5350991876F, 0.5355875290F, 0.5360758007F, 0.5365640021F,
                  0.5370521327F, 0.5375401920F, 0.5380281792F, 0.5385160939F,
                  0.5390039355F, 0.5394917034F, 0.5399793971F, 0.5404670159F,
                  0.5409545594F, 0.5414420269F, 0.5419294179F, 0.5424167318F,
                  0.5429039680F, 0.5433911261F, 0.5438782053F, 0.5443652051F,
                  0.5448521250F, 0.5453389644F, 0.5458257228F, 0.5463123995F,
                  0.5467989940F, 0.5472855057F, 0.5477719341F, 0.5482582786F,
                  0.5487445387F, 0.5492307137F, 0.5497168031F, 0.5502028063F,
                  0.5506887228F, 0.5511745520F, 0.5516602934F, 0.5521459463F,
                  0.5526315103F, 0.5531169847F, 0.5536023690F, 0.5540876626F,
                  0.5545728649F, 0.5550579755F, 0.5555429937F, 0.5560279189F,
                  0.5565127507F, 0.5569974884F, 0.5574821315F, 0.5579666794F,
                  0.5584511316F, 0.5589354875F, 0.5594197465F, 0.5599039080F,
                  0.5603879716F, 0.5608719367F, 0.5613558026F, 0.5618395689F,
                  0.5623232350F, 0.5628068002F, 0.5632902642F, 0.5637736262F,
                  0.5642568858F, 0.5647400423F, 0.5652230953F, 0.5657060442F,
                  0.5661888883F, 0.5666716272F, 0.5671542603F, 0.5676367870F,
                  0.5681192069F, 0.5686015192F, 0.5690837235F, 0.5695658192F,
                  0.5700478058F, 0.5705296827F, 0.5710114494F, 0.5714931052F,
                  0.5719746497F, 0.5724560822F, 0.5729374023F, 0.5734186094F,
                  0.5738997029F, 0.5743806823F, 0.5748615470F, 0.5753422965F,
                  0.5758229301F, 0.5763034475F, 0.5767838480F, 0.5772641310F,
                  0.5777442960F, 0.5782243426F, 0.5787042700F, 0.5791840778F,
                  0.5796637654F, 0.5801433322F, 0.5806227778F, 0.5811021016F,
                  0.5815813029F, 0.5820603814F, 0.5825393363F, 0.5830181673F,
                  0.5834968737F, 0.5839754549F, 0.5844539105F, 0.5849322399F,
                  0.5854104425F, 0.5858885179F, 0.5863664653F, 0.5868442844F,
                  0.5873219746F, 0.5877995353F, 0.5882769660F, 0.5887542661F,
                  0.5892314351F, 0.5897084724F, 0.5901853776F, 0.5906621500F,
                  0.5911387892F, 0.5916152945F, 0.5920916655F, 0.5925679016F,
                  0.5930440022F, 0.5935199669F, 0.5939957950F, 0.5944714861F,
                  0.5949470396F, 0.5954224550F, 0.5958977317F, 0.5963728692F,
                  0.5968478669F, 0.5973227244F, 0.5977974411F, 0.5982720163F,
                  0.5987464497F, 0.5992207407F, 0.5996948887F, 0.6001688932F,
                  0.6006427537F, 0.6011164696F, 0.6015900405F, 0.6020634657F,
                  0.6025367447F, 0.6030098770F, 0.6034828621F, 0.6039556995F,
                  0.6044283885F, 0.6049009288F, 0.6053733196F, 0.6058455606F,
                  0.6063176512F, 0.6067895909F, 0.6072613790F, 0.6077330152F,
                  0.6082044989F, 0.6086758295F, 0.6091470065F, 0.6096180294F,
                  0.6100888977F, 0.6105596108F, 0.6110301682F, 0.6115005694F,
                  0.6119708139F, 0.6124409011F, 0.6129108305F, 0.6133806017F,
                  0.6138502139F, 0.6143196669F, 0.6147889599F, 0.6152580926F,
                  0.6157270643F, 0.6161958746F, 0.6166645230F, 0.6171330088F,
                  0.6176013317F, 0.6180694910F, 0.6185374863F, 0.6190053171F,
                  0.6194729827F, 0.6199404828F, 0.6204078167F, 0.6208749841F,
                  0.6213419842F, 0.6218088168F, 0.6222754811F, 0.6227419768F,
                  0.6232083032F, 0.6236744600F, 0.6241404465F, 0.6246062622F,
                  0.6250719067F, 0.6255373795F, 0.6260026799F, 0.6264678076F,
                  0.6269327619F, 0.6273975425F, 0.6278621487F, 0.6283265800F,
                  0.6287908361F, 0.6292549163F, 0.6297188201F, 0.6301825471F,
                  0.6306460966F, 0.6311094683F, 0.6315726617F, 0.6320356761F,
                  0.6324985111F, 0.6329611662F, 0.6334236410F, 0.6338859348F,
                  0.6343480472F, 0.6348099777F, 0.6352717257F, 0.6357332909F,
                  0.6361946726F, 0.6366558704F, 0.6371168837F, 0.6375777122F,
                  0.6380383552F, 0.6384988123F, 0.6389590830F, 0.6394191668F,
                  0.6398790631F, 0.6403387716F, 0.6407982916F, 0.6412576228F,
                  0.6417167645F, 0.6421757163F, 0.6426344778F, 0.6430930483F,
                  0.6435514275F, 0.6440096149F, 0.6444676098F, 0.6449254119F,
                  0.6453830207F, 0.6458404356F, 0.6462976562F, 0.6467546820F,
                  0.6472115125F, 0.6476681472F, 0.6481245856F, 0.6485808273F,
                  0.6490368717F, 0.6494927183F, 0.6499483667F, 0.6504038164F,
                  0.6508590670F, 0.6513141178F, 0.6517689684F, 0.6522236185F,
                  0.6526780673F, 0.6531323146F, 0.6535863598F, 0.6540402024F,
                  0.6544938419F, 0.6549472779F, 0.6554005099F, 0.6558535373F,
                  0.6563063598F, 0.6567589769F, 0.6572113880F, 0.6576635927F,
                  0.6581155906F, 0.6585673810F, 0.6590189637F, 0.6594703380F,
                  0.6599215035F, 0.6603724598F, 0.6608232064F, 0.6612737427F,
                  0.6617240684F, 0.6621741829F, 0.6626240859F, 0.6630737767F,
                  0.6635232550F, 0.6639725202F, 0.6644215720F, 0.6648704098F,
                  0.6653190332F, 0.6657674417F, 0.6662156348F, 0.6666636121F,
                  0.6671113731F, 0.6675589174F, 0.6680062445F, 0.6684533538F,
                  0.6689002450F, 0.6693469177F, 0.6697933712F, 0.6702396052F,
                  0.6706856193F, 0.6711314129F, 0.6715769855F, 0.6720223369F,
                  0.6724674664F, 0.6729123736F, 0.6733570581F, 0.6738015194F,
                  0.6742457570F, 0.6746897706F, 0.6751335596F, 0.6755771236F,
                  0.6760204621F, 0.6764635747F, 0.6769064609F, 0.6773491204F,
                  0.6777915525F, 0.6782337570F, 0.6786757332F, 0.6791174809F,
                  0.6795589995F, 0.6800002886F, 0.6804413477F, 0.6808821765F,
                  0.6813227743F, 0.6817631409F, 0.6822032758F, 0.6826431785F,
                  0.6830828485F, 0.6835222855F, 0.6839614890F, 0.6844004585F,
                  0.6848391936F, 0.6852776939F, 0.6857159589F, 0.6861539883F,
                  0.6865917815F, 0.6870293381F, 0.6874666576F, 0.6879037398F,
                  0.6883405840F, 0.6887771899F, 0.6892135571F, 0.6896496850F,
                  0.6900855733F, 0.6905212216F, 0.6909566294F, 0.6913917963F,
                  0.6918267218F, 0.6922614055F, 0.6926958471F, 0.6931300459F,
                  0.6935640018F, 0.6939977141F, 0.6944311825F, 0.6948644066F,
                  0.6952973859F, 0.6957301200F, 0.6961626085F, 0.6965948510F,
                  0.6970268470F, 0.6974585961F, 0.6978900980F, 0.6983213521F,
                  0.6987523580F, 0.6991831154F, 0.6996136238F, 0.7000438828F,
                  0.7004738921F, 0.7009036510F, 0.7013331594F, 0.7017624166F,
                  0.7021914224F, 0.7026201763F, 0.7030486779F, 0.7034769268F,
                  0.7039049226F, 0.7043326648F, 0.7047601531F, 0.7051873870F,
                  0.7056143662F, 0.7060410902F, 0.7064675586F, 0.7068937711F,
                  0.7073197271F, 0.7077454264F, 0.7081708684F, 0.7085960529F,
                  0.7090209793F, 0.7094456474F, 0.7098700566F, 0.7102942066F,
                  0.7107180970F, 0.7111417274F, 0.7115650974F, 0.7119882066F,
                  0.7124110545F, 0.7128336409F, 0.7132559653F, 0.7136780272F,
                  0.7140998264F, 0.7145213624F, 0.7149426348F, 0.7153636433F,
                  0.7157843874F, 0.7162048668F, 0.7166250810F, 0.7170450296F,
                  0.7174647124F, 0.7178841289F, 0.7183032786F, 0.7187221613F,
                  0.7191407765F, 0.7195591239F, 0.7199772030F, 0.7203950135F,
                  0.7208125550F, 0.7212298271F, 0.7216468294F, 0.7220635616F,
                  0.7224800233F, 0.7228962140F, 0.7233121335F, 0.7237277813F,
                  0.7241431571F, 0.7245582604F, 0.7249730910F, 0.7253876484F,
                  0.7258019322F, 0.7262159422F, 0.7266296778F, 0.7270431388F,
                  0.7274563247F, 0.7278692353F, 0.7282818700F, 0.7286942287F,
                  0.7291063108F, 0.7295181160F, 0.7299296440F, 0.7303408944F,
                  0.7307518669F, 0.7311625609F, 0.7315729763F, 0.7319831126F,
                  0.7323929695F, 0.7328025466F, 0.7332118435F, 0.7336208600F,
                  0.7340295955F, 0.7344380499F, 0.7348462226F, 0.7352541134F,
                  0.7356617220F, 0.7360690478F, 0.7364760907F, 0.7368828502F,
                  0.7372893259F, 0.7376955176F, 0.7381014249F, 0.7385070475F,
                  0.7389123849F, 0.7393174368F, 0.7397222029F, 0.7401266829F,
                  0.7405308763F, 0.7409347829F, 0.7413384023F, 0.7417417341F,
                  0.7421447780F, 0.7425475338F, 0.7429500009F, 0.7433521791F,
                  0.7437540681F, 0.7441556674F, 0.7445569769F, 0.7449579960F,
                  0.7453587245F, 0.7457591621F, 0.7461593084F, 0.7465591631F,
                  0.7469587259F, 0.7473579963F, 0.7477569741F, 0.7481556590F,
                  0.7485540506F, 0.7489521486F, 0.7493499526F, 0.7497474623F,
                  0.7501446775F, 0.7505415977F, 0.7509382227F, 0.7513345521F,
                  0.7517305856F, 0.7521263229F, 0.7525217636F, 0.7529169074F,
                  0.7533117541F, 0.7537063032F, 0.7541005545F, 0.7544945076F,
                  0.7548881623F, 0.7552815182F, 0.7556745749F, 0.7560673323F,
                  0.7564597899F, 0.7568519474F, 0.7572438046F, 0.7576353611F,
                  0.7580266166F, 0.7584175708F, 0.7588082235F, 0.7591985741F,
                  0.7595886226F, 0.7599783685F, 0.7603678116F, 0.7607569515F,
                  0.7611457879F, 0.7615343206F, 0.7619225493F, 0.7623104735F,
                  0.7626980931F, 0.7630854078F, 0.7634724171F, 0.7638591209F,
                  0.7642455188F, 0.7646316106F, 0.7650173959F, 0.7654028744F,
                  0.7657880459F, 0.7661729100F, 0.7665574664F, 0.7669417150F,
                  0.7673256553F, 0.7677092871F, 0.7680926100F, 0.7684756239F,
                  0.7688583284F, 0.7692407232F, 0.7696228080F, 0.7700045826F,
                  0.7703860467F, 0.7707671999F, 0.7711480420F, 0.7715285728F,
                  0.7719087918F, 0.7722886989F, 0.7726682938F, 0.7730475762F,
                  0.7734265458F, 0.7738052023F, 0.7741835454F, 0.7745615750F,
                  0.7749392906F, 0.7753166921F, 0.7756937791F, 0.7760705514F,
                  0.7764470087F, 0.7768231508F, 0.7771989773F, 0.7775744880F,
                  0.7779496827F, 0.7783245610F, 0.7786991227F, 0.7790733676F,
                  0.7794472953F, 0.7798209056F, 0.7801941982F, 0.7805671729F,
                  0.7809398294F, 0.7813121675F, 0.7816841869F, 0.7820558873F,
                  0.7824272684F, 0.7827983301F, 0.7831690720F, 0.7835394940F,
                  0.7839095957F, 0.7842793768F, 0.7846488373F, 0.7850179767F,
                  0.7853867948F, 0.7857552914F, 0.7861234663F, 0.7864913191F,
                  0.7868588497F, 0.7872260578F, 0.7875929431F, 0.7879595055F,
                  0.7883257445F, 0.7886916601F, 0.7890572520F, 0.7894225198F,
                  0.7897874635F, 0.7901520827F, 0.7905163772F, 0.7908803468F,
                  0.7912439912F, 0.7916073102F, 0.7919703035F, 0.7923329710F,
                  0.7926953124F, 0.7930573274F, 0.7934190158F, 0.7937803774F,
                  0.7941414120F, 0.7945021193F, 0.7948624991F, 0.7952225511F,
                  0.7955822752F, 0.7959416711F, 0.7963007387F, 0.7966594775F,
                  0.7970178875F, 0.7973759685F, 0.7977337201F, 0.7980911422F,
                  0.7984482346F, 0.7988049970F, 0.7991614292F, 0.7995175310F,
                  0.7998733022F, 0.8002287426F, 0.8005838519F, 0.8009386299F,
                  0.8012930765F, 0.8016471914F, 0.8020009744F, 0.8023544253F,
                  0.8027075438F, 0.8030603298F, 0.8034127831F, 0.8037649035F,
                  0.8041166906F, 0.8044681445F, 0.8048192647F, 0.8051700512F,
                  0.8055205038F, 0.8058706222F, 0.8062204062F, 0.8065698556F,
                  0.8069189702F, 0.8072677499F, 0.8076161944F, 0.8079643036F,
                  0.8083120772F, 0.8086595151F, 0.8090066170F, 0.8093533827F,
                  0.8096998122F, 0.8100459051F, 0.8103916613F, 0.8107370806F,
                  0.8110821628F, 0.8114269077F, 0.8117713151F, 0.8121153849F,
                  0.8124591169F, 0.8128025108F, 0.8131455666F, 0.8134882839F,
                  0.8138306627F, 0.8141727027F, 0.8145144038F, 0.8148557658F,
                  0.8151967886F, 0.8155374718F, 0.8158778154F, 0.8162178192F,
                  0.8165574830F, 0.8168968067F, 0.8172357900F, 0.8175744328F,
                  0.8179127349F, 0.8182506962F, 0.8185883164F, 0.8189255955F,
                  0.8192625332F, 0.8195991295F, 0.8199353840F, 0.8202712967F,
                  0.8206068673F, 0.8209420958F, 0.8212769820F, 0.8216115256F,
                  0.8219457266F, 0.8222795848F, 0.8226131000F, 0.8229462721F,
                  0.8232791009F, 0.8236115863F, 0.8239437280F, 0.8242755260F,
                  0.8246069801F, 0.8249380901F, 0.8252688559F, 0.8255992774F,
                  0.8259293544F, 0.8262590867F, 0.8265884741F, 0.8269175167F,
                  0.8272462141F, 0.8275745663F, 0.8279025732F, 0.8282302344F,
                  0.8285575501F, 0.8288845199F, 0.8292111437F, 0.8295374215F,
                  0.8298633530F, 0.8301889382F, 0.8305141768F, 0.8308390688F,
                  0.8311636141F, 0.8314878124F, 0.8318116637F, 0.8321351678F,
                  0.8324583246F, 0.8327811340F, 0.8331035957F, 0.8334257098F,
                  0.8337474761F, 0.8340688944F, 0.8343899647F, 0.8347106867F,
                  0.8350310605F, 0.8353510857F, 0.8356707624F, 0.8359900904F,
                  0.8363090696F, 0.8366276999F, 0.8369459811F, 0.8372639131F,
                  0.8375814958F, 0.8378987292F, 0.8382156130F, 0.8385321472F,
                  0.8388483316F, 0.8391641662F, 0.8394796508F, 0.8397947853F,
                  0.8401095697F, 0.8404240037F, 0.8407380873F, 0.8410518204F,
                  0.8413652029F, 0.8416782347F, 0.8419909156F, 0.8423032456F,
                  0.8426152245F, 0.8429268523F, 0.8432381289F, 0.8435490541F,
                  0.8438596279F, 0.8441698502F, 0.8444797208F, 0.8447892396F,
                  0.8450984067F, 0.8454072218F, 0.8457156849F, 0.8460237959F,
                  0.8463315547F, 0.8466389612F, 0.8469460154F, 0.8472527170F,
                  0.8475590661F, 0.8478650625F, 0.8481707063F, 0.8484759971F,
                  0.8487809351F, 0.8490855201F, 0.8493897521F, 0.8496936308F,
                  0.8499971564F, 0.8503003286F, 0.8506031474F, 0.8509056128F,
                  0.8512077246F, 0.8515094828F, 0.8518108872F, 0.8521119379F,
                  0.8524126348F, 0.8527129777F, 0.8530129666F, 0.8533126015F,
                  0.8536118822F, 0.8539108087F, 0.8542093809F, 0.8545075988F,
                  0.8548054623F, 0.8551029712F, 0.8554001257F, 0.8556969255F,
                  0.8559933707F, 0.8562894611F, 0.8565851968F, 0.8568805775F,
                  0.8571756034F, 0.8574702743F, 0.8577645902F, 0.8580585509F,
                  0.8583521566F, 0.8586454070F, 0.8589383021F, 0.8592308420F,
                  0.8595230265F, 0.8598148556F, 0.8601063292F, 0.8603974473F,
                  0.8606882098F, 0.8609786167F, 0.8612686680F, 0.8615583636F,
                  0.8618477034F, 0.8621366874F, 0.8624253156F, 0.8627135878F,
                  0.8630015042F, 0.8632890646F, 0.8635762690F, 0.8638631173F,
                  0.8641496096F, 0.8644357457F, 0.8647215257F, 0.8650069495F,
                  0.8652920171F, 0.8655767283F, 0.8658610833F, 0.8661450820F,
                  0.8664287243F, 0.8667120102F, 0.8669949397F, 0.8672775127F,
                  0.8675597293F, 0.8678415894F, 0.8681230929F, 0.8684042398F,
                  0.8686850302F, 0.8689654640F, 0.8692455412F, 0.8695252617F,
                  0.8698046255F, 0.8700836327F, 0.8703622831F, 0.8706405768F,
                  0.8709185138F, 0.8711960940F, 0.8714733174F, 0.8717501840F,
                  0.8720266939F, 0.8723028469F, 0.8725786430F, 0.8728540824F,
                  0.8731291648F, 0.8734038905F, 0.8736782592F, 0.8739522711F,
                  0.8742259261F, 0.8744992242F, 0.8747721653F, 0.8750447496F,
                  0.8753169770F, 0.8755888475F, 0.8758603611F, 0.8761315177F,
                  0.8764023175F, 0.8766727603F, 0.8769428462F, 0.8772125752F,
                  0.8774819474F, 0.8777509626F, 0.8780196209F, 0.8782879224F,
                  0.8785558669F, 0.8788234546F, 0.8790906854F, 0.8793575594F,
                  0.8796240765F, 0.8798902368F, 0.8801560403F, 0.8804214870F,
                  0.8806865768F, 0.8809513099F, 0.8812156863F, 0.8814797059F,
                  0.8817433687F, 0.8820066749F, 0.8822696243F, 0.8825322171F,
                  0.8827944532F, 0.8830563327F, 0.8833178556F, 0.8835790219F,
                  0.8838398316F, 0.8841002848F, 0.8843603815F, 0.8846201217F,
                  0.8848795054F, 0.8851385327F, 0.8853972036F, 0.8856555182F,
                  0.8859134764F, 0.8861710783F, 0.8864283239F, 0.8866852133F,
                  0.8869417464F, 0.8871979234F, 0.8874537443F, 0.8877092090F,
                  0.8879643177F, 0.8882190704F, 0.8884734671F, 0.8887275078F,
                  0.8889811927F, 0.8892345216F, 0.8894874948F, 0.8897401122F,
                  0.8899923738F, 0.8902442798F, 0.8904958301F, 0.8907470248F,
                  0.8909978640F, 0.8912483477F, 0.8914984759F, 0.8917482487F,
                  0.8919976662F, 0.8922467284F, 0.8924954353F, 0.8927437871F,
                  0.8929917837F, 0.8932394252F, 0.8934867118F, 0.8937336433F,
                  0.8939802199F, 0.8942264417F, 0.8944723087F, 0.8947178210F,
                  0.8949629785F, 0.8952077815F, 0.8954522299F, 0.8956963239F,
                  0.8959400634F, 0.8961834486F, 0.8964264795F, 0.8966691561F,
                  0.8969114786F, 0.8971534470F, 0.8973950614F, 0.8976363219F,
                  0.8978772284F, 0.8981177812F, 0.8983579802F, 0.8985978256F,
                  0.8988373174F, 0.8990764556F, 0.8993152405F, 0.8995536720F,
                  0.8997917502F, 0.9000294751F, 0.9002668470F, 0.9005038658F,
                  0.9007405317F, 0.9009768446F, 0.9012128048F, 0.9014484123F,
                  0.9016836671F, 0.9019185693F, 0.9021531191F, 0.9023873165F,
                  0.9026211616F, 0.9028546546F, 0.9030877954F, 0.9033205841F,
                  0.9035530210F, 0.9037851059F, 0.9040168392F, 0.9042482207F,
                  0.9044792507F, 0.9047099293F, 0.9049402564F, 0.9051702323F,
                  0.9053998569F, 0.9056291305F, 0.9058580531F, 0.9060866248F,
                  0.9063148457F, 0.9065427159F, 0.9067702355F, 0.9069974046F,
                  0.9072242233F, 0.9074506917F, 0.9076768100F, 0.9079025782F,
                  0.9081279964F, 0.9083530647F, 0.9085777833F, 0.9088021523F,
                  0.9090261717F, 0.9092498417F, 0.9094731623F, 0.9096961338F,
                  0.9099187561F, 0.9101410295F, 0.9103629540F, 0.9105845297F,
                  0.9108057568F, 0.9110266354F, 0.9112471656F, 0.9114673475F,
                  0.9116871812F, 0.9119066668F, 0.9121258046F, 0.9123445945F,
                  0.9125630367F, 0.9127811314F, 0.9129988786F, 0.9132162785F,
                  0.9134333312F, 0.9136500368F, 0.9138663954F, 0.9140824073F,
                  0.9142980724F, 0.9145133910F, 0.9147283632F, 0.9149429890F,
                  0.9151572687F, 0.9153712023F, 0.9155847900F, 0.9157980319F,
                  0.9160109282F, 0.9162234790F, 0.9164356844F, 0.9166475445F,
                  0.9168590595F, 0.9170702296F, 0.9172810548F, 0.9174915354F,
                  0.9177016714F, 0.9179114629F, 0.9181209102F, 0.9183300134F,
                  0.9185387726F, 0.9187471879F, 0.9189552595F, 0.9191629876F,
                  0.9193703723F, 0.9195774136F, 0.9197841119F, 0.9199904672F,
                  0.9201964797F, 0.9204021495F, 0.9206074767F, 0.9208124616F,
                  0.9210171043F, 0.9212214049F, 0.9214253636F, 0.9216289805F,
                  0.9218322558F, 0.9220351896F, 0.9222377821F, 0.9224400335F,
                  0.9226419439F, 0.9228435134F, 0.9230447423F, 0.9232456307F,
                  0.9234461787F, 0.9236463865F, 0.9238462543F, 0.9240457822F,
                  0.9242449704F, 0.9244438190F, 0.9246423282F, 0.9248404983F,
                  0.9250383293F, 0.9252358214F, 0.9254329747F, 0.9256297896F,
                  0.9258262660F, 0.9260224042F, 0.9262182044F, 0.9264136667F,
                  0.9266087913F, 0.9268035783F, 0.9269980280F, 0.9271921405F,
                  0.9273859160F, 0.9275793546F, 0.9277724566F, 0.9279652221F,
                  0.9281576513F, 0.9283497443F, 0.9285415014F, 0.9287329227F,
                  0.9289240084F, 0.9291147586F, 0.9293051737F, 0.9294952536F,
                  0.9296849987F, 0.9298744091F, 0.9300634850F, 0.9302522266F,
                  0.9304406340F, 0.9306287074F, 0.9308164471F, 0.9310038532F,
                  0.9311909259F, 0.9313776654F, 0.9315640719F, 0.9317501455F,
                  0.9319358865F, 0.9321212951F, 0.9323063713F, 0.9324911155F,
                  0.9326755279F, 0.9328596085F, 0.9330433577F, 0.9332267756F,
                  0.9334098623F, 0.9335926182F, 0.9337750434F, 0.9339571380F,
                  0.9341389023F, 0.9343203366F, 0.9345014409F, 0.9346822155F,
                  0.9348626606F, 0.9350427763F, 0.9352225630F, 0.9354020207F,
                  0.9355811498F, 0.9357599503F, 0.9359384226F, 0.9361165667F,
                  0.9362943830F, 0.9364718716F, 0.9366490327F, 0.9368258666F,
                  0.9370023733F, 0.9371785533F, 0.9373544066F, 0.9375299335F,
                  0.9377051341F, 0.9378800087F, 0.9380545576F, 0.9382287809F,
                  0.9384026787F, 0.9385762515F, 0.9387494993F, 0.9389224223F,
                  0.9390950209F, 0.9392672951F, 0.9394392453F, 0.9396108716F,
                  0.9397821743F, 0.9399531536F, 0.9401238096F, 0.9402941427F,
                  0.9404641530F, 0.9406338407F, 0.9408032061F, 0.9409722495F,
                  0.9411409709F, 0.9413093707F, 0.9414774491F, 0.9416452062F,
                  0.9418126424F, 0.9419797579F, 0.9421465528F, 0.9423130274F,
                  0.9424791819F, 0.9426450166F, 0.9428105317F, 0.9429757274F,
                  0.9431406039F, 0.9433051616F, 0.9434694005F, 0.9436333209F,
                  0.9437969232F, 0.9439602074F, 0.9441231739F, 0.9442858229F,
                  0.9444481545F, 0.9446101691F, 0.9447718669F, 0.9449332481F,
                  0.9450943129F, 0.9452550617F, 0.9454154945F, 0.9455756118F,
                  0.9457354136F, 0.9458949003F, 0.9460540721F, 0.9462129292F,
                  0.9463714719F, 0.9465297003F, 0.9466876149F, 0.9468452157F,
                  0.9470025031F, 0.9471594772F, 0.9473161384F, 0.9474724869F,
                  0.9476285229F, 0.9477842466F, 0.9479396584F, 0.9480947585F,
                  0.9482495470F, 0.9484040243F, 0.9485581906F, 0.9487120462F,
                  0.9488655913F, 0.9490188262F, 0.9491717511F, 0.9493243662F,
                  0.9494766718F, 0.9496286683F, 0.9497803557F, 0.9499317345F,
                  0.9500828047F, 0.9502335668F, 0.9503840209F, 0.9505341673F,
                  0.9506840062F, 0.9508335380F, 0.9509827629F, 0.9511316810F,
                  0.9512802928F, 0.9514285984F, 0.9515765982F, 0.9517242923F,
                  0.9518716810F, 0.9520187646F, 0.9521655434F, 0.9523120176F,
                  0.9524581875F, 0.9526040534F, 0.9527496154F, 0.9528948739F,
                  0.9530398292F, 0.9531844814F, 0.9533288310F, 0.9534728780F,
                  0.9536166229F, 0.9537600659F, 0.9539032071F, 0.9540460470F,
                  0.9541885858F, 0.9543308237F, 0.9544727611F, 0.9546143981F,
                  0.9547557351F, 0.9548967723F, 0.9550375100F, 0.9551779485F,
                  0.9553180881F, 0.9554579290F, 0.9555974714F, 0.9557367158F,
                  0.9558756623F, 0.9560143112F, 0.9561526628F, 0.9562907174F,
                  0.9564284752F, 0.9565659366F, 0.9567031017F, 0.9568399710F,
                  0.9569765446F, 0.9571128229F, 0.9572488061F, 0.9573844944F,
                  0.9575198883F, 0.9576549879F, 0.9577897936F, 0.9579243056F,
                  0.9580585242F, 0.9581924497F, 0.9583260824F, 0.9584594226F,
                  0.9585924705F, 0.9587252264F, 0.9588576906F, 0.9589898634F,
                  0.9591217452F, 0.9592533360F, 0.9593846364F, 0.9595156465F,
                  0.9596463666F, 0.9597767971F, 0.9599069382F, 0.9600367901F,
                  0.9601663533F, 0.9602956279F, 0.9604246143F, 0.9605533128F,
                  0.9606817236F, 0.9608098471F, 0.9609376835F, 0.9610652332F,
                  0.9611924963F, 0.9613194733F, 0.9614461644F, 0.9615725699F,
                  0.9616986901F, 0.9618245253F, 0.9619500757F, 0.9620753418F,
                  0.9622003238F, 0.9623250219F, 0.9624494365F, 0.9625735679F,
                  0.9626974163F, 0.9628209821F, 0.9629442656F, 0.9630672671F,
                  0.9631899868F, 0.9633124251F, 0.9634345822F, 0.9635564585F,
                  0.9636780543F, 0.9637993699F, 0.9639204056F, 0.9640411616F,
                  0.9641616383F, 0.9642818359F, 0.9644017549F, 0.9645213955F,
                  0.9646407579F, 0.9647598426F, 0.9648786497F, 0.9649971797F,
                  0.9651154328F, 0.9652334092F, 0.9653511095F, 0.9654685337F,
                  0.9655856823F, 0.9657025556F, 0.9658191538F, 0.9659354773F,
                  0.9660515263F, 0.9661673013F, 0.9662828024F, 0.9663980300F,
                  0.9665129845F, 0.9666276660F, 0.9667420750F, 0.9668562118F,
                  0.9669700766F, 0.9670836698F, 0.9671969917F, 0.9673100425F,
                  0.9674228227F, 0.9675353325F, 0.9676475722F, 0.9677595422F,
                  0.9678712428F, 0.9679826742F, 0.9680938368F, 0.9682047309F,
                  0.9683153569F, 0.9684257150F, 0.9685358056F, 0.9686456289F,
                  0.9687551853F, 0.9688644752F, 0.9689734987F, 0.9690822564F,
                  0.9691907483F, 0.9692989750F, 0.9694069367F, 0.9695146337F,
                  0.9696220663F, 0.9697292349F, 0.9698361398F, 0.9699427813F,
                  0.9700491597F, 0.9701552754F, 0.9702611286F, 0.9703667197F,
                  0.9704720490F, 0.9705771169F, 0.9706819236F, 0.9707864695F,
                  0.9708907549F, 0.9709947802F, 0.9710985456F, 0.9712020514F,
                  0.9713052981F, 0.9714082859F, 0.9715110151F, 0.9716134862F,
                  0.9717156993F, 0.9718176549F, 0.9719193532F, 0.9720207946F,
                  0.9721219794F, 0.9722229080F, 0.9723235806F, 0.9724239976F,
                  0.9725241593F, 0.9726240661F, 0.9727237183F, 0.9728231161F,
                  0.9729222601F, 0.9730211503F, 0.9731197873F, 0.9732181713F,
                  0.9733163027F, 0.9734141817F, 0.9735118088F, 0.9736091842F,
                  0.9737063083F, 0.9738031814F, 0.9738998039F, 0.9739961760F,
                  0.9740922981F, 0.9741881706F, 0.9742837938F, 0.9743791680F,
                  0.9744742935F, 0.9745691707F, 0.9746637999F, 0.9747581814F,
                  0.9748523157F, 0.9749462029F, 0.9750398435F, 0.9751332378F,
                  0.9752263861F, 0.9753192887F, 0.9754119461F, 0.9755043585F,
                  0.9755965262F, 0.9756884496F, 0.9757801291F, 0.9758715650F,
                  0.9759627575F, 0.9760537071F, 0.9761444141F, 0.9762348789F,
                  0.9763251016F, 0.9764150828F, 0.9765048228F, 0.9765943218F,
                  0.9766835802F, 0.9767725984F, 0.9768613767F, 0.9769499154F,
                  0.9770382149F, 0.9771262755F, 0.9772140976F, 0.9773016815F,
                  0.9773890275F, 0.9774761360F, 0.9775630073F, 0.9776496418F,
                  0.9777360398F, 0.9778222016F, 0.9779081277F, 0.9779938182F,
                  0.9780792736F, 0.9781644943F, 0.9782494805F, 0.9783342326F,
                  0.9784187509F, 0.9785030359F, 0.9785870877F, 0.9786709069F,
                  0.9787544936F, 0.9788378484F, 0.9789209714F, 0.9790038631F,
                  0.9790865238F, 0.9791689538F, 0.9792511535F, 0.9793331232F,
                  0.9794148633F, 0.9794963742F, 0.9795776561F, 0.9796587094F,
                  0.9797395345F, 0.9798201316F, 0.9799005013F, 0.9799806437F,
                  0.9800605593F, 0.9801402483F, 0.9802197112F, 0.9802989483F,
                  0.9803779600F, 0.9804567465F, 0.9805353082F, 0.9806136455F,
                  0.9806917587F, 0.9807696482F, 0.9808473143F, 0.9809247574F,
                  0.9810019778F, 0.9810789759F, 0.9811557519F, 0.9812323064F,
                  0.9813086395F, 0.9813847517F, 0.9814606433F, 0.9815363147F,
                  0.9816117662F, 0.9816869981F, 0.9817620108F, 0.9818368047F,
                  0.9819113801F, 0.9819857374F, 0.9820598769F, 0.9821337989F,
                  0.9822075038F, 0.9822809920F, 0.9823542638F, 0.9824273195F,
                  0.9825001596F, 0.9825727843F, 0.9826451940F, 0.9827173891F,
                  0.9827893700F, 0.9828611368F, 0.9829326901F, 0.9830040302F,
                  0.9830751574F, 0.9831460720F, 0.9832167745F, 0.9832872652F,
                  0.9833575444F, 0.9834276124F, 0.9834974697F, 0.9835671166F,
                  0.9836365535F, 0.9837057806F, 0.9837747983F, 0.9838436071F,
                  0.9839122072F, 0.9839805990F, 0.9840487829F, 0.9841167591F,
                  0.9841845282F, 0.9842520903F, 0.9843194459F, 0.9843865953F,
                  0.9844535389F, 0.9845202771F, 0.9845868101F, 0.9846531383F,
                  0.9847192622F, 0.9847851820F, 0.9848508980F, 0.9849164108F,
                  0.9849817205F, 0.9850468276F, 0.9851117324F, 0.9851764352F,
                  0.9852409365F, 0.9853052366F, 0.9853693358F, 0.9854332344F,
                  0.9854969330F, 0.9855604317F, 0.9856237309F, 0.9856868310F,
                  0.9857497325F, 0.9858124355F, 0.9858749404F, 0.9859372477F,
                  0.9859993577F, 0.9860612707F, 0.9861229871F, 0.9861845072F,
                  0.9862458315F, 0.9863069601F, 0.9863678936F, 0.9864286322F,
                  0.9864891764F, 0.9865495264F, 0.9866096826F, 0.9866696454F,
                  0.9867294152F, 0.9867889922F, 0.9868483769F, 0.9869075695F,
                  0.9869665706F, 0.9870253803F, 0.9870839991F, 0.9871424273F,
                  0.9872006653F, 0.9872587135F, 0.9873165721F, 0.9873742415F,
                  0.9874317222F, 0.9874890144F, 0.9875461185F, 0.9876030348F,
                  0.9876597638F, 0.9877163057F, 0.9877726610F, 0.9878288300F,
                  0.9878848130F, 0.9879406104F, 0.9879962225F, 0.9880516497F,
                  0.9881068924F, 0.9881619509F, 0.9882168256F, 0.9882715168F,
                  0.9883260249F, 0.9883803502F, 0.9884344931F, 0.9884884539F,
                  0.9885422331F, 0.9885958309F, 0.9886492477F, 0.9887024838F,
                  0.9887555397F, 0.9888084157F, 0.9888611120F, 0.9889136292F,
                  0.9889659675F, 0.9890181273F, 0.9890701089F, 0.9891219128F,
                  0.9891735392F, 0.9892249885F, 0.9892762610F, 0.9893273572F,
                  0.9893782774F, 0.9894290219F, 0.9894795911F, 0.9895299853F,
                  0.9895802049F, 0.9896302502F, 0.9896801217F, 0.9897298196F,
                  0.9897793443F, 0.9898286961F, 0.9898778755F, 0.9899268828F,
                  0.9899757183F, 0.9900243823F, 0.9900728753F, 0.9901211976F,
                  0.9901693495F, 0.9902173314F, 0.9902651436F, 0.9903127865F,
                  0.9903602605F, 0.9904075659F, 0.9904547031F, 0.9905016723F,
                  0.9905484740F, 0.9905951086F, 0.9906415763F, 0.9906878775F,
                  0.9907340126F, 0.9907799819F, 0.9908257858F, 0.9908714247F,
                  0.9909168988F, 0.9909622086F, 0.9910073543F, 0.9910523364F,
                  0.9910971552F, 0.9911418110F, 0.9911863042F, 0.9912306351F,
                  0.9912748042F, 0.9913188117F, 0.9913626580F, 0.9914063435F,
                  0.9914498684F, 0.9914932333F, 0.9915364383F, 0.9915794839F,
                  0.9916223703F, 0.9916650981F, 0.9917076674F, 0.9917500787F,
                  0.9917923323F, 0.9918344286F, 0.9918763679F, 0.9919181505F,
                  0.9919597769F, 0.9920012473F, 0.9920425621F, 0.9920837217F,
                  0.9921247263F, 0.9921655765F, 0.9922062724F, 0.9922468145F,
                  0.9922872030F, 0.9923274385F, 0.9923675211F, 0.9924074513F,
                  0.9924472294F, 0.9924868557F, 0.9925263306F, 0.9925656544F,
                  0.9926048275F, 0.9926438503F, 0.9926827230F, 0.9927214461F,
                  0.9927600199F, 0.9927984446F, 0.9928367208F, 0.9928748486F,
                  0.9929128285F, 0.9929506608F, 0.9929883459F, 0.9930258841F,
                  0.9930632757F, 0.9931005211F, 0.9931376207F, 0.9931745747F,
                  0.9932113836F, 0.9932480476F, 0.9932845671F, 0.9933209425F,
                  0.9933571742F, 0.9933932623F, 0.9934292074F, 0.9934650097F,
                  0.9935006696F, 0.9935361874F, 0.9935715635F, 0.9936067982F,
                  0.9936418919F, 0.9936768448F, 0.9937116574F, 0.9937463300F,
                  0.9937808629F, 0.9938152565F, 0.9938495111F, 0.9938836271F,
                  0.9939176047F, 0.9939514444F, 0.9939851465F, 0.9940187112F,
                  0.9940521391F, 0.9940854303F, 0.9941185853F, 0.9941516044F,
                  0.9941844879F, 0.9942172361F, 0.9942498495F, 0.9942823283F,
                  0.9943146729F, 0.9943468836F, 0.9943789608F, 0.9944109047F,
                  0.9944427158F, 0.9944743944F, 0.9945059408F, 0.9945373553F,
                  0.9945686384F, 0.9945997902F, 0.9946308112F, 0.9946617017F,
                  0.9946924621F, 0.9947230926F, 0.9947535937F, 0.9947839656F,
                  0.9948142086F, 0.9948443232F, 0.9948743097F, 0.9949041683F,
                  0.9949338995F, 0.9949635035F, 0.9949929807F, 0.9950223315F,
                  0.9950515561F, 0.9950806549F, 0.9951096282F, 0.9951384764F,
                  0.9951671998F, 0.9951957987F, 0.9952242735F, 0.9952526245F,
                  0.9952808520F, 0.9953089564F, 0.9953369380F, 0.9953647971F,
                  0.9953925340F, 0.9954201491F, 0.9954476428F, 0.9954750153F,
                  0.9955022670F, 0.9955293981F, 0.9955564092F, 0.9955833003F,
                  0.9956100720F, 0.9956367245F, 0.9956632582F, 0.9956896733F,
                  0.9957159703F, 0.9957421494F, 0.9957682110F, 0.9957941553F,
                  0.9958199828F, 0.9958456937F, 0.9958712884F, 0.9958967672F,
                  0.9959221305F, 0.9959473784F, 0.9959725115F, 0.9959975300F,
                  0.9960224342F, 0.9960472244F, 0.9960719011F, 0.9960964644F,
                  0.9961209148F, 0.9961452525F, 0.9961694779F, 0.9961935913F,
                  0.9962175930F, 0.9962414834F, 0.9962652627F, 0.9962889313F,
                  0.9963124895F, 0.9963359377F, 0.9963592761F, 0.9963825051F,
                  0.9964056250F, 0.9964286361F, 0.9964515387F, 0.9964743332F,
                  0.9964970198F, 0.9965195990F, 0.9965420709F, 0.9965644360F,
                  0.9965866946F, 0.9966088469F, 0.9966308932F, 0.9966528340F,
                  0.9966746695F, 0.9966964001F, 0.9967180260F, 0.9967395475F,
                  0.9967609651F, 0.9967822789F, 0.9968034894F, 0.9968245968F,
                  0.9968456014F, 0.9968665036F, 0.9968873037F, 0.9969080019F,
                  0.9969285987F, 0.9969490942F, 0.9969694889F, 0.9969897830F,
                  0.9970099769F, 0.9970300708F, 0.9970500651F, 0.9970699601F,
                  0.9970897561F, 0.9971094533F, 0.9971290522F, 0.9971485531F,
                  0.9971679561F, 0.9971872617F, 0.9972064702F, 0.9972255818F,
                  0.9972445968F, 0.9972635157F, 0.9972823386F, 0.9973010659F,
                  0.9973196980F, 0.9973382350F, 0.9973566773F, 0.9973750253F,
                  0.9973932791F, 0.9974114392F, 0.9974295059F, 0.9974474793F,
                  0.9974653599F, 0.9974831480F, 0.9975008438F, 0.9975184476F,
                  0.9975359598F, 0.9975533806F, 0.9975707104F, 0.9975879495F,
                  0.9976050981F, 0.9976221566F, 0.9976391252F, 0.9976560043F,
                  0.9976727941F, 0.9976894950F, 0.9977061073F, 0.9977226312F,
                  0.9977390671F, 0.9977554152F, 0.9977716759F, 0.9977878495F,
                  0.9978039361F, 0.9978199363F, 0.9978358501F, 0.9978516780F,
                  0.9978674202F, 0.9978830771F, 0.9978986488F, 0.9979141358F,
                  0.9979295383F, 0.9979448566F, 0.9979600909F, 0.9979752417F,
                  0.9979903091F, 0.9980052936F, 0.9980201952F, 0.9980350145F,
                  0.9980497515F, 0.9980644067F, 0.9980789804F, 0.9980934727F,
                  0.9981078841F, 0.9981222147F, 0.9981364649F, 0.9981506350F,
                  0.9981647253F, 0.9981787360F, 0.9981926674F, 0.9982065199F,
                  0.9982202936F, 0.9982339890F, 0.9982476062F, 0.9982611456F,
                  0.9982746074F, 0.9982879920F, 0.9983012996F, 0.9983145304F,
                  0.9983276849F, 0.9983407632F, 0.9983537657F, 0.9983666926F,
                  0.9983795442F, 0.9983923208F, 0.9984050226F, 0.9984176501F,
                  0.9984302033F, 0.9984426827F, 0.9984550884F, 0.9984674208F,
                  0.9984796802F, 0.9984918667F, 0.9985039808F, 0.9985160227F,
                  0.9985279926F, 0.9985398909F, 0.9985517177F, 0.9985634734F,
                  0.9985751583F, 0.9985867727F, 0.9985983167F, 0.9986097907F,
                  0.9986211949F, 0.9986325297F, 0.9986437953F, 0.9986549919F,
                  0.9986661199F, 0.9986771795F, 0.9986881710F, 0.9986990946F,
                  0.9987099507F, 0.9987207394F, 0.9987314611F, 0.9987421161F,
                  0.9987527045F, 0.9987632267F, 0.9987736829F, 0.9987840734F,
                  0.9987943985F, 0.9988046584F, 0.9988148534F, 0.9988249838F,
                  0.9988350498F, 0.9988450516F, 0.9988549897F, 0.9988648641F,
                  0.9988746753F, 0.9988844233F, 0.9988941086F, 0.9989037313F,
                  0.9989132918F, 0.9989227902F, 0.9989322269F, 0.9989416021F,
                  0.9989509160F, 0.9989601690F, 0.9989693613F, 0.9989784931F,
                  0.9989875647F, 0.9989965763F, 0.9990055283F, 0.9990144208F,
                  0.9990232541F, 0.9990320286F, 0.9990407443F, 0.9990494016F,
                  0.9990580008F, 0.9990665421F, 0.9990750257F, 0.9990834519F,
                  0.9990918209F, 0.9991001331F, 0.9991083886F, 0.9991165877F,
                  0.9991247307F, 0.9991328177F, 0.9991408491F, 0.9991488251F,
                  0.9991567460F, 0.9991646119F, 0.9991724232F, 0.9991801801F,
                  0.9991878828F, 0.9991955316F, 0.9992031267F, 0.9992106684F,
                  0.9992181569F, 0.9992255925F, 0.9992329753F, 0.9992403057F,
                  0.9992475839F, 0.9992548101F, 0.9992619846F, 0.9992691076F,
                  0.9992761793F, 0.9992832001F, 0.9992901701F, 0.9992970895F,
                  0.9993039587F, 0.9993107777F, 0.9993175470F, 0.9993242667F,
                  0.9993309371F, 0.9993375583F, 0.9993441307F, 0.9993506545F,
                  0.9993571298F, 0.9993635570F, 0.9993699362F, 0.9993762678F,
                  0.9993825519F, 0.9993887887F, 0.9993949785F, 0.9994011216F,
                  0.9994072181F, 0.9994132683F, 0.9994192725F, 0.9994252307F,
                  0.9994311434F, 0.9994370107F, 0.9994428327F, 0.9994486099F,
                  0.9994543423F, 0.9994600303F, 0.9994656739F, 0.9994712736F,
                  0.9994768294F, 0.9994823417F, 0.9994878105F, 0.9994932363F,
                  0.9994986191F, 0.9995039592F, 0.9995092568F, 0.9995145122F,
                  0.9995197256F, 0.9995248971F, 0.9995300270F, 0.9995351156F,
                  0.9995401630F, 0.9995451695F, 0.9995501352F, 0.9995550604F,
                  0.9995599454F, 0.9995647903F, 0.9995695953F, 0.9995743607F,
                  0.9995790866F, 0.9995837734F, 0.9995884211F, 0.9995930300F,
                  0.9995976004F, 0.9996021324F, 0.9996066263F, 0.9996110822F,
                  0.9996155004F, 0.9996198810F, 0.9996242244F, 0.9996285306F,
                  0.9996327999F, 0.9996370326F, 0.9996412287F, 0.9996453886F,
                  0.9996495125F, 0.9996536004F, 0.9996576527F, 0.9996616696F,
                  0.9996656512F, 0.9996695977F, 0.9996735094F, 0.9996773865F,
                  0.9996812291F, 0.9996850374F, 0.9996888118F, 0.9996925523F,
                  0.9996962591F, 0.9996999325F, 0.9997035727F, 0.9997071798F,
                  0.9997107541F, 0.9997142957F, 0.9997178049F, 0.9997212818F,
                  0.9997247266F, 0.9997281396F, 0.9997315209F, 0.9997348708F,
                  0.9997381893F, 0.9997414767F, 0.9997447333F, 0.9997479591F,
                  0.9997511544F, 0.9997543194F, 0.9997574542F, 0.9997605591F,
                  0.9997636342F, 0.9997666797F, 0.9997696958F, 0.9997726828F,
                  0.9997756407F, 0.9997785698F, 0.9997814703F, 0.9997843423F,
                  0.9997871860F, 0.9997900016F, 0.9997927894F, 0.9997955494F,
                  0.9997982818F, 0.9998009869F, 0.9998036648F, 0.9998063157F,
                  0.9998089398F, 0.9998115373F, 0.9998141082F, 0.9998166529F,
                  0.9998191715F, 0.9998216642F, 0.9998241311F, 0.9998265724F,
                  0.9998289884F, 0.9998313790F, 0.9998337447F, 0.9998360854F,
                  0.9998384015F, 0.9998406930F, 0.9998429602F, 0.9998452031F,
                  0.9998474221F, 0.9998496171F, 0.9998517885F, 0.9998539364F,
                  0.9998560610F, 0.9998581624F, 0.9998602407F, 0.9998622962F,
                  0.9998643291F, 0.9998663394F, 0.9998683274F, 0.9998702932F,
                  0.9998722370F, 0.9998741589F, 0.9998760591F, 0.9998779378F,
                  0.9998797952F, 0.9998816313F, 0.9998834464F, 0.9998852406F,
                  0.9998870141F, 0.9998887670F, 0.9998904995F, 0.9998922117F,
                  0.9998939039F, 0.9998955761F, 0.9998972285F, 0.9998988613F,
                  0.9999004746F, 0.9999020686F, 0.9999036434F, 0.9999051992F,
                  0.9999067362F, 0.9999082544F, 0.9999097541F, 0.9999112354F,
                  0.9999126984F, 0.9999141433F, 0.9999155703F, 0.9999169794F,
                  0.9999183709F, 0.9999197449F, 0.9999211014F, 0.9999224408F,
                  0.9999237631F, 0.9999250684F, 0.9999263570F, 0.9999276289F,
                  0.9999288843F, 0.9999301233F, 0.9999313461F, 0.9999325529F,
                  0.9999337437F, 0.9999349187F, 0.9999360780F, 0.9999372218F,
                  0.9999383503F, 0.9999394635F, 0.9999405616F, 0.9999416447F,
                  0.9999427129F, 0.9999437665F, 0.9999448055F, 0.9999458301F,
                  0.9999468404F, 0.9999478365F, 0.9999488185F, 0.9999497867F,
                  0.9999507411F, 0.9999516819F, 0.9999526091F, 0.9999535230F,
                  0.9999544236F, 0.9999553111F, 0.9999561856F, 0.9999570472F,
                  0.9999578960F, 0.9999587323F, 0.9999595560F, 0.9999603674F,
                  0.9999611666F, 0.9999619536F, 0.9999627286F, 0.9999634917F,
                  0.9999642431F, 0.9999649828F, 0.9999657110F, 0.9999664278F,
                  0.9999671334F, 0.9999678278F, 0.9999685111F, 0.9999691835F,
                  0.9999698451F, 0.9999704960F, 0.9999711364F, 0.9999717662F,
                  0.9999723858F, 0.9999729950F, 0.9999735942F, 0.9999741834F,
                  0.9999747626F, 0.9999753321F, 0.9999758919F, 0.9999764421F,
                  0.9999769828F, 0.9999775143F, 0.9999780364F, 0.9999785495F,
                  0.9999790535F, 0.9999795485F, 0.9999800348F, 0.9999805124F,
                  0.9999809813F, 0.9999814417F, 0.9999818938F, 0.9999823375F,
                  0.9999827731F, 0.9999832005F, 0.9999836200F, 0.9999840316F,
                  0.9999844353F, 0.9999848314F, 0.9999852199F, 0.9999856008F,
                  0.9999859744F, 0.9999863407F, 0.9999866997F, 0.9999870516F,
                  0.9999873965F, 0.9999877345F, 0.9999880656F, 0.9999883900F,
                  0.9999887078F, 0.9999890190F, 0.9999893237F, 0.9999896220F,
                  0.9999899140F, 0.9999901999F, 0.9999904796F, 0.9999907533F,
                  0.9999910211F, 0.9999912830F, 0.9999915391F, 0.9999917896F,
                  0.9999920345F, 0.9999922738F, 0.9999925077F, 0.9999927363F,
                  0.9999929596F, 0.9999931777F, 0.9999933907F, 0.9999935987F,
                  0.9999938018F, 0.9999940000F, 0.9999941934F, 0.9999943820F,
                  0.9999945661F, 0.9999947456F, 0.9999949206F, 0.9999950912F,
                  0.9999952575F, 0.9999954195F, 0.9999955773F, 0.9999957311F,
                  0.9999958807F, 0.9999960265F, 0.9999961683F, 0.9999963063F,
                  0.9999964405F, 0.9999965710F, 0.9999966979F, 0.9999968213F,
                  0.9999969412F, 0.9999970576F, 0.9999971707F, 0.9999972805F,
                  0.9999973871F, 0.9999974905F, 0.9999975909F, 0.9999976881F,
                  0.9999977824F, 0.9999978738F, 0.9999979624F, 0.9999980481F,
                  0.9999981311F, 0.9999982115F, 0.9999982892F, 0.9999983644F,
                  0.9999984370F, 0.9999985072F, 0.9999985750F, 0.9999986405F,
                  0.9999987037F, 0.9999987647F, 0.9999988235F, 0.9999988802F,
                  0.9999989348F, 0.9999989873F, 0.9999990379F, 0.9999990866F,
                  0.9999991334F, 0.9999991784F, 0.9999992217F, 0.9999992632F,
                  0.9999993030F, 0.9999993411F, 0.9999993777F, 0.9999994128F,
                  0.9999994463F, 0.9999994784F, 0.9999995091F, 0.9999995384F,
                  0.9999995663F, 0.9999995930F, 0.9999996184F, 0.9999996426F,
                  0.9999996657F, 0.9999996876F, 0.9999997084F, 0.9999997282F,
                  0.9999997469F, 0.9999997647F, 0.9999997815F, 0.9999997973F,
                  0.9999998123F, 0.9999998265F, 0.9999998398F, 0.9999998524F,
                  0.9999998642F, 0.9999998753F, 0.9999998857F, 0.9999998954F,
                  0.9999999045F, 0.9999999130F, 0.9999999209F, 0.9999999282F,
                  0.9999999351F, 0.9999999414F, 0.9999999472F, 0.9999999526F,
                  0.9999999576F, 0.9999999622F, 0.9999999664F, 0.9999999702F,
                  0.9999999737F, 0.9999999769F, 0.9999999798F, 0.9999999824F,
                  0.9999999847F, 0.9999999868F, 0.9999999887F, 0.9999999904F,
                  0.9999999919F, 0.9999999932F, 0.9999999943F, 0.9999999953F,
                  0.9999999961F, 0.9999999969F, 0.9999999975F, 0.9999999980F,
                  0.9999999985F, 0.9999999988F, 0.9999999991F, 0.9999999993F,
                  0.9999999995F, 0.9999999997F, 0.9999999998F, 0.9999999999F,
                  0.9999999999F, 1.0000000000F, 1.0000000000F, 1.0000000000F,
                  1.0000000000F, 1.0000000000F, 1.0000000000F, 1.0000000000F,
                };
                
                static const float *const vwin[8] = {
                  vwin64,
                  vwin128,
                  vwin256,
                  vwin512,
                  vwin1024,
                  vwin2048,
                  vwin4096,
                  vwin8192,
                };
                
        7768 -> const float *_vorbis_window_get(int n){
                  return vwin[n];
                }
                
                void _vorbis_apply_window(float *d,int *winno,long *blocksizes,
      257467 ->                           int lW,int W,int nW){
                  lW=(W?lW:0);
                  nW=(W?nW:0);
                
                  {
                    const float *windowLW=vwin[winno[lW]];
                    const float *windowNW=vwin[winno[nW]];
                
                    long n=blocksizes[W];
                    long ln=blocksizes[lW];
                    long rn=blocksizes[nW];
                
                    long leftbegin=n/4-ln/4;
                    long leftend=leftbegin+ln/2;
                
                    long rightbegin=n/2+n/4-rn/4;
                    long rightend=rightbegin+rn/2;
                
                    int i,p;
                
                    for(i=0;i<leftbegin;i++)
                      d[i]=0.f;
                
                    for(p=0;i<leftend;i++,p++)
                      d[i]*=windowLW[p];
                
                    for(i=rightbegin,p=rn/2-1;i<rightend;i++,p--)
                      d[i]*=windowNW[p];
                
                    for(;i<n;i++)
                      d[i]=0.f;
                  }
                }


Top 10 Lines:

     Line      Count

     2103     257467
     2098       7768

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

   265235   Total number of line executions
132617.50   Average executions per line


*** File C:\cygwin\workspace\_git_repos\CustomizeVorbis_static\GprofCdt/../lib/bitrate.c:
                /********************************************************************
                 *                                                                  *
                 * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
                 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
                 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
                 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
                 *                                                                  *
                 * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
                 * by the Xiph.Org Foundation http://www.xiph.org/                  *
                 *                                                                  *
                 ********************************************************************
                
                 function: bitrate tracking and management
                 last mod: $Id: bitrate.c 16227 2009-07-08 06:58:46Z xiphmont $
                
                 ********************************************************************/
                
                #include <stdlib.h>
                #include <string.h>
                #include <math.h>
                #include <ogg/ogg.h>
                #include "vorbis/codec.h"
                #include "codec_internal.h"
                #include "os.h"
                #include "misc.h"
                #include "bitrate.h"
                
                /* compute bitrate tracking setup  */
       ##### -> void vorbis_bitrate_init(vorbis_info *vi,bitrate_manager_state *bm){
                  codec_setup_info *ci=vi->codec_setup;
                  bitrate_manager_info *bi=&ci->bi;
                
                  memset(bm,0,sizeof(*bm));
                
                  if(bi && (bi->reservoir_bits>0)){
                    long ratesamples=vi->rate;
                    int  halfsamples=ci->blocksizes[0]>>1;
                
                    bm->short_per_long=ci->blocksizes[1]/ci->blocksizes[0];
                    bm->managed=1;
                
                    bm->avg_bitsper= rint(1.*bi->avg_rate*halfsamples/ratesamples);
                    bm->min_bitsper= rint(1.*bi->min_rate*halfsamples/ratesamples);
                    bm->max_bitsper= rint(1.*bi->max_rate*halfsamples/ratesamples);
                
                    bm->avgfloat=PACKETBLOBS/2;
                
                    /* not a necessary fix, but one that leads to a more balanced
                       typical initialization */
                    {
                      long desired_fill=bi->reservoir_bits*bi->reservoir_bias;
                      bm->minmax_reservoir=desired_fill;
                      bm->avg_reservoir=desired_fill;
                    }
                
                  }
                }
                
           4 -> void vorbis_bitrate_clear(bitrate_manager_state *bm){
                  memset(bm,0,sizeof(*bm));
                  return;
                }
                
       ##### -> int vorbis_bitrate_managed(vorbis_block *vb){
                  vorbis_dsp_state      *vd=vb->vd;
                  private_state         *b=vd->backend_state;
                  bitrate_manager_state *bm=&b->bms;
                
                  if(bm && bm->managed)return(1);
                  return(0);
                }
                
                /* finish taking in the block we just processed */
       ##### -> int vorbis_bitrate_addblock(vorbis_block *vb){
                  vorbis_block_internal *vbi=vb->internal;
                  vorbis_dsp_state      *vd=vb->vd;
                  private_state         *b=vd->backend_state;
                  bitrate_manager_state *bm=&b->bms;
                  vorbis_info           *vi=vd->vi;
                  codec_setup_info      *ci=vi->codec_setup;
                  bitrate_manager_info  *bi=&ci->bi;
                
                  int  choice=rint(bm->avgfloat);
                  long this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
                  long min_target_bits=(vb->W?bm->min_bitsper*bm->short_per_long:bm->min_bitsper);
                  long max_target_bits=(vb->W?bm->max_bitsper*bm->short_per_long:bm->max_bitsper);
                  int  samples=ci->blocksizes[vb->W]>>1;
                  long desired_fill=bi->reservoir_bits*bi->reservoir_bias;
                  if(!bm->managed){
                    /* not a bitrate managed stream, but for API simplicity, we'll
                       buffer the packet to keep the code path clean */
                
                    if(bm->vb)return(-1); /* one has been submitted without
                                             being claimed */
                    bm->vb=vb;
                    return(0);
                  }
                
                  bm->vb=vb;
                
                  /* look ahead for avg floater */
                  if(bm->avg_bitsper>0){
                    double slew=0.;
                    long avg_target_bits=(vb->W?bm->avg_bitsper*bm->short_per_long:bm->avg_bitsper);
                    double slewlimit= 15./bi->slew_damp;
                
                    /* choosing a new floater:
                       if we're over target, we slew down
                       if we're under target, we slew up
                
                       choose slew as follows: look through packetblobs of this frame
                       and set slew as the first in the appropriate direction that
                       gives us the slew we want.  This may mean no slew if delta is
                       already favorable.
                
                       Then limit slew to slew max */
                
                    if(bm->avg_reservoir+(this_bits-avg_target_bits)>desired_fill){
                      while(choice>0 && this_bits>avg_target_bits &&
                            bm->avg_reservoir+(this_bits-avg_target_bits)>desired_fill){
                        choice--;
                        this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
                      }
                    }else if(bm->avg_reservoir+(this_bits-avg_target_bits)<desired_fill){
                      while(choice+1<PACKETBLOBS && this_bits<avg_target_bits &&
                            bm->avg_reservoir+(this_bits-avg_target_bits)<desired_fill){
                        choice++;
                        this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
                      }
                    }
                
                    slew=rint(choice-bm->avgfloat)/samples*vi->rate;
                    if(slew<-slewlimit)slew=-slewlimit;
                    if(slew>slewlimit)slew=slewlimit;
                    choice=rint(bm->avgfloat+= slew/vi->rate*samples);
                    this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
                  }
                
                
                
                  /* enforce min(if used) on the current floater (if used) */
                  if(bm->min_bitsper>0){
                    /* do we need to force the bitrate up? */
                    if(this_bits<min_target_bits){
                      while(bm->minmax_reservoir-(min_target_bits-this_bits)<0){
                        choice++;
                        if(choice>=PACKETBLOBS)break;
                        this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
                      }
                    }
                  }
                
                  /* enforce max (if used) on the current floater (if used) */
                  if(bm->max_bitsper>0){
                    /* do we need to force the bitrate down? */
                    if(this_bits>max_target_bits){
                      while(bm->minmax_reservoir+(this_bits-max_target_bits)>bi->reservoir_bits){
                        choice--;
                        if(choice<0)break;
                        this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
                      }
                    }
                  }
                
                  /* Choice of packetblobs now made based on floater, and min/max
                     requirements. Now boundary check extreme choices */
                
                  if(choice<0){
                    /* choosing a smaller packetblob is insufficient to trim bitrate.
                       frame will need to be truncated */
                    long maxsize=(max_target_bits+(bi->reservoir_bits-bm->minmax_reservoir))/8;
                    bm->choice=choice=0;
                
                    if(oggpack_bytes(vbi->packetblob[choice])>maxsize){
                
                      oggpack_writetrunc(vbi->packetblob[choice],maxsize*8);
                      this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
                    }
                  }else{
                    long minsize=(min_target_bits-bm->minmax_reservoir+7)/8;
                    if(choice>=PACKETBLOBS)
                      choice=PACKETBLOBS-1;
                
                    bm->choice=choice;
                
                    /* prop up bitrate according to demand. pad this frame out with zeroes */
                    minsize-=oggpack_bytes(vbi->packetblob[choice]);
                    while(minsize-->0)oggpack_write(vbi->packetblob[choice],0,8);
                    this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
                
                  }
                
                  /* now we have the final packet and the final packet size.  Update statistics */
                  /* min and max reservoir */
                  if(bm->min_bitsper>0 || bm->max_bitsper>0){
                
                    if(max_target_bits>0 && this_bits>max_target_bits){
                      bm->minmax_reservoir+=(this_bits-max_target_bits);
                    }else if(min_target_bits>0 && this_bits<min_target_bits){
                      bm->minmax_reservoir+=(this_bits-min_target_bits);
                    }else{
                      /* inbetween; we want to take reservoir toward but not past desired_fill */
                      if(bm->minmax_reservoir>desired_fill){
                        if(max_target_bits>0){ /* logical bulletproofing against initialization state */
                          bm->minmax_reservoir+=(this_bits-max_target_bits);
                          if(bm->minmax_reservoir<desired_fill)bm->minmax_reservoir=desired_fill;
                        }else{
                          bm->minmax_reservoir=desired_fill;
                        }
                      }else{
                        if(min_target_bits>0){ /* logical bulletproofing against initialization state */
                          bm->minmax_reservoir+=(this_bits-min_target_bits);
                          if(bm->minmax_reservoir>desired_fill)bm->minmax_reservoir=desired_fill;
                        }else{
                          bm->minmax_reservoir=desired_fill;
                        }
                      }
                    }
                  }
                
                  /* avg reservoir */
                  if(bm->avg_bitsper>0){
                    long avg_target_bits=(vb->W?bm->avg_bitsper*bm->short_per_long:bm->avg_bitsper);
                    bm->avg_reservoir+=this_bits-avg_target_bits;
                  }
                
                  return(0);
                }
                
       ##### -> int vorbis_bitrate_flushpacket(vorbis_dsp_state *vd,ogg_packet *op){
                  private_state         *b=vd->backend_state;
                  bitrate_manager_state *bm=&b->bms;
                  vorbis_block          *vb=bm->vb;
                  int                    choice=PACKETBLOBS/2;
                  if(!vb)return 0;
                
                  if(op){
                    vorbis_block_internal *vbi=vb->internal;
                
                    if(vorbis_bitrate_managed(vb))
                      choice=bm->choice;
                
                    op->packet=oggpack_get_buffer(vbi->packetblob[choice]);
                    op->bytes=oggpack_bytes(vbi->packetblob[choice]);
                    op->b_o_s=0;
                    op->e_o_s=vb->eofflag;
                    op->granulepos=vb->granulepos;
                    op->packetno=vb->sequence; /* for sake of completeness */
                  }
                
                  bm->vb=0;
                  return(1);
                }


Top 10 Lines:

     Line      Count

       59          4

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

        4   Total number of line executions
     0.80   Average executions per line


*** File C:\cygwin\workspace\_git_repos\CustomizeVorbis_static\GprofCdt/../lib/smallft.c:
                /********************************************************************
                 *                                                                  *
                 * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
                 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
                 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
                 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
                 *                                                                  *
                 * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
                 * by the Xiph.Org Foundation http://www.xiph.org/                  *
                 *                                                                  *
                 ********************************************************************
                
                 function: *unnormalized* fft transform
                 last mod: $Id: smallft.c 16227 2009-07-08 06:58:46Z xiphmont $
                
                 ********************************************************************/
                
                /* FFT implementation from OggSquish, minus cosine transforms,
                 * minus all but radix 2/4 case.  In Vorbis we only need this
                 * cut-down version.
                 *
                 * To do more than just power-of-two sized vectors, see the full
                 * version I wrote for NetLib.
                 *
                 * Note that the packing is a little strange; rather than the FFT r/i
                 * packing following R_0, I_n, R_1, I_1, R_2, I_2 ... R_n-1, I_n-1,
                 * it follows R_0, R_1, I_1, R_2, I_2 ... R_n-1, I_n-1, I_n like the
                 * FORTRAN version
                 */
                
                #include <stdlib.h>
                #include <string.h>
                #include <math.h>
                #include "smallft.h"
                #include "os.h"
                #include "misc.h"
                
                static void drfti1(int n, float *wa, int *ifac){
                  static int ntryh[4] = { 4,2,3,5 };
                  static float tpi = 6.28318530717958648f;
                  float arg,argh,argld,fi;
                  int ntry=0,i,j=-1;
                  int k1, l1, l2, ib;
                  int ld, ii, ip, is, nq, nr;
                  int ido, ipm, nfm1;
                  int nl=n;
                  int nf=0;
                
                 L101:
                  j++;
                  if (j < 4)
                    ntry=ntryh[j];
                  else
                    ntry+=2;
                
                 L104:
                  nq=nl/ntry;
                  nr=nl-ntry*nq;
                  if (nr!=0) goto L101;
                
                  nf++;
                  ifac[nf+1]=ntry;
                  nl=nq;
                  if(ntry!=2)goto L107;
                  if(nf==1)goto L107;
                
                  for (i=1;i<nf;i++){
                    ib=nf-i+1;
                    ifac[ib+1]=ifac[ib];
                  }
                  ifac[2] = 2;
                
                 L107:
                  if(nl!=1)goto L104;
                  ifac[0]=n;
                  ifac[1]=nf;
                  argh=tpi/n;
                  is=0;
                  nfm1=nf-1;
                  l1=1;
                
                  if(nfm1==0)return;
                
                  for (k1=0;k1<nfm1;k1++){
                    ip=ifac[k1+2];
                    ld=0;
                    l2=l1*ip;
                    ido=n/l2;
                    ipm=ip-1;
                
                    for (j=0;j<ipm;j++){
                      ld+=l1;
                      i=is;
                      argld=(float)ld*argh;
                      fi=0.f;
                      for (ii=2;ii<ido;ii+=2){
                        fi+=1.f;
                        arg=fi*argld;
                        wa[i++]=cos(arg);
                        wa[i++]=sin(arg);
                      }
                      is+=ido;
                    }
                    l1=l2;
                  }
                }
                
                static void fdrffti(int n, float *wsave, int *ifac){
                
                  if (n == 1) return;
                  drfti1(n, wsave+n, ifac);
                }
                
                static void dradf2(int ido,int l1,float *cc,float *ch,float *wa1){
                  int i,k;
                  float ti2,tr2;
                  int t0,t1,t2,t3,t4,t5,t6;
                
                  t1=0;
                  t0=(t2=l1*ido);
                  t3=ido<<1;
                  for(k=0;k<l1;k++){
                    ch[t1<<1]=cc[t1]+cc[t2];
                    ch[(t1<<1)+t3-1]=cc[t1]-cc[t2];
                    t1+=ido;
                    t2+=ido;
                  }
                
                  if(ido<2)return;
                  if(ido==2)goto L105;
                
                  t1=0;
                  t2=t0;
                  for(k=0;k<l1;k++){
                    t3=t2;
                    t4=(t1<<1)+(ido<<1);
                    t5=t1;
                    t6=t1+t1;
                    for(i=2;i<ido;i+=2){
                      t3+=2;
                      t4-=2;
                      t5+=2;
                      t6+=2;
                      tr2=wa1[i-2]*cc[t3-1]+wa1[i-1]*cc[t3];
                      ti2=wa1[i-2]*cc[t3]-wa1[i-1]*cc[t3-1];
                      ch[t6]=cc[t5]+ti2;
                      ch[t4]=ti2-cc[t5];
                      ch[t6-1]=cc[t5-1]+tr2;
                      ch[t4-1]=cc[t5-1]-tr2;
                    }
                    t1+=ido;
                    t2+=ido;
                  }
                
                  if(ido%2==1)return;
                
                 L105:
                  t3=(t2=(t1=ido)-1);
                  t2+=t0;
                  for(k=0;k<l1;k++){
                    ch[t1]=-cc[t2];
                    ch[t1-1]=cc[t3];
                    t1+=ido<<1;
                    t2+=ido;
                    t3+=ido;
                  }
                }
                
                static void dradf4(int ido,int l1,float *cc,float *ch,float *wa1,
                            float *wa2,float *wa3){
                  static float hsqt2 = .70710678118654752f;
                  int i,k,t0,t1,t2,t3,t4,t5,t6;
                  float ci2,ci3,ci4,cr2,cr3,cr4,ti1,ti2,ti3,ti4,tr1,tr2,tr3,tr4;
                  t0=l1*ido;
                
                  t1=t0;
                  t4=t1<<1;
                  t2=t1+(t1<<1);
                  t3=0;
                
                  for(k=0;k<l1;k++){
                    tr1=cc[t1]+cc[t2];
                    tr2=cc[t3]+cc[t4];
                
                    ch[t5=t3<<2]=tr1+tr2;
                    ch[(ido<<2)+t5-1]=tr2-tr1;
                    ch[(t5+=(ido<<1))-1]=cc[t3]-cc[t4];
                    ch[t5]=cc[t2]-cc[t1];
                
                    t1+=ido;
                    t2+=ido;
                    t3+=ido;
                    t4+=ido;
                  }
                
                  if(ido<2)return;
                  if(ido==2)goto L105;
                
                
                  t1=0;
                  for(k=0;k<l1;k++){
                    t2=t1;
                    t4=t1<<2;
                    t5=(t6=ido<<1)+t4;
                    for(i=2;i<ido;i+=2){
                      t3=(t2+=2);
                      t4+=2;
                      t5-=2;
                
                      t3+=t0;
                      cr2=wa1[i-2]*cc[t3-1]+wa1[i-1]*cc[t3];
                      ci2=wa1[i-2]*cc[t3]-wa1[i-1]*cc[t3-1];
                      t3+=t0;
                      cr3=wa2[i-2]*cc[t3-1]+wa2[i-1]*cc[t3];
                      ci3=wa2[i-2]*cc[t3]-wa2[i-1]*cc[t3-1];
                      t3+=t0;
                      cr4=wa3[i-2]*cc[t3-1]+wa3[i-1]*cc[t3];
                      ci4=wa3[i-2]*cc[t3]-wa3[i-1]*cc[t3-1];
                
                      tr1=cr2+cr4;
                      tr4=cr4-cr2;
                      ti1=ci2+ci4;
                      ti4=ci2-ci4;
                
                      ti2=cc[t2]+ci3;
                      ti3=cc[t2]-ci3;
                      tr2=cc[t2-1]+cr3;
                      tr3=cc[t2-1]-cr3;
                
                      ch[t4-1]=tr1+tr2;
                      ch[t4]=ti1+ti2;
                
                      ch[t5-1]=tr3-ti4;
                      ch[t5]=tr4-ti3;
                
                      ch[t4+t6-1]=ti4+tr3;
                      ch[t4+t6]=tr4+ti3;
                
                      ch[t5+t6-1]=tr2-tr1;
                      ch[t5+t6]=ti1-ti2;
                    }
                    t1+=ido;
                  }
                  if(ido&1)return;
                
                 L105:
                
                  t2=(t1=t0+ido-1)+(t0<<1);
                  t3=ido<<2;
                  t4=ido;
                  t5=ido<<1;
                  t6=ido;
                
                  for(k=0;k<l1;k++){
                    ti1=-hsqt2*(cc[t1]+cc[t2]);
                    tr1=hsqt2*(cc[t1]-cc[t2]);
                
                    ch[t4-1]=tr1+cc[t6-1];
                    ch[t4+t5-1]=cc[t6-1]-tr1;
                
                    ch[t4]=ti1-cc[t1+t0];
                    ch[t4+t5]=ti1+cc[t1+t0];
                
                    t1+=ido;
                    t2+=ido;
                    t4+=t3;
                    t6+=ido;
                  }
                }
                
                static void dradfg(int ido,int ip,int l1,int idl1,float *cc,float *c1,
                                          float *c2,float *ch,float *ch2,float *wa){
                
                  static float tpi=6.283185307179586f;
                  int idij,ipph,i,j,k,l,ic,ik,is;
                  int t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;
                  float dc2,ai1,ai2,ar1,ar2,ds2;
                  int nbd;
                  float dcp,arg,dsp,ar1h,ar2h;
                  int idp2,ipp2;
                
                  arg=tpi/(float)ip;
                  dcp=cos(arg);
                  dsp=sin(arg);
                  ipph=(ip+1)>>1;
                  ipp2=ip;
                  idp2=ido;
                  nbd=(ido-1)>>1;
                  t0=l1*ido;
                  t10=ip*ido;
                
                  if(ido==1)goto L119;
                  for(ik=0;ik<idl1;ik++)ch2[ik]=c2[ik];
                
                  t1=0;
                  for(j=1;j<ip;j++){
                    t1+=t0;
                    t2=t1;
                    for(k=0;k<l1;k++){
                      ch[t2]=c1[t2];
                      t2+=ido;
                    }
                  }
                
                  is=-ido;
                  t1=0;
                  if(nbd>l1){
                    for(j=1;j<ip;j++){
                      t1+=t0;
                      is+=ido;
                      t2= -ido+t1;
                      for(k=0;k<l1;k++){
                        idij=is-1;
                        t2+=ido;
                        t3=t2;
                        for(i=2;i<ido;i+=2){
                          idij+=2;
                          t3+=2;
                          ch[t3-1]=wa[idij-1]*c1[t3-1]+wa[idij]*c1[t3];
                          ch[t3]=wa[idij-1]*c1[t3]-wa[idij]*c1[t3-1];
                        }
                      }
                    }
                  }else{
                
                    for(j=1;j<ip;j++){
                      is+=ido;
                      idij=is-1;
                      t1+=t0;
                      t2=t1;
                      for(i=2;i<ido;i+=2){
                        idij+=2;
                        t2+=2;
                        t3=t2;
                        for(k=0;k<l1;k++){
                          ch[t3-1]=wa[idij-1]*c1[t3-1]+wa[idij]*c1[t3];
                          ch[t3]=wa[idij-1]*c1[t3]-wa[idij]*c1[t3-1];
                          t3+=ido;
                        }
                      }
                    }
                  }
                
                  t1=0;
                  t2=ipp2*t0;
                  if(nbd<l1){
                    for(j=1;j<ipph;j++){
                      t1+=t0;
                      t2-=t0;
                      t3=t1;
                      t4=t2;
                      for(i=2;i<ido;i+=2){
                        t3+=2;
                        t4+=2;
                        t5=t3-ido;
                        t6=t4-ido;
                        for(k=0;k<l1;k++){
                          t5+=ido;
                          t6+=ido;
                          c1[t5-1]=ch[t5-1]+ch[t6-1];
                          c1[t6-1]=ch[t5]-ch[t6];
                          c1[t5]=ch[t5]+ch[t6];
                          c1[t6]=ch[t6-1]-ch[t5-1];
                        }
                      }
                    }
                  }else{
                    for(j=1;j<ipph;j++){
                      t1+=t0;
                      t2-=t0;
                      t3=t1;
                      t4=t2;
                      for(k=0;k<l1;k++){
                        t5=t3;
                        t6=t4;
                        for(i=2;i<ido;i+=2){
                          t5+=2;
                          t6+=2;
                          c1[t5-1]=ch[t5-1]+ch[t6-1];
                          c1[t6-1]=ch[t5]-ch[t6];
                          c1[t5]=ch[t5]+ch[t6];
                          c1[t6]=ch[t6-1]-ch[t5-1];
                        }
                        t3+=ido;
                        t4+=ido;
                      }
                    }
                  }
                
                L119:
                  for(ik=0;ik<idl1;ik++)c2[ik]=ch2[ik];
                
                  t1=0;
                  t2=ipp2*idl1;
                  for(j=1;j<ipph;j++){
                    t1+=t0;
                    t2-=t0;
                    t3=t1-ido;
                    t4=t2-ido;
                    for(k=0;k<l1;k++){
                      t3+=ido;
                      t4+=ido;
                      c1[t3]=ch[t3]+ch[t4];
                      c1[t4]=ch[t4]-ch[t3];
                    }
                  }
                
                  ar1=1.f;
                  ai1=0.f;
                  t1=0;
                  t2=ipp2*idl1;
                  t3=(ip-1)*idl1;
                  for(l=1;l<ipph;l++){
                    t1+=idl1;
                    t2-=idl1;
                    ar1h=dcp*ar1-dsp*ai1;
                    ai1=dcp*ai1+dsp*ar1;
                    ar1=ar1h;
                    t4=t1;
                    t5=t2;
                    t6=t3;
                    t7=idl1;
                
                    for(ik=0;ik<idl1;ik++){
                      ch2[t4++]=c2[ik]+ar1*c2[t7++];
                      ch2[t5++]=ai1*c2[t6++];
                    }
                
                    dc2=ar1;
                    ds2=ai1;
                    ar2=ar1;
                    ai2=ai1;
                
                    t4=idl1;
                    t5=(ipp2-1)*idl1;
                    for(j=2;j<ipph;j++){
                      t4+=idl1;
                      t5-=idl1;
                
                      ar2h=dc2*ar2-ds2*ai2;
                      ai2=dc2*ai2+ds2*ar2;
                      ar2=ar2h;
                
                      t6=t1;
                      t7=t2;
                      t8=t4;
                      t9=t5;
                      for(ik=0;ik<idl1;ik++){
                        ch2[t6++]+=ar2*c2[t8++];
                        ch2[t7++]+=ai2*c2[t9++];
                      }
                    }
                  }
                
                  t1=0;
                  for(j=1;j<ipph;j++){
                    t1+=idl1;
                    t2=t1;
                    for(ik=0;ik<idl1;ik++)ch2[ik]+=c2[t2++];
                  }
                
                  if(ido<l1)goto L132;
                
                  t1=0;
                  t2=0;
                  for(k=0;k<l1;k++){
                    t3=t1;
                    t4=t2;
                    for(i=0;i<ido;i++)cc[t4++]=ch[t3++];
                    t1+=ido;
                    t2+=t10;
                  }
                
                  goto L135;
                
                 L132:
                  for(i=0;i<ido;i++){
                    t1=i;
                    t2=i;
                    for(k=0;k<l1;k++){
                      cc[t2]=ch[t1];
                      t1+=ido;
                      t2+=t10;
                    }
                  }
                
                 L135:
                  t1=0;
                  t2=ido<<1;
                  t3=0;
                  t4=ipp2*t0;
                  for(j=1;j<ipph;j++){
                
                    t1+=t2;
                    t3+=t0;
                    t4-=t0;
                
                    t5=t1;
                    t6=t3;
                    t7=t4;
                
                    for(k=0;k<l1;k++){
                      cc[t5-1]=ch[t6];
                      cc[t5]=ch[t7];
                      t5+=t10;
                      t6+=ido;
                      t7+=ido;
                    }
                  }
                
                  if(ido==1)return;
                  if(nbd<l1)goto L141;
                
                  t1=-ido;
                  t3=0;
                  t4=0;
                  t5=ipp2*t0;
                  for(j=1;j<ipph;j++){
                    t1+=t2;
                    t3+=t2;
                    t4+=t0;
                    t5-=t0;
                    t6=t1;
                    t7=t3;
                    t8=t4;
                    t9=t5;
                    for(k=0;k<l1;k++){
                      for(i=2;i<ido;i+=2){
                        ic=idp2-i;
                        cc[i+t7-1]=ch[i+t8-1]+ch[i+t9-1];
                        cc[ic+t6-1]=ch[i+t8-1]-ch[i+t9-1];
                        cc[i+t7]=ch[i+t8]+ch[i+t9];
                        cc[ic+t6]=ch[i+t9]-ch[i+t8];
                      }
                      t6+=t10;
                      t7+=t10;
                      t8+=ido;
                      t9+=ido;
                    }
                  }
                  return;
                
                 L141:
                
                  t1=-ido;
                  t3=0;
                  t4=0;
                  t5=ipp2*t0;
                  for(j=1;j<ipph;j++){
                    t1+=t2;
                    t3+=t2;
                    t4+=t0;
                    t5-=t0;
                    for(i=2;i<ido;i+=2){
                      t6=idp2+t1-i;
                      t7=i+t3;
                      t8=i+t4;
                      t9=i+t5;
                      for(k=0;k<l1;k++){
                        cc[t7-1]=ch[t8-1]+ch[t9-1];
                        cc[t6-1]=ch[t8-1]-ch[t9-1];
                        cc[t7]=ch[t8]+ch[t9];
                        cc[t6]=ch[t9]-ch[t8];
                        t6+=t10;
                        t7+=t10;
                        t8+=ido;
                        t9+=ido;
                      }
                    }
                  }
                }
                
                static void drftf1(int n,float *c,float *ch,float *wa,int *ifac){
                  int i,k1,l1,l2;
                  int na,kh,nf;
                  int ip,iw,ido,idl1,ix2,ix3;
                
                  nf=ifac[1];
                  na=1;
                  l2=n;
                  iw=n;
                
                  for(k1=0;k1<nf;k1++){
                    kh=nf-k1;
                    ip=ifac[kh+1];
                    l1=l2/ip;
                    ido=n/l2;
                    idl1=ido*l1;
                    iw-=(ip-1)*ido;
                    na=1-na;
                
                    if(ip!=4)goto L102;
                
                    ix2=iw+ido;
                    ix3=ix2+ido;
                    if(na!=0)
                      dradf4(ido,l1,ch,c,wa+iw-1,wa+ix2-1,wa+ix3-1);
                    else
                      dradf4(ido,l1,c,ch,wa+iw-1,wa+ix2-1,wa+ix3-1);
                    goto L110;
                
                 L102:
                    if(ip!=2)goto L104;
                    if(na!=0)goto L103;
                
                    dradf2(ido,l1,c,ch,wa+iw-1);
                    goto L110;
                
                  L103:
                    dradf2(ido,l1,ch,c,wa+iw-1);
                    goto L110;
                
                  L104:
                    if(ido==1)na=1-na;
                    if(na!=0)goto L109;
                
                    dradfg(ido,ip,l1,idl1,c,c,c,ch,ch,wa+iw-1);
                    na=1;
                    goto L110;
                
                  L109:
                    dradfg(ido,ip,l1,idl1,ch,ch,ch,c,c,wa+iw-1);
                    na=0;
                
                  L110:
                    l2=l1;
                  }
                
                  if(na==1)return;
                
                  for(i=0;i<n;i++)c[i]=ch[i];
                }
                
                static void dradb2(int ido,int l1,float *cc,float *ch,float *wa1){
                  int i,k,t0,t1,t2,t3,t4,t5,t6;
                  float ti2,tr2;
                
                  t0=l1*ido;
                
                  t1=0;
                  t2=0;
                  t3=(ido<<1)-1;
                  for(k=0;k<l1;k++){
                    ch[t1]=cc[t2]+cc[t3+t2];
                    ch[t1+t0]=cc[t2]-cc[t3+t2];
                    t2=(t1+=ido)<<1;
                  }
                
                  if(ido<2)return;
                  if(ido==2)goto L105;
                
                  t1=0;
                  t2=0;
                  for(k=0;k<l1;k++){
                    t3=t1;
                    t5=(t4=t2)+(ido<<1);
                    t6=t0+t1;
                    for(i=2;i<ido;i+=2){
                      t3+=2;
                      t4+=2;
                      t5-=2;
                      t6+=2;
                      ch[t3-1]=cc[t4-1]+cc[t5-1];
                      tr2=cc[t4-1]-cc[t5-1];
                      ch[t3]=cc[t4]-cc[t5];
                      ti2=cc[t4]+cc[t5];
                      ch[t6-1]=wa1[i-2]*tr2-wa1[i-1]*ti2;
                      ch[t6]=wa1[i-2]*ti2+wa1[i-1]*tr2;
                    }
                    t2=(t1+=ido)<<1;
                  }
                
                  if(ido%2==1)return;
                
                L105:
                  t1=ido-1;
                  t2=ido-1;
                  for(k=0;k<l1;k++){
                    ch[t1]=cc[t2]+cc[t2];
                    ch[t1+t0]=-(cc[t2+1]+cc[t2+1]);
                    t1+=ido;
                    t2+=ido<<1;
                  }
                }
                
                static void dradb3(int ido,int l1,float *cc,float *ch,float *wa1,
                                          float *wa2){
                  static float taur = -.5f;
                  static float taui = .8660254037844386f;
                  int i,k,t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;
                  float ci2,ci3,di2,di3,cr2,cr3,dr2,dr3,ti2,tr2;
                  t0=l1*ido;
                
                  t1=0;
                  t2=t0<<1;
                  t3=ido<<1;
                  t4=ido+(ido<<1);
                  t5=0;
                  for(k=0;k<l1;k++){
                    tr2=cc[t3-1]+cc[t3-1];
                    cr2=cc[t5]+(taur*tr2);
                    ch[t1]=cc[t5]+tr2;
                    ci3=taui*(cc[t3]+cc[t3]);
                    ch[t1+t0]=cr2-ci3;
                    ch[t1+t2]=cr2+ci3;
                    t1+=ido;
                    t3+=t4;
                    t5+=t4;
                  }
                
                  if(ido==1)return;
                
                  t1=0;
                  t3=ido<<1;
                  for(k=0;k<l1;k++){
                    t7=t1+(t1<<1);
                    t6=(t5=t7+t3);
                    t8=t1;
                    t10=(t9=t1+t0)+t0;
                
                    for(i=2;i<ido;i+=2){
                      t5+=2;
                      t6-=2;
                      t7+=2;
                      t8+=2;
                      t9+=2;
                      t10+=2;
                      tr2=cc[t5-1]+cc[t6-1];
                      cr2=cc[t7-1]+(taur*tr2);
                      ch[t8-1]=cc[t7-1]+tr2;
                      ti2=cc[t5]-cc[t6];
                      ci2=cc[t7]+(taur*ti2);
                      ch[t8]=cc[t7]+ti2;
                      cr3=taui*(cc[t5-1]-cc[t6-1]);
                      ci3=taui*(cc[t5]+cc[t6]);
                      dr2=cr2-ci3;
                      dr3=cr2+ci3;
                      di2=ci2+cr3;
                      di3=ci2-cr3;
                      ch[t9-1]=wa1[i-2]*dr2-wa1[i-1]*di2;
                      ch[t9]=wa1[i-2]*di2+wa1[i-1]*dr2;
                      ch[t10-1]=wa2[i-2]*dr3-wa2[i-1]*di3;
                      ch[t10]=wa2[i-2]*di3+wa2[i-1]*dr3;
                    }
                    t1+=ido;
                  }
                }
                
                static void dradb4(int ido,int l1,float *cc,float *ch,float *wa1,
                                          float *wa2,float *wa3){
                  static float sqrt2=1.414213562373095f;
                  int i,k,t0,t1,t2,t3,t4,t5,t6,t7,t8;
                  float ci2,ci3,ci4,cr2,cr3,cr4,ti1,ti2,ti3,ti4,tr1,tr2,tr3,tr4;
                  t0=l1*ido;
                
                  t1=0;
                  t2=ido<<2;
                  t3=0;
                  t6=ido<<1;
                  for(k=0;k<l1;k++){
                    t4=t3+t6;
                    t5=t1;
                    tr3=cc[t4-1]+cc[t4-1];
                    tr4=cc[t4]+cc[t4];
                    tr1=cc[t3]-cc[(t4+=t6)-1];
                    tr2=cc[t3]+cc[t4-1];
                    ch[t5]=tr2+tr3;
                    ch[t5+=t0]=tr1-tr4;
                    ch[t5+=t0]=tr2-tr3;
                    ch[t5+=t0]=tr1+tr4;
                    t1+=ido;
                    t3+=t2;
                  }
                
                  if(ido<2)return;
                  if(ido==2)goto L105;
                
                  t1=0;
                  for(k=0;k<l1;k++){
                    t5=(t4=(t3=(t2=t1<<2)+t6))+t6;
                    t7=t1;
                    for(i=2;i<ido;i+=2){
                      t2+=2;
                      t3+=2;
                      t4-=2;
                      t5-=2;
                      t7+=2;
                      ti1=cc[t2]+cc[t5];
                      ti2=cc[t2]-cc[t5];
                      ti3=cc[t3]-cc[t4];
                      tr4=cc[t3]+cc[t4];
                      tr1=cc[t2-1]-cc[t5-1];
                      tr2=cc[t2-1]+cc[t5-1];
                      ti4=cc[t3-1]-cc[t4-1];
                      tr3=cc[t3-1]+cc[t4-1];
                      ch[t7-1]=tr2+tr3;
                      cr3=tr2-tr3;
                      ch[t7]=ti2+ti3;
                      ci3=ti2-ti3;
                      cr2=tr1-tr4;
                      cr4=tr1+tr4;
                      ci2=ti1+ti4;
                      ci4=ti1-ti4;
                
                      ch[(t8=t7+t0)-1]=wa1[i-2]*cr2-wa1[i-1]*ci2;
                      ch[t8]=wa1[i-2]*ci2+wa1[i-1]*cr2;
                      ch[(t8+=t0)-1]=wa2[i-2]*cr3-wa2[i-1]*ci3;
                      ch[t8]=wa2[i-2]*ci3+wa2[i-1]*cr3;
                      ch[(t8+=t0)-1]=wa3[i-2]*cr4-wa3[i-1]*ci4;
                      ch[t8]=wa3[i-2]*ci4+wa3[i-1]*cr4;
                    }
                    t1+=ido;
                  }
                
                  if(ido%2 == 1)return;
                
                 L105:
                
                  t1=ido;
                  t2=ido<<2;
                  t3=ido-1;
                  t4=ido+(ido<<1);
                  for(k=0;k<l1;k++){
                    t5=t3;
                    ti1=cc[t1]+cc[t4];
                    ti2=cc[t4]-cc[t1];
                    tr1=cc[t1-1]-cc[t4-1];
                    tr2=cc[t1-1]+cc[t4-1];
                    ch[t5]=tr2+tr2;
                    ch[t5+=t0]=sqrt2*(tr1-ti1);
                    ch[t5+=t0]=ti2+ti2;
                    ch[t5+=t0]=-sqrt2*(tr1+ti1);
                
                    t3+=ido;
                    t1+=t2;
                    t4+=t2;
                  }
                }
                
                static void dradbg(int ido,int ip,int l1,int idl1,float *cc,float *c1,
                            float *c2,float *ch,float *ch2,float *wa){
                  static float tpi=6.283185307179586f;
                  int idij,ipph,i,j,k,l,ik,is,t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,
                      t11,t12;
                  float dc2,ai1,ai2,ar1,ar2,ds2;
                  int nbd;
                  float dcp,arg,dsp,ar1h,ar2h;
                  int ipp2;
                
                  t10=ip*ido;
                  t0=l1*ido;
                  arg=tpi/(float)ip;
                  dcp=cos(arg);
                  dsp=sin(arg);
                  nbd=(ido-1)>>1;
                  ipp2=ip;
                  ipph=(ip+1)>>1;
                  if(ido<l1)goto L103;
                
                  t1=0;
                  t2=0;
                  for(k=0;k<l1;k++){
                    t3=t1;
                    t4=t2;
                    for(i=0;i<ido;i++){
                      ch[t3]=cc[t4];
                      t3++;
                      t4++;
                    }
                    t1+=ido;
                    t2+=t10;
                  }
                  goto L106;
                
                 L103:
                  t1=0;
                  for(i=0;i<ido;i++){
                    t2=t1;
                    t3=t1;
                    for(k=0;k<l1;k++){
                      ch[t2]=cc[t3];
                      t2+=ido;
                      t3+=t10;
                    }
                    t1++;
                  }
                
                 L106:
                  t1=0;
                  t2=ipp2*t0;
                  t7=(t5=ido<<1);
                  for(j=1;j<ipph;j++){
                    t1+=t0;
                    t2-=t0;
                    t3=t1;
                    t4=t2;
                    t6=t5;
                    for(k=0;k<l1;k++){
                      ch[t3]=cc[t6-1]+cc[t6-1];
                      ch[t4]=cc[t6]+cc[t6];
                      t3+=ido;
                      t4+=ido;
                      t6+=t10;
                    }
                    t5+=t7;
                  }
                
                  if (ido == 1)goto L116;
                  if(nbd<l1)goto L112;
                
                  t1=0;
                  t2=ipp2*t0;
                  t7=0;
                  for(j=1;j<ipph;j++){
                    t1+=t0;
                    t2-=t0;
                    t3=t1;
                    t4=t2;
                
                    t7+=(ido<<1);
                    t8=t7;
                    for(k=0;k<l1;k++){
                      t5=t3;
                      t6=t4;
                      t9=t8;
                      t11=t8;
                      for(i=2;i<ido;i+=2){
                        t5+=2;
                        t6+=2;
                        t9+=2;
                        t11-=2;
                        ch[t5-1]=cc[t9-1]+cc[t11-1];
                        ch[t6-1]=cc[t9-1]-cc[t11-1];
                        ch[t5]=cc[t9]-cc[t11];
                        ch[t6]=cc[t9]+cc[t11];
                      }
                      t3+=ido;
                      t4+=ido;
                      t8+=t10;
                    }
                  }
                  goto L116;
                
                 L112:
                  t1=0;
                  t2=ipp2*t0;
                  t7=0;
                  for(j=1;j<ipph;j++){
                    t1+=t0;
                    t2-=t0;
                    t3=t1;
                    t4=t2;
                    t7+=(ido<<1);
                    t8=t7;
                    t9=t7;
                    for(i=2;i<ido;i+=2){
                      t3+=2;
                      t4+=2;
                      t8+=2;
                      t9-=2;
                      t5=t3;
                      t6=t4;
                      t11=t8;
                      t12=t9;
                      for(k=0;k<l1;k++){
                        ch[t5-1]=cc[t11-1]+cc[t12-1];
                        ch[t6-1]=cc[t11-1]-cc[t12-1];
                        ch[t5]=cc[t11]-cc[t12];
                        ch[t6]=cc[t11]+cc[t12];
                        t5+=ido;
                        t6+=ido;
                        t11+=t10;
                        t12+=t10;
                      }
                    }
                  }
                
                L116:
                  ar1=1.f;
                  ai1=0.f;
                  t1=0;
                  t9=(t2=ipp2*idl1);
                  t3=(ip-1)*idl1;
                  for(l=1;l<ipph;l++){
                    t1+=idl1;
                    t2-=idl1;
                
                    ar1h=dcp*ar1-dsp*ai1;
                    ai1=dcp*ai1+dsp*ar1;
                    ar1=ar1h;
                    t4=t1;
                    t5=t2;
                    t6=0;
                    t7=idl1;
                    t8=t3;
                    for(ik=0;ik<idl1;ik++){
                      c2[t4++]=ch2[t6++]+ar1*ch2[t7++];
                      c2[t5++]=ai1*ch2[t8++];
                    }
                    dc2=ar1;
                    ds2=ai1;
                    ar2=ar1;
                    ai2=ai1;
                
                    t6=idl1;
                    t7=t9-idl1;
                    for(j=2;j<ipph;j++){
                      t6+=idl1;
                      t7-=idl1;
                      ar2h=dc2*ar2-ds2*ai2;
                      ai2=dc2*ai2+ds2*ar2;
                      ar2=ar2h;
                      t4=t1;
                      t5=t2;
                      t11=t6;
                      t12=t7;
                      for(ik=0;ik<idl1;ik++){
                        c2[t4++]+=ar2*ch2[t11++];
                        c2[t5++]+=ai2*ch2[t12++];
                      }
                    }
                  }
                
                  t1=0;
                  for(j=1;j<ipph;j++){
                    t1+=idl1;
                    t2=t1;
                    for(ik=0;ik<idl1;ik++)ch2[ik]+=ch2[t2++];
                  }
                
                  t1=0;
                  t2=ipp2*t0;
                  for(j=1;j<ipph;j++){
                    t1+=t0;
                    t2-=t0;
                    t3=t1;
                    t4=t2;
                    for(k=0;k<l1;k++){
                      ch[t3]=c1[t3]-c1[t4];
                      ch[t4]=c1[t3]+c1[t4];
                      t3+=ido;
                      t4+=ido;
                    }
                  }
                
                  if(ido==1)goto L132;
                  if(nbd<l1)goto L128;
                
                  t1=0;
                  t2=ipp2*t0;
                  for(j=1;j<ipph;j++){
                    t1+=t0;
                    t2-=t0;
                    t3=t1;
                    t4=t2;
                    for(k=0;k<l1;k++){
                      t5=t3;
                      t6=t4;
                      for(i=2;i<ido;i+=2){
                        t5+=2;
                        t6+=2;
                        ch[t5-1]=c1[t5-1]-c1[t6];
                        ch[t6-1]=c1[t5-1]+c1[t6];
                        ch[t5]=c1[t5]+c1[t6-1];
                        ch[t6]=c1[t5]-c1[t6-1];
                      }
                      t3+=ido;
                      t4+=ido;
                    }
                  }
                  goto L132;
                
                 L128:
                  t1=0;
                  t2=ipp2*t0;
                  for(j=1;j<ipph;j++){
                    t1+=t0;
                    t2-=t0;
                    t3=t1;
                    t4=t2;
                    for(i=2;i<ido;i+=2){
                      t3+=2;
                      t4+=2;
                      t5=t3;
                      t6=t4;
                      for(k=0;k<l1;k++){
                        ch[t5-1]=c1[t5-1]-c1[t6];
                        ch[t6-1]=c1[t5-1]+c1[t6];
                        ch[t5]=c1[t5]+c1[t6-1];
                        ch[t6]=c1[t5]-c1[t6-1];
                        t5+=ido;
                        t6+=ido;
                      }
                    }
                  }
                
                L132:
                  if(ido==1)return;
                
                  for(ik=0;ik<idl1;ik++)c2[ik]=ch2[ik];
                
                  t1=0;
                  for(j=1;j<ip;j++){
                    t2=(t1+=t0);
                    for(k=0;k<l1;k++){
                      c1[t2]=ch[t2];
                      t2+=ido;
                    }
                  }
                
                  if(nbd>l1)goto L139;
                
                  is= -ido-1;
                  t1=0;
                  for(j=1;j<ip;j++){
                    is+=ido;
                    t1+=t0;
                    idij=is;
                    t2=t1;
                    for(i=2;i<ido;i+=2){
                      t2+=2;
                      idij+=2;
                      t3=t2;
                      for(k=0;k<l1;k++){
                        c1[t3-1]=wa[idij-1]*ch[t3-1]-wa[idij]*ch[t3];
                        c1[t3]=wa[idij-1]*ch[t3]+wa[idij]*ch[t3-1];
                        t3+=ido;
                      }
                    }
                  }
                  return;
                
                 L139:
                  is= -ido-1;
                  t1=0;
                  for(j=1;j<ip;j++){
                    is+=ido;
                    t1+=t0;
                    t2=t1;
                    for(k=0;k<l1;k++){
                      idij=is;
                      t3=t2;
                      for(i=2;i<ido;i+=2){
                        idij+=2;
                        t3+=2;
                        c1[t3-1]=wa[idij-1]*ch[t3-1]-wa[idij]*ch[t3];
                        c1[t3]=wa[idij-1]*ch[t3]+wa[idij]*ch[t3-1];
                      }
                      t2+=ido;
                    }
                  }
                }
                
                static void drftb1(int n, float *c, float *ch, float *wa, int *ifac){
                  int i,k1,l1,l2;
                  int na;
                  int nf,ip,iw,ix2,ix3,ido,idl1;
                
                  nf=ifac[1];
                  na=0;
                  l1=1;
                  iw=1;
                
                  for(k1=0;k1<nf;k1++){
                    ip=ifac[k1 + 2];
                    l2=ip*l1;
                    ido=n/l2;
                    idl1=ido*l1;
                    if(ip!=4)goto L103;
                    ix2=iw+ido;
                    ix3=ix2+ido;
                
                    if(na!=0)
                      dradb4(ido,l1,ch,c,wa+iw-1,wa+ix2-1,wa+ix3-1);
                    else
                      dradb4(ido,l1,c,ch,wa+iw-1,wa+ix2-1,wa+ix3-1);
                    na=1-na;
                    goto L115;
                
                  L103:
                    if(ip!=2)goto L106;
                
                    if(na!=0)
                      dradb2(ido,l1,ch,c,wa+iw-1);
                    else
                      dradb2(ido,l1,c,ch,wa+iw-1);
                    na=1-na;
                    goto L115;
                
                  L106:
                    if(ip!=3)goto L109;
                
                    ix2=iw+ido;
                    if(na!=0)
                      dradb3(ido,l1,ch,c,wa+iw-1,wa+ix2-1);
                    else
                      dradb3(ido,l1,c,ch,wa+iw-1,wa+ix2-1);
                    na=1-na;
                    goto L115;
                
                  L109:
                /*    The radix five case can be translated later..... */
                /*    if(ip!=5)goto L112;
                
                    ix2=iw+ido;
                    ix3=ix2+ido;
                    ix4=ix3+ido;
                    if(na!=0)
                      dradb5(ido,l1,ch,c,wa+iw-1,wa+ix2-1,wa+ix3-1,wa+ix4-1);
                    else
                      dradb5(ido,l1,c,ch,wa+iw-1,wa+ix2-1,wa+ix3-1,wa+ix4-1);
                    na=1-na;
                    goto L115;
                
                  L112:*/
                    if(na!=0)
                      dradbg(ido,ip,l1,idl1,ch,ch,ch,c,c,wa+iw-1);
                    else
                      dradbg(ido,ip,l1,idl1,c,c,c,ch,ch,wa+iw-1);
                    if(ido==1)na=1-na;
                
                  L115:
                    l1=l2;
                    iw+=(ip-1)*ido;
                  }
                
                  if(na==0)return;
                
                  for(i=0;i<n;i++)c[i]=ch[i];
                }
                
       ##### -> void drft_forward(drft_lookup *l,float *data){
                  if(l->n==1)return;
                  drftf1(l->n,data,l->trigcache,l->trigcache+l->n,l->splitcache);
                }
                
       ##### -> void drft_backward(drft_lookup *l,float *data){
                  if (l->n==1)return;
                  drftb1(l->n,data,l->trigcache,l->trigcache+l->n,l->splitcache);
                }
                
       ##### -> void drft_init(drft_lookup *l,int n){
                  l->n=n;
                  l->trigcache=_ogg_calloc(3*n,sizeof(*l->trigcache));
                  l->splitcache=_ogg_calloc(32,sizeof(*l->splitcache));
                  fdrffti(n, l->trigcache, l->splitcache);
                }
                
           8 -> void drft_clear(drft_lookup *l){
                  if(l){
                    if(l->trigcache)_ogg_free(l->trigcache);
                    if(l->splitcache)_ogg_free(l->splitcache);
                    memset(l,0,sizeof(*l));
                  }
                }


Top 10 Lines:

     Line      Count

     1249          8

Execution Summary:

       15   Executable lines in this file
        4   Lines executed
    26.67   Percent of the file executed

        8   Total number of line executions
     0.53   Average executions per line


*** File C:\cygwin\workspace\_git_repos\CustomizeVorbis_static\GprofCdt/../lib/mdct.c:
                /********************************************************************
                 *                                                                  *
                 * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
                 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
                 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
                 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
                 *                                                                  *
                 * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
                 * by the Xiph.Org Foundation http://www.xiph.org/                  *
                 *                                                                  *
                 ********************************************************************
                
                 function: normalized modified discrete cosine transform
                           power of two length transform only [64 <= n ]
                 last mod: $Id: mdct.c 16227 2009-07-08 06:58:46Z xiphmont $
                
                 Original algorithm adapted long ago from _The use of multirate filter
                 banks for coding of high quality digital audio_, by T. Sporer,
                 K. Brandenburg and B. Edler, collection of the European Signal
                 Processing Conference (EUSIPCO), Amsterdam, June 1992, Vol.1, pp
                 211-214
                
                 The below code implements an algorithm that no longer looks much like
                 that presented in the paper, but the basic structure remains if you
                 dig deep enough to see it.
                
                 This module DOES NOT INCLUDE code to generate/apply the window
                 function.  Everybody has their own weird favorite including me... I
                 happen to like the properties of y=sin(.5PI*sin^2(x)), but others may
                 vehemently disagree.
                
                 ********************************************************************/
                
                /* this can also be run as an integer transform by uncommenting a
                   define in mdct.h; the integerization is a first pass and although
                   it's likely stable for Vorbis, the dynamic range is constrained and
                   roundoff isn't done (so it's noisy).  Consider it functional, but
                   only a starting point.  There's no point on a machine with an FPU */
                
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <math.h>
                #include "vorbis/codec.h"
                #include "mdct.h"
                #include "os.h"
                #include "misc.h"
                
                /* build lookups for trig functions; also pre-figure scaling and
                   some window function algebra. */
                
      860984 -> void mdct_init(mdct_lookup *lookup,int n){
                  int   *bitrev=_ogg_malloc(sizeof(*bitrev)*(n/4));
                  DATA_TYPE *T=_ogg_malloc(sizeof(*T)*(n+n/4));
                
                  int i;
                  int n2=n>>1;
                  int log2n=lookup->log2n=rint(log((float)n)/log(2.f));
                  lookup->n=n;
                  lookup->trig=T;
                  lookup->bitrev=bitrev;
                
                /* trig lookups... */
                
                  for(i=0;i<n/4;i++){
                    T[i*2]=FLOAT_CONV(cos((M_PI/n)*(4*i)));
                    T[i*2+1]=FLOAT_CONV(-sin((M_PI/n)*(4*i)));
                    T[n2+i*2]=FLOAT_CONV(cos((M_PI/(2*n))*(2*i+1)));
                    T[n2+i*2+1]=FLOAT_CONV(sin((M_PI/(2*n))*(2*i+1)));
                  }
                  for(i=0;i<n/8;i++){
                    T[n+i*2]=FLOAT_CONV(cos((M_PI/n)*(4*i+2))*.5);
                    T[n+i*2+1]=FLOAT_CONV(-sin((M_PI/n)*(4*i+2))*.5);
                  }
                
                  /* bitreverse lookup... */
                
                  {
                    int mask=(1<<(log2n-1))-1,i,j;
                    int msb=1<<(log2n-2);
                    for(i=0;i<n/8;i++){
                      int acc=0;
                      for(j=0;msb>>j;j++)
                        if((msb>>j)&i)acc|=1<<j;
                      bitrev[i*2]=((~acc)&mask)-1;
                      bitrev[i*2+1]=acc;
                
                    }
                  }
                  lookup->scale=FLOAT_CONV(4.f/n);
                }
                
                /* 8 point butterfly (in place, 4 register) */
                STIN void mdct_butterfly_8(DATA_TYPE *x){
                  REG_TYPE r0   = x[6] + x[2];
                  REG_TYPE r1   = x[6] - x[2];
                  REG_TYPE r2   = x[4] + x[0];
                  REG_TYPE r3   = x[4] - x[0];
                
                           x[6] = r0   + r2;
                           x[4] = r0   - r2;
                
                           r0   = x[5] - x[1];
                           r2   = x[7] - x[3];
                           x[0] = r1   + r0;
                           x[2] = r1   - r0;
                
                           r0   = x[5] + x[1];
                           r1   = x[7] + x[3];
                           x[3] = r2   + r3;
                           x[1] = r2   - r3;
                           x[7] = r1   + r0;
                           x[5] = r1   - r0;
                
                }
                
                /* 16 point butterfly (in place, 4 register) */
                STIN void mdct_butterfly_16(DATA_TYPE *x){
                  REG_TYPE r0     = x[1]  - x[9];
                  REG_TYPE r1     = x[0]  - x[8];
                
                           x[8]  += x[0];
                           x[9]  += x[1];
                           x[0]   = MULT_NORM((r0   + r1) * cPI2_8);
                           x[1]   = MULT_NORM((r0   - r1) * cPI2_8);
                
                           r0     = x[3]  - x[11];
                           r1     = x[10] - x[2];
                           x[10] += x[2];
                           x[11] += x[3];
                           x[2]   = r0;
                           x[3]   = r1;
                
                           r0     = x[12] - x[4];
                           r1     = x[13] - x[5];
                           x[12] += x[4];
                           x[13] += x[5];
                           x[4]   = MULT_NORM((r0   - r1) * cPI2_8);
                           x[5]   = MULT_NORM((r0   + r1) * cPI2_8);
                
                           r0     = x[14] - x[6];
                           r1     = x[15] - x[7];
                           x[14] += x[6];
                           x[15] += x[7];
                           x[6]  = r0;
                           x[7]  = r1;
                
                           mdct_butterfly_8(x);
                           mdct_butterfly_8(x+8);
                }
                
                /* 32 point butterfly (in place, 4 register) */
                STIN void mdct_butterfly_32(DATA_TYPE *x){
                  REG_TYPE r0     = x[30] - x[14];
                  REG_TYPE r1     = x[31] - x[15];
                
                           x[30] +=         x[14];
                           x[31] +=         x[15];
                           x[14]  =         r0;
                           x[15]  =         r1;
                
                           r0     = x[28] - x[12];
                           r1     = x[29] - x[13];
                           x[28] +=         x[12];
                           x[29] +=         x[13];
                           x[12]  = MULT_NORM( r0 * cPI1_8  -  r1 * cPI3_8 );
                           x[13]  = MULT_NORM( r0 * cPI3_8  +  r1 * cPI1_8 );
                
                           r0     = x[26] - x[10];
                           r1     = x[27] - x[11];
                           x[26] +=         x[10];
                           x[27] +=         x[11];
                           x[10]  = MULT_NORM(( r0  - r1 ) * cPI2_8);
                           x[11]  = MULT_NORM(( r0  + r1 ) * cPI2_8);
                
                           r0     = x[24] - x[8];
                           r1     = x[25] - x[9];
                           x[24] += x[8];
                           x[25] += x[9];
                           x[8]   = MULT_NORM( r0 * cPI3_8  -  r1 * cPI1_8 );
                           x[9]   = MULT_NORM( r1 * cPI3_8  +  r0 * cPI1_8 );
                
                           r0     = x[22] - x[6];
                           r1     = x[7]  - x[23];
                           x[22] += x[6];
                           x[23] += x[7];
                           x[6]   = r1;
                           x[7]   = r0;
                
                           r0     = x[4]  - x[20];
                           r1     = x[5]  - x[21];
                           x[20] += x[4];
                           x[21] += x[5];
                           x[4]   = MULT_NORM( r1 * cPI1_8  +  r0 * cPI3_8 );
                           x[5]   = MULT_NORM( r1 * cPI3_8  -  r0 * cPI1_8 );
                
                           r0     = x[2]  - x[18];
                           r1     = x[3]  - x[19];
                           x[18] += x[2];
                           x[19] += x[3];
                           x[2]   = MULT_NORM(( r1  + r0 ) * cPI2_8);
                           x[3]   = MULT_NORM(( r1  - r0 ) * cPI2_8);
                
                           r0     = x[0]  - x[16];
                           r1     = x[1]  - x[17];
                           x[16] += x[0];
                           x[17] += x[1];
                           x[0]   = MULT_NORM( r1 * cPI3_8  +  r0 * cPI1_8 );
                           x[1]   = MULT_NORM( r1 * cPI1_8  -  r0 * cPI3_8 );
                
                           mdct_butterfly_16(x);
                           mdct_butterfly_16(x+16);
                
                }
                
                /* N point first stage butterfly (in place, 2 register) */
                STIN void mdct_butterfly_first(DATA_TYPE *T,
                                                        DATA_TYPE *x,
                                                        int points){
                
                  DATA_TYPE *x1        = x          + points      - 8;
                  DATA_TYPE *x2        = x          + (points>>1) - 8;
                  REG_TYPE   r0;
                  REG_TYPE   r1;
                
                  do{
                
                               r0      = x1[6]      -  x2[6];
                               r1      = x1[7]      -  x2[7];
                               x1[6]  += x2[6];
                               x1[7]  += x2[7];
                               x2[6]   = MULT_NORM(r1 * T[1]  +  r0 * T[0]);
                               x2[7]   = MULT_NORM(r1 * T[0]  -  r0 * T[1]);
                
                               r0      = x1[4]      -  x2[4];
                               r1      = x1[5]      -  x2[5];
                               x1[4]  += x2[4];
                               x1[5]  += x2[5];
                               x2[4]   = MULT_NORM(r1 * T[5]  +  r0 * T[4]);
                               x2[5]   = MULT_NORM(r1 * T[4]  -  r0 * T[5]);
                
                               r0      = x1[2]      -  x2[2];
                               r1      = x1[3]      -  x2[3];
                               x1[2]  += x2[2];
                               x1[3]  += x2[3];
                               x2[2]   = MULT_NORM(r1 * T[9]  +  r0 * T[8]);
                               x2[3]   = MULT_NORM(r1 * T[8]  -  r0 * T[9]);
                
                               r0      = x1[0]      -  x2[0];
                               r1      = x1[1]      -  x2[1];
                               x1[0]  += x2[0];
                               x1[1]  += x2[1];
                               x2[0]   = MULT_NORM(r1 * T[13] +  r0 * T[12]);
                               x2[1]   = MULT_NORM(r1 * T[12] -  r0 * T[13]);
                
                    x1-=8;
                    x2-=8;
                    T+=16;
                
                  }while(x2>=x);
                }
                
                /* N/stage point generic N stage butterfly (in place, 2 register) */
                STIN void mdct_butterfly_generic(DATA_TYPE *T,
                                                          DATA_TYPE *x,
                                                          int points,
                                                          int trigint){
                
                  DATA_TYPE *x1        = x          + points      - 8;
                  DATA_TYPE *x2        = x          + (points>>1) - 8;
                  REG_TYPE   r0;
                  REG_TYPE   r1;
                
                  do{
                
                               r0      = x1[6]      -  x2[6];
                               r1      = x1[7]      -  x2[7];
                               x1[6]  += x2[6];
                               x1[7]  += x2[7];
                               x2[6]   = MULT_NORM(r1 * T[1]  +  r0 * T[0]);
                               x2[7]   = MULT_NORM(r1 * T[0]  -  r0 * T[1]);
                
                               T+=trigint;
                
                               r0      = x1[4]      -  x2[4];
                               r1      = x1[5]      -  x2[5];
                               x1[4]  += x2[4];
                               x1[5]  += x2[5];
                               x2[4]   = MULT_NORM(r1 * T[1]  +  r0 * T[0]);
                               x2[5]   = MULT_NORM(r1 * T[0]  -  r0 * T[1]);
                
                               T+=trigint;
                
                               r0      = x1[2]      -  x2[2];
                               r1      = x1[3]      -  x2[3];
                               x1[2]  += x2[2];
                               x1[3]  += x2[3];
                               x2[2]   = MULT_NORM(r1 * T[1]  +  r0 * T[0]);
                               x2[3]   = MULT_NORM(r1 * T[0]  -  r0 * T[1]);
                
                               T+=trigint;
                
                               r0      = x1[0]      -  x2[0];
                               r1      = x1[1]      -  x2[1];
                               x1[0]  += x2[0];
                               x1[1]  += x2[1];
                               x2[0]   = MULT_NORM(r1 * T[1]  +  r0 * T[0]);
                               x2[1]   = MULT_NORM(r1 * T[0]  -  r0 * T[1]);
                
                               T+=trigint;
                    x1-=8;
                    x2-=8;
                
                  }while(x2>=x);
                }
                
                STIN void mdct_butterflies(mdct_lookup *init,
                                             DATA_TYPE *x,
                                             int points){
                
                  DATA_TYPE *T=init->trig;
                  int stages=init->log2n-5;
                  int i,j;
                
                  if(--stages>0){
                    mdct_butterfly_first(T,x,points);
                  }
                
                  for(i=1;--stages>0;i++){
                    for(j=0;j<(1<<i);j++)
                      mdct_butterfly_generic(T,x+(points>>i)*j,points>>i,4<<i);
                  }
                
                  for(j=0;j<points;j+=32)
                    mdct_butterfly_32(x+j);
                
                }
                
        7826 -> void mdct_clear(mdct_lookup *l){
                  if(l){
                    if(l->trig)_ogg_free(l->trig);
                    if(l->bitrev)_ogg_free(l->bitrev);
                    memset(l,0,sizeof(*l));
                  }
                }
                
                STIN void mdct_bitreverse(mdct_lookup *init,
                                            DATA_TYPE *x){
                  int        n       = init->n;
                  int       *bit     = init->bitrev;
                  DATA_TYPE *w0      = x;
                  DATA_TYPE *w1      = x = w0+(n>>1);
                  DATA_TYPE *T       = init->trig+n;
                
                  do{
                    DATA_TYPE *x0    = x+bit[0];
                    DATA_TYPE *x1    = x+bit[1];
                
                    REG_TYPE  r0     = x0[1]  - x1[1];
                    REG_TYPE  r1     = x0[0]  + x1[0];
                    REG_TYPE  r2     = MULT_NORM(r1     * T[0]   + r0 * T[1]);
                    REG_TYPE  r3     = MULT_NORM(r1     * T[1]   - r0 * T[0]);
                
                              w1    -= 4;
                
                              r0     = HALVE(x0[1] + x1[1]);
                              r1     = HALVE(x0[0] - x1[0]);
                
                              w0[0]  = r0     + r2;
                              w1[2]  = r0     - r2;
                              w0[1]  = r1     + r3;
                              w1[3]  = r3     - r1;
                
                              x0     = x+bit[2];
                              x1     = x+bit[3];
                
                              r0     = x0[1]  - x1[1];
                              r1     = x0[0]  + x1[0];
                              r2     = MULT_NORM(r1     * T[2]   + r0 * T[3]);
                              r3     = MULT_NORM(r1     * T[3]   - r0 * T[2]);
                
                              r0     = HALVE(x0[1] + x1[1]);
                              r1     = HALVE(x0[0] - x1[0]);
                
                              w0[2]  = r0     + r2;
                              w1[0]  = r0     - r2;
                              w0[3]  = r1     + r3;
                              w1[1]  = r3     - r1;
                
                              T     += 4;
                              bit   += 4;
                              w0    += 4;
                
                  }while(w0<w1);
                }
                
        7783 -> void mdct_backward(mdct_lookup *init, DATA_TYPE *in, DATA_TYPE *out){
                  int n=init->n;
                  int n2=n>>1;
                  int n4=n>>2;
                
                  /* rotate */
                
                  DATA_TYPE *iX = in+n2-7;
                  DATA_TYPE *oX = out+n2+n4;
                  DATA_TYPE *T  = init->trig+n4;
                
                  do{
                    oX         -= 4;
                    oX[0]       = MULT_NORM(-iX[2] * T[3] - iX[0]  * T[2]);
                    oX[1]       = MULT_NORM (iX[0] * T[3] - iX[2]  * T[2]);
                    oX[2]       = MULT_NORM(-iX[6] * T[1] - iX[4]  * T[0]);
                    oX[3]       = MULT_NORM (iX[4] * T[1] - iX[6]  * T[0]);
                    iX         -= 8;
                    T          += 4;
                  }while(iX>=in);
                
                  iX            = in+n2-8;
                  oX            = out+n2+n4;
                  T             = init->trig+n4;
                
                  do{
                    T          -= 4;
                    oX[0]       =  MULT_NORM (iX[4] * T[3] + iX[6] * T[2]);
                    oX[1]       =  MULT_NORM (iX[4] * T[2] - iX[6] * T[3]);
                    oX[2]       =  MULT_NORM (iX[0] * T[1] + iX[2] * T[0]);
                    oX[3]       =  MULT_NORM (iX[0] * T[0] - iX[2] * T[1]);
                    iX         -= 8;
                    oX         += 4;
                  }while(iX>=in);
                
                  mdct_butterflies(init,out+n2,n2);
                  mdct_bitreverse(init,out);
                
                  /* roatate + window */
                
                  {
                    DATA_TYPE *oX1=out+n2+n4;
                    DATA_TYPE *oX2=out+n2+n4;
                    DATA_TYPE *iX =out;
                    T             =init->trig+n2;
                
                    do{
                      oX1-=4;
                
                      oX1[3]  =  MULT_NORM (iX[0] * T[1] - iX[1] * T[0]);
                      oX2[0]  = -MULT_NORM (iX[0] * T[0] + iX[1] * T[1]);
                
                      oX1[2]  =  MULT_NORM (iX[2] * T[3] - iX[3] * T[2]);
                      oX2[1]  = -MULT_NORM (iX[2] * T[2] + iX[3] * T[3]);
                
                      oX1[1]  =  MULT_NORM (iX[4] * T[5] - iX[5] * T[4]);
                      oX2[2]  = -MULT_NORM (iX[4] * T[4] + iX[5] * T[5]);
                
                      oX1[0]  =  MULT_NORM (iX[6] * T[7] - iX[7] * T[6]);
                      oX2[3]  = -MULT_NORM (iX[6] * T[6] + iX[7] * T[7]);
                
                      oX2+=4;
                      iX    +=   8;
                      T     +=   8;
                    }while(iX<oX1);
                
                    iX=out+n2+n4;
                    oX1=out+n4;
                    oX2=oX1;
                
                    do{
                      oX1-=4;
                      iX-=4;
                
                      oX2[0] = -(oX1[3] = iX[3]);
                      oX2[1] = -(oX1[2] = iX[2]);
                      oX2[2] = -(oX1[1] = iX[1]);
                      oX2[3] = -(oX1[0] = iX[0]);
                
                      oX2+=4;
                    }while(oX2<iX);
                
                    iX=out+n2+n4;
                    oX1=out+n2+n4;
                    oX2=out+n2;
                    do{
                      oX1-=4;
                      oX1[0]= iX[3];
                      oX1[1]= iX[2];
                      oX1[2]= iX[1];
                      oX1[3]= iX[0];
                      iX+=4;
                    }while(oX1>oX2);
                  }
                }
                
       ##### -> void mdct_forward(mdct_lookup *init, DATA_TYPE *in, DATA_TYPE *out){
                  int n=init->n;
                  int n2=n>>1;
                  int n4=n>>2;
                  int n8=n>>3;
                  DATA_TYPE *w=alloca(n*sizeof(*w)); /* forward needs working space */
                  DATA_TYPE *w2=w+n2;
                
                  /* rotate */
                
                  /* window + rotate + step 1 */
                
                  REG_TYPE r0;
                  REG_TYPE r1;
                  DATA_TYPE *x0=in+n2+n4;
                  DATA_TYPE *x1=x0+1;
                  DATA_TYPE *T=init->trig+n2;
                
                  int i=0;
                
                  for(i=0;i<n8;i+=2){
                    x0 -=4;
                    T-=2;
                    r0= x0[2] + x1[0];
                    r1= x0[0] + x1[2];
                    w2[i]=   MULT_NORM(r1*T[1] + r0*T[0]);
                    w2[i+1]= MULT_NORM(r1*T[0] - r0*T[1]);
                    x1 +=4;
                  }
                
                  x1=in+1;
                
                  for(;i<n2-n8;i+=2){
                    T-=2;
                    x0 -=4;
                    r0= x0[2] - x1[0];
                    r1= x0[0] - x1[2];
                    w2[i]=   MULT_NORM(r1*T[1] + r0*T[0]);
                    w2[i+1]= MULT_NORM(r1*T[0] - r0*T[1]);
                    x1 +=4;
                  }
                
                  x0=in+n;
                
                  for(;i<n2;i+=2){
                    T-=2;
                    x0 -=4;
                    r0= -x0[2] - x1[0];
                    r1= -x0[0] - x1[2];
                    w2[i]=   MULT_NORM(r1*T[1] + r0*T[0]);
                    w2[i+1]= MULT_NORM(r1*T[0] - r0*T[1]);
                    x1 +=4;
                  }
                
                
                  mdct_butterflies(init,w+n2,n2);
                  mdct_bitreverse(init,w);
                
                  /* roatate + window */
                
                  T=init->trig+n2;
                  x0=out+n2;
                
                  for(i=0;i<n4;i++){
                    x0--;
                    out[i] =MULT_NORM((w[0]*T[0]+w[1]*T[1])*init->scale);
                    x0[0]  =MULT_NORM((w[0]*T[1]-w[1]*T[0])*init->scale);
                    w+=2;
                    T+=2;
                  }
                }


Top 10 Lines:

     Line      Count

       52     860984
      339       7826
      397       7783

Execution Summary:

       11   Executable lines in this file
        4   Lines executed
    36.36   Percent of the file executed

   876593   Total number of line executions
 79690.27   Average executions per line


*** File C:\cygwin\workspace\_git_repos\CustomizeVorbis_static\GprofCdt/../lib/codebook.c:
                /********************************************************************
                 *                                                                  *
                 * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
                 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
                 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
                 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
                 *                                                                  *
                 * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
                 * by the Xiph.Org Foundation http://www.xiph.org/                  *
                 *                                                                  *
                 ********************************************************************
                
                 function: basic codebook pack/unpack/code/decode operations
                 last mod: $Id: codebook.c 17553 2010-10-21 17:54:26Z tterribe $
                
                 ********************************************************************/
                
                #include <stdlib.h>
                #include <string.h>
                #include <math.h>
                #include <ogg/ogg.h>
                #include "vorbis/codec.h"
                #include "codebook.h"
                #include "scales.h"
                #include "misc.h"
                #include "os.h"
                
                /* packs the given codebook into the bitstream **************************/
                
       ##### -> int vorbis_staticbook_pack(const static_codebook *c,oggpack_buffer *opb){
                  long i,j;
                  int ordered=0;
                
                  /* first the basic parameters */
                  oggpack_write(opb,0x564342,24);
                  oggpack_write(opb,c->dim,16);
                  oggpack_write(opb,c->entries,24);
                
                  /* pack the codewords.  There are two packings; length ordered and
                     length random.  Decide between the two now. */
                
                  for(i=1;i<c->entries;i++)
                    if(c->lengthlist[i-1]==0 || c->lengthlist[i]<c->lengthlist[i-1])break;
                  if(i==c->entries)ordered=1;
                
                  if(ordered){
                    /* length ordered.  We only need to say how many codewords of
                       each length.  The actual codewords are generated
                       deterministically */
                
                    long count=0;
                    oggpack_write(opb,1,1);  /* ordered */
                    oggpack_write(opb,c->lengthlist[0]-1,5); /* 1 to 32 */
                
                    for(i=1;i<c->entries;i++){
                      long this=c->lengthlist[i];
                      long last=c->lengthlist[i-1];
                      if(this>last){
                        for(j=last;j<this;j++){
                          oggpack_write(opb,i-count,_ilog(c->entries-count));
                          count=i;
                        }
                      }
                    }
                    oggpack_write(opb,i-count,_ilog(c->entries-count));
                
                  }else{
                    /* length random.  Again, we don't code the codeword itself, just
                       the length.  This time, though, we have to encode each length */
                    oggpack_write(opb,0,1);   /* unordered */
                
                    /* algortihmic mapping has use for 'unused entries', which we tag
                       here.  The algorithmic mapping happens as usual, but the unused
                       entry has no codeword. */
                    for(i=0;i<c->entries;i++)
                      if(c->lengthlist[i]==0)break;
                
                    if(i==c->entries){
                      oggpack_write(opb,0,1); /* no unused entries */
                      for(i=0;i<c->entries;i++)
                        oggpack_write(opb,c->lengthlist[i]-1,5);
                    }else{
                      oggpack_write(opb,1,1); /* we have unused entries; thus we tag */
                      for(i=0;i<c->entries;i++){
                        if(c->lengthlist[i]==0){
                          oggpack_write(opb,0,1);
                        }else{
                          oggpack_write(opb,1,1);
                          oggpack_write(opb,c->lengthlist[i]-1,5);
                        }
                      }
                    }
                  }
                
                  /* is the entry number the desired return value, or do we have a
                     mapping? If we have a mapping, what type? */
                  oggpack_write(opb,c->maptype,4);
                  switch(c->maptype){
                  case 0:
                    /* no mapping */
                    break;
                  case 1:case 2:
                    /* implicitly populated value mapping */
                    /* explicitly populated value mapping */
                
                    if(!c->quantlist){
                      /* no quantlist?  error */
                      return(-1);
                    }
                
                    /* values that define the dequantization */
                    oggpack_write(opb,c->q_min,32);
                    oggpack_write(opb,c->q_delta,32);
                    oggpack_write(opb,c->q_quant-1,4);
                    oggpack_write(opb,c->q_sequencep,1);
                
                    {
                      int quantvals;
                      switch(c->maptype){
                      case 1:
                        /* a single column of (c->entries/c->dim) quantized values for
                           building a full value list algorithmically (square lattice) */
                        quantvals=_book_maptype1_quantvals(c);
                        break;
                      case 2:
                        /* every value (c->entries*c->dim total) specified explicitly */
                        quantvals=c->entries*c->dim;
                        break;
                      default: /* NOT_REACHABLE */
                        quantvals=-1;
                      }
                
                      /* quantized values */
                      for(i=0;i<quantvals;i++)
                        oggpack_write(opb,labs(c->quantlist[i]),c->q_quant);
                
                    }
                    break;
                  default:
                    /* error case; we don't have any other map types now */
                    return(-1);
                  }
                
                  return(0);
                }
                
                /* unpacks a codebook from the packet buffer into the codebook struct,
                   readies the codebook auxiliary structures for decode *************/
         528 -> static_codebook *vorbis_staticbook_unpack(oggpack_buffer *opb){
                  long i,j;
                  static_codebook *s=_ogg_calloc(1,sizeof(*s));
                  s->allocedp=1;
                
                  /* make sure alignment is correct */
                  if(oggpack_read(opb,24)!=0x564342)goto _eofout;
                
                  /* first the basic parameters */
                  s->dim=oggpack_read(opb,16);
                  s->entries=oggpack_read(opb,24);
                  if(s->entries==-1)goto _eofout;
                
                  if(_ilog(s->dim)+_ilog(s->entries)>24)goto _eofout;
                
                  /* codeword ordering.... length ordered or unordered? */
                  switch((int)oggpack_read(opb,1)){
                  case 0:{
                    long unused;
                    /* allocated but unused entries? */
                    unused=oggpack_read(opb,1);
                    if((s->entries*(unused?1:5)+7)>>3>opb->storage-oggpack_bytes(opb))
                      goto _eofout;
                    /* unordered */
                    s->lengthlist=_ogg_malloc(sizeof(*s->lengthlist)*s->entries);
                
                    /* allocated but unused entries? */
                    if(unused){
                      /* yes, unused entries */
                
                      for(i=0;i<s->entries;i++){
                        if(oggpack_read(opb,1)){
                          long num=oggpack_read(opb,5);
                          if(num==-1)goto _eofout;
                          s->lengthlist[i]=num+1;
                        }else
                          s->lengthlist[i]=0;
                      }
                    }else{
                      /* all entries used; no tagging */
                      for(i=0;i<s->entries;i++){
                        long num=oggpack_read(opb,5);
                        if(num==-1)goto _eofout;
                        s->lengthlist[i]=num+1;
                      }
                    }
                
                    break;
                  }
                  case 1:
                    /* ordered */
                    {
                      long length=oggpack_read(opb,5)+1;
                      if(length==0)goto _eofout;
                      s->lengthlist=_ogg_malloc(sizeof(*s->lengthlist)*s->entries);
                
                      for(i=0;i<s->entries;){
                        long num=oggpack_read(opb,_ilog(s->entries-i));
                        if(num==-1)goto _eofout;
                        if(length>32 || num>s->entries-i ||
                           (num>0 && (num-1)>>(length-1)>1)){
                          goto _errout;
                        }
                        if(length>32)goto _errout;
                        for(j=0;j<num;j++,i++)
                          s->lengthlist[i]=length;
                        length++;
                      }
                    }
                    break;
                  default:
                    /* EOF */
                    goto _eofout;
                  }
                
                  /* Do we have a mapping to unpack? */
                  switch((s->maptype=oggpack_read(opb,4))){
                  case 0:
                    /* no mapping */
                    break;
                  case 1: case 2:
                    /* implicitly populated value mapping */
                    /* explicitly populated value mapping */
                
                    s->q_min=oggpack_read(opb,32);
                    s->q_delta=oggpack_read(opb,32);
                    s->q_quant=oggpack_read(opb,4)+1;
                    s->q_sequencep=oggpack_read(opb,1);
                    if(s->q_sequencep==-1)goto _eofout;
                
                    {
                      int quantvals=0;
                      switch(s->maptype){
                      case 1:
                        quantvals=(s->dim==0?0:_book_maptype1_quantvals(s));
                        break;
                      case 2:
                        quantvals=s->entries*s->dim;
                        break;
                      }
                
                      /* quantized values */
                      if((quantvals*s->q_quant+7>>3)>opb->storage-oggpack_bytes(opb))
                        goto _eofout;
                      s->quantlist=_ogg_malloc(sizeof(*s->quantlist)*quantvals);
                      for(i=0;i<quantvals;i++)
                        s->quantlist[i]=oggpack_read(opb,s->q_quant);
                
                      if(quantvals&&s->quantlist[quantvals-1]==-1)goto _eofout;
                    }
                    break;
                  default:
                    goto _errout;
                  }
                
                  /* all set */
                  return(s);
                
                 _errout:
                 _eofout:
                  vorbis_staticbook_destroy(s);
                  return(NULL);
                }
                
                /* returns the number of bits ************************************************/
     4443174 -> int vorbis_book_encode(codebook *book, int a, oggpack_buffer *b){
                  if(a<0 || a>=book->c->entries)return(0);
                  oggpack_write(b,book->codelist[a],book->c->lengthlist[a]);
                  return(book->c->lengthlist[a]);
                }
                
                /* the 'eliminate the decode tree' optimization actually requires the
                   codewords to be MSb first, not LSb.  This is an annoying inelegancy
                   (and one of the first places where carefully thought out design
                   turned out to be wrong; Vorbis II and future Ogg codecs should go
                   to an MSb bitpacker), but not actually the huge hit it appears to
                   be.  The first-stage decode table catches most words so that
                   bitreverse is not in the main execution path. */
                
                static ogg_uint32_t bitreverse(ogg_uint32_t x){
                  x=    ((x>>16)&0x0000ffff) | ((x<<16)&0xffff0000);
                  x=    ((x>> 8)&0x00ff00ff) | ((x<< 8)&0xff00ff00);
                  x=    ((x>> 4)&0x0f0f0f0f) | ((x<< 4)&0xf0f0f0f0);
                  x=    ((x>> 2)&0x33333333) | ((x<< 2)&0xcccccccc);
                  return((x>> 1)&0x55555555) | ((x<< 1)&0xaaaaaaaa);
                }
                
                STIN long decode_packed_entry_number(codebook *book, oggpack_buffer *b){
                  int  read=book->dec_maxlength;
                  long lo,hi;
                  long lok = oggpack_look(b,book->dec_firsttablen);
                
                  if (lok >= 0) {
                    long entry = book->dec_firsttable[lok];
                    if(entry&0x80000000UL){
                      lo=(entry>>15)&0x7fff;
                      hi=book->used_entries-(entry&0x7fff);
                    }else{
                      oggpack_adv(b, book->dec_codelengths[entry-1]);
                      return(entry-1);
                    }
                  }else{
                    lo=0;
                    hi=book->used_entries;
                  }
                
                  lok = oggpack_look(b, read);
                
                  while(lok<0 && read>1)
                    lok = oggpack_look(b, --read);
                  if(lok<0)return -1;
                
                  /* bisect search for the codeword in the ordered list */
                  {
                    ogg_uint32_t testword=bitreverse((ogg_uint32_t)lok);
                
                    while(hi-lo>1){
                      long p=(hi-lo)>>1;
                      long test=book->codelist[lo+p]>testword;
                      lo+=p&(test-1);
                      hi-=p&(-test);
                      }
                
                    if(book->dec_codelengths[lo]<=read){
                      oggpack_adv(b, book->dec_codelengths[lo]);
                      return(lo);
                    }
                  }
                
                  oggpack_adv(b, read);
                
                  return(-1);
                }
                
                /* Decode side is specced and easier, because we don't need to find
                   matches using different criteria; we simply read and map.  There are
                   two things we need to do 'depending':
                
                   We may need to support interleave.  We don't really, but it's
                   convenient to do it here rather than rebuild the vector later.
                
                   Cascades may be additive or multiplicitive; this is not inherent in
                   the codebook, but set in the code using the codebook.  Like
                   interleaving, it's easiest to do it here.
                   addmul==0 -> declarative (set the value)
                   addmul==1 -> additive
                   addmul==2 -> multiplicitive */
                
                /* returns the [original, not compacted] entry number or -1 on eof *********/
      203700 -> long vorbis_book_decode(codebook *book, oggpack_buffer *b){
                  if(book->used_entries>0){
                    long packed_entry=decode_packed_entry_number(book,b);
                    if(packed_entry>=0)
                      return(book->dec_index[packed_entry]);
                  }
                
                  /* if there's no dec_index, the codebook unpacking isn't collapsed */
                  return(-1);
                }
                
                /* returns 0 on OK or -1 on eof *************************************/
       ##### -> long vorbis_book_decodevs_add(codebook *book,float *a,oggpack_buffer *b,int n){
                  if(book->used_entries>0){
                    int step=n/book->dim;
                    long *entry = alloca(sizeof(*entry)*step);
                    float **t = alloca(sizeof(*t)*step);
                    int i,j,o;
                
                    for (i = 0; i < step; i++) {
                      entry[i]=decode_packed_entry_number(book,b);
                      if(entry[i]==-1)return(-1);
                      t[i] = book->valuelist+entry[i]*book->dim;
                    }
                    for(i=0,o=0;i<book->dim;i++,o+=step)
                      for (j=0;j<step;j++)
                        a[o+j]+=t[j][i];
                  }
                  return(0);
                }
                
       ##### -> long vorbis_book_decodev_add(codebook *book,float *a,oggpack_buffer *b,int n){
                  if(book->used_entries>0){
                    int i,j,entry;
                    float *t;
                
                    if(book->dim>8){
                      for(i=0;i<n;){
                        entry = decode_packed_entry_number(book,b);
                        if(entry==-1)return(-1);
                        t     = book->valuelist+entry*book->dim;
                        for (j=0;j<book->dim;)
                          a[i++]+=t[j++];
                      }
                    }else{
                      for(i=0;i<n;){
                        entry = decode_packed_entry_number(book,b);
                        if(entry==-1)return(-1);
                        t     = book->valuelist+entry*book->dim;
                        j=0;
                        switch((int)book->dim){
                        case 8:
                          a[i++]+=t[j++];
                        case 7:
                          a[i++]+=t[j++];
                        case 6:
                          a[i++]+=t[j++];
                        case 5:
                          a[i++]+=t[j++];
                        case 4:
                          a[i++]+=t[j++];
                        case 3:
                          a[i++]+=t[j++];
                        case 2:
                          a[i++]+=t[j++];
                        case 1:
                          a[i++]+=t[j++];
                        case 0:
                          break;
                        }
                      }
                    }
                  }
                  return(0);
                }
                
       ##### -> long vorbis_book_decodev_set(codebook *book,float *a,oggpack_buffer *b,int n){
                  if(book->used_entries>0){
                    int i,j,entry;
                    float *t;
                
                    for(i=0;i<n;){
                      entry = decode_packed_entry_number(book,b);
                      if(entry==-1)return(-1);
                      t     = book->valuelist+entry*book->dim;
                      for (j=0;j<book->dim;)
                        a[i++]=t[j++];
                    }
                  }else{
                    int i,j;
                
                    for(i=0;i<n;){
                      for (j=0;j<book->dim;)
                        a[i++]=0.f;
                    }
                  }
                  return(0);
                }
                
                long vorbis_book_decodevv_add(codebook *book,float **a,long offset,int ch,
      185497 ->                               oggpack_buffer *b,int n){
                
                  long i,j,entry;
                  int chptr=0;
                  if(book->used_entries>0){
                    for(i=offset/ch;i<(offset+n)/ch;){
                      entry = decode_packed_entry_number(book,b);
                      if(entry==-1)return(-1);
                      {
                        const float *t = book->valuelist+entry*book->dim;
                        for (j=0;j<book->dim;j++){
                          a[chptr++][i]+=t[j];
                          if(chptr==ch){
                            chptr=0;
                            i++;
                          }
                        }
                      }
                    }
                  }
                  return(0);
                }


Top 10 Lines:

     Line      Count

      274    4443174
      358     203700
      458     185497
      149        528

Execution Summary:

       10   Executable lines in this file
        8   Lines executed
    80.00   Percent of the file executed

  4832899   Total number of line executions
483289.90   Average executions per line


*** File C:\cygwin\workspace\_git_repos\CustomizeVorbis_static\GprofCdt/../lib/sharedbook.c:
                /********************************************************************
                 *                                                                  *
                 * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
                 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
                 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
                 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
                 *                                                                  *
                 * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
                 * by the Xiph.Org Foundation http://www.xiph.org/                  *
                 *                                                                  *
                 ********************************************************************
                
                 function: basic shared codebook operations
                 last mod: $Id: sharedbook.c 17030 2010-03-25 06:52:55Z xiphmont $
                
                 ********************************************************************/
                
                #include <stdlib.h>
                #include <math.h>
                #include <string.h>
                #include <ogg/ogg.h>
                #include "os.h"
                #include "misc.h"
                #include "vorbis/codec.h"
                #include "codebook.h"
                #include "scales.h"
                
                /**** pack/unpack helpers ******************************************/
        1304 -> int _ilog(unsigned int v){
                  int ret=0;
                  while(v){
                    ret++;
                    v>>=1;
                  }
                  return(ret);
                }
                
                /* 32 bit float (not IEEE; nonnormalized mantissa +
                   biased exponent) : neeeeeee eeemmmmm mmmmmmmm mmmmmmmm
                   Why not IEEE?  It's just not that important here. */
                
                #define VQ_FEXP 10
                #define VQ_FMAN 21
                #define VQ_FEXP_BIAS 768 /* bias toward values smaller than 1. */
                
                /* doesn't currently guard under/overflow */
       ##### -> long _float32_pack(float val){
                  int sign=0;
                  long exp;
                  long mant;
                  if(val<0){
                    sign=0x80000000;
                    val= -val;
                  }
                  exp= floor(log(val)/log(2.f)+.001); //+epsilon
                  mant=rint(ldexp(val,(VQ_FMAN-1)-exp));
                  exp=(exp+VQ_FEXP_BIAS)<<VQ_FMAN;
                
                  return(sign|exp|mant);
                }
                
         120 -> float _float32_unpack(long val){
                  double mant=val&0x1fffff;
                  int    sign=val&0x80000000;
                  long   exp =(val&0x7fe00000L)>>VQ_FMAN;
                  if(sign)mant= -mant;
                  return(ldexp(mant,exp-(VQ_FMAN-1)-VQ_FEXP_BIAS));
                }
                
                /* given a list of word lengths, generate a list of codewords.  Works
                   for length ordered or unordered, always assigns the lowest valued
                   codewords first.  Extended to handle unused entries (length 0) */
         176 -> ogg_uint32_t *_make_words(long *l,long n,long sparsecount){
                  long i,j,count=0;
                  ogg_uint32_t marker[33];
                  ogg_uint32_t *r=_ogg_malloc((sparsecount?sparsecount:n)*sizeof(*r));
                  memset(marker,0,sizeof(marker));
                
                  for(i=0;i<n;i++){
                    long length=l[i];
                    if(length>0){
                      ogg_uint32_t entry=marker[length];
                
                      /* when we claim a node for an entry, we also claim the nodes
                         below it (pruning off the imagined tree that may have dangled
                         from it) as well as blocking the use of any nodes directly
                         above for leaves */
                
                      /* update ourself */
                      if(length<32 && (entry>>length)){
                        /* error condition; the lengths must specify an overpopulated tree */
                        _ogg_free(r);
                        return(NULL);
                      }
                      r[count++]=entry;
                
                      /* Look to see if the next shorter marker points to the node
                         above. if so, update it and repeat.  */
                      {
                        for(j=length;j>0;j--){
                
                          if(marker[j]&1){
                            /* have to jump branches */
                            if(j==1)
                              marker[1]++;
                            else
                              marker[j]=marker[j-1]<<1;
                            break; /* invariant says next upper marker would already
                                      have been moved if it was on the same path */
                          }
                          marker[j]++;
                        }
                      }
                
                      /* prune the tree; the implicit invariant says all the longer
                         markers were dangling from our just-taken node.  Dangle them
                         from our *new* node. */
                      for(j=length+1;j<33;j++)
                        if((marker[j]>>1) == entry){
                          entry=marker[j];
                          marker[j]=marker[j-1]<<1;
                        }else
                          break;
                    }else
                      if(sparsecount==0)count++;
                  }
                
                  /* sanity check the huffman tree; an underpopulated tree must be
                     rejected. The only exception is the one-node pseudo-nil tree,
                     which appears to be underpopulated because the tree doesn't
                     really exist; there's only one possible 'codeword' or zero bits,
                     but the above tree-gen code doesn't mark that. */
                  if(sparsecount != 1){
                    for(i=1;i<33;i++)
                      if(marker[i] & (0xffffffffUL>>(32-i))){
                	_ogg_free(r);
                	return(NULL);
                      }
                  }
                
                  /* bitreverse the words because our bitwise packer/unpacker is LSb
                     endian */
                  for(i=0,count=0;i<n;i++){
                    ogg_uint32_t temp=0;
                    for(j=0;j<l[i];j++){
                      temp<<=1;
                      temp|=(r[count]>>j)&1;
                    }
                
                    if(sparsecount){
                      if(l[i])
                        r[count++]=temp;
                    }else
                      r[count++]=temp;
                  }
                
                  return(r);
                }
                
                /* there might be a straightforward one-line way to do the below
                   that's portable and totally safe against roundoff, but I haven't
                   thought of it.  Therefore, we opt on the side of caution */
         240 -> long _book_maptype1_quantvals(const static_codebook *b){
                  long vals=floor(pow((float)b->entries,1.f/b->dim));
                
                  /* the above *should* be reliable, but we'll not assume that FP is
                     ever reliable when bitstream sync is at stake; verify via integer
                     means that vals really is the greatest value of dim for which
                     vals^b->bim <= b->entries */
                  /* treat the above as an initial guess */
                  while(1){
                    long acc=1;
                    long acc1=1;
                    int i;
                    for(i=0;i<b->dim;i++){
                      acc*=vals;
                      acc1*=vals+1;
                    }
                    if(acc<=b->entries && acc1>b->entries){
                      return(vals);
                    }else{
                      if(acc>b->entries){
                        vals--;
                      }else{
                        vals++;
                      }
                    }
                  }
                }
                
                /* unpack the quantized list of values for encode/decode ***********/
                /* we need to deal with two map types: in map type 1, the values are
                   generated algorithmically (each column of the vector counts through
                   the values in the quant vector). in map type 2, all the values came
                   in in an explicit list.  Both value lists must be unpacked */
         176 -> float *_book_unquantize(const static_codebook *b,int n,int *sparsemap){
                  long j,k,count=0;
                  if(b->maptype==1 || b->maptype==2){
                    int quantvals;
                    float mindel=_float32_unpack(b->q_min);
                    float delta=_float32_unpack(b->q_delta);
                    float *r=_ogg_calloc(n*b->dim,sizeof(*r));
                
                    /* maptype 1 and 2 both use a quantized value vector, but
                       different sizes */
                    switch(b->maptype){
                    case 1:
                      /* most of the time, entries%dimensions == 0, but we need to be
                         well defined.  We define that the possible vales at each
                         scalar is values == entries/dim.  If entries%dim != 0, we'll
                         have 'too few' values (values*dim<entries), which means that
                         we'll have 'left over' entries; left over entries use zeroed
                         values (and are wasted).  So don't generate codebooks like
                         that */
                      quantvals=_book_maptype1_quantvals(b);
                      for(j=0;j<b->entries;j++){
                        if((sparsemap && b->lengthlist[j]) || !sparsemap){
                          float last=0.f;
                          int indexdiv=1;
                          for(k=0;k<b->dim;k++){
                            int index= (j/indexdiv)%quantvals;
                            float val=b->quantlist[index];
                            val=fabs(val)*delta+mindel+last;
                            if(b->q_sequencep)last=val;
                            if(sparsemap)
                              r[sparsemap[count]*b->dim+k]=val;
                            else
                              r[count*b->dim+k]=val;
                            indexdiv*=quantvals;
                          }
                          count++;
                        }
                
                      }
                      break;
                    case 2:
                      for(j=0;j<b->entries;j++){
                        if((sparsemap && b->lengthlist[j]) || !sparsemap){
                          float last=0.f;
                
                          for(k=0;k<b->dim;k++){
                            float val=b->quantlist[j*b->dim+k];
                            val=fabs(val)*delta+mindel+last;
                            if(b->q_sequencep)last=val;
                            if(sparsemap)
                              r[sparsemap[count]*b->dim+k]=val;
                            else
                              r[count*b->dim+k]=val;
                          }
                          count++;
                        }
                      }
                      break;
                    }
                
                    return(r);
                  }
                  return(NULL);
                }
                
         528 -> void vorbis_staticbook_destroy(static_codebook *b){
                  if(b->allocedp){
                    if(b->quantlist)_ogg_free(b->quantlist);
                    if(b->lengthlist)_ogg_free(b->lengthlist);
                    memset(b,0,sizeof(*b));
                    _ogg_free(b);
                  } /* otherwise, it is in static memory */
                }
                
         176 -> void vorbis_book_clear(codebook *b){
                  /* static book is not cleared; we're likely called on the lookup and
                     the static codebook belongs to the info struct */
                  if(b->valuelist)_ogg_free(b->valuelist);
                  if(b->codelist)_ogg_free(b->codelist);
                
                  if(b->dec_index)_ogg_free(b->dec_index);
                  if(b->dec_codelengths)_ogg_free(b->dec_codelengths);
                  if(b->dec_firsttable)_ogg_free(b->dec_firsttable);
                
                  memset(b,0,sizeof(*b));
                }
                
       26708 -> int vorbis_book_init_encode(codebook *c,const static_codebook *s){
                
                  memset(c,0,sizeof(*c));
                  c->c=s;
                  c->entries=s->entries;
                  c->used_entries=s->entries;
                  c->dim=s->dim;
                  c->codelist=_make_words(s->lengthlist,s->entries,0);
                  //c->valuelist=_book_unquantize(s,s->entries,NULL);
                  c->quantvals=_book_maptype1_quantvals(s);
                  c->minval=(int)rint(_float32_unpack(s->q_min));
                  c->delta=(int)rint(_float32_unpack(s->q_delta));
                
                  return(0);
                }
                
                static ogg_uint32_t bitreverse(ogg_uint32_t x){
                  x=    ((x>>16)&0x0000ffffUL) | ((x<<16)&0xffff0000UL);
                  x=    ((x>> 8)&0x00ff00ffUL) | ((x<< 8)&0xff00ff00UL);
                  x=    ((x>> 4)&0x0f0f0f0fUL) | ((x<< 4)&0xf0f0f0f0UL);
                  x=    ((x>> 2)&0x33333333UL) | ((x<< 2)&0xccccccccUL);
                  return((x>> 1)&0x55555555UL) | ((x<< 1)&0xaaaaaaaaUL);
                }
                
                static int sort32a(const void *a,const void *b){
                  return ( **(ogg_uint32_t **)a>**(ogg_uint32_t **)b)-
                    ( **(ogg_uint32_t **)a<**(ogg_uint32_t **)b);
                }
                
                /* decode codebook arrangement is more heavily optimized than encode */
         176 -> int vorbis_book_init_decode(codebook *c,const static_codebook *s){
                  int i,j,n=0,tabn;
                  int *sortindex;
                  memset(c,0,sizeof(*c));
                
                  /* count actually used entries */
                  for(i=0;i<s->entries;i++)
                    if(s->lengthlist[i]>0)
                      n++;
                
                  c->entries=s->entries;
                  c->used_entries=n;
                  c->dim=s->dim;
                
                  if(n>0){
                
                    /* two different remappings go on here.
                
                    First, we collapse the likely sparse codebook down only to
                    actually represented values/words.  This collapsing needs to be
                    indexed as map-valueless books are used to encode original entry
                    positions as integers.
                
                    Second, we reorder all vectors, including the entry index above,
                    by sorted bitreversed codeword to allow treeless decode. */
                
                    /* perform sort */
                    ogg_uint32_t *codes=_make_words(s->lengthlist,s->entries,c->used_entries);
                    ogg_uint32_t **codep=alloca(sizeof(*codep)*n);
                
                    if(codes==NULL)goto err_out;
                
                    for(i=0;i<n;i++){
                      codes[i]=bitreverse(codes[i]);
                      codep[i]=codes+i;
                    }
                
                    qsort(codep,n,sizeof(*codep),sort32a);
                
                    sortindex=alloca(n*sizeof(*sortindex));
                    c->codelist=_ogg_malloc(n*sizeof(*c->codelist));
                    /* the index is a reverse index */
                    for(i=0;i<n;i++){
                      int position=codep[i]-codes;
                      sortindex[position]=i;
                    }
                
                    for(i=0;i<n;i++)
                      c->codelist[sortindex[i]]=codes[i];
                    _ogg_free(codes);
                
                
                    c->valuelist=_book_unquantize(s,n,sortindex);
                    c->dec_index=_ogg_malloc(n*sizeof(*c->dec_index));
                
                    for(n=0,i=0;i<s->entries;i++)
                      if(s->lengthlist[i]>0)
                        c->dec_index[sortindex[n++]]=i;
                
                    c->dec_codelengths=_ogg_malloc(n*sizeof(*c->dec_codelengths));
                    for(n=0,i=0;i<s->entries;i++)
                      if(s->lengthlist[i]>0)
                        c->dec_codelengths[sortindex[n++]]=s->lengthlist[i];
                
                    c->dec_firsttablen=_ilog(c->used_entries)-4; /* this is magic */
                    if(c->dec_firsttablen<5)c->dec_firsttablen=5;
                    if(c->dec_firsttablen>8)c->dec_firsttablen=8;
                
                    tabn=1<<c->dec_firsttablen;
                    c->dec_firsttable=_ogg_calloc(tabn,sizeof(*c->dec_firsttable));
                    c->dec_maxlength=0;
                
                    for(i=0;i<n;i++){
                      if(c->dec_maxlength<c->dec_codelengths[i])
                        c->dec_maxlength=c->dec_codelengths[i];
                      if(c->dec_codelengths[i]<=c->dec_firsttablen){
                        ogg_uint32_t orig=bitreverse(c->codelist[i]);
                        for(j=0;j<(1<<(c->dec_firsttablen-c->dec_codelengths[i]));j++)
                          c->dec_firsttable[orig|(j<<c->dec_codelengths[i])]=i+1;
                      }
                    }
                
                    /* now fill in 'unused' entries in the firsttable with hi/lo search
                       hints for the non-direct-hits */
                    {
                      ogg_uint32_t mask=0xfffffffeUL<<(31-c->dec_firsttablen);
                      long lo=0,hi=0;
                
                      for(i=0;i<tabn;i++){
                        ogg_uint32_t word=i<<(32-c->dec_firsttablen);
                        if(c->dec_firsttable[bitreverse(word)]==0){
                          while((lo+1)<n && c->codelist[lo+1]<=word)lo++;
                          while(    hi<n && word>=(c->codelist[hi]&mask))hi++;
                
                          /* we only actually have 15 bits per hint to play with here.
                             In order to overflow gracefully (nothing breaks, efficiency
                             just drops), encode as the difference from the extremes. */
                          {
                            unsigned long loval=lo;
                            unsigned long hival=n-hi;
                
                            if(loval>0x7fff)loval=0x7fff;
                            if(hival>0x7fff)hival=0x7fff;
                            c->dec_firsttable[bitreverse(word)]=
                              0x80000000UL | (loval<<15) | hival;
                          }
                        }
                      }
                    }
                  }
                
                  return(0);
                 err_out:
                  vorbis_book_clear(c);
                  return(-1);
                }
                
       ##### -> long vorbis_book_codeword(codebook *book,int entry){
                  if(book->c) /* only use with encode; decode optimizations are
                                 allowed to break this */
                    return book->codelist[entry];
                  return -1;
                }
                
       ##### -> long vorbis_book_codelen(codebook *book,int entry){
                  if(book->c) /* only use with encode; decode optimizations are
                                 allowed to break this */
                    return book->c->lengthlist[entry];
                  return -1;
                }
                
                #ifdef _V_SELFTEST
                
                /* Unit tests of the dequantizer; this stuff will be OK
                   cross-platform, I simply want to be sure that special mapping cases
                   actually work properly; a bug could go unnoticed for a while */
                
                #include <stdio.h>
                
                /* cases:
                
                   no mapping
                   full, explicit mapping
                   algorithmic mapping
                
                   nonsequential
                   sequential
                */
                
                static long full_quantlist1[]={0,1,2,3,    4,5,6,7, 8,3,6,1};
                static long partial_quantlist1[]={0,7,2};
                
                /* no mapping */
                static_codebook test1={
                  4,16,
                  NULL,
                  0,
                  0,0,0,0,
                  NULL,
                  0
                };
                static float *test1_result=NULL;
                
                /* linear, full mapping, nonsequential */
                static_codebook test2={
                  4,3,
                  NULL,
                  2,
                  -533200896,1611661312,4,0,
                  full_quantlist1,
                  0
                };
                static float test2_result[]={-3,-2,-1,0, 1,2,3,4, 5,0,3,-2};
                
                /* linear, full mapping, sequential */
                static_codebook test3={
                  4,3,
                  NULL,
                  2,
                  -533200896,1611661312,4,1,
                  full_quantlist1,
                  0
                };
                static float test3_result[]={-3,-5,-6,-6, 1,3,6,10, 5,5,8,6};
                
                /* linear, algorithmic mapping, nonsequential */
                static_codebook test4={
                  3,27,
                  NULL,
                  1,
                  -533200896,1611661312,4,0,
                  partial_quantlist1,
                  0
                };
                static float test4_result[]={-3,-3,-3, 4,-3,-3, -1,-3,-3,
                                              -3, 4,-3, 4, 4,-3, -1, 4,-3,
                                              -3,-1,-3, 4,-1,-3, -1,-1,-3,
                                              -3,-3, 4, 4,-3, 4, -1,-3, 4,
                                              -3, 4, 4, 4, 4, 4, -1, 4, 4,
                                              -3,-1, 4, 4,-1, 4, -1,-1, 4,
                                              -3,-3,-1, 4,-3,-1, -1,-3,-1,
                                              -3, 4,-1, 4, 4,-1, -1, 4,-1,
                                              -3,-1,-1, 4,-1,-1, -1,-1,-1};
                
                /* linear, algorithmic mapping, sequential */
                static_codebook test5={
                  3,27,
                  NULL,
                  1,
                  -533200896,1611661312,4,1,
                  partial_quantlist1,
                  0
                };
                static float test5_result[]={-3,-6,-9, 4, 1,-2, -1,-4,-7,
                                              -3, 1,-2, 4, 8, 5, -1, 3, 0,
                                              -3,-4,-7, 4, 3, 0, -1,-2,-5,
                                              -3,-6,-2, 4, 1, 5, -1,-4, 0,
                                              -3, 1, 5, 4, 8,12, -1, 3, 7,
                                              -3,-4, 0, 4, 3, 7, -1,-2, 2,
                                              -3,-6,-7, 4, 1, 0, -1,-4,-5,
                                              -3, 1, 0, 4, 8, 7, -1, 3, 2,
                                              -3,-4,-5, 4, 3, 2, -1,-2,-3};
                
                void run_test(static_codebook *b,float *comp){
                  float *out=_book_unquantize(b,b->entries,NULL);
                  int i;
                
                  if(comp){
                    if(!out){
                      fprintf(stderr,"_book_unquantize incorrectly returned NULL\n");
                      exit(1);
                    }
                
                    for(i=0;i<b->entries*b->dim;i++)
                      if(fabs(out[i]-comp[i])>.0001){
                        fprintf(stderr,"disagreement in unquantized and reference data:\n"
                                "position %d, %g != %g\n",i,out[i],comp[i]);
                        exit(1);
                      }
                
                  }else{
                    if(out){
                      fprintf(stderr,"_book_unquantize returned a value array: \n"
                              " correct result should have been NULL\n");
                      exit(1);
                    }
                  }
                }
                
                int main(){
                  /* run the nine dequant tests, and compare to the hand-rolled results */
                  fprintf(stderr,"Dequant test 1... ");
                  run_test(&test1,test1_result);
                  fprintf(stderr,"OK\nDequant test 2... ");
                  run_test(&test2,test2_result);
                  fprintf(stderr,"OK\nDequant test 3... ");
                  run_test(&test3,test3_result);
                  fprintf(stderr,"OK\nDequant test 4... ");
                  run_test(&test4,test4_result);
                  fprintf(stderr,"OK\nDequant test 5... ");
                  run_test(&test5,test5_result);
                  fprintf(stderr,"OK\n\n");
                
                  return(0);
                }
                
                #endif


Top 10 Lines:

     Line      Count

      283      26708
       29       1304
      261        528
      163        240
       73        176
      196        176
      270        176
      313        176
       62        120

Execution Summary:

       14   Executable lines in this file
       12   Lines executed
    85.71   Percent of the file executed

    29604   Total number of line executions
  2114.57   Average executions per line


*** File C:\cygwin\workspace\_git_repos\CustomizeVorbis_static\GprofCdt/../lib/block.c:
                /********************************************************************
                 *                                                                  *
                 * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
                 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
                 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
                 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
                 *                                                                  *
                 * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
                 * by the Xiph.Org Foundation http://www.xiph.org/                  *
                 *                                                                  *
                 ********************************************************************
                
                 function: PCM data vector blocking, windowing and dis/reassembly
                 last mod: $Id: block.c 17561 2010-10-23 10:34:24Z xiphmont $
                
                 Handle windowing, overlap-add, etc of the PCM vectors.  This is made
                 more amusing by Vorbis' current two allowed block sizes.
                
                 ********************************************************************/
                
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <ogg/ogg.h>
                #include "vorbis/codec.h"
                #include "codec_internal.h"
                
                #include "window.h"
                #include "mdct.h"
                #include "lpc.h"
                #include "registry.h"
                #include "misc.h"
                
                static int ilog2(unsigned int v){
                  int ret=0;
                  if(v)--v;
                  while(v){
                    ret++;
                    v>>=1;
                  }
                  return(ret);
                }
                
                /* pcm accumulator examples (not exhaustive):
                
                 <-------------- lW ---------------->
                                   <--------------- W ---------------->
                :            .....|.....       _______________         |
                :        .'''     |     '''_---      |       |\        |
                :.....'''         |_____--- '''......|       | \_______|
                :.................|__________________|_______|__|______|
                                  |<------ Sl ------>|      > Sr <     |endW
                                  |beginSl           |endSl  |  |endSr
                                  |beginW            |endlW  |beginSr
                
                
                                      |< lW >|
                                   <--------------- W ---------------->
                                  |   |  ..  ______________            |
                                  |   | '  `/        |     ---_        |
                                  |___.'___/`.       |         ---_____|
                                  |_______|__|_______|_________________|
                                  |      >|Sl|<      |<------ Sr ----->|endW
                                  |       |  |endSl  |beginSr          |endSr
                                  |beginW |  |endlW
                                  mult[0] |beginSl                     mult[n]
                
                 <-------------- lW ----------------->
                                          |<--W-->|
                :            ..............  ___  |   |
                :        .'''             |`/   \ |   |
                :.....'''                 |/`....\|...|
                :.........................|___|___|___|
                                          |Sl |Sr |endW
                                          |   |   |endSr
                                          |   |beginSr
                                          |   |endSl
                                          |beginSl
                                          |beginW
                */
                
                /* block abstraction setup *********************************************/
                
                #ifndef WORD_ALIGN
                #define WORD_ALIGN 8
                #endif
                
           4 -> int vorbis_block_init(vorbis_dsp_state *v, vorbis_block *vb){
                  int i;
                  memset(vb,0,sizeof(*vb));
                  vb->vd=v;
                  vb->localalloc=0;
                  vb->localstore=NULL;
                  if(v->analysisp){
                    vorbis_block_internal *vbi=
                      vb->internal=_ogg_calloc(1,sizeof(vorbis_block_internal));
                    vbi->ampmax=-9999;
                
                    for(i=0;i<PACKETBLOBS;i++){
                      if(i==PACKETBLOBS/2){
                        vbi->packetblob[i]=&vb->opb;
                      }else{
                        vbi->packetblob[i]=
                          _ogg_calloc(1,sizeof(oggpack_buffer));
                      }
                      oggpack_writeinit(vbi->packetblob[i]);
                    }
                  }
                
                  return(0);
                }
                
       23343 -> void *_vorbis_block_alloc(vorbis_block *vb,long bytes){
                  bytes=(bytes+(WORD_ALIGN-1)) & ~(WORD_ALIGN-1);
                  if(bytes+vb->localtop>vb->localalloc){
                    /* can't just _ogg_realloc... there are outstanding pointers */
                    if(vb->localstore){
                      struct alloc_chain *link=_ogg_malloc(sizeof(*link));
                      vb->totaluse+=vb->localtop;
                      link->next=vb->reap;
                      link->ptr=vb->localstore;
                      vb->reap=link;
                    }
                    /* highly conservative */
                    vb->localalloc=bytes;
                    vb->localstore=_ogg_malloc(vb->localalloc);
                    vb->localtop=0;
                  }
                  {
                    void *ret=(void *)(((char *)vb->localstore)+vb->localtop);
                    vb->localtop+=bytes;
                    return ret;
                  }
                }
                
                /* reap the chain, pull the ripcord */
        3933 -> void _vorbis_block_ripcord(vorbis_block *vb){
                  /* reap the chain */
                  struct alloc_chain *reap=vb->reap;
                  while(reap){
                    struct alloc_chain *next=reap->next;
                    _ogg_free(reap->ptr);
                    memset(reap,0,sizeof(*reap));
                    _ogg_free(reap);
                    reap=next;
                  }
                  /* consolidate storage */
                  if(vb->totaluse){
                    vb->localstore=_ogg_realloc(vb->localstore,vb->totaluse+vb->localalloc);
                    vb->localalloc+=vb->totaluse;
                    vb->totaluse=0;
                  }
                
                  /* pull the ripcord */
                  vb->localtop=0;
                  vb->reap=NULL;
                }
                
          28 -> int vorbis_block_clear(vorbis_block *vb){
                  int i;
                  vorbis_block_internal *vbi=vb->internal;
                
                  _vorbis_block_ripcord(vb);
                  if(vb->localstore)_ogg_free(vb->localstore);
                
                  if(vbi){
                    for(i=0;i<PACKETBLOBS;i++){
                      oggpack_writeclear(vbi->packetblob[i]);
                      if(i!=PACKETBLOBS/2)_ogg_free(vbi->packetblob[i]);
                    }
                    _ogg_free(vbi);
                  }
                  memset(vb,0,sizeof(*vb));
                  return(0);
                }
                
                /* Analysis side code, but directly related to blocking.  Thus it's
                   here and not in analysis.c (which is for analysis transforms only).
                   The init is here because some of it is shared */
                
                static int _vds_shared_init(vorbis_dsp_state *v,vorbis_info *vi,int encp){
                  int i;
                  codec_setup_info *ci=vi->codec_setup;
                  private_state *b=NULL;
                  int hs;
                
                  if(ci==NULL) return 1;
                  hs=ci->halfrate_flag;
                
                  memset(v,0,sizeof(*v));
                  b=v->backend_state=_ogg_calloc(1,sizeof(*b));
                
                  v->vi=vi;
                  b->modebits=ilog2(ci->modes);
                
                  b->transform[0]=_ogg_calloc(VI_TRANSFORMB,sizeof(*b->transform[0]));
                  b->transform[1]=_ogg_calloc(VI_TRANSFORMB,sizeof(*b->transform[1]));
                
                  /* MDCT is tranform 0 */
                
                  b->transform[0][0]=_ogg_calloc(1,sizeof(mdct_lookup));
                  b->transform[1][0]=_ogg_calloc(1,sizeof(mdct_lookup));
                  mdct_init(b->transform[0][0],ci->blocksizes[0]>>hs);
                  mdct_init(b->transform[1][0],ci->blocksizes[1]>>hs);
                
                  /* Vorbis I uses only window type 0 */
                  b->window[0]=ilog2(ci->blocksizes[0])-6;
                  b->window[1]=ilog2(ci->blocksizes[1])-6;
                
                  if(encp){ /* encode/decode differ here */
                
                    /* analysis always needs an fft */
                    drft_init(&b->fft_look[0],ci->blocksizes[0]);
                    drft_init(&b->fft_look[1],ci->blocksizes[1]);
                
                    /* finish the codebooks */
                    if(!ci->fullbooks){
                      ci->fullbooks=_ogg_calloc(ci->books,sizeof(*ci->fullbooks));
                      for(i=0;i<ci->books;i++)
                        vorbis_book_init_encode(ci->fullbooks+i,ci->book_param[i]);
                    }
                
                    b->psy=_ogg_calloc(ci->psys,sizeof(*b->psy));
                    for(i=0;i<ci->psys;i++){
                      _vp_psy_init(b->psy+i,
                                   ci->psy_param[i],
                                   &ci->psy_g_param,
                                   ci->blocksizes[ci->psy_param[i]->blockflag]/2,
                                   vi->rate);
                    }
                
                    v->analysisp=1;
                  }else{
                    /* finish the codebooks */
                    if(!ci->fullbooks){
                      ci->fullbooks=_ogg_calloc(ci->books,sizeof(*ci->fullbooks));
                      for(i=0;i<ci->books;i++){
                        if(ci->book_param[i]==NULL)
                          goto abort_books;
                        if(vorbis_book_init_decode(ci->fullbooks+i,ci->book_param[i]))
                          goto abort_books;
                        /* decode codebooks are now standalone after init */
                        vorbis_staticbook_destroy(ci->book_param[i]);
                        ci->book_param[i]=NULL;
                      }
                    }
                  }
                
                  /* initialize the storage vectors. blocksize[1] is small for encode,
                     but the correct size for decode */
                  v->pcm_storage=ci->blocksizes[1];
                  v->pcm=_ogg_malloc(vi->channels*sizeof(*v->pcm));
                  v->pcmret=_ogg_malloc(vi->channels*sizeof(*v->pcmret));
                  {
                    int i;
                    for(i=0;i<vi->channels;i++)
                      v->pcm[i]=_ogg_calloc(v->pcm_storage,sizeof(*v->pcm[i]));
                  }
                
                  /* all 1 (large block) or 0 (small block) */
                  /* explicitly set for the sake of clarity */
                  v->lW=0; /* previous window size */
                  v->W=0;  /* current window size */
                
                  /* all vector indexes */
                  v->centerW=ci->blocksizes[1]/2;
                
                  v->pcm_current=v->centerW;
                
                  /* initialize all the backend lookups */
                  b->flr=_ogg_calloc(ci->floors,sizeof(*b->flr));
                  b->residue=_ogg_calloc(ci->residues,sizeof(*b->residue));
                
                  for(i=0;i<ci->floors;i++)
                    b->flr[i]=_floor_P[ci->floor_type[i]]->
                      look(v,ci->floor_param[i]);
                
                  for(i=0;i<ci->residues;i++)
                    b->residue[i]=_residue_P[ci->residue_type[i]]->
                      look(v,ci->residue_param[i]);
                
                  return 0;
                 abort_books:
                  for(i=0;i<ci->books;i++){
                    if(ci->book_param[i]!=NULL){
                      vorbis_staticbook_destroy(ci->book_param[i]);
                      ci->book_param[i]=NULL;
                    }
                  }
                  vorbis_dsp_clear(v);
                  return -1;
                }
                
                /* arbitrary settings and spec-mandated numbers get filled in here */
       ##### -> int vorbis_analysis_init(vorbis_dsp_state *v,vorbis_info *vi){
                  private_state *b=NULL;
                
                  if(_vds_shared_init(v,vi,1))return 1;
                  b=v->backend_state;
                  b->psy_g_look=_vp_global_look(vi);
                
                  /* Initialize the envelope state storage */
                  b->ve=_ogg_calloc(1,sizeof(*b->ve));
                  _ve_envelope_init(b->ve,vi);
                
                  vorbis_bitrate_init(vi,&b->bms);
                
                  /* compressed audio packets start after the headers
                     with sequence number 3 */
                  v->sequence=3;
                
                  return(0);
                }
                
          24 -> void vorbis_dsp_clear(vorbis_dsp_state *v){
                  int i;
                  if(v){
                    vorbis_info *vi=v->vi;
                    codec_setup_info *ci=(vi?vi->codec_setup:NULL);
                    private_state *b=v->backend_state;
                
                    if(b){
                
                      if(b->ve){
                        _ve_envelope_clear(b->ve);
                        _ogg_free(b->ve);
                      }
                
                      if(b->transform[0]){
                        mdct_clear(b->transform[0][0]);
                        _ogg_free(b->transform[0][0]);
                        _ogg_free(b->transform[0]);
                      }
                      if(b->transform[1]){
                        mdct_clear(b->transform[1][0]);
                        _ogg_free(b->transform[1][0]);
                        _ogg_free(b->transform[1]);
                      }
                
                      if(b->flr){
                        if(ci)
                          for(i=0;i<ci->floors;i++)
                            _floor_P[ci->floor_type[i]]->
                              free_look(b->flr[i]);
                        _ogg_free(b->flr);
                      }
                      if(b->residue){
                        if(ci)
                          for(i=0;i<ci->residues;i++)
                            _residue_P[ci->residue_type[i]]->
                              free_look(b->residue[i]);
                        _ogg_free(b->residue);
                      }
                      if(b->psy){
                        if(ci)
                          for(i=0;i<ci->psys;i++)
                            _vp_psy_clear(b->psy+i);
                        _ogg_free(b->psy);
                      }
                
                      if(b->psy_g_look)_vp_global_free(b->psy_g_look);
                      vorbis_bitrate_clear(&b->bms);
                
                      drft_clear(&b->fft_look[0]);
                      drft_clear(&b->fft_look[1]);
                
                    }
                
                    if(v->pcm){
                      if(vi)
                        for(i=0;i<vi->channels;i++)
                          if(v->pcm[i])_ogg_free(v->pcm[i]);
                      _ogg_free(v->pcm);
                      if(v->pcmret)_ogg_free(v->pcmret);
                    }
                
                    if(b){
                      /* free header, header1, header2 */
                      if(b->header)_ogg_free(b->header);
                      if(b->header1)_ogg_free(b->header1);
                      if(b->header2)_ogg_free(b->header2);
                      _ogg_free(b);
                    }
                
                    memset(v,0,sizeof(*v));
                  }
                }
                
       ##### -> float **vorbis_analysis_buffer(vorbis_dsp_state *v, int vals){
                  int i;
                  vorbis_info *vi=v->vi;
                  private_state *b=v->backend_state;
                
                  /* free header, header1, header2 */
                  if(b->header)_ogg_free(b->header);b->header=NULL;
                  if(b->header1)_ogg_free(b->header1);b->header1=NULL;
                  if(b->header2)_ogg_free(b->header2);b->header2=NULL;
                
                  /* Do we have enough storage space for the requested buffer? If not,
                     expand the PCM (and envelope) storage */
                
                  if(v->pcm_current+vals>=v->pcm_storage){
                    v->pcm_storage=v->pcm_current+vals*2;
                
                    for(i=0;i<vi->channels;i++){
                      v->pcm[i]=_ogg_realloc(v->pcm[i],v->pcm_storage*sizeof(*v->pcm[i]));
                    }
                  }
                
                  for(i=0;i<vi->channels;i++)
                    v->pcmret[i]=v->pcm[i]+v->pcm_current;
                
                  return(v->pcmret);
                }
                
                static void _preextrapolate_helper(vorbis_dsp_state *v){
                  int i;
                  int order=16;
                  float *lpc=alloca(order*sizeof(*lpc));
                  float *work=alloca(v->pcm_current*sizeof(*work));
                  long j;
                  v->preextrapolate=1;
                
                  if(v->pcm_current-v->centerW>order*2){ /* safety */
                    for(i=0;i<v->vi->channels;i++){
                      /* need to run the extrapolation in reverse! */
                      for(j=0;j<v->pcm_current;j++)
                        work[j]=v->pcm[i][v->pcm_current-j-1];
                
                      /* prime as above */
                      vorbis_lpc_from_data(work,lpc,v->pcm_current-v->centerW,order);
                
                #if 0
                      if(v->vi->channels==2){
                        if(i==0)
                          _analysis_output("predataL",0,work,v->pcm_current-v->centerW,0,0,0);
                        else
                          _analysis_output("predataR",0,work,v->pcm_current-v->centerW,0,0,0);
                      }else{
                        _analysis_output("predata",0,work,v->pcm_current-v->centerW,0,0,0);
                      }
                #endif
                
                      /* run the predictor filter */
                      vorbis_lpc_predict(lpc,work+v->pcm_current-v->centerW-order,
                                         order,
                                         work+v->pcm_current-v->centerW,
                                         v->centerW);
                
                      for(j=0;j<v->pcm_current;j++)
                        v->pcm[i][v->pcm_current-j-1]=work[j];
                
                    }
                  }
                }
                
                
                /* call with val<=0 to set eof */
                
       ##### -> int vorbis_analysis_wrote(vorbis_dsp_state *v, int vals){
                  vorbis_info *vi=v->vi;
                  codec_setup_info *ci=vi->codec_setup;
                
                  if(vals<=0){
                    int order=32;
                    int i;
                    float *lpc=alloca(order*sizeof(*lpc));
                
                    /* if it wasn't done earlier (very short sample) */
                    if(!v->preextrapolate)
                      _preextrapolate_helper(v);
                
                    /* We're encoding the end of the stream.  Just make sure we have
                       [at least] a few full blocks of zeroes at the end. */
                    /* actually, we don't want zeroes; that could drop a large
                       amplitude off a cliff, creating spread spectrum noise that will
                       suck to encode.  Extrapolate for the sake of cleanliness. */
                
                    vorbis_analysis_buffer(v,ci->blocksizes[1]*3);
                    v->eofflag=v->pcm_current;
                    v->pcm_current+=ci->blocksizes[1]*3;
                
                    for(i=0;i<vi->channels;i++){
                      if(v->eofflag>order*2){
                        /* extrapolate with LPC to fill in */
                        long n;
                
                        /* make a predictor filter */
                        n=v->eofflag;
                        if(n>ci->blocksizes[1])n=ci->blocksizes[1];
                        vorbis_lpc_from_data(v->pcm[i]+v->eofflag-n,lpc,n,order);
                
                        /* run the predictor filter */
                        vorbis_lpc_predict(lpc,v->pcm[i]+v->eofflag-order,order,
                                           v->pcm[i]+v->eofflag,v->pcm_current-v->eofflag);
                      }else{
                        /* not enough data to extrapolate (unlikely to happen due to
                           guarding the overlap, but bulletproof in case that
                           assumtion goes away). zeroes will do. */
                        memset(v->pcm[i]+v->eofflag,0,
                               (v->pcm_current-v->eofflag)*sizeof(*v->pcm[i]));
                
                      }
                    }
                  }else{
                
                    if(v->pcm_current+vals>v->pcm_storage)
                      return(OV_EINVAL);
                
                    v->pcm_current+=vals;
                
                    /* we may want to reverse extrapolate the beginning of a stream
                       too... in case we're beginning on a cliff! */
                    /* clumsy, but simple.  It only runs once, so simple is good. */
                    if(!v->preextrapolate && v->pcm_current-v->centerW>ci->blocksizes[1])
                      _preextrapolate_helper(v);
                
                  }
                  return(0);
                }
                
                /* do the deltas, envelope shaping, pre-echo and determine the size of
                   the next block on which to continue analysis */
       ##### -> int vorbis_analysis_blockout(vorbis_dsp_state *v,vorbis_block *vb){
                  int i;
                  vorbis_info *vi=v->vi;
                  codec_setup_info *ci=vi->codec_setup;
                  private_state *b=v->backend_state;
                  vorbis_look_psy_global *g=b->psy_g_look;
                  long beginW=v->centerW-ci->blocksizes[v->W]/2,centerNext;
                  vorbis_block_internal *vbi=(vorbis_block_internal *)vb->internal;
                
                  /* check to see if we're started... */
                  if(!v->preextrapolate)return(0);
                
                  /* check to see if we're done... */
                  if(v->eofflag==-1)return(0);
                
                  /* By our invariant, we have lW, W and centerW set.  Search for
                     the next boundary so we can determine nW (the next window size)
                     which lets us compute the shape of the current block's window */
                
                  /* we do an envelope search even on a single blocksize; we may still
                     be throwing more bits at impulses, and envelope search handles
                     marking impulses too. */
                  {
                    long bp=_ve_envelope_search(v);
                    if(bp==-1){
                
                      if(v->eofflag==0)return(0); /* not enough data currently to search for a
                                                     full long block */
                      v->nW=0;
                    }else{
                
                      if(ci->blocksizes[0]==ci->blocksizes[1])
                        v->nW=0;
                      else
                        v->nW=bp;
                    }
                  }
                
                  centerNext=v->centerW+ci->blocksizes[v->W]/4+ci->blocksizes[v->nW]/4;
                
                  {
                    /* center of next block + next block maximum right side. */
                
                    long blockbound=centerNext+ci->blocksizes[v->nW]/2;
                    if(v->pcm_current<blockbound)return(0); /* not enough data yet;
                                                               although this check is
                                                               less strict that the
                                                               _ve_envelope_search,
                                                               the search is not run
                                                               if we only use one
                                                               block size */
                
                
                  }
                
                  /* fill in the block.  Note that for a short window, lW and nW are *short*
                     regardless of actual settings in the stream */
                
                  _vorbis_block_ripcord(vb);
                  vb->lW=v->lW;
                  vb->W=v->W;
                  vb->nW=v->nW;
                
                  if(v->W){
                    if(!v->lW || !v->nW){
                      vbi->blocktype=BLOCKTYPE_TRANSITION;
                      /*fprintf(stderr,"-");*/
                    }else{
                      vbi->blocktype=BLOCKTYPE_LONG;
                      /*fprintf(stderr,"_");*/
                    }
                  }else{
                    if(_ve_envelope_mark(v)){
                      vbi->blocktype=BLOCKTYPE_IMPULSE;
                      /*fprintf(stderr,"|");*/
                
                    }else{
                      vbi->blocktype=BLOCKTYPE_PADDING;
                      /*fprintf(stderr,".");*/
                
                    }
                  }
                
                  vb->vd=v;
                  vb->sequence=v->sequence++;
                  vb->granulepos=v->granulepos;
                  vb->pcmend=ci->blocksizes[v->W];
                
                  /* copy the vectors; this uses the local storage in vb */
                
                  /* this tracks 'strongest peak' for later psychoacoustics */
                  /* moved to the global psy state; clean this mess up */
                  if(vbi->ampmax>g->ampmax)g->ampmax=vbi->ampmax;
                  g->ampmax=_vp_ampmax_decay(g->ampmax,v);
                  vbi->ampmax=g->ampmax;
                
                  vb->pcm=_vorbis_block_alloc(vb,sizeof(*vb->pcm)*vi->channels);
                  vbi->pcmdelay=_vorbis_block_alloc(vb,sizeof(*vbi->pcmdelay)*vi->channels);
                  for(i=0;i<vi->channels;i++){
                    vbi->pcmdelay[i]=
                      _vorbis_block_alloc(vb,(vb->pcmend+beginW)*sizeof(*vbi->pcmdelay[i]));
                    memcpy(vbi->pcmdelay[i],v->pcm[i],(vb->pcmend+beginW)*sizeof(*vbi->pcmdelay[i]));
                    vb->pcm[i]=vbi->pcmdelay[i]+beginW;
                
                    /* before we added the delay
                       vb->pcm[i]=_vorbis_block_alloc(vb,vb->pcmend*sizeof(*vb->pcm[i]));
                       memcpy(vb->pcm[i],v->pcm[i]+beginW,ci->blocksizes[v->W]*sizeof(*vb->pcm[i]));
                    */
                
                  }
                
                  /* handle eof detection: eof==0 means that we've not yet received EOF
                                           eof>0  marks the last 'real' sample in pcm[]
                                           eof<0  'no more to do'; doesn't get here */
                
                  if(v->eofflag){
                    if(v->centerW>=v->eofflag){
                      v->eofflag=-1;
                      vb->eofflag=1;
                      return(1);
                    }
                  }
                
                  /* advance storage vectors and clean up */
                  {
                    int new_centerNext=ci->blocksizes[1]/2;
                    int movementW=centerNext-new_centerNext;
                
                    if(movementW>0){
                
                      _ve_envelope_shift(b->ve,movementW);
                      v->pcm_current-=movementW;
                
                      for(i=0;i<vi->channels;i++)
                        memmove(v->pcm[i],v->pcm[i]+movementW,
                                v->pcm_current*sizeof(*v->pcm[i]));
                
                
                      v->lW=v->W;
                      v->W=v->nW;
                      v->centerW=new_centerNext;
                
                      if(v->eofflag){
                        v->eofflag-=movementW;
                        if(v->eofflag<=0)v->eofflag=-1;
                        /* do not add padding to end of stream! */
                        if(v->centerW>=v->eofflag){
                          v->granulepos+=movementW-(v->centerW-v->eofflag);
                        }else{
                          v->granulepos+=movementW;
                        }
                      }else{
                        v->granulepos+=movementW;
                      }
                    }
                  }
                
                  /* done */
                  return(1);
                }
                
          20 -> int vorbis_synthesis_restart(vorbis_dsp_state *v){
                  vorbis_info *vi=v->vi;
                  codec_setup_info *ci;
                  int hs;
                
                  if(!v->backend_state)return -1;
                  if(!vi)return -1;
                  ci=vi->codec_setup;
                  if(!ci)return -1;
                  hs=ci->halfrate_flag;
                
                  v->centerW=ci->blocksizes[1]>>(hs+1);
                  v->pcm_current=v->centerW>>hs;
                
                  v->pcm_returned=-1;
                  v->granulepos=-1;
                  v->sequence=-1;
                  v->eofflag=0;
                  ((private_state *)(v->backend_state))->sample_count=-1;
                
                  return(0);
                }
                
           4 -> int vorbis_synthesis_init(vorbis_dsp_state *v,vorbis_info *vi){
                  if(_vds_shared_init(v,vi,0)){
                    vorbis_dsp_clear(v);
                    return 1;
                  }
                  vorbis_synthesis_restart(v);
                  return 0;
                }
                
                /* Unlike in analysis, the window is only partially applied for each
                   block.  The time domain envelope is not yet handled at the point of
                   calling (as it relies on the previous block). */
                
        3902 -> int vorbis_synthesis_blockin(vorbis_dsp_state *v,vorbis_block *vb){
                  vorbis_info *vi=v->vi;
                  codec_setup_info *ci=vi->codec_setup;
                  private_state *b=v->backend_state;
                  int hs=ci->halfrate_flag;
                  int i,j;
                
                  if(!vb)return(OV_EINVAL);
                  if(v->pcm_current>v->pcm_returned  && v->pcm_returned!=-1)return(OV_EINVAL);
                
                  v->lW=v->W;
                  v->W=vb->W;
                  v->nW=-1;
                
                  if((v->sequence==-1)||
                     (v->sequence+1 != vb->sequence)){
                    v->granulepos=-1; /* out of sequence; lose count */
                    b->sample_count=-1;
                  }
                
                  v->sequence=vb->sequence;
                
                  if(vb->pcm){  /* no pcm to process if vorbis_synthesis_trackonly
                                   was called on block */
                    int n=ci->blocksizes[v->W]>>(hs+1);
                    int n0=ci->blocksizes[0]>>(hs+1);
                    int n1=ci->blocksizes[1]>>(hs+1);
                
                    int thisCenter;
                    int prevCenter;
                
                    v->glue_bits+=vb->glue_bits;
                    v->time_bits+=vb->time_bits;
                    v->floor_bits+=vb->floor_bits;
                    v->res_bits+=vb->res_bits;
                
                    if(v->centerW){
                      thisCenter=n1;
                      prevCenter=0;
                    }else{
                      thisCenter=0;
                      prevCenter=n1;
                    }
                
                    /* v->pcm is now used like a two-stage double buffer.  We don't want
                       to have to constantly shift *or* adjust memory usage.  Don't
                       accept a new block until the old is shifted out */
                
                    for(j=0;j<vi->channels;j++){
                      /* the overlap/add section */
                      if(v->lW){
                        if(v->W){
                          /* large/large */
                          float *w=_vorbis_window_get(b->window[1]-hs);
                          float *pcm=v->pcm[j]+prevCenter;
                          float *p=vb->pcm[j];
                          for(i=0;i<n1;i++)
                            pcm[i]=pcm[i]*w[n1-i-1] + p[i]*w[i];
                        }else{
                          /* large/small */
                          float *w=_vorbis_window_get(b->window[0]-hs);
                          float *pcm=v->pcm[j]+prevCenter+n1/2-n0/2;
                          float *p=vb->pcm[j];
                          for(i=0;i<n0;i++)
                            pcm[i]=pcm[i]*w[n0-i-1] +p[i]*w[i];
                        }
                      }else{
                        if(v->W){
                          /* small/large */
                          float *w=_vorbis_window_get(b->window[0]-hs);
                          float *pcm=v->pcm[j]+prevCenter;
                          float *p=vb->pcm[j]+n1/2-n0/2;
                          for(i=0;i<n0;i++)
                            pcm[i]=pcm[i]*w[n0-i-1] +p[i]*w[i];
                          for(;i<n1/2+n0/2;i++)
                            pcm[i]=p[i];
                        }else{
                          /* small/small */
                          float *w=_vorbis_window_get(b->window[0]-hs);
                          float *pcm=v->pcm[j]+prevCenter;
                          float *p=vb->pcm[j];
                          for(i=0;i<n0;i++)
                            pcm[i]=pcm[i]*w[n0-i-1] +p[i]*w[i];
                        }
                      }
                
                      /* the copy section */
                      {
                        float *pcm=v->pcm[j]+thisCenter;
                        float *p=vb->pcm[j]+n;
                        for(i=0;i<n;i++)
                          pcm[i]=p[i];
                      }
                    }
                
                    if(v->centerW)
                      v->centerW=0;
                    else
                      v->centerW=n1;
                
                    /* deal with initial packet state; we do this using the explicit
                       pcm_returned==-1 flag otherwise we're sensitive to first block
                       being short or long */
                
                    if(v->pcm_returned==-1){
                      v->pcm_returned=thisCenter;
                      v->pcm_current=thisCenter;
                    }else{
                      v->pcm_returned=prevCenter;
                      v->pcm_current=prevCenter+
                        ((ci->blocksizes[v->lW]/4+
                        ci->blocksizes[v->W]/4)>>hs);
                    }
                
                  }
                
                  /* track the frame number... This is for convenience, but also
                     making sure our last packet doesn't end with added padding.  If
                     the last packet is partial, the number of samples we'll have to
                     return will be past the vb->granulepos.
                
                     This is not foolproof!  It will be confused if we begin
                     decoding at the last page after a seek or hole.  In that case,
                     we don't have a starting point to judge where the last frame
                     is.  For this reason, vorbisfile will always try to make sure
                     it reads the last two marked pages in proper sequence */
                
                  if(b->sample_count==-1){
                    b->sample_count=0;
                  }else{
                    b->sample_count+=ci->blocksizes[v->lW]/4+ci->blocksizes[v->W]/4;
                  }
                
                  if(v->granulepos==-1){
                    if(vb->granulepos!=-1){ /* only set if we have a position to set to */
                
                      v->granulepos=vb->granulepos;
                
                      /* is this a short page? */
                      if(b->sample_count>v->granulepos){
                        /* corner case; if this is both the first and last audio page,
                           then spec says the end is cut, not beginning */
                       long extra=b->sample_count-vb->granulepos;
                
                        /* we use ogg_int64_t for granule positions because a
                           uint64 isn't universally available.  Unfortunately,
                           that means granposes can be 'negative' and result in
                           extra being negative */
                        if(extra<0)
                          extra=0;
                
                        if(vb->eofflag){
                          /* trim the end */
                          /* no preceding granulepos; assume we started at zero (we'd
                             have to in a short single-page stream) */
                          /* granulepos could be -1 due to a seek, but that would result
                             in a long count, not short count */
                
                          /* Guard against corrupt/malicious frames that set EOP and
                             a backdated granpos; don't rewind more samples than we
                             actually have */
                          if(extra > (v->pcm_current - v->pcm_returned)<<hs)
                            extra = (v->pcm_current - v->pcm_returned)<<hs;
                
                          v->pcm_current-=extra>>hs;
                        }else{
                          /* trim the beginning */
                          v->pcm_returned+=extra>>hs;
                          if(v->pcm_returned>v->pcm_current)
                            v->pcm_returned=v->pcm_current;
                        }
                
                      }
                
                    }
                  }else{
                    v->granulepos+=ci->blocksizes[v->lW]/4+ci->blocksizes[v->W]/4;
                    if(vb->granulepos!=-1 && v->granulepos!=vb->granulepos){
                
                      if(v->granulepos>vb->granulepos){
                        long extra=v->granulepos-vb->granulepos;
                
                        if(extra)
                          if(vb->eofflag){
                            /* partial last frame.  Strip the extra samples off */
                
                            /* Guard against corrupt/malicious frames that set EOP and
                               a backdated granpos; don't rewind more samples than we
                               actually have */
                            if(extra > (v->pcm_current - v->pcm_returned)<<hs)
                              extra = (v->pcm_current - v->pcm_returned)<<hs;
                
                            /* we use ogg_int64_t for granule positions because a
                               uint64 isn't universally available.  Unfortunately,
                               that means granposes can be 'negative' and result in
                               extra being negative */
                            if(extra<0)
                              extra=0;
                
                            v->pcm_current-=extra>>hs;
                          } /* else {Shouldn't happen *unless* the bitstream is out of
                               spec.  Either way, believe the bitstream } */
                      } /* else {Shouldn't happen *unless* the bitstream is out of
                           spec.  Either way, believe the bitstream } */
                      v->granulepos=vb->granulepos;
                    }
                  }
                
                  /* Update, cleanup */
                
                  if(vb->eofflag)v->eofflag=1;
                  return(0);
                
                }
                
                /* pcm==NULL indicates we just want the pending samples, no more */
       16074 -> int vorbis_synthesis_pcmout(vorbis_dsp_state *v,float ***pcm){
                  vorbis_info *vi=v->vi;
                
                  if(v->pcm_returned>-1 && v->pcm_returned<v->pcm_current){
                    if(pcm){
                      int i;
                      for(i=0;i<vi->channels;i++)
                        v->pcmret[i]=v->pcm[i]+v->pcm_returned;
                      *pcm=v->pcmret;
                    }
                    return(v->pcm_current-v->pcm_returned);
                  }
                  return(0);
                }
                
        3980 -> int vorbis_synthesis_read(vorbis_dsp_state *v,int n){
                  if(n && v->pcm_returned+n>v->pcm_current)return(OV_EINVAL);
                  v->pcm_returned+=n;
                  return(0);
                }
                
                /* intended for use with a specific vorbisfile feature; we want access
                   to the [usually synthetic/postextrapolated] buffer and lapping at
                   the end of a decode cycle, specifically, a half-short-block worth.
                   This funtion works like pcmout above, except it will also expose
                   this implicit buffer data not normally decoded. */
       ##### -> int vorbis_synthesis_lapout(vorbis_dsp_state *v,float ***pcm){
                  vorbis_info *vi=v->vi;
                  codec_setup_info *ci=vi->codec_setup;
                  int hs=ci->halfrate_flag;
                
                  int n=ci->blocksizes[v->W]>>(hs+1);
                  int n0=ci->blocksizes[0]>>(hs+1);
                  int n1=ci->blocksizes[1]>>(hs+1);
                  int i,j;
                
                  if(v->pcm_returned<0)return 0;
                
                  /* our returned data ends at pcm_returned; because the synthesis pcm
                     buffer is a two-fragment ring, that means our data block may be
                     fragmented by buffering, wrapping or a short block not filling
                     out a buffer.  To simplify things, we unfragment if it's at all
                     possibly needed. Otherwise, we'd need to call lapout more than
                     once as well as hold additional dsp state.  Opt for
                     simplicity. */
                
                  /* centerW was advanced by blockin; it would be the center of the
                     *next* block */
                  if(v->centerW==n1){
                    /* the data buffer wraps; swap the halves */
                    /* slow, sure, small */
                    for(j=0;j<vi->channels;j++){
                      float *p=v->pcm[j];
                      for(i=0;i<n1;i++){
                        float temp=p[i];
                        p[i]=p[i+n1];
                        p[i+n1]=temp;
                      }
                    }
                
                    v->pcm_current-=n1;
                    v->pcm_returned-=n1;
                    v->centerW=0;
                  }
                
                  /* solidify buffer into contiguous space */
                  if((v->lW^v->W)==1){
                    /* long/short or short/long */
                    for(j=0;j<vi->channels;j++){
                      float *s=v->pcm[j];
                      float *d=v->pcm[j]+(n1-n0)/2;
                      for(i=(n1+n0)/2-1;i>=0;--i)
                        d[i]=s[i];
                    }
                    v->pcm_returned+=(n1-n0)/2;
                    v->pcm_current+=(n1-n0)/2;
                  }else{
                    if(v->lW==0){
                      /* short/short */
                      for(j=0;j<vi->channels;j++){
                        float *s=v->pcm[j];
                        float *d=v->pcm[j]+n1-n0;
                        for(i=n0-1;i>=0;--i)
                          d[i]=s[i];
                      }
                      v->pcm_returned+=n1-n0;
                      v->pcm_current+=n1-n0;
                    }
                  }
                
                  if(pcm){
                    int i;
                    for(i=0;i<vi->channels;i++)
                      v->pcmret[i]=v->pcm[i]+v->pcm_returned;
                    *pcm=v->pcmret;
                  }
                
                  return(n1+n-v->pcm_returned);
                
                }
                
       ##### -> float *vorbis_window(vorbis_dsp_state *v,int W){
                  vorbis_info *vi=v->vi;
                  codec_setup_info *ci=vi->codec_setup;
                  int hs=ci->halfrate_flag;
                  private_state *b=v->backend_state;
                
                  if(b->window[W]-1<0)return NULL;
                  return _vorbis_window_get(b->window[W]-hs);
                }


Top 10 Lines:

     Line      Count

      113      23343
      937      16074
      952       3980
      137       3933
      721       3902
      159         28
      315         24
      685         20
       88          4
      708          4

Execution Summary:

       19   Executable lines in this file
       16   Lines executed
    84.21   Percent of the file executed

    51312   Total number of line executions
  2700.63   Average executions per line


*** File C:\cygwin\workspace\_git_repos\CustomizeVorbis_static\GprofCdt/../lib/synthesis.c:
                /********************************************************************
                 *                                                                  *
                 * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
                 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
                 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
                 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
                 *                                                                  *
                 * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
                 * by the Xiph.Org Foundation http://www.xiph.org/                  *
                 *                                                                  *
                 ********************************************************************
                
                 function: single-block PCM synthesis
                 last mod: $Id: synthesis.c 17474 2010-09-30 03:41:41Z gmaxwell $
                
                 ********************************************************************/
                
                #include <stdio.h>
                #include <ogg/ogg.h>
                #include "vorbis/codec.h"
                #include "codec_internal.h"
                #include "registry.h"
                #include "misc.h"
                #include "os.h"
                
        3891 -> int vorbis_synthesis(vorbis_block *vb,ogg_packet *op){
                  vorbis_dsp_state     *vd= vb ? vb->vd : 0;
                  private_state        *b= vd ? vd->backend_state : 0;
                  vorbis_info          *vi= vd ? vd->vi : 0;
                  codec_setup_info     *ci= vi ? vi->codec_setup : 0;
                  oggpack_buffer       *opb=vb ? &vb->opb : 0;
                  int                   type,mode,i;
                
                  if (!vd || !b || !vi || !ci || !opb) {
                    return OV_EBADPACKET;
                  }
                
                  /* first things first.  Make sure decode is ready */
                  _vorbis_block_ripcord(vb);
                  oggpack_readinit(opb,op->packet,op->bytes);
                
                  /* Check the packet type */
                  if(oggpack_read(opb,1)!=0){
                    /* Oops.  This is not an audio data packet */
                    return(OV_ENOTAUDIO);
                  }
                
                  /* read our mode and pre/post windowsize */
                  mode=oggpack_read(opb,b->modebits);
                  if(mode==-1){
                    return(OV_EBADPACKET);
                  }
                
                  vb->mode=mode;
                  if(!ci->mode_param[mode]){
                    return(OV_EBADPACKET);
                  }
                
                  vb->W=ci->mode_param[mode]->blockflag;
                  if(vb->W){
                
                    /* this doesn;t get mapped through mode selection as it's used
                       only for window selection */
                    vb->lW=oggpack_read(opb,1);
                    vb->nW=oggpack_read(opb,1);
                    if(vb->nW==-1){
                      return(OV_EBADPACKET);
                    }
                  }else{
                    vb->lW=0;
                    vb->nW=0;
                  }
                
                  /* more setup */
                  vb->granulepos=op->granulepos;
                  vb->sequence=op->packetno;
                  vb->eofflag=op->e_o_s;
                
                  /* alloc pcm passback storage */
                  vb->pcmend=ci->blocksizes[vb->W];
                  vb->pcm=_vorbis_block_alloc(vb,sizeof(*vb->pcm)*vi->channels);
                  for(i=0;i<vi->channels;i++)
                    vb->pcm[i]=_vorbis_block_alloc(vb,vb->pcmend*sizeof(*vb->pcm[i]));
                
                  /* unpack_header enforces range checking */
                  type=ci->map_type[ci->mode_param[mode]->mapping];
                
                  return(_mapping_P[type]->inverse(vb,ci->map_param[ci->mode_param[mode]->
                                                                   mapping]));
                }
                
                /* used to track pcm position without actually performing decode.
                   Useful for sequential 'fast forward' */
       ##### -> int vorbis_synthesis_trackonly(vorbis_block *vb,ogg_packet *op){
                  vorbis_dsp_state     *vd=vb->vd;
                  private_state        *b=vd->backend_state;
                  vorbis_info          *vi=vd->vi;
                  codec_setup_info     *ci=vi->codec_setup;
                  oggpack_buffer       *opb=&vb->opb;
                  int                   mode;
                
                  /* first things first.  Make sure decode is ready */
                  _vorbis_block_ripcord(vb);
                  oggpack_readinit(opb,op->packet,op->bytes);
                
                  /* Check the packet type */
                  if(oggpack_read(opb,1)!=0){
                    /* Oops.  This is not an audio data packet */
                    return(OV_ENOTAUDIO);
                  }
                
                  /* read our mode and pre/post windowsize */
                  mode=oggpack_read(opb,b->modebits);
                  if(mode==-1)return(OV_EBADPACKET);
                
                  vb->mode=mode;
                  if(!ci->mode_param[mode]){
                    return(OV_EBADPACKET);
                  }
                  
                  vb->W=ci->mode_param[mode]->blockflag;
                  if(vb->W){
                    vb->lW=oggpack_read(opb,1);
                    vb->nW=oggpack_read(opb,1);
                    if(vb->nW==-1)   return(OV_EBADPACKET);
                  }else{
                    vb->lW=0;
                    vb->nW=0;
                  }
                
                  /* more setup */
                  vb->granulepos=op->granulepos;
                  vb->sequence=op->packetno;
                  vb->eofflag=op->e_o_s;
                
                  /* no pcm */
                  vb->pcmend=0;
                  vb->pcm=NULL;
                
                  return(0);
                }
                
         544 -> long vorbis_packet_blocksize(vorbis_info *vi,ogg_packet *op){
                  codec_setup_info     *ci=vi->codec_setup;
                  oggpack_buffer       opb;
                  int                  mode;
                
                  oggpack_readinit(&opb,op->packet,op->bytes);
                
                  /* Check the packet type */
                  if(oggpack_read(&opb,1)!=0){
                    /* Oops.  This is not an audio data packet */
                    return(OV_ENOTAUDIO);
                  }
                
                  {
                    int modebits=0;
                    int v=ci->modes;
                    while(v>1){
                      modebits++;
                      v>>=1;
                    }
                
                    /* read our mode and pre/post windowsize */
                    mode=oggpack_read(&opb,modebits);
                  }
                  if(mode==-1)return(OV_EBADPACKET);
                  return(ci->blocksizes[ci->mode_param[mode]->blockflag]);
                }
                
       ##### -> int vorbis_synthesis_halfrate(vorbis_info *vi,int flag){
                  /* set / clear half-sample-rate mode */
                  codec_setup_info     *ci=vi->codec_setup;
                
                  /* right now, our MDCT can't handle < 64 sample windows. */
                  if(ci->blocksizes[0]<=64 && flag)return -1;
                  ci->halfrate_flag=(flag?1:0);
                  return 0;
                }
                
        8412 -> int vorbis_synthesis_halfrate_p(vorbis_info *vi){
                  codec_setup_info     *ci=vi->codec_setup;
                  return ci->halfrate_flag;
                }


Top 10 Lines:

     Line      Count

      181       8412
       26       3891
      143        544

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

    12847   Total number of line executions
  2569.40   Average executions per line


*** File C:\cygwin\workspace\_git_repos\CustomizeVorbis_static\GprofCdt/../lib/info.c:
                /********************************************************************
                 *                                                                  *
                 * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
                 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
                 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
                 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
                 *                                                                  *
                 * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2010             *
                 * by the Xiph.Org Foundation http://www.xiph.org/                  *
                 *                                                                  *
                 ********************************************************************
                
                 function: maintain the info structure, info <-> header packets
                 last mod: $Id: info.c 17584 2010-11-01 19:26:16Z xiphmont $
                
                 ********************************************************************/
                
                /* general handling of the header and the vorbis_info structure (and
                   substructures) */
                
                #include <stdlib.h>
                #include <string.h>
                #include <ctype.h>
                #include <ogg/ogg.h>
                #include "vorbis/codec.h"
                #include "codec_internal.h"
                #include "codebook.h"
                #include "registry.h"
                #include "window.h"
                #include "psy.h"
                #include "misc.h"
                #include "os.h"
                
                #define GENERAL_VENDOR_STRING "Xiph.Org libVorbis 1.3.2"
                #define ENCODE_VENDOR_STRING "Xiph.Org libVorbis I 20101101 (Schaufenugget)"
                
                /* helpers */
                static int ilog2(unsigned int v){
                  int ret=0;
                  if(v)--v;
                  while(v){
                    ret++;
                    v>>=1;
                  }
                  return(ret);
                }
                
                static void _v_writestring(oggpack_buffer *o,const char *s, int bytes){
                
                  while(bytes--){
                    oggpack_write(o,*s++,8);
                  }
                }
                
                static void _v_readstring(oggpack_buffer *o,char *buf,int bytes){
                  while(bytes--){
                    *buf++=oggpack_read(o,8);
                  }
                }
                
          12 -> void vorbis_comment_init(vorbis_comment *vc){
                  memset(vc,0,sizeof(*vc));
                }
                
       ##### -> void vorbis_comment_add(vorbis_comment *vc,const char *comment){
                  vc->user_comments=_ogg_realloc(vc->user_comments,
                                            (vc->comments+2)*sizeof(*vc->user_comments));
                  vc->comment_lengths=_ogg_realloc(vc->comment_lengths,
                                                  (vc->comments+2)*sizeof(*vc->comment_lengths));
                  vc->comment_lengths[vc->comments]=strlen(comment);
                  vc->user_comments[vc->comments]=_ogg_malloc(vc->comment_lengths[vc->comments]+1);
                  strcpy(vc->user_comments[vc->comments], comment);
                  vc->comments++;
                  vc->user_comments[vc->comments]=NULL;
                }
                
       ##### -> void vorbis_comment_add_tag(vorbis_comment *vc, const char *tag, const char *contents){
                  char *comment=alloca(strlen(tag)+strlen(contents)+2); /* +2 for = and \0 */
                  strcpy(comment, tag);
                  strcat(comment, "=");
                  strcat(comment, contents);
                  vorbis_comment_add(vc, comment);
                }
                
                /* This is more or less the same as strncasecmp - but that doesn't exist
                 * everywhere, and this is a fairly trivial function, so we include it */
                static int tagcompare(const char *s1, const char *s2, int n){
                  int c=0;
                  while(c < n){
                    if(toupper(s1[c]) != toupper(s2[c]))
                      return !0;
                    c++;
                  }
                  return 0;
                }
                
       ##### -> char *vorbis_comment_query(vorbis_comment *vc, const char *tag, int count){
                  long i;
                  int found = 0;
                  int taglen = strlen(tag)+1; /* +1 for the = we append */
                  char *fulltag = alloca(taglen+ 1);
                
                  strcpy(fulltag, tag);
                  strcat(fulltag, "=");
                
                  for(i=0;i<vc->comments;i++){
                    if(!tagcompare(vc->user_comments[i], fulltag, taglen)){
                      if(count == found)
                        /* We return a pointer to the data, not a copy */
                              return vc->user_comments[i] + taglen;
                      else
                        found++;
                    }
                  }
                  return NULL; /* didn't find anything */
                }
                
       ##### -> int vorbis_comment_query_count(vorbis_comment *vc, const char *tag){
                  int i,count=0;
                  int taglen = strlen(tag)+1; /* +1 for the = we append */
                  char *fulltag = alloca(taglen+1);
                  strcpy(fulltag,tag);
                  strcat(fulltag, "=");
                
                  for(i=0;i<vc->comments;i++){
                    if(!tagcompare(vc->user_comments[i], fulltag, taglen))
                      count++;
                  }
                
                  return count;
                }
                
          12 -> void vorbis_comment_clear(vorbis_comment *vc){
                  if(vc){
                    long i;
                    if(vc->user_comments){
                      for(i=0;i<vc->comments;i++)
                        if(vc->user_comments[i])_ogg_free(vc->user_comments[i]);
                      _ogg_free(vc->user_comments);
                    }
                    if(vc->comment_lengths)_ogg_free(vc->comment_lengths);
                    if(vc->vendor)_ogg_free(vc->vendor);
                    memset(vc,0,sizeof(*vc));
                  }
                }
                
                /* blocksize 0 is guaranteed to be short, 1 is guaranteed to be long.
                   They may be equal, but short will never ge greater than long */
           4 -> int vorbis_info_blocksize(vorbis_info *vi,int zo){
                  codec_setup_info *ci = vi->codec_setup;
                  return ci ? ci->blocksizes[zo] : -1;
                }
                
                /* used by synthesis, which has a full, alloced vi */
          12 -> void vorbis_info_init(vorbis_info *vi){
                  memset(vi,0,sizeof(*vi));
                  vi->codec_setup=_ogg_calloc(1,sizeof(codec_setup_info));
                }
                
          48 -> void vorbis_info_clear(vorbis_info *vi){
                  codec_setup_info     *ci=vi->codec_setup;
                  int i;
                
                  if(ci){
                
                    for(i=0;i<ci->modes;i++)
                      if(ci->mode_param[i])_ogg_free(ci->mode_param[i]);
                
                    for(i=0;i<ci->maps;i++) /* unpack does the range checking */
                      if(ci->map_param[i]) /* this may be cleaning up an aborted
                                              unpack, in which case the below type
                                              cannot be trusted */
                        _mapping_P[ci->map_type[i]]->free_info(ci->map_param[i]);
                
                    for(i=0;i<ci->floors;i++) /* unpack does the range checking */
                      if(ci->floor_param[i]) /* this may be cleaning up an aborted
                                                unpack, in which case the below type
                                                cannot be trusted */
                        _floor_P[ci->floor_type[i]]->free_info(ci->floor_param[i]);
                
                    for(i=0;i<ci->residues;i++) /* unpack does the range checking */
                      if(ci->residue_param[i]) /* this may be cleaning up an aborted
                                                  unpack, in which case the below type
                                                  cannot be trusted */
                        _residue_P[ci->residue_type[i]]->free_info(ci->residue_param[i]);
                
                    for(i=0;i<ci->books;i++){
                      if(ci->book_param[i]){
                        /* knows if the book was not alloced */
                        vorbis_staticbook_destroy(ci->book_param[i]);
                      }
                      if(ci->fullbooks)
                        vorbis_book_clear(ci->fullbooks+i);
                    }
                    if(ci->fullbooks)
                        _ogg_free(ci->fullbooks);
                
                    for(i=0;i<ci->psys;i++)
                      _vi_psy_free(ci->psy_param[i]);
                
                    _ogg_free(ci);
                  }
                
                  memset(vi,0,sizeof(*vi));
                }
                
                /* Header packing/unpacking ********************************************/
                
                static int _vorbis_unpack_info(vorbis_info *vi,oggpack_buffer *opb){
                  codec_setup_info     *ci=vi->codec_setup;
                  if(!ci)return(OV_EFAULT);
                
                  vi->version=oggpack_read(opb,32);
                  if(vi->version!=0)return(OV_EVERSION);
                
                  vi->channels=oggpack_read(opb,8);
                  vi->rate=oggpack_read(opb,32);
                
                  vi->bitrate_upper=oggpack_read(opb,32);
                  vi->bitrate_nominal=oggpack_read(opb,32);
                  vi->bitrate_lower=oggpack_read(opb,32);
                
                  ci->blocksizes[0]=1<<oggpack_read(opb,4);
                  ci->blocksizes[1]=1<<oggpack_read(opb,4);
                
                  if(vi->rate<1)goto err_out;
                  if(vi->channels<1)goto err_out;
                  if(ci->blocksizes[0]<64)goto err_out;
                  if(ci->blocksizes[1]<ci->blocksizes[0])goto err_out;
                  if(ci->blocksizes[1]>8192)goto err_out;
                
                  if(oggpack_read(opb,1)!=1)goto err_out; /* EOP check */
                
                  return(0);
                 err_out:
                  vorbis_info_clear(vi);
                  return(OV_EBADHEADER);
                }
                
                static int _vorbis_unpack_comment(vorbis_comment *vc,oggpack_buffer *opb){
                  int i;
                  int vendorlen=oggpack_read(opb,32);
                  if(vendorlen<0)goto err_out;
                  if(vendorlen>opb->storage-8)goto err_out;
                  vc->vendor=_ogg_calloc(vendorlen+1,1);
                  _v_readstring(opb,vc->vendor,vendorlen);
                  i=oggpack_read(opb,32);
                  if(i<0)goto err_out;
                  if(i>((opb->storage-oggpack_bytes(opb))>>2))goto err_out;
                  vc->comments=i;
                  vc->user_comments=_ogg_calloc(vc->comments+1,sizeof(*vc->user_comments));
                  vc->comment_lengths=_ogg_calloc(vc->comments+1, sizeof(*vc->comment_lengths));
                
                  for(i=0;i<vc->comments;i++){
                    int len=oggpack_read(opb,32);
                    if(len<0)goto err_out;
                    if(len>opb->storage-oggpack_bytes(opb))goto err_out;
                    vc->comment_lengths[i]=len;
                    vc->user_comments[i]=_ogg_calloc(len+1,1);
                    _v_readstring(opb,vc->user_comments[i],len);
                  }
                  if(oggpack_read(opb,1)!=1)goto err_out; /* EOP check */
                
                  return(0);
                 err_out:
                  vorbis_comment_clear(vc);
                  return(OV_EBADHEADER);
                }
                
                /* all of the real encoding details are here.  The modes, books,
                   everything */
                static int _vorbis_unpack_books(vorbis_info *vi,oggpack_buffer *opb){
                  codec_setup_info     *ci=vi->codec_setup;
                  int i;
                  if(!ci)return(OV_EFAULT);
                
                  /* codebooks */
                  ci->books=oggpack_read(opb,8)+1;
                  if(ci->books<=0)goto err_out;
                  for(i=0;i<ci->books;i++){
                    ci->book_param[i]=vorbis_staticbook_unpack(opb);
                    if(!ci->book_param[i])goto err_out;
                  }
                
                  /* time backend settings; hooks are unused */
                  {
                    int times=oggpack_read(opb,6)+1;
                    if(times<=0)goto err_out;
                    for(i=0;i<times;i++){
                      int test=oggpack_read(opb,16);
                      if(test<0 || test>=VI_TIMEB)goto err_out;
                    }
                  }
                
                  /* floor backend settings */
                  ci->floors=oggpack_read(opb,6)+1;
                  if(ci->floors<=0)goto err_out;
                  for(i=0;i<ci->floors;i++){
                    ci->floor_type[i]=oggpack_read(opb,16);
                    if(ci->floor_type[i]<0 || ci->floor_type[i]>=VI_FLOORB)goto err_out;
                    ci->floor_param[i]=_floor_P[ci->floor_type[i]]->unpack(vi,opb);
                    if(!ci->floor_param[i])goto err_out;
                  }
                
                  /* residue backend settings */
                  ci->residues=oggpack_read(opb,6)+1;
                  if(ci->residues<=0)goto err_out;
                  for(i=0;i<ci->residues;i++){
                    ci->residue_type[i]=oggpack_read(opb,16);
                    if(ci->residue_type[i]<0 || ci->residue_type[i]>=VI_RESB)goto err_out;
                    ci->residue_param[i]=_residue_P[ci->residue_type[i]]->unpack(vi,opb);
                    if(!ci->residue_param[i])goto err_out;
                  }
                
                  /* map backend settings */
                  ci->maps=oggpack_read(opb,6)+1;
                  if(ci->maps<=0)goto err_out;
                  for(i=0;i<ci->maps;i++){
                    ci->map_type[i]=oggpack_read(opb,16);
                    if(ci->map_type[i]<0 || ci->map_type[i]>=VI_MAPB)goto err_out;
                    ci->map_param[i]=_mapping_P[ci->map_type[i]]->unpack(vi,opb);
                    if(!ci->map_param[i])goto err_out;
                  }
                
                  /* mode settings */
                  ci->modes=oggpack_read(opb,6)+1;
                  if(ci->modes<=0)goto err_out;
                  for(i=0;i<ci->modes;i++){
                    ci->mode_param[i]=_ogg_calloc(1,sizeof(*ci->mode_param[i]));
                    ci->mode_param[i]->blockflag=oggpack_read(opb,1);
                    ci->mode_param[i]->windowtype=oggpack_read(opb,16);
                    ci->mode_param[i]->transformtype=oggpack_read(opb,16);
                    ci->mode_param[i]->mapping=oggpack_read(opb,8);
                
                    if(ci->mode_param[i]->windowtype>=VI_WINDOWB)goto err_out;
                    if(ci->mode_param[i]->transformtype>=VI_WINDOWB)goto err_out;
                    if(ci->mode_param[i]->mapping>=ci->maps)goto err_out;
                    if(ci->mode_param[i]->mapping<0)goto err_out;
                  }
                
                  if(oggpack_read(opb,1)!=1)goto err_out; /* top level EOP check */
                
                  return(0);
                 err_out:
                  vorbis_info_clear(vi);
                  return(OV_EBADHEADER);
                }
                
                /* Is this packet a vorbis ID header? */
          12 -> int vorbis_synthesis_idheader(ogg_packet *op){
                  oggpack_buffer opb;
                  char buffer[6];
                
                  if(op){
                    oggpack_readinit(&opb,op->packet,op->bytes);
                
                    if(!op->b_o_s)
                      return(0); /* Not the initial packet */
                
                    if(oggpack_read(&opb,8) != 1)
                      return 0; /* not an ID header */
                
                    memset(buffer,0,6);
                    _v_readstring(&opb,buffer,6);
                    if(memcmp(buffer,"vorbis",6))
                      return 0; /* not vorbis */
                
                    return 1;
                  }
                
                  return 0;
                }
                
                /* The Vorbis header is in three packets; the initial small packet in
                   the first page that identifies basic parameters, a second packet
                   with bitstream comments and a third packet that holds the
                   codebook. */
                
          36 -> int vorbis_synthesis_headerin(vorbis_info *vi,vorbis_comment *vc,ogg_packet *op){
                  oggpack_buffer opb;
                
                  if(op){
                    oggpack_readinit(&opb,op->packet,op->bytes);
                
                    /* Which of the three types of header is this? */
                    /* Also verify header-ness, vorbis */
                    {
                      char buffer[6];
                      int packtype=oggpack_read(&opb,8);
                      memset(buffer,0,6);
                      _v_readstring(&opb,buffer,6);
                      if(memcmp(buffer,"vorbis",6)){
                        /* not a vorbis header */
                        return(OV_ENOTVORBIS);
                      }
                      switch(packtype){
                      case 0x01: /* least significant *bit* is read first */
                        if(!op->b_o_s){
                          /* Not the initial packet */
                          return(OV_EBADHEADER);
                        }
                        if(vi->rate!=0){
                          /* previously initialized info header */
                          return(OV_EBADHEADER);
                        }
                
                        return(_vorbis_unpack_info(vi,&opb));
                
                      case 0x03: /* least significant *bit* is read first */
                        if(vi->rate==0){
                          /* um... we didn't get the initial header */
                          return(OV_EBADHEADER);
                        }
                
                        return(_vorbis_unpack_comment(vc,&opb));
                
                      case 0x05: /* least significant *bit* is read first */
                        if(vi->rate==0 || vc->vendor==NULL){
                          /* um... we didn;t get the initial header or comments yet */
                          return(OV_EBADHEADER);
                        }
                
                        return(_vorbis_unpack_books(vi,&opb));
                
                      default:
                        /* Not a valid vorbis header type */
                        return(OV_EBADHEADER);
                        break;
                      }
                    }
                  }
                  return(OV_EBADHEADER);
                }
                
                /* pack side **********************************************************/
                
                static int _vorbis_pack_info(oggpack_buffer *opb,vorbis_info *vi){
                  codec_setup_info     *ci=vi->codec_setup;
                  if(!ci)return(OV_EFAULT);
                
                  /* preamble */
                  oggpack_write(opb,0x01,8);
                  _v_writestring(opb,"vorbis", 6);
                
                  /* basic information about the stream */
                  oggpack_write(opb,0x00,32);
                  oggpack_write(opb,vi->channels,8);
                  oggpack_write(opb,vi->rate,32);
                
                  oggpack_write(opb,vi->bitrate_upper,32);
                  oggpack_write(opb,vi->bitrate_nominal,32);
                  oggpack_write(opb,vi->bitrate_lower,32);
                
                  oggpack_write(opb,ilog2(ci->blocksizes[0]),4);
                  oggpack_write(opb,ilog2(ci->blocksizes[1]),4);
                  oggpack_write(opb,1,1);
                
                  return(0);
                }
                
                static int _vorbis_pack_comment(oggpack_buffer *opb,vorbis_comment *vc){
                  int bytes = strlen(ENCODE_VENDOR_STRING);
                
                  /* preamble */
                  oggpack_write(opb,0x03,8);
                  _v_writestring(opb,"vorbis", 6);
                
                  /* vendor */
                  oggpack_write(opb,bytes,32);
                  _v_writestring(opb,ENCODE_VENDOR_STRING, bytes);
                
                  /* comments */
                
                  oggpack_write(opb,vc->comments,32);
                  if(vc->comments){
                    int i;
                    for(i=0;i<vc->comments;i++){
                      if(vc->user_comments[i]){
                        oggpack_write(opb,vc->comment_lengths[i],32);
                        _v_writestring(opb,vc->user_comments[i], vc->comment_lengths[i]);
                      }else{
                        oggpack_write(opb,0,32);
                      }
                    }
                  }
                  oggpack_write(opb,1,1);
                
                  return(0);
                }
                
                static int _vorbis_pack_books(oggpack_buffer *opb,vorbis_info *vi){
                  codec_setup_info     *ci=vi->codec_setup;
                  int i;
                  if(!ci)return(OV_EFAULT);
                
                  oggpack_write(opb,0x05,8);
                  _v_writestring(opb,"vorbis", 6);
                
                  /* books */
                  oggpack_write(opb,ci->books-1,8);
                  for(i=0;i<ci->books;i++)
                    if(vorbis_staticbook_pack(ci->book_param[i],opb))goto err_out;
                
                  /* times; hook placeholders */
                  oggpack_write(opb,0,6);
                  oggpack_write(opb,0,16);
                
                  /* floors */
                  oggpack_write(opb,ci->floors-1,6);
                  for(i=0;i<ci->floors;i++){
                    oggpack_write(opb,ci->floor_type[i],16);
                    if(_floor_P[ci->floor_type[i]]->pack)
                      _floor_P[ci->floor_type[i]]->pack(ci->floor_param[i],opb);
                    else
                      goto err_out;
                  }
                
                  /* residues */
                  oggpack_write(opb,ci->residues-1,6);
                  for(i=0;i<ci->residues;i++){
                    oggpack_write(opb,ci->residue_type[i],16);
                    _residue_P[ci->residue_type[i]]->pack(ci->residue_param[i],opb);
                  }
                
                  /* maps */
                  oggpack_write(opb,ci->maps-1,6);
                  for(i=0;i<ci->maps;i++){
                    oggpack_write(opb,ci->map_type[i],16);
                    _mapping_P[ci->map_type[i]]->pack(vi,ci->map_param[i],opb);
                  }
                
                  /* modes */
                  oggpack_write(opb,ci->modes-1,6);
                  for(i=0;i<ci->modes;i++){
                    oggpack_write(opb,ci->mode_param[i]->blockflag,1);
                    oggpack_write(opb,ci->mode_param[i]->windowtype,16);
                    oggpack_write(opb,ci->mode_param[i]->transformtype,16);
                    oggpack_write(opb,ci->mode_param[i]->mapping,8);
                  }
                  oggpack_write(opb,1,1);
                
                  return(0);
                err_out:
                  return(-1);
                }
                
                int vorbis_commentheader_out(vorbis_comment *vc,
       ##### ->                                           ogg_packet *op){
                
                  oggpack_buffer opb;
                
                  oggpack_writeinit(&opb);
                  if(_vorbis_pack_comment(&opb,vc)) return OV_EIMPL;
                
                  op->packet = _ogg_malloc(oggpack_bytes(&opb));
                  memcpy(op->packet, opb.buffer, oggpack_bytes(&opb));
                
                  op->bytes=oggpack_bytes(&opb);
                  op->b_o_s=0;
                  op->e_o_s=0;
                  op->granulepos=0;
                  op->packetno=1;
                
                  return 0;
                }
                
                int vorbis_analysis_headerout(vorbis_dsp_state *v,
                                              vorbis_comment *vc,
                                              ogg_packet *op,
                                              ogg_packet *op_comm,
       ##### ->                               ogg_packet *op_code){
                  int ret=OV_EIMPL;
                  vorbis_info *vi=v->vi;
                  oggpack_buffer opb;
                  private_state *b=v->backend_state;
                
                  if(!b){
                    ret=OV_EFAULT;
                    goto err_out;
                  }
                
                  /* first header packet **********************************************/
                
                  oggpack_writeinit(&opb);
                  if(_vorbis_pack_info(&opb,vi))goto err_out;
                
                  /* build the packet */
                  if(b->header)_ogg_free(b->header);
                  b->header=_ogg_malloc(oggpack_bytes(&opb));
                  memcpy(b->header,opb.buffer,oggpack_bytes(&opb));
                  op->packet=b->header;
                  op->bytes=oggpack_bytes(&opb);
                  op->b_o_s=1;
                  op->e_o_s=0;
                  op->granulepos=0;
                  op->packetno=0;
                
                  /* second header packet (comments) **********************************/
                
                  oggpack_reset(&opb);
                  if(_vorbis_pack_comment(&opb,vc))goto err_out;
                
                  if(b->header1)_ogg_free(b->header1);
                  b->header1=_ogg_malloc(oggpack_bytes(&opb));
                  memcpy(b->header1,opb.buffer,oggpack_bytes(&opb));
                  op_comm->packet=b->header1;
                  op_comm->bytes=oggpack_bytes(&opb);
                  op_comm->b_o_s=0;
                  op_comm->e_o_s=0;
                  op_comm->granulepos=0;
                  op_comm->packetno=1;
                
                  /* third header packet (modes/codebooks) ****************************/
                
                  oggpack_reset(&opb);
                  if(_vorbis_pack_books(&opb,vi))goto err_out;
                
                  if(b->header2)_ogg_free(b->header2);
                  b->header2=_ogg_malloc(oggpack_bytes(&opb));
                  memcpy(b->header2,opb.buffer,oggpack_bytes(&opb));
                  op_code->packet=b->header2;
                  op_code->bytes=oggpack_bytes(&opb);
                  op_code->b_o_s=0;
                  op_code->e_o_s=0;
                  op_code->granulepos=0;
                  op_code->packetno=2;
                
                  oggpack_writeclear(&opb);
                  return(0);
                 err_out:
                  memset(op,0,sizeof(*op));
                  memset(op_comm,0,sizeof(*op_comm));
                  memset(op_code,0,sizeof(*op_code));
                
                  if(b){
                    oggpack_writeclear(&opb);
                    if(b->header)_ogg_free(b->header);
                    if(b->header1)_ogg_free(b->header1);
                    if(b->header2)_ogg_free(b->header2);
                    b->header=NULL;
                    b->header1=NULL;
                    b->header2=NULL;
                  }
                  return(ret);
                }
                
       ##### -> double vorbis_granule_time(vorbis_dsp_state *v,ogg_int64_t granulepos){
                  if(granulepos == -1) return -1;
                
                  /* We're not guaranteed a 64 bit unsigned type everywhere, so we
                     have to put the unsigned granpo in a signed type. */
                  if(granulepos>=0){
                    return((double)granulepos/v->vi->rate);
                  }else{
                    ogg_int64_t granuleoff=0xffffffff;
                    granuleoff<<=31;
                    granuleoff|=0x7ffffffff;
                    return(((double)granulepos+2+granuleoff+granuleoff)/v->vi->rate);
                  }
                }
                
       ##### -> const char *vorbis_version_string(void){
                  return GENERAL_VENDOR_STRING;
                }


Top 10 Lines:

     Line      Count

      160         48
      379         36
       61         12
      133         12
      155         12
      350         12
      149          4

Execution Summary:

       25   Executable lines in this file
       15   Lines executed
    60.00   Percent of the file executed

      136   Total number of line executions
     5.44   Average executions per line


*** File C:\cygwin\workspace\_git_repos\CustomizeVorbis_static\GprofCdt/../lib/vorbisfile.c:
                /********************************************************************
                 *                                                                  *
                 * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
                 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
                 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
                 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
                 *                                                                  *
                 * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
                 * by the Xiph.Org Foundation http://www.xiph.org/                  *
                 *                                                                  *
                 ********************************************************************
                
                 function: stdio-based convenience library for opening/seeking/decoding
                 last mod: $Id: vorbisfile.c 17573 2010-10-27 14:53:59Z xiphmont $
                
                 ********************************************************************/
                
                #include <stdlib.h>
                #include <stdio.h>
                #include <errno.h>
                #include <string.h>
                #include <math.h>
                
                #include "vorbis/codec.h"
                
                /* we don't need or want the static callback symbols here */
                #define OV_EXCLUDE_STATIC_CALLBACKS
                #include "vorbis/vorbisfile.h"
                
                #include "os.h"
                #include "misc.h"
                
                /* A 'chained bitstream' is a Vorbis bitstream that contains more than
                   one logical bitstream arranged end to end (the only form of Ogg
                   multiplexing allowed in a Vorbis bitstream; grouping [parallel
                   multiplexing] is not allowed in Vorbis) */
                
                /* A Vorbis file can be played beginning to end (streamed) without
                   worrying ahead of time about chaining (see decoder_example.c).  If
                   we have the whole file, however, and want random access
                   (seeking/scrubbing) or desire to know the total length/time of a
                   file, we need to account for the possibility of chaining. */
                
                /* We can handle things a number of ways; we can determine the entire
                   bitstream structure right off the bat, or find pieces on demand.
                   This example determines and caches structure for the entire
                   bitstream, but builds a virtual decoder on the fly when moving
                   between links in the chain. */
                
                /* There are also different ways to implement seeking.  Enough
                   information exists in an Ogg bitstream to seek to
                   sample-granularity positions in the output.  Or, one can seek by
                   picking some portion of the stream roughly in the desired area if
                   we only want coarse navigation through the stream. */
                
                /*************************************************************************
                 * Many, many internal helpers.  The intention is not to be confusing;
                 * rampant duplication and monolithic function implementation would be
                 * harder to understand anyway.  The high level functions are last.  Begin
                 * grokking near the end of the file */
                
                /* read a little more data from the file/pipe into the ogg_sync framer
                */
                #define CHUNKSIZE 65536 /* greater-than-page-size granularity seeking */
                #define READSIZE 2048 /* a smaller read size is needed for low-rate streaming. */
                
                static long _get_data(OggVorbis_File *vf){
                  errno=0;
                  if(!(vf->callbacks.read_func))return(-1);
                  if(vf->datasource){
                    char *buffer=ogg_sync_buffer(&vf->oy,READSIZE);
                    long bytes=(vf->callbacks.read_func)(buffer,1,READSIZE,vf->datasource);
                    if(bytes>0)ogg_sync_wrote(&vf->oy,bytes);
                    if(bytes==0 && errno)return(-1);
                    return(bytes);
                  }else
                    return(0);
                }
                
                /* save a tiny smidge of verbosity to make the code more readable */
                static int _seek_helper(OggVorbis_File *vf,ogg_int64_t offset){
                  if(vf->datasource){
                    if(!(vf->callbacks.seek_func)||
                       (vf->callbacks.seek_func)(vf->datasource, offset, SEEK_SET) == -1)
                      return OV_EREAD;
                    vf->offset=offset;
                    ogg_sync_reset(&vf->oy);
                  }else{
                    /* shouldn't happen unless someone writes a broken callback */
                    return OV_EFAULT;
                  }
                  return 0;
                }
                
                /* The read/seek functions track absolute position within the stream */
                
                /* from the head of the stream, get the next page.  boundary specifies
                   if the function is allowed to fetch more data from the stream (and
                   how much) or only use internally buffered data.
                
                   boundary: -1) unbounded search
                              0) read no additional data; use cached only
                              n) search for a new page beginning for n bytes
                
                   return:   <0) did not find a page (OV_FALSE, OV_EOF, OV_EREAD)
                              n) found a page at absolute offset n */
                
                static ogg_int64_t _get_next_page(OggVorbis_File *vf,ogg_page *og,
                                                  ogg_int64_t boundary){
                  if(boundary>0)boundary+=vf->offset;
                  while(1){
                    long more;
                
                    if(boundary>0 && vf->offset>=boundary)return(OV_FALSE);
                    more=ogg_sync_pageseek(&vf->oy,og);
                
                    if(more<0){
                      /* skipped n bytes */
                      vf->offset-=more;
                    }else{
                      if(more==0){
                        /* send more paramedics */
                        if(!boundary)return(OV_FALSE);
                        {
                          long ret=_get_data(vf);
                          if(ret==0)return(OV_EOF);
                          if(ret<0)return(OV_EREAD);
                        }
                      }else{
                        /* got a page.  Return the offset at the page beginning,
                           advance the internal offset past the page end */
                        ogg_int64_t ret=vf->offset;
                        vf->offset+=more;
                        return(ret);
                
                      }
                    }
                  }
                }
                
                /* find the latest page beginning before the current stream cursor
                   position. Much dirtier than the above as Ogg doesn't have any
                   backward search linkage.  no 'readp' as it will certainly have to
                   read. */
                /* returns offset or OV_EREAD, OV_FAULT */
                static ogg_int64_t _get_prev_page(OggVorbis_File *vf,ogg_page *og){
                  ogg_int64_t begin=vf->offset;
                  ogg_int64_t end=begin;
                  ogg_int64_t ret;
                  ogg_int64_t offset=-1;
                
                  while(offset==-1){
                    begin-=CHUNKSIZE;
                    if(begin<0)
                      begin=0;
                
                    ret=_seek_helper(vf,begin);
                    if(ret)return(ret);
                
                    while(vf->offset<end){
                      memset(og,0,sizeof(*og));
                      ret=_get_next_page(vf,og,end-vf->offset);
                      if(ret==OV_EREAD)return(OV_EREAD);
                      if(ret<0){
                        break;
                      }else{
                        offset=ret;
                      }
                    }
                  }
                
                  /* In a fully compliant, non-multiplexed stream, we'll still be
                     holding the last page.  In multiplexed (or noncompliant streams),
                     we will probably have to re-read the last page we saw */
                  if(og->header_len==0){
                    ret=_seek_helper(vf,offset);
                    if(ret)return(ret);
                
                    ret=_get_next_page(vf,og,CHUNKSIZE);
                    if(ret<0)
                      /* this shouldn't be possible */
                      return(OV_EFAULT);
                  }
                
                  return(offset);
                }
                
                static void _add_serialno(ogg_page *og,long **serialno_list, int *n){
                  long s = ogg_page_serialno(og);
                  (*n)++;
                
                  if(*serialno_list){
                    *serialno_list = _ogg_realloc(*serialno_list, sizeof(**serialno_list)*(*n));
                  }else{
                    *serialno_list = _ogg_malloc(sizeof(**serialno_list));
                  }
                
                  (*serialno_list)[(*n)-1] = s;
                }
                
                /* returns nonzero if found */
                static int _lookup_serialno(long s, long *serialno_list, int n){
                  if(serialno_list){
                    while(n--){
                      if(*serialno_list == s) return 1;
                      serialno_list++;
                    }
                  }
                  return 0;
                }
                
                static int _lookup_page_serialno(ogg_page *og, long *serialno_list, int n){
                  long s = ogg_page_serialno(og);
                  return _lookup_serialno(s,serialno_list,n);
                }
                
                /* performs the same search as _get_prev_page, but prefers pages of
                   the specified serial number. If a page of the specified serialno is
                   spotted during the seek-back-and-read-forward, it will return the
                   info of last page of the matching serial number instead of the very
                   last page.  If no page of the specified serialno is seen, it will
                   return the info of last page and alter *serialno.  */
                static ogg_int64_t _get_prev_page_serial(OggVorbis_File *vf,
                                                         long *serial_list, int serial_n,
                                                         int *serialno, ogg_int64_t *granpos){
                  ogg_page og;
                  ogg_int64_t begin=vf->offset;
                  ogg_int64_t end=begin;
                  ogg_int64_t ret;
                
                  ogg_int64_t prefoffset=-1;
                  ogg_int64_t offset=-1;
                  ogg_int64_t ret_serialno=-1;
                  ogg_int64_t ret_gran=-1;
                
                  while(offset==-1){
                    begin-=CHUNKSIZE;
                    if(begin<0)
                      begin=0;
                
                    ret=_seek_helper(vf,begin);
                    if(ret)return(ret);
                
                    while(vf->offset<end){
                      ret=_get_next_page(vf,&og,end-vf->offset);
                      if(ret==OV_EREAD)return(OV_EREAD);
                      if(ret<0){
                        break;
                      }else{
                        ret_serialno=ogg_page_serialno(&og);
                        ret_gran=ogg_page_granulepos(&og);
                        offset=ret;
                
                        if(ret_serialno == *serialno){
                          prefoffset=ret;
                          *granpos=ret_gran;
                        }
                
                        if(!_lookup_serialno(ret_serialno,serial_list,serial_n)){
                          /* we fell off the end of the link, which means we seeked
                             back too far and shouldn't have been looking in that link
                             to begin with.  If we found the preferred serial number,
                             forget that we saw it. */
                          prefoffset=-1;
                        }
                      }
                    }
                  }
                
                  /* we're not interested in the page... just the serialno and granpos. */
                  if(prefoffset>=0)return(prefoffset);
                
                  *serialno = ret_serialno;
                  *granpos = ret_gran;
                  return(offset);
                
                }
                
                /* uses the local ogg_stream storage in vf; this is important for
                   non-streaming input sources */
                static int _fetch_headers(OggVorbis_File *vf,vorbis_info *vi,vorbis_comment *vc,
                                          long **serialno_list, int *serialno_n,
                                          ogg_page *og_ptr){
                  ogg_page og;
                  ogg_packet op;
                  int i,ret;
                  int allbos=0;
                
                  if(!og_ptr){
                    ogg_int64_t llret=_get_next_page(vf,&og,CHUNKSIZE);
                    if(llret==OV_EREAD)return(OV_EREAD);
                    if(llret<0)return(OV_ENOTVORBIS);
                    og_ptr=&og;
                  }
                
                  vorbis_info_init(vi);
                  vorbis_comment_init(vc);
                  vf->ready_state=OPENED;
                
                  /* extract the serialnos of all BOS pages + the first set of vorbis
                     headers we see in the link */
                
                  while(ogg_page_bos(og_ptr)){
                    if(serialno_list){
                      if(_lookup_page_serialno(og_ptr,*serialno_list,*serialno_n)){
                        /* a dupe serialnumber in an initial header packet set == invalid stream */
                        if(*serialno_list)_ogg_free(*serialno_list);
                        *serialno_list=0;
                        *serialno_n=0;
                        ret=OV_EBADHEADER;
                        goto bail_header;
                      }
                
                      _add_serialno(og_ptr,serialno_list,serialno_n);
                    }
                
                    if(vf->ready_state<STREAMSET){
                      /* we don't have a vorbis stream in this link yet, so begin
                         prospective stream setup. We need a stream to get packets */
                      ogg_stream_reset_serialno(&vf->os,ogg_page_serialno(og_ptr));
                      ogg_stream_pagein(&vf->os,og_ptr);
                
                      if(ogg_stream_packetout(&vf->os,&op) > 0 &&
                         vorbis_synthesis_idheader(&op)){
                        /* vorbis header; continue setup */
                        vf->ready_state=STREAMSET;
                        if((ret=vorbis_synthesis_headerin(vi,vc,&op))){
                          ret=OV_EBADHEADER;
                          goto bail_header;
                        }
                      }
                    }
                
                    /* get next page */
                    {
                      ogg_int64_t llret=_get_next_page(vf,og_ptr,CHUNKSIZE);
                      if(llret==OV_EREAD){
                        ret=OV_EREAD;
                        goto bail_header;
                      }
                      if(llret<0){
                        ret=OV_ENOTVORBIS;
                        goto bail_header;
                      }
                
                      /* if this page also belongs to our vorbis stream, submit it and break */
                      if(vf->ready_state==STREAMSET &&
                         vf->os.serialno == ogg_page_serialno(og_ptr)){
                        ogg_stream_pagein(&vf->os,og_ptr);
                        break;
                      }
                    }
                  }
                
                  if(vf->ready_state!=STREAMSET){
                    ret = OV_ENOTVORBIS;
                    goto bail_header;
                  }
                
                  while(1){
                
                    i=0;
                    while(i<2){ /* get a page loop */
                
                      while(i<2){ /* get a packet loop */
                
                        int result=ogg_stream_packetout(&vf->os,&op);
                        if(result==0)break;
                        if(result==-1){
                          ret=OV_EBADHEADER;
                          goto bail_header;
                        }
                
                        if((ret=vorbis_synthesis_headerin(vi,vc,&op)))
                          goto bail_header;
                
                        i++;
                      }
                
                      while(i<2){
                        if(_get_next_page(vf,og_ptr,CHUNKSIZE)<0){
                          ret=OV_EBADHEADER;
                          goto bail_header;
                        }
                
                        /* if this page belongs to the correct stream, go parse it */
                        if(vf->os.serialno == ogg_page_serialno(og_ptr)){
                          ogg_stream_pagein(&vf->os,og_ptr);
                          break;
                        }
                
                        /* if we never see the final vorbis headers before the link
                           ends, abort */
                        if(ogg_page_bos(og_ptr)){
                          if(allbos){
                            ret = OV_EBADHEADER;
                            goto bail_header;
                          }else
                            allbos=1;
                        }
                
                        /* otherwise, keep looking */
                      }
                    }
                
                    return 0;
                  }
                
                 bail_header:
                  vorbis_info_clear(vi);
                  vorbis_comment_clear(vc);
                  vf->ready_state=OPENED;
                
                  return ret;
                }
                
                /* Starting from current cursor position, get initial PCM offset of
                   next page.  Consumes the page in the process without decoding
                   audio, however this is only called during stream parsing upon
                   seekable open. */
                static ogg_int64_t _initial_pcmoffset(OggVorbis_File *vf, vorbis_info *vi){
                  ogg_page    og;
                  ogg_int64_t accumulated=0;
                  long        lastblock=-1;
                  int         result;
                  int         serialno = vf->os.serialno;
                
                  while(1){
                    ogg_packet op;
                    if(_get_next_page(vf,&og,-1)<0)
                      break; /* should not be possible unless the file is truncated/mangled */
                
                    if(ogg_page_bos(&og)) break;
                    if(ogg_page_serialno(&og)!=serialno) continue;
                
                    /* count blocksizes of all frames in the page */
                    ogg_stream_pagein(&vf->os,&og);
                    while((result=ogg_stream_packetout(&vf->os,&op))){
                      if(result>0){ /* ignore holes */
                        long thisblock=vorbis_packet_blocksize(vi,&op);
                        if(lastblock!=-1)
                          accumulated+=(lastblock+thisblock)>>2;
                        lastblock=thisblock;
                      }
                    }
                
                    if(ogg_page_granulepos(&og)!=-1){
                      /* pcm offset of last packet on the first audio page */
                      accumulated= ogg_page_granulepos(&og)-accumulated;
                      break;
                    }
                  }
                
                  /* less than zero?  Either a corrupt file or a stream with samples
                     trimmed off the beginning, a normal occurrence; in both cases set
                     the offset to zero */
                  if(accumulated<0)accumulated=0;
                
                  return accumulated;
                }
                
                /* finds each bitstream link one at a time using a bisection search
                   (has to begin by knowing the offset of the lb's initial page).
                   Recurses for each link so it can alloc the link storage after
                   finding them all, then unroll and fill the cache at the same time */
                static int _bisect_forward_serialno(OggVorbis_File *vf,
                                                    ogg_int64_t begin,
                                                    ogg_int64_t searched,
                                                    ogg_int64_t end,
                                                    ogg_int64_t endgran,
                                                    int endserial,
                                                    long *currentno_list,
                                                    int  currentnos,
                                                    long m){
                  ogg_int64_t pcmoffset;
                  ogg_int64_t dataoffset=searched;
                  ogg_int64_t endsearched=end;
                  ogg_int64_t next=end;
                  ogg_int64_t searchgran=-1;
                  ogg_page og;
                  ogg_int64_t ret,last;
                  int serialno = vf->os.serialno;
                
                  /* invariants:
                     we have the headers and serialnos for the link beginning at 'begin'
                     we have the offset and granpos of the last page in the file (potentially
                       not a page we care about)
                  */
                
                  /* Is the last page in our list of current serialnumbers? */
                  if(_lookup_serialno(endserial,currentno_list,currentnos)){
                
                    /* last page is in the starting serialno list, so we've bisected
                       down to (or just started with) a single link.  Now we need to
                       find the last vorbis page belonging to the first vorbis stream
                       for this link. */
                
                    while(endserial != serialno){
                      endserial = serialno;
                      vf->offset=_get_prev_page_serial(vf,currentno_list,currentnos,&endserial,&endgran);
                    }
                
                    vf->links=m+1;
                    if(vf->offsets)_ogg_free(vf->offsets);
                    if(vf->serialnos)_ogg_free(vf->serialnos);
                    if(vf->dataoffsets)_ogg_free(vf->dataoffsets);
                
                    vf->offsets=_ogg_malloc((vf->links+1)*sizeof(*vf->offsets));
                    vf->vi=_ogg_realloc(vf->vi,vf->links*sizeof(*vf->vi));
                    vf->vc=_ogg_realloc(vf->vc,vf->links*sizeof(*vf->vc));
                    vf->serialnos=_ogg_malloc(vf->links*sizeof(*vf->serialnos));
                    vf->dataoffsets=_ogg_malloc(vf->links*sizeof(*vf->dataoffsets));
                    vf->pcmlengths=_ogg_malloc(vf->links*2*sizeof(*vf->pcmlengths));
                
                    vf->offsets[m+1]=end;
                    vf->offsets[m]=begin;
                    vf->pcmlengths[m*2+1]=(endgran<0?0:endgran);
                
                  }else{
                
                    long *next_serialno_list=NULL;
                    int next_serialnos=0;
                    vorbis_info vi;
                    vorbis_comment vc;
                
                    /* the below guards against garbage seperating the last and
                       first pages of two links. */
                    while(searched<endsearched){
                      ogg_int64_t bisect;
                
                      if(endsearched-searched<CHUNKSIZE){
                        bisect=searched;
                      }else{
                        bisect=(searched+endsearched)/2;
                      }
                
                      if(bisect != vf->offset){
                        ret=_seek_helper(vf,bisect);
                        if(ret)return(ret);
                      }
                
                      last=_get_next_page(vf,&og,-1);
                      if(last==OV_EREAD)return(OV_EREAD);
                      if(last<0 || !_lookup_page_serialno(&og,currentno_list,currentnos)){
                        endsearched=bisect;
                        if(last>=0)next=last;
                      }else{
                        searched=vf->offset;
                      }
                    }
                
                    /* Bisection point found */
                
                    /* for the time being, fetch end PCM offset the simple way */
                    {
                      int testserial = serialno+1;
                      vf->offset = next;
                      while(testserial != serialno){
                        testserial = serialno;
                        vf->offset=_get_prev_page_serial(vf,currentno_list,currentnos,&testserial,&searchgran);
                      }
                    }
                
                    if(vf->offset!=next){
                      ret=_seek_helper(vf,next);
                      if(ret)return(ret);
                    }
                
                    ret=_fetch_headers(vf,&vi,&vc,&next_serialno_list,&next_serialnos,NULL);
                    if(ret)return(ret);
                    serialno = vf->os.serialno;
                    dataoffset = vf->offset;
                
                    /* this will consume a page, however the next bistection always
                       starts with a raw seek */
                    pcmoffset = _initial_pcmoffset(vf,&vi);
                
                    ret=_bisect_forward_serialno(vf,next,vf->offset,end,endgran,endserial,
                                                 next_serialno_list,next_serialnos,m+1);
                    if(ret)return(ret);
                
                    if(next_serialno_list)_ogg_free(next_serialno_list);
                
                    vf->offsets[m+1]=next;
                    vf->serialnos[m+1]=serialno;
                    vf->dataoffsets[m+1]=dataoffset;
                
                    vf->vi[m+1]=vi;
                    vf->vc[m+1]=vc;
                
                    vf->pcmlengths[m*2+1]=searchgran;
                    vf->pcmlengths[m*2+2]=pcmoffset;
                    vf->pcmlengths[m*2+3]-=pcmoffset;
                    if(vf->pcmlengths[m*2+3]<0)vf->pcmlengths[m*2+3]=0;
                  }
                  return(0);
                }
                
                static int _make_decode_ready(OggVorbis_File *vf){
                  if(vf->ready_state>STREAMSET)return 0;
                  if(vf->ready_state<STREAMSET)return OV_EFAULT;
                  if(vf->seekable){
                    if(vorbis_synthesis_init(&vf->vd,vf->vi+vf->current_link))
                      return OV_EBADLINK;
                  }else{
                    if(vorbis_synthesis_init(&vf->vd,vf->vi))
                      return OV_EBADLINK;
                  }
                  vorbis_block_init(&vf->vd,&vf->vb);
                  vf->ready_state=INITSET;
                  vf->bittrack=0.f;
                  vf->samptrack=0.f;
                  return 0;
                }
                
                static int _open_seekable2(OggVorbis_File *vf){
                  ogg_int64_t dataoffset=vf->dataoffsets[0],end,endgran=-1;
                  int endserial=vf->os.serialno;
                  int serialno=vf->os.serialno;
                
                  /* we're partially open and have a first link header state in
                     storage in vf */
                
                  /* fetch initial PCM offset */
                  ogg_int64_t pcmoffset = _initial_pcmoffset(vf,vf->vi);
                
                  /* we can seek, so set out learning all about this file */
                  if(vf->callbacks.seek_func && vf->callbacks.tell_func){
                    (vf->callbacks.seek_func)(vf->datasource,0,SEEK_END);
                    vf->offset=vf->end=(vf->callbacks.tell_func)(vf->datasource);
                  }else{
                    vf->offset=vf->end=-1;
                  }
                
                  /* If seek_func is implemented, tell_func must also be implemented */
                  if(vf->end==-1) return(OV_EINVAL);
                
                  /* Get the offset of the last page of the physical bitstream, or, if
                     we're lucky the last vorbis page of this link as most OggVorbis
                     files will contain a single logical bitstream */
                  end=_get_prev_page_serial(vf,vf->serialnos+2,vf->serialnos[1],&endserial,&endgran);
                  if(end<0)return(end);
                
                  /* now determine bitstream structure recursively */
                  if(_bisect_forward_serialno(vf,0,dataoffset,vf->offset,endgran,endserial,
                                              vf->serialnos+2,vf->serialnos[1],0)<0)return(OV_EREAD);
                
                  vf->offsets[0]=0;
                  vf->serialnos[0]=serialno;
                  vf->dataoffsets[0]=dataoffset;
                  vf->pcmlengths[0]=pcmoffset;
                  vf->pcmlengths[1]-=pcmoffset;
                  if(vf->pcmlengths[1]<0)vf->pcmlengths[1]=0;
                
                  return(ov_raw_seek(vf,dataoffset));
                }
                
                /* clear out the current logical bitstream decoder */
                static void _decode_clear(OggVorbis_File *vf){
                  vorbis_dsp_clear(&vf->vd);
                  vorbis_block_clear(&vf->vb);
                  vf->ready_state=OPENED;
                }
                
                /* fetch and process a packet.  Handles the case where we're at a
                   bitstream boundary and dumps the decoding machine.  If the decoding
                   machine is unloaded, it loads it.  It also keeps pcm_offset up to
                   date (seek and read both use this.  seek uses a special hack with
                   readp).
                
                   return: <0) error, OV_HOLE (lost packet) or OV_EOF
                            0) need more data (only if readp==0)
                            1) got a packet
                */
                
                static int _fetch_and_process_packet(OggVorbis_File *vf,
                                                     ogg_packet *op_in,
                                                     int readp,
                                                     int spanp){
                  ogg_page og;
                
                  /* handle one packet.  Try to fetch it from current stream state */
                  /* extract packets from page */
                  while(1){
                
                    if(vf->ready_state==STREAMSET){
                      int ret=_make_decode_ready(vf);
                      if(ret<0)return ret;
                    }
                
                    /* process a packet if we can. */
                
                    if(vf->ready_state==INITSET){
                      int hs=vorbis_synthesis_halfrate_p(vf->vi);
                
                      while(1) {
                              ogg_packet op;
                              ogg_packet *op_ptr=(op_in?op_in:&op);
                        int result=ogg_stream_packetout(&vf->os,op_ptr);
                        ogg_int64_t granulepos;
                
                        op_in=NULL;
                        if(result==-1)return(OV_HOLE); /* hole in the data. */
                        if(result>0){
                          /* got a packet.  process it */
                          granulepos=op_ptr->granulepos;
                          if(!vorbis_synthesis(&vf->vb,op_ptr)){ /* lazy check for lazy
                                                                    header handling.  The
                                                                    header packets aren't
                                                                    audio, so if/when we
                                                                    submit them,
                                                                    vorbis_synthesis will
                                                                    reject them */
                
                            /* suck in the synthesis data and track bitrate */
                            {
                              int oldsamples=vorbis_synthesis_pcmout(&vf->vd,NULL);
                              /* for proper use of libvorbis within libvorbisfile,
                                 oldsamples will always be zero. */
                              if(oldsamples)return(OV_EFAULT);
                
                              vorbis_synthesis_blockin(&vf->vd,&vf->vb);
                              vf->samptrack+=(vorbis_synthesis_pcmout(&vf->vd,NULL)<<hs);
                              vf->bittrack+=op_ptr->bytes*8;
                            }
                
                            /* update the pcm offset. */
                            if(granulepos!=-1 && !op_ptr->e_o_s){
                              int link=(vf->seekable?vf->current_link:0);
                              int i,samples;
                
                              /* this packet has a pcm_offset on it (the last packet
                                 completed on a page carries the offset) After processing
                                 (above), we know the pcm position of the *last* sample
                                 ready to be returned. Find the offset of the *first*
                
                                 As an aside, this trick is inaccurate if we begin
                                 reading anew right at the last page; the end-of-stream
                                 granulepos declares the last frame in the stream, and the
                                 last packet of the last page may be a partial frame.
                                 So, we need a previous granulepos from an in-sequence page
                                 to have a reference point.  Thus the !op_ptr->e_o_s clause
                                 above */
                
                              if(vf->seekable && link>0)
                                granulepos-=vf->pcmlengths[link*2];
                              if(granulepos<0)granulepos=0; /* actually, this
                                                               shouldn't be possible
                                                               here unless the stream
                                                               is very broken */
                
                              samples=(vorbis_synthesis_pcmout(&vf->vd,NULL)<<hs);
                
                              granulepos-=samples;
                              for(i=0;i<link;i++)
                                granulepos+=vf->pcmlengths[i*2+1];
                              vf->pcm_offset=granulepos;
                            }
                            return(1);
                          }
                        }
                        else
                          break;
                      }
                    }
                
                    if(vf->ready_state>=OPENED){
                      ogg_int64_t ret;
                
                      while(1){
                        /* the loop is not strictly necessary, but there's no sense in
                           doing the extra checks of the larger loop for the common
                           case in a multiplexed bistream where the page is simply
                           part of a different logical bitstream; keep reading until
                           we get one with the correct serialno */
                
                        if(!readp)return(0);
                        if((ret=_get_next_page(vf,&og,-1))<0){
                          return(OV_EOF); /* eof. leave unitialized */
                        }
                
                        /* bitrate tracking; add the header's bytes here, the body bytes
                           are done by packet above */
                        vf->bittrack+=og.header_len*8;
                
                        if(vf->ready_state==INITSET){
                          if(vf->current_serialno!=ogg_page_serialno(&og)){
                
                            /* two possibilities:
                               1) our decoding just traversed a bitstream boundary
                               2) another stream is multiplexed into this logical section */
                
                            if(ogg_page_bos(&og)){
                              /* boundary case */
                              if(!spanp)
                                return(OV_EOF);
                
                              _decode_clear(vf);
                
                              if(!vf->seekable){
                                vorbis_info_clear(vf->vi);
                                vorbis_comment_clear(vf->vc);
                              }
                              break;
                
                            }else
                              continue; /* possibility #2 */
                          }
                        }
                
                        break;
                      }
                    }
                
                    /* Do we need to load a new machine before submitting the page? */
                    /* This is different in the seekable and non-seekable cases.
                
                       In the seekable case, we already have all the header
                       information loaded and cached; we just initialize the machine
                       with it and continue on our merry way.
                
                       In the non-seekable (streaming) case, we'll only be at a
                       boundary if we just left the previous logical bitstream and
                       we're now nominally at the header of the next bitstream
                    */
                
                    if(vf->ready_state!=INITSET){
                      int link;
                
                      if(vf->ready_state<STREAMSET){
                        if(vf->seekable){
                          long serialno = ogg_page_serialno(&og);
                
                          /* match the serialno to bitstream section.  We use this rather than
                             offset positions to avoid problems near logical bitstream
                             boundaries */
                
                          for(link=0;link<vf->links;link++)
                            if(vf->serialnos[link]==serialno)break;
                
                          if(link==vf->links) continue; /* not the desired Vorbis
                                                           bitstream section; keep
                                                           trying */
                
                          vf->current_serialno=serialno;
                          vf->current_link=link;
                
                          ogg_stream_reset_serialno(&vf->os,vf->current_serialno);
                          vf->ready_state=STREAMSET;
                
                        }else{
                          /* we're streaming */
                          /* fetch the three header packets, build the info struct */
                
                          int ret=_fetch_headers(vf,vf->vi,vf->vc,NULL,NULL,&og);
                          if(ret)return(ret);
                          vf->current_serialno=vf->os.serialno;
                          vf->current_link++;
                          link=0;
                        }
                      }
                    }
                
                    /* the buffered page is the data we want, and we're ready for it;
                       add it to the stream state */
                    ogg_stream_pagein(&vf->os,&og);
                
                  }
                }
                
                /* if, eg, 64 bit stdio is configured by default, this will build with
                   fseek64 */
                static int _fseek64_wrap(FILE *f,ogg_int64_t off,int whence){
                  if(f==NULL)return(-1);
                  return fseek(f,off,whence);
                }
                
                static int _ov_open1(void *f,OggVorbis_File *vf,const char *initial,
                                     long ibytes, ov_callbacks callbacks){
                  int offsettest=((f && callbacks.seek_func)?callbacks.seek_func(f,0,SEEK_CUR):-1);
                  long *serialno_list=NULL;
                  int serialno_list_size=0;
                  int ret;
                
                  memset(vf,0,sizeof(*vf));
                  vf->datasource=f;
                  vf->callbacks = callbacks;
                
                  /* init the framing state */
                  ogg_sync_init(&vf->oy);
                
                  /* perhaps some data was previously read into a buffer for testing
                     against other stream types.  Allow initialization from this
                     previously read data (especially as we may be reading from a
                     non-seekable stream) */
                  if(initial){
                    char *buffer=ogg_sync_buffer(&vf->oy,ibytes);
                    memcpy(buffer,initial,ibytes);
                    ogg_sync_wrote(&vf->oy,ibytes);
                  }
                
                  /* can we seek? Stevens suggests the seek test was portable */
                  if(offsettest!=-1)vf->seekable=1;
                
                  /* No seeking yet; Set up a 'single' (current) logical bitstream
                     entry for partial open */
                  vf->links=1;
                  vf->vi=_ogg_calloc(vf->links,sizeof(*vf->vi));
                  vf->vc=_ogg_calloc(vf->links,sizeof(*vf->vc));
                  ogg_stream_init(&vf->os,-1); /* fill in the serialno later */
                
                  /* Fetch all BOS pages, store the vorbis header and all seen serial
                     numbers, load subsequent vorbis setup headers */
                  if((ret=_fetch_headers(vf,vf->vi,vf->vc,&serialno_list,&serialno_list_size,NULL))<0){
                    vf->datasource=NULL;
                    ov_clear(vf);
                  }else{
                    /* serial number list for first link needs to be held somewhere
                       for second stage of seekable stream open; this saves having to
                       seek/reread first link's serialnumber data then. */
                    vf->serialnos=_ogg_calloc(serialno_list_size+2,sizeof(*vf->serialnos));
                    vf->serialnos[0]=vf->current_serialno=vf->os.serialno;
                    vf->serialnos[1]=serialno_list_size;
                    memcpy(vf->serialnos+2,serialno_list,serialno_list_size*sizeof(*vf->serialnos));
                
                    vf->offsets=_ogg_calloc(1,sizeof(*vf->offsets));
                    vf->dataoffsets=_ogg_calloc(1,sizeof(*vf->dataoffsets));
                    vf->offsets[0]=0;
                    vf->dataoffsets[0]=vf->offset;
                
                    vf->ready_state=PARTOPEN;
                  }
                  if(serialno_list)_ogg_free(serialno_list);
                  return(ret);
                }
                
                static int _ov_open2(OggVorbis_File *vf){
                  if(vf->ready_state != PARTOPEN) return OV_EINVAL;
                  vf->ready_state=OPENED;
                  if(vf->seekable){
                    int ret=_open_seekable2(vf);
                    if(ret){
                      vf->datasource=NULL;
                      ov_clear(vf);
                    }
                    return(ret);
                  }else
                    vf->ready_state=STREAMSET;
                
                  return 0;
                }
                
                
                /* clear out the OggVorbis_File struct */
          24 -> int ov_clear(OggVorbis_File *vf){
                  if(vf){
                    vorbis_block_clear(&vf->vb);
                    vorbis_dsp_clear(&vf->vd);
                    ogg_stream_clear(&vf->os);
                
                    if(vf->vi && vf->links){
                      int i;
                      for(i=0;i<vf->links;i++){
                        vorbis_info_clear(vf->vi+i);
                        vorbis_comment_clear(vf->vc+i);
                      }
                      _ogg_free(vf->vi);
                      _ogg_free(vf->vc);
                    }
                    if(vf->dataoffsets)_ogg_free(vf->dataoffsets);
                    if(vf->pcmlengths)_ogg_free(vf->pcmlengths);
                    if(vf->serialnos)_ogg_free(vf->serialnos);
                    if(vf->offsets)_ogg_free(vf->offsets);
                    ogg_sync_clear(&vf->oy);
                    if(vf->datasource && vf->callbacks.close_func)
                      (vf->callbacks.close_func)(vf->datasource);
                    memset(vf,0,sizeof(*vf));
                  }
                #ifdef DEBUG_LEAKS
                  _VDBG_dump();
                #endif
                  return(0);
                }
                
                /* inspects the OggVorbis file and finds/documents all the logical
                   bitstreams contained in it.  Tries to be tolerant of logical
                   bitstream sections that are truncated/woogie.
                
                   return: -1) error
                            0) OK
                */
                
                int ov_open_callbacks(void *f,OggVorbis_File *vf,
          12 ->     const char *initial,long ibytes,ov_callbacks callbacks){
                  int ret=_ov_open1(f,vf,initial,ibytes,callbacks);
                  if(ret)return ret;
                  return _ov_open2(vf);
                }
                
          12 -> int ov_open(FILE *f,OggVorbis_File *vf,const char *initial,long ibytes){
                  ov_callbacks callbacks = {
                    (size_t (*)(void *, size_t, size_t, void *))  fread,
                    (int (*)(void *, ogg_int64_t, int))              _fseek64_wrap,
                    (int (*)(void *))                             fclose,
                    (long (*)(void *))                            ftell
                  };
                
                  return ov_open_callbacks((void *)f, vf, initial, ibytes, callbacks);
                }
                
          12 -> int ov_fopen(const char *path,OggVorbis_File *vf){
                  int ret;
                  FILE *f = fopen(path,"rb");
                  if(!f) return -1;
                
                  ret = ov_open(f,vf,NULL,0);
                  if(ret) fclose(f);
                  return ret;
                }
                
                
                /* cheap hack for game usage where downsampling is desirable; there's
                   no need for SRC as we can just do it cheaply in libvorbis. */
                
       ##### -> int ov_halfrate(OggVorbis_File *vf,int flag){
                  int i;
                  if(vf->vi==NULL)return OV_EINVAL;
                  if(vf->ready_state>STREAMSET){
                    /* clear out stream state; dumping the decode machine is needed to
                       reinit the MDCT lookups. */
                    vorbis_dsp_clear(&vf->vd);
                    vorbis_block_clear(&vf->vb);
                    vf->ready_state=STREAMSET;
                    if(vf->pcm_offset>=0){
                      ogg_int64_t pos=vf->pcm_offset;
                      vf->pcm_offset=-1; /* make sure the pos is dumped if unseekable */
                      ov_pcm_seek(vf,pos);
                    }
                  }
                
                  for(i=0;i<vf->links;i++){
                    if(vorbis_synthesis_halfrate(vf->vi+i,flag)){
                      if(flag) ov_halfrate(vf,0);
                      return OV_EINVAL;
                    }
                  }
                  return 0;
                }
                
       ##### -> int ov_halfrate_p(OggVorbis_File *vf){
                  if(vf->vi==NULL)return OV_EINVAL;
                  return vorbis_synthesis_halfrate_p(vf->vi);
                }
                
                /* Only partially open the vorbis file; test for Vorbisness, and load
                   the headers for the first chain.  Do not seek (although test for
                   seekability).  Use ov_test_open to finish opening the file, else
                   ov_clear to close/free it. Same return codes as open. */
                
                int ov_test_callbacks(void *f,OggVorbis_File *vf,
                    const char *initial,long ibytes,ov_callbacks callbacks)
       ##### -> {
                  return _ov_open1(f,vf,initial,ibytes,callbacks);
                }
                
       ##### -> int ov_test(FILE *f,OggVorbis_File *vf,const char *initial,long ibytes){
                  ov_callbacks callbacks = {
                    (size_t (*)(void *, size_t, size_t, void *))  fread,
                    (int (*)(void *, ogg_int64_t, int))              _fseek64_wrap,
                    (int (*)(void *))                             fclose,
                    (long (*)(void *))                            ftell
                  };
                
                  return ov_test_callbacks((void *)f, vf, initial, ibytes, callbacks);
                }
                
       ##### -> int ov_test_open(OggVorbis_File *vf){
                  if(vf->ready_state!=PARTOPEN)return(OV_EINVAL);
                  return _ov_open2(vf);
                }
                
                /* How many logical bitstreams in this physical bitstream? */
       ##### -> long ov_streams(OggVorbis_File *vf){
                  return vf->links;
                }
                
                /* Is the FILE * associated with vf seekable? */
       ##### -> long ov_seekable(OggVorbis_File *vf){
                  return vf->seekable;
                }
                
                /* returns the bitrate for a given logical bitstream or the entire
                   physical bitstream.  If the file is open for random access, it will
                   find the *actual* average bitrate.  If the file is streaming, it
                   returns the nominal bitrate (if set) else the average of the
                   upper/lower bounds (if set) else -1 (unset).
                
                   If you want the actual bitrate field settings, get them from the
                   vorbis_info structs */
                
       ##### -> long ov_bitrate(OggVorbis_File *vf,int i){
                  if(vf->ready_state<OPENED)return(OV_EINVAL);
                  if(i>=vf->links)return(OV_EINVAL);
                  if(!vf->seekable && i!=0)return(ov_bitrate(vf,0));
                  if(i<0){
                    ogg_int64_t bits=0;
                    int i;
                    float br;
                    for(i=0;i<vf->links;i++)
                      bits+=(vf->offsets[i+1]-vf->dataoffsets[i])*8;
                    /* This once read: return(rint(bits/ov_time_total(vf,-1)));
                     * gcc 3.x on x86 miscompiled this at optimisation level 2 and above,
                     * so this is slightly transformed to make it work.
                     */
                    br = bits/ov_time_total(vf,-1);
                    return(rint(br));
                  }else{
                    if(vf->seekable){
                      /* return the actual bitrate */
                      return(rint((vf->offsets[i+1]-vf->dataoffsets[i])*8/ov_time_total(vf,i)));
                    }else{
                      /* return nominal if set */
                      if(vf->vi[i].bitrate_nominal>0){
                        return vf->vi[i].bitrate_nominal;
                      }else{
                        if(vf->vi[i].bitrate_upper>0){
                          if(vf->vi[i].bitrate_lower>0){
                            return (vf->vi[i].bitrate_upper+vf->vi[i].bitrate_lower)/2;
                          }else{
                            return vf->vi[i].bitrate_upper;
                          }
                        }
                        return(OV_FALSE);
                      }
                    }
                  }
                }
                
                /* returns the actual bitrate since last call.  returns -1 if no
                   additional data to offer since last call (or at beginning of stream),
                   EINVAL if stream is only partially open
                */
       ##### -> long ov_bitrate_instant(OggVorbis_File *vf){
                  int link=(vf->seekable?vf->current_link:0);
                  long ret;
                  if(vf->ready_state<OPENED)return(OV_EINVAL);
                  if(vf->samptrack==0)return(OV_FALSE);
                  ret=vf->bittrack/vf->samptrack*vf->vi[link].rate+.5;
                  vf->bittrack=0.f;
                  vf->samptrack=0.f;
                  return(ret);
                }
                
                /* Guess */
       ##### -> long ov_serialnumber(OggVorbis_File *vf,int i){
                  if(i>=vf->links)return(ov_serialnumber(vf,vf->links-1));
                  if(!vf->seekable && i>=0)return(ov_serialnumber(vf,-1));
                  if(i<0){
                    return(vf->current_serialno);
                  }else{
                    return(vf->serialnos[i]);
                  }
                }
                
                /* returns: total raw (compressed) length of content if i==-1
                            raw (compressed) length of that logical bitstream for i==0 to n
                            OV_EINVAL if the stream is not seekable (we can't know the length)
                            or if stream is only partially open
                */
       ##### -> ogg_int64_t ov_raw_total(OggVorbis_File *vf,int i){
                  if(vf->ready_state<OPENED)return(OV_EINVAL);
                  if(!vf->seekable || i>=vf->links)return(OV_EINVAL);
                  if(i<0){
                    ogg_int64_t acc=0;
                    int i;
                    for(i=0;i<vf->links;i++)
                      acc+=ov_raw_total(vf,i);
                    return(acc);
                  }else{
                    return(vf->offsets[i+1]-vf->offsets[i]);
                  }
                }
                
                /* returns: total PCM length (samples) of content if i==-1 PCM length
                            (samples) of that logical bitstream for i==0 to n
                            OV_EINVAL if the stream is not seekable (we can't know the
                            length) or only partially open
                */
           8 -> ogg_int64_t ov_pcm_total(OggVorbis_File *vf,int i){
                  if(vf->ready_state<OPENED)return(OV_EINVAL);
                  if(!vf->seekable || i>=vf->links)return(OV_EINVAL);
                  if(i<0){
                    ogg_int64_t acc=0;
                    int i;
                    for(i=0;i<vf->links;i++)
                      acc+=ov_pcm_total(vf,i);
                    return(acc);
                  }else{
                    return(vf->pcmlengths[i*2+1]);
                  }
                }
                
                /* returns: total seconds of content if i==-1
                            seconds in that logical bitstream for i==0 to n
                            OV_EINVAL if the stream is not seekable (we can't know the
                            length) or only partially open
                */
           4 -> double ov_time_total(OggVorbis_File *vf,int i){
                  if(vf->ready_state<OPENED)return(OV_EINVAL);
                  if(!vf->seekable || i>=vf->links)return(OV_EINVAL);
                  if(i<0){
                    double acc=0;
                    int i;
                    for(i=0;i<vf->links;i++)
                      acc+=ov_time_total(vf,i);
                    return(acc);
                  }else{
                    return((double)(vf->pcmlengths[i*2+1])/vf->vi[i].rate);
                  }
                }
                
                /* seek to an offset relative to the *compressed* data. This also
                   scans packets to update the PCM cursor. It will cross a logical
                   bitstream boundary, but only if it can't get any packets out of the
                   tail of the bitstream we seek to (so no surprises).
                
                   returns zero on success, nonzero on failure */
                
          12 -> int ov_raw_seek(OggVorbis_File *vf,ogg_int64_t pos){
                  ogg_stream_state work_os;
                  int ret;
                
                  if(vf->ready_state<OPENED)return(OV_EINVAL);
                  if(!vf->seekable)
                    return(OV_ENOSEEK); /* don't dump machine if we can't seek */
                
                  if(pos<0 || pos>vf->end)return(OV_EINVAL);
                
                  /* is the seek position outside our current link [if any]? */
                  if(vf->ready_state>=STREAMSET){
                    if(pos<vf->offsets[vf->current_link] || pos>=vf->offsets[vf->current_link+1])
                      _decode_clear(vf); /* clear out stream state */
                  }
                
                  /* don't yet clear out decoding machine (if it's initialized), in
                     the case we're in the same link.  Restart the decode lapping, and
                     let _fetch_and_process_packet deal with a potential bitstream
                     boundary */
                  vf->pcm_offset=-1;
                  ogg_stream_reset_serialno(&vf->os,
                                            vf->current_serialno); /* must set serialno */
                  vorbis_synthesis_restart(&vf->vd);
                
                  ret=_seek_helper(vf,pos);
                  if(ret)goto seek_error;
                
                  /* we need to make sure the pcm_offset is set, but we don't want to
                     advance the raw cursor past good packets just to get to the first
                     with a granulepos.  That's not equivalent behavior to beginning
                     decoding as immediately after the seek position as possible.
                
                     So, a hack.  We use two stream states; a local scratch state and
                     the shared vf->os stream state.  We use the local state to
                     scan, and the shared state as a buffer for later decode.
                
                     Unfortuantely, on the last page we still advance to last packet
                     because the granulepos on the last page is not necessarily on a
                     packet boundary, and we need to make sure the granpos is
                     correct.
                  */
                
                  {
                    ogg_page og;
                    ogg_packet op;
                    int lastblock=0;
                    int accblock=0;
                    int thisblock=0;
                    int lastflag=0;
                    int firstflag=0;
                    ogg_int64_t pagepos=-1;
                
                    ogg_stream_init(&work_os,vf->current_serialno); /* get the memory ready */
                    ogg_stream_reset(&work_os); /* eliminate the spurious OV_HOLE
                                                   return from not necessarily
                                                   starting from the beginning */
                
                    while(1){
                      if(vf->ready_state>=STREAMSET){
                        /* snarf/scan a packet if we can */
                        int result=ogg_stream_packetout(&work_os,&op);
                
                        if(result>0){
                
                          if(vf->vi[vf->current_link].codec_setup){
                            thisblock=vorbis_packet_blocksize(vf->vi+vf->current_link,&op);
                            if(thisblock<0){
                              ogg_stream_packetout(&vf->os,NULL);
                              thisblock=0;
                            }else{
                
                              /* We can't get a guaranteed correct pcm position out of the
                                 last page in a stream because it might have a 'short'
                                 granpos, which can only be detected in the presence of a
                                 preceding page.  However, if the last page is also the first
                                 page, the granpos rules of a first page take precedence.  Not
                                 only that, but for first==last, the EOS page must be treated
                                 as if its a normal first page for the stream to open/play. */
                              if(lastflag && !firstflag)
                                ogg_stream_packetout(&vf->os,NULL);
                              else
                                if(lastblock)accblock+=(lastblock+thisblock)>>2;
                            }
                
                            if(op.granulepos!=-1){
                              int i,link=vf->current_link;
                              ogg_int64_t granulepos=op.granulepos-vf->pcmlengths[link*2];
                              if(granulepos<0)granulepos=0;
                
                              for(i=0;i<link;i++)
                                granulepos+=vf->pcmlengths[i*2+1];
                              vf->pcm_offset=granulepos-accblock;
                              if(vf->pcm_offset<0)vf->pcm_offset=0;
                              break;
                            }
                            lastblock=thisblock;
                            continue;
                          }else
                            ogg_stream_packetout(&vf->os,NULL);
                        }
                      }
                
                      if(!lastblock){
                        pagepos=_get_next_page(vf,&og,-1);
                        if(pagepos<0){
                          vf->pcm_offset=ov_pcm_total(vf,-1);
                          break;
                        }
                      }else{
                        /* huh?  Bogus stream with packets but no granulepos */
                        vf->pcm_offset=-1;
                        break;
                      }
                
                      /* has our decoding just traversed a bitstream boundary? */
                      if(vf->ready_state>=STREAMSET){
                        if(vf->current_serialno!=ogg_page_serialno(&og)){
                
                          /* two possibilities:
                             1) our decoding just traversed a bitstream boundary
                             2) another stream is multiplexed into this logical section? */
                
                          if(ogg_page_bos(&og)){
                            /* we traversed */
                            _decode_clear(vf); /* clear out stream state */
                            ogg_stream_clear(&work_os);
                          } /* else, do nothing; next loop will scoop another page */
                        }
                      }
                
                      if(vf->ready_state<STREAMSET){
                        int link;
                        long serialno = ogg_page_serialno(&og);
                
                        for(link=0;link<vf->links;link++)
                          if(vf->serialnos[link]==serialno)break;
                
                        if(link==vf->links) continue; /* not the desired Vorbis
                                                         bitstream section; keep
                                                         trying */
                        vf->current_link=link;
                        vf->current_serialno=serialno;
                        ogg_stream_reset_serialno(&vf->os,serialno);
                        ogg_stream_reset_serialno(&work_os,serialno);
                        vf->ready_state=STREAMSET;
                        firstflag=(pagepos<=vf->dataoffsets[link]);
                      }
                
                      ogg_stream_pagein(&vf->os,&og);
                      ogg_stream_pagein(&work_os,&og);
                      lastflag=ogg_page_eos(&og);
                
                    }
                  }
                
                  ogg_stream_clear(&work_os);
                  vf->bittrack=0.f;
                  vf->samptrack=0.f;
                  return(0);
                
                 seek_error:
                  /* dump the machine so we're in a known state */
                  vf->pcm_offset=-1;
                  ogg_stream_clear(&work_os);
                  _decode_clear(vf);
                  return OV_EBADLINK;
                }
                
                /* Page granularity seek (faster than sample granularity because we
                   don't do the last bit of decode to find a specific sample).
                
                   Seek to the last [granule marked] page preceding the specified pos
                   location, such that decoding past the returned point will quickly
                   arrive at the requested position. */
           4 -> int ov_pcm_seek_page(OggVorbis_File *vf,ogg_int64_t pos){
                  int link=-1;
                  ogg_int64_t result=0;
                  ogg_int64_t total=ov_pcm_total(vf,-1);
                
                  if(vf->ready_state<OPENED)return(OV_EINVAL);
                  if(!vf->seekable)return(OV_ENOSEEK);
                
                  if(pos<0 || pos>total)return(OV_EINVAL);
                
                  /* which bitstream section does this pcm offset occur in? */
                  for(link=vf->links-1;link>=0;link--){
                    total-=vf->pcmlengths[link*2+1];
                    if(pos>=total)break;
                  }
                
                  /* search within the logical bitstream for the page with the highest
                     pcm_pos preceding (or equal to) pos.  There is a danger here;
                     missing pages or incorrect frame number information in the
                     bitstream could make our task impossible.  Account for that (it
                     would be an error condition) */
                
                  /* new search algorithm by HB (Nicholas Vinen) */
                  {
                    ogg_int64_t end=vf->offsets[link+1];
                    ogg_int64_t begin=vf->offsets[link];
                    ogg_int64_t begintime = vf->pcmlengths[link*2];
                    ogg_int64_t endtime = vf->pcmlengths[link*2+1]+begintime;
                    ogg_int64_t target=pos-total+begintime;
                    ogg_int64_t best=begin;
                
                    ogg_page og;
                    while(begin<end){
                      ogg_int64_t bisect;
                
                      if(end-begin<CHUNKSIZE){
                        bisect=begin;
                      }else{
                        /* take a (pretty decent) guess. */
                        bisect=begin +
                          (ogg_int64_t)((double)(target-begintime)*(end-begin)/(endtime-begintime))
                          - CHUNKSIZE;
                        if(bisect<begin+CHUNKSIZE)
                          bisect=begin;
                      }
                
                      if(bisect!=vf->offset){
                        result=_seek_helper(vf,bisect);
                        if(result) goto seek_error;
                      }
                
                      while(begin<end){
                        result=_get_next_page(vf,&og,end-vf->offset);
                        if(result==OV_EREAD) goto seek_error;
                        if(result<0){
                          if(bisect<=begin+1)
                            end=begin; /* found it */
                          else{
                            if(bisect==0) goto seek_error;
                            bisect-=CHUNKSIZE;
                            if(bisect<=begin)bisect=begin+1;
                            result=_seek_helper(vf,bisect);
                            if(result) goto seek_error;
                          }
                        }else{
                          ogg_int64_t granulepos;
                
                          if(ogg_page_serialno(&og)!=vf->serialnos[link])
                            continue;
                
                          granulepos=ogg_page_granulepos(&og);
                          if(granulepos==-1)continue;
                
                          if(granulepos<target){
                            best=result;  /* raw offset of packet with granulepos */
                            begin=vf->offset; /* raw offset of next page */
                            begintime=granulepos;
                
                            if(target-begintime>44100)break;
                            bisect=begin; /* *not* begin + 1 */
                          }else{
                            if(bisect<=begin+1)
                              end=begin;  /* found it */
                            else{
                              if(end==vf->offset){ /* we're pretty close - we'd be stuck in */
                                end=result;
                                bisect-=CHUNKSIZE; /* an endless loop otherwise. */
                                if(bisect<=begin)bisect=begin+1;
                                result=_seek_helper(vf,bisect);
                                if(result) goto seek_error;
                              }else{
                                end=bisect;
                                endtime=granulepos;
                                break;
                              }
                            }
                          }
                        }
                      }
                    }
                
                    /* found our page. seek to it, update pcm offset. Easier case than
                       raw_seek, don't keep packets preceding granulepos. */
                    {
                      ogg_page og;
                      ogg_packet op;
                
                      /* seek */
                      result=_seek_helper(vf,best);
                      vf->pcm_offset=-1;
                      if(result) goto seek_error;
                      result=_get_next_page(vf,&og,-1);
                      if(result<0) goto seek_error;
                
                      if(link!=vf->current_link){
                        /* Different link; dump entire decode machine */
                        _decode_clear(vf);
                
                        vf->current_link=link;
                        vf->current_serialno=vf->serialnos[link];
                        vf->ready_state=STREAMSET;
                
                      }else{
                        vorbis_synthesis_restart(&vf->vd);
                      }
                
                      ogg_stream_reset_serialno(&vf->os,vf->current_serialno);
                      ogg_stream_pagein(&vf->os,&og);
                
                      /* pull out all but last packet; the one with granulepos */
                      while(1){
                        result=ogg_stream_packetpeek(&vf->os,&op);
                        if(result==0){
                          /* !!! the packet finishing this page originated on a
                             preceding page. Keep fetching previous pages until we
                             get one with a granulepos or without the 'continued' flag
                             set.  Then just use raw_seek for simplicity. */
                
                          result=_seek_helper(vf,best);
                          if(result<0) goto seek_error;
                
                          while(1){
                            result=_get_prev_page(vf,&og);
                            if(result<0) goto seek_error;
                            if(ogg_page_serialno(&og)==vf->current_serialno &&
                               (ogg_page_granulepos(&og)>-1 ||
                                !ogg_page_continued(&og))){
                              return ov_raw_seek(vf,result);
                            }
                            vf->offset=result;
                          }
                        }
                        if(result<0){
                          result = OV_EBADPACKET;
                          goto seek_error;
                        }
                        if(op.granulepos!=-1){
                          vf->pcm_offset=op.granulepos-vf->pcmlengths[vf->current_link*2];
                          if(vf->pcm_offset<0)vf->pcm_offset=0;
                          vf->pcm_offset+=total;
                          break;
                        }else
                          result=ogg_stream_packetout(&vf->os,NULL);
                      }
                    }
                  }
                
                  /* verify result */
                  if(vf->pcm_offset>pos || pos>ov_pcm_total(vf,-1)){
                    result=OV_EFAULT;
                    goto seek_error;
                  }
                  vf->bittrack=0.f;
                  vf->samptrack=0.f;
                  return(0);
                
                 seek_error:
                  /* dump machine so we're in a known state */
                  vf->pcm_offset=-1;
                  _decode_clear(vf);
                  return (int)result;
                }
                
                /* seek to a sample offset relative to the decompressed pcm stream
                   returns zero on success, nonzero on failure */
                
           4 -> int ov_pcm_seek(OggVorbis_File *vf,ogg_int64_t pos){
                  int thisblock,lastblock=0;
                  int ret=ov_pcm_seek_page(vf,pos);
                  if(ret<0)return(ret);
                  if((ret=_make_decode_ready(vf)))return ret;
                
                  /* discard leading packets we don't need for the lapping of the
                     position we want; don't decode them */
                
                  while(1){
                    ogg_packet op;
                    ogg_page og;
                
                    int ret=ogg_stream_packetpeek(&vf->os,&op);
                    if(ret>0){
                      thisblock=vorbis_packet_blocksize(vf->vi+vf->current_link,&op);
                      if(thisblock<0){
                        ogg_stream_packetout(&vf->os,NULL);
                        continue; /* non audio packet */
                      }
                      if(lastblock)vf->pcm_offset+=(lastblock+thisblock)>>2;
                
                      if(vf->pcm_offset+((thisblock+
                                          vorbis_info_blocksize(vf->vi,1))>>2)>=pos)break;
                
                      /* remove the packet from packet queue and track its granulepos */
                      ogg_stream_packetout(&vf->os,NULL);
                      vorbis_synthesis_trackonly(&vf->vb,&op);  /* set up a vb with
                                                                   only tracking, no
                                                                   pcm_decode */
                      vorbis_synthesis_blockin(&vf->vd,&vf->vb);
                
                      /* end of logical stream case is hard, especially with exact
                         length positioning. */
                
                      if(op.granulepos>-1){
                        int i;
                        /* always believe the stream markers */
                        vf->pcm_offset=op.granulepos-vf->pcmlengths[vf->current_link*2];
                        if(vf->pcm_offset<0)vf->pcm_offset=0;
                        for(i=0;i<vf->current_link;i++)
                          vf->pcm_offset+=vf->pcmlengths[i*2+1];
                      }
                
                      lastblock=thisblock;
                
                    }else{
                      if(ret<0 && ret!=OV_HOLE)break;
                
                      /* suck in a new page */
                      if(_get_next_page(vf,&og,-1)<0)break;
                      if(ogg_page_bos(&og))_decode_clear(vf);
                
                      if(vf->ready_state<STREAMSET){
                        long serialno=ogg_page_serialno(&og);
                        int link;
                
                        for(link=0;link<vf->links;link++)
                          if(vf->serialnos[link]==serialno)break;
                        if(link==vf->links) continue;
                        vf->current_link=link;
                
                        vf->ready_state=STREAMSET;
                        vf->current_serialno=ogg_page_serialno(&og);
                        ogg_stream_reset_serialno(&vf->os,serialno);
                        ret=_make_decode_ready(vf);
                        if(ret)return ret;
                        lastblock=0;
                      }
                
                      ogg_stream_pagein(&vf->os,&og);
                    }
                  }
                
                  vf->bittrack=0.f;
                  vf->samptrack=0.f;
                  /* discard samples until we reach the desired position. Crossing a
                     logical bitstream boundary with abandon is OK. */
                  {
                    /* note that halfrate could be set differently in each link, but
                       vorbisfile encoforces all links are set or unset */
                    int hs=vorbis_synthesis_halfrate_p(vf->vi);
                    while(vf->pcm_offset<((pos>>hs)<<hs)){
                      ogg_int64_t target=(pos-vf->pcm_offset)>>hs;
                      long samples=vorbis_synthesis_pcmout(&vf->vd,NULL);
                
                      if(samples>target)samples=target;
                      vorbis_synthesis_read(&vf->vd,samples);
                      vf->pcm_offset+=samples<<hs;
                
                      if(samples<target)
                        if(_fetch_and_process_packet(vf,NULL,1,1)<=0)
                          vf->pcm_offset=ov_pcm_total(vf,-1); /* eof */
                    }
                  }
                  return 0;
                }
                
                /* seek to a playback time relative to the decompressed pcm stream
                   returns zero on success, nonzero on failure */
           4 -> int ov_time_seek(OggVorbis_File *vf,double seconds){
                  /* translate time to PCM position and call ov_pcm_seek */
                
                  int link=-1;
                  ogg_int64_t pcm_total=0;
                  double time_total=0.;
                
                  if(vf->ready_state<OPENED)return(OV_EINVAL);
                  if(!vf->seekable)return(OV_ENOSEEK);
                  if(seconds<0)return(OV_EINVAL);
                
                  /* which bitstream section does this time offset occur in? */
                  for(link=0;link<vf->links;link++){
                    double addsec = ov_time_total(vf,link);
                    if(seconds<time_total+addsec)break;
                    time_total+=addsec;
                    pcm_total+=vf->pcmlengths[link*2+1];
                  }
                
                  if(link==vf->links)return(OV_EINVAL);
                
                  /* enough information to convert time offset to pcm offset */
                  {
                    ogg_int64_t target=pcm_total+(seconds-time_total)*vf->vi[link].rate;
                    return(ov_pcm_seek(vf,target));
                  }
                }
                
                /* page-granularity version of ov_time_seek
                   returns zero on success, nonzero on failure */
       ##### -> int ov_time_seek_page(OggVorbis_File *vf,double seconds){
                  /* translate time to PCM position and call ov_pcm_seek */
                
                  int link=-1;
                  ogg_int64_t pcm_total=0;
                  double time_total=0.;
                
                  if(vf->ready_state<OPENED)return(OV_EINVAL);
                  if(!vf->seekable)return(OV_ENOSEEK);
                  if(seconds<0)return(OV_EINVAL);
                
                  /* which bitstream section does this time offset occur in? */
                  for(link=0;link<vf->links;link++){
                    double addsec = ov_time_total(vf,link);
                    if(seconds<time_total+addsec)break;
                    time_total+=addsec;
                    pcm_total+=vf->pcmlengths[link*2+1];
                  }
                
                  if(link==vf->links)return(OV_EINVAL);
                
                  /* enough information to convert time offset to pcm offset */
                  {
                    ogg_int64_t target=pcm_total+(seconds-time_total)*vf->vi[link].rate;
                    return(ov_pcm_seek_page(vf,target));
                  }
                }
                
                /* tell the current stream offset cursor.  Note that seek followed by
                   tell will likely not give the set offset due to caching */
       ##### -> ogg_int64_t ov_raw_tell(OggVorbis_File *vf){
                  if(vf->ready_state<OPENED)return(OV_EINVAL);
                  return(vf->offset);
                }
                
                /* return PCM offset (sample) of next PCM sample to be read */
       ##### -> ogg_int64_t ov_pcm_tell(OggVorbis_File *vf){
                  if(vf->ready_state<OPENED)return(OV_EINVAL);
                  return(vf->pcm_offset);
                }
                
                /* return time offset (seconds) of next PCM sample to be read */
       ##### -> double ov_time_tell(OggVorbis_File *vf){
                  int link=0;
                  ogg_int64_t pcm_total=0;
                  double time_total=0.f;
                
                  if(vf->ready_state<OPENED)return(OV_EINVAL);
                  if(vf->seekable){
                    pcm_total=ov_pcm_total(vf,-1);
                    time_total=ov_time_total(vf,-1);
                
                    /* which bitstream section does this time offset occur in? */
                    for(link=vf->links-1;link>=0;link--){
                      pcm_total-=vf->pcmlengths[link*2+1];
                      time_total-=ov_time_total(vf,link);
                      if(vf->pcm_offset>=pcm_total)break;
                    }
                  }
                
                  return((double)time_total+(double)(vf->pcm_offset-pcm_total)/vf->vi[link].rate);
                }
                
                /*  link:   -1) return the vorbis_info struct for the bitstream section
                                currently being decoded
                           0-n) to request information for a specific bitstream section
                
                    In the case of a non-seekable bitstream, any call returns the
                    current bitstream.  NULL in the case that the machine is not
                    initialized */
                
        3969 -> vorbis_info *ov_info(OggVorbis_File *vf,int link){
                  if(vf->seekable){
                    if(link<0)
                      if(vf->ready_state>=STREAMSET)
                        return vf->vi+vf->current_link;
                      else
                      return vf->vi;
                    else
                      if(link>=vf->links)
                        return NULL;
                      else
                        return vf->vi+link;
                  }else{
                    return vf->vi;
                  }
                }
                
                /* grr, strong typing, grr, no templates/inheritence, grr */
        3993 -> vorbis_comment *ov_comment(OggVorbis_File *vf,int link){
                  if(vf->seekable){
                    if(link<0)
                      if(vf->ready_state>=STREAMSET)
                        return vf->vc+vf->current_link;
                      else
                        return vf->vc;
                    else
                      if(link>=vf->links)
                        return NULL;
                      else
                        return vf->vc+link;
                  }else{
                    return vf->vc;
                  }
                }
                
                static int host_is_big_endian() {
                  ogg_int32_t pattern = 0xfeedface; /* deadbeef */
                  unsigned char *bytewise = (unsigned char *)&pattern;
                  if (bytewise[0] == 0xfe) return 1;
                  return 0;
                }
                
                /* up to this point, everything could more or less hide the multiple
                   logical bitstream nature of chaining from the toplevel application
                   if the toplevel application didn't particularly care.  However, at
                   the point that we actually read audio back, the multiple-section
                   nature must surface: Multiple bitstream sections do not necessarily
                   have to have the same number of channels or sampling rate.
                
                   ov_read returns the sequential logical bitstream number currently
                   being decoded along with the PCM data in order that the toplevel
                   application can take action on channel/sample rate changes.  This
                   number will be incremented even for streamed (non-seekable) streams
                   (for seekable streams, it represents the actual logical bitstream
                   index within the physical bitstream.  Note that the accessor
                   functions above are aware of this dichotomy).
                
                   ov_read_filter is exactly the same as ov_read except that it processes
                   the decoded audio data through a filter before packing it into the
                   requested format. This gives greater accuracy than applying a filter
                   after the audio has been converted into integral PCM.
                
                   input values: buffer) a buffer to hold packed PCM data for return
                                 length) the byte length requested to be placed into buffer
                                 bigendianp) should the data be packed LSB first (0) or
                                             MSB first (1)
                                 word) word size for output.  currently 1 (byte) or
                                       2 (16 bit short)
                
                   return values: <0) error/hole in data (OV_HOLE), partial open (OV_EINVAL)
                                   0) EOF
                                   n) number of bytes of PCM actually returned.  The
                                   below works on a packet-by-packet basis, so the
                                   return length is not related to the 'length' passed
                                   in, just guaranteed to fit.
                
                            *section) set to the logical bitstream number */
                
                long ov_read_filter(OggVorbis_File *vf,char *buffer,int length,
                                    int bigendianp,int word,int sgned,int *bitstream,
        3981 ->                     void (*filter)(float **pcm,long channels,long samples,void *filter_param),void *filter_param){
                  int i,j;
                  int host_endian = host_is_big_endian();
                  int hs;
                
                  float **pcm;
                  long samples;
                
                  if(vf->ready_state<OPENED)return(OV_EINVAL);
                
                  while(1){
                    if(vf->ready_state==INITSET){
                      samples=vorbis_synthesis_pcmout(&vf->vd,&pcm);
                      if(samples)break;
                    }
                
                    /* suck in another packet */
                    {
                      int ret=_fetch_and_process_packet(vf,NULL,1,1);
                      if(ret==OV_EOF)
                        return(0);
                      if(ret<=0)
                        return(ret);
                    }
                
                  }
                
                  if(samples>0){
                
                    /* yay! proceed to pack data into the byte buffer */
                
                    long channels=ov_info(vf,-1)->channels;
                    long bytespersample=word * channels;
                    vorbis_fpu_control fpu;
                    if(samples>length/bytespersample)samples=length/bytespersample;
                
                    if(samples <= 0)
                      return OV_EINVAL;
                
                    /* Here. */
                    if(filter)
                      filter(pcm,channels,samples,filter_param);
                
                    /* a tight loop to pack each size */
                    {
                      int val;
                      if(word==1){
                        int off=(sgned?0:128);
                        vorbis_fpu_setround(&fpu);
                        for(j=0;j<samples;j++)
                          for(i=0;i<channels;i++){
                            val=vorbis_ftoi(pcm[i][j]*128.f);
                            if(val>127)val=127;
                            else if(val<-128)val=-128;
                            *buffer++=val+off;
                          }
                        vorbis_fpu_restore(fpu);
                      }else{
                        int off=(sgned?0:32768);
                
                        if(host_endian==bigendianp){
                          if(sgned){
                
                            vorbis_fpu_setround(&fpu);
                            for(i=0;i<channels;i++) { /* It's faster in this order */
                              float *src=pcm[i];
                              short *dest=((short *)buffer)+i;
                              for(j=0;j<samples;j++) {
                                val=vorbis_ftoi(src[j]*32768.f);
                                if(val>32767)val=32767;
                                else if(val<-32768)val=-32768;
                                *dest=val;
                                dest+=channels;
                              }
                            }
                            vorbis_fpu_restore(fpu);
                
                          }else{
                
                            vorbis_fpu_setround(&fpu);
                            for(i=0;i<channels;i++) {
                              float *src=pcm[i];
                              short *dest=((short *)buffer)+i;
                              for(j=0;j<samples;j++) {
                                val=vorbis_ftoi(src[j]*32768.f);
                                if(val>32767)val=32767;
                                else if(val<-32768)val=-32768;
                                *dest=val+off;
                                dest+=channels;
                              }
                            }
                            vorbis_fpu_restore(fpu);
                
                          }
                        }else if(bigendianp){
                
                          vorbis_fpu_setround(&fpu);
                          for(j=0;j<samples;j++)
                            for(i=0;i<channels;i++){
                              val=vorbis_ftoi(pcm[i][j]*32768.f);
                              if(val>32767)val=32767;
                              else if(val<-32768)val=-32768;
                              val+=off;
                              *buffer++=(val>>8);
                              *buffer++=(val&0xff);
                            }
                          vorbis_fpu_restore(fpu);
                
                        }else{
                          int val;
                          vorbis_fpu_setround(&fpu);
                          for(j=0;j<samples;j++)
                            for(i=0;i<channels;i++){
                              val=vorbis_ftoi(pcm[i][j]*32768.f);
                              if(val>32767)val=32767;
                              else if(val<-32768)val=-32768;
                              val+=off;
                              *buffer++=(val&0xff);
                              *buffer++=(val>>8);
                                  }
                          vorbis_fpu_restore(fpu);
                
                        }
                      }
                    }
                
                    vorbis_synthesis_read(&vf->vd,samples);
                    hs=vorbis_synthesis_halfrate_p(vf->vi);
                    vf->pcm_offset+=(samples<<hs);
                    if(bitstream)*bitstream=vf->current_link;
                    return(samples*bytespersample);
                  }else{
                    return(samples);
                  }
                }
                
                long ov_read(OggVorbis_File *vf,char *buffer,int length,
        3950 ->              int bigendianp,int word,int sgned,int *bitstream){
                  return ov_read_filter(vf, buffer, length, bigendianp, word, sgned, bitstream, NULL, NULL);
                }
                
                /* input values: pcm_channels) a float vector per channel of output
                                 length) the sample length being read by the app
                
                   return values: <0) error/hole in data (OV_HOLE), partial open (OV_EINVAL)
                                   0) EOF
                                   n) number of samples of PCM actually returned.  The
                                   below works on a packet-by-packet basis, so the
                                   return length is not related to the 'length' passed
                                   in, just guaranteed to fit.
                
                            *section) set to the logical bitstream number */
                
                
                
                long ov_read_float(OggVorbis_File *vf,float ***pcm_channels,int length,
       ##### ->                    int *bitstream){
                
                  if(vf->ready_state<OPENED)return(OV_EINVAL);
                
                  while(1){
                    if(vf->ready_state==INITSET){
                      float **pcm;
                      long samples=vorbis_synthesis_pcmout(&vf->vd,&pcm);
                      if(samples){
                        int hs=vorbis_synthesis_halfrate_p(vf->vi);
                        if(pcm_channels)*pcm_channels=pcm;
                        if(samples>length)samples=length;
                        vorbis_synthesis_read(&vf->vd,samples);
                        vf->pcm_offset+=samples<<hs;
                        if(bitstream)*bitstream=vf->current_link;
                        return samples;
                
                      }
                    }
                
                    /* suck in another packet */
                    {
                      int ret=_fetch_and_process_packet(vf,NULL,1,1);
                      if(ret==OV_EOF)return(0);
                      if(ret<=0)return(ret);
                    }
                
                  }
                }
                
                extern float *vorbis_window(vorbis_dsp_state *v,int W);
                
                static void _ov_splice(float **pcm,float **lappcm,
                                       int n1, int n2,
                                       int ch1, int ch2,
                                       float *w1, float *w2){
                  int i,j;
                  float *w=w1;
                  int n=n1;
                
                  if(n1>n2){
                    n=n2;
                    w=w2;
                  }
                
                  /* splice */
                  for(j=0;j<ch1 && j<ch2;j++){
                    float *s=lappcm[j];
                    float *d=pcm[j];
                
                    for(i=0;i<n;i++){
                      float wd=w[i]*w[i];
                      float ws=1.-wd;
                      d[i]=d[i]*wd + s[i]*ws;
                    }
                  }
                  /* window from zero */
                  for(;j<ch2;j++){
                    float *d=pcm[j];
                    for(i=0;i<n;i++){
                      float wd=w[i]*w[i];
                      d[i]=d[i]*wd;
                    }
                  }
                
                }
                
                /* make sure vf is INITSET */
                static int _ov_initset(OggVorbis_File *vf){
                  while(1){
                    if(vf->ready_state==INITSET)break;
                    /* suck in another packet */
                    {
                      int ret=_fetch_and_process_packet(vf,NULL,1,0);
                      if(ret<0 && ret!=OV_HOLE)return(ret);
                    }
                  }
                  return 0;
                }
                
                /* make sure vf is INITSET and that we have a primed buffer; if
                   we're crosslapping at a stream section boundary, this also makes
                   sure we're sanity checking against the right stream information */
                static int _ov_initprime(OggVorbis_File *vf){
                  vorbis_dsp_state *vd=&vf->vd;
                  while(1){
                    if(vf->ready_state==INITSET)
                      if(vorbis_synthesis_pcmout(vd,NULL))break;
                
                    /* suck in another packet */
                    {
                      int ret=_fetch_and_process_packet(vf,NULL,1,0);
                      if(ret<0 && ret!=OV_HOLE)return(ret);
                    }
                  }
                  return 0;
                }
                
                /* grab enough data for lapping from vf; this may be in the form of
                   unreturned, already-decoded pcm, remaining PCM we will need to
                   decode, or synthetic postextrapolation from last packets. */
                static void _ov_getlap(OggVorbis_File *vf,vorbis_info *vi,vorbis_dsp_state *vd,
                                       float **lappcm,int lapsize){
                  int lapcount=0,i;
                  float **pcm;
                
                  /* try first to decode the lapping data */
                  while(lapcount<lapsize){
                    int samples=vorbis_synthesis_pcmout(vd,&pcm);
                    if(samples){
                      if(samples>lapsize-lapcount)samples=lapsize-lapcount;
                      for(i=0;i<vi->channels;i++)
                        memcpy(lappcm[i]+lapcount,pcm[i],sizeof(**pcm)*samples);
                      lapcount+=samples;
                      vorbis_synthesis_read(vd,samples);
                    }else{
                    /* suck in another packet */
                      int ret=_fetch_and_process_packet(vf,NULL,1,0); /* do *not* span */
                      if(ret==OV_EOF)break;
                    }
                  }
                  if(lapcount<lapsize){
                    /* failed to get lapping data from normal decode; pry it from the
                       postextrapolation buffering, or the second half of the MDCT
                       from the last packet */
                    int samples=vorbis_synthesis_lapout(&vf->vd,&pcm);
                    if(samples==0){
                      for(i=0;i<vi->channels;i++)
                        memset(lappcm[i]+lapcount,0,sizeof(**pcm)*lapsize-lapcount);
                      lapcount=lapsize;
                    }else{
                      if(samples>lapsize-lapcount)samples=lapsize-lapcount;
                      for(i=0;i<vi->channels;i++)
                        memcpy(lappcm[i]+lapcount,pcm[i],sizeof(**pcm)*samples);
                      lapcount+=samples;
                    }
                  }
                }
                
                /* this sets up crosslapping of a sample by using trailing data from
                   sample 1 and lapping it into the windowing buffer of sample 2 */
       ##### -> int ov_crosslap(OggVorbis_File *vf1, OggVorbis_File *vf2){
                  vorbis_info *vi1,*vi2;
                  float **lappcm;
                  float **pcm;
                  float *w1,*w2;
                  int n1,n2,i,ret,hs1,hs2;
                
                  if(vf1==vf2)return(0); /* degenerate case */
                  if(vf1->ready_state<OPENED)return(OV_EINVAL);
                  if(vf2->ready_state<OPENED)return(OV_EINVAL);
                
                  /* the relevant overlap buffers must be pre-checked and pre-primed
                     before looking at settings in the event that priming would cross
                     a bitstream boundary.  So, do it now */
                
                  ret=_ov_initset(vf1);
                  if(ret)return(ret);
                  ret=_ov_initprime(vf2);
                  if(ret)return(ret);
                
                  vi1=ov_info(vf1,-1);
                  vi2=ov_info(vf2,-1);
                  hs1=ov_halfrate_p(vf1);
                  hs2=ov_halfrate_p(vf2);
                
                  lappcm=alloca(sizeof(*lappcm)*vi1->channels);
                  n1=vorbis_info_blocksize(vi1,0)>>(1+hs1);
                  n2=vorbis_info_blocksize(vi2,0)>>(1+hs2);
                  w1=vorbis_window(&vf1->vd,0);
                  w2=vorbis_window(&vf2->vd,0);
                
                  for(i=0;i<vi1->channels;i++)
                    lappcm[i]=alloca(sizeof(**lappcm)*n1);
                
                  _ov_getlap(vf1,vi1,&vf1->vd,lappcm,n1);
                
                  /* have a lapping buffer from vf1; now to splice it into the lapping
                     buffer of vf2 */
                  /* consolidate and expose the buffer. */
                  vorbis_synthesis_lapout(&vf2->vd,&pcm);
                
                #if 0
                  _analysis_output_always("pcmL",0,pcm[0],n1*2,0,0,0);
                  _analysis_output_always("pcmR",0,pcm[1],n1*2,0,0,0);
                #endif
                
                  /* splice */
                  _ov_splice(pcm,lappcm,n1,n2,vi1->channels,vi2->channels,w1,w2);
                
                  /* done */
                  return(0);
                }
                
                static int _ov_64_seek_lap(OggVorbis_File *vf,ogg_int64_t pos,
                                           int (*localseek)(OggVorbis_File *,ogg_int64_t)){
                  vorbis_info *vi;
                  float **lappcm;
                  float **pcm;
                  float *w1,*w2;
                  int n1,n2,ch1,ch2,hs;
                  int i,ret;
                
                  if(vf->ready_state<OPENED)return(OV_EINVAL);
                  ret=_ov_initset(vf);
                  if(ret)return(ret);
                  vi=ov_info(vf,-1);
                  hs=ov_halfrate_p(vf);
                
                  ch1=vi->channels;
                  n1=vorbis_info_blocksize(vi,0)>>(1+hs);
                  w1=vorbis_window(&vf->vd,0);  /* window arrays from libvorbis are
                                                   persistent; even if the decode state
                                                   from this link gets dumped, this
                                                   window array continues to exist */
                
                  lappcm=alloca(sizeof(*lappcm)*ch1);
                  for(i=0;i<ch1;i++)
                    lappcm[i]=alloca(sizeof(**lappcm)*n1);
                  _ov_getlap(vf,vi,&vf->vd,lappcm,n1);
                
                  /* have lapping data; seek and prime the buffer */
                  ret=localseek(vf,pos);
                  if(ret)return ret;
                  ret=_ov_initprime(vf);
                  if(ret)return(ret);
                
                 /* Guard against cross-link changes; they're perfectly legal */
                  vi=ov_info(vf,-1);
                  ch2=vi->channels;
                  n2=vorbis_info_blocksize(vi,0)>>(1+hs);
                  w2=vorbis_window(&vf->vd,0);
                
                  /* consolidate and expose the buffer. */
                  vorbis_synthesis_lapout(&vf->vd,&pcm);
                
                  /* splice */
                  _ov_splice(pcm,lappcm,n1,n2,ch1,ch2,w1,w2);
                
                  /* done */
                  return(0);
                }
                
       ##### -> int ov_raw_seek_lap(OggVorbis_File *vf,ogg_int64_t pos){
                  return _ov_64_seek_lap(vf,pos,ov_raw_seek);
                }
                
       ##### -> int ov_pcm_seek_lap(OggVorbis_File *vf,ogg_int64_t pos){
                  return _ov_64_seek_lap(vf,pos,ov_pcm_seek);
                }
                
       ##### -> int ov_pcm_seek_page_lap(OggVorbis_File *vf,ogg_int64_t pos){
                  return _ov_64_seek_lap(vf,pos,ov_pcm_seek_page);
                }
                
                static int _ov_d_seek_lap(OggVorbis_File *vf,double pos,
                                           int (*localseek)(OggVorbis_File *,double)){
                  vorbis_info *vi;
                  float **lappcm;
                  float **pcm;
                  float *w1,*w2;
                  int n1,n2,ch1,ch2,hs;
                  int i,ret;
                
                  if(vf->ready_state<OPENED)return(OV_EINVAL);
                  ret=_ov_initset(vf);
                  if(ret)return(ret);
                  vi=ov_info(vf,-1);
                  hs=ov_halfrate_p(vf);
                
                  ch1=vi->channels;
                  n1=vorbis_info_blocksize(vi,0)>>(1+hs);
                  w1=vorbis_window(&vf->vd,0);  /* window arrays from libvorbis are
                                                   persistent; even if the decode state
                                                   from this link gets dumped, this
                                                   window array continues to exist */
                
                  lappcm=alloca(sizeof(*lappcm)*ch1);
                  for(i=0;i<ch1;i++)
                    lappcm[i]=alloca(sizeof(**lappcm)*n1);
                  _ov_getlap(vf,vi,&vf->vd,lappcm,n1);
                
                  /* have lapping data; seek and prime the buffer */
                  ret=localseek(vf,pos);
                  if(ret)return ret;
                  ret=_ov_initprime(vf);
                  if(ret)return(ret);
                
                 /* Guard against cross-link changes; they're perfectly legal */
                  vi=ov_info(vf,-1);
                  ch2=vi->channels;
                  n2=vorbis_info_blocksize(vi,0)>>(1+hs);
                  w2=vorbis_window(&vf->vd,0);
                
                  /* consolidate and expose the buffer. */
                  vorbis_synthesis_lapout(&vf->vd,&pcm);
                
                  /* splice */
                  _ov_splice(pcm,lappcm,n1,n2,ch1,ch2,w1,w2);
                
                  /* done */
                  return(0);
                }
                
       ##### -> int ov_time_seek_lap(OggVorbis_File *vf,double pos){
                  return _ov_d_seek_lap(vf,pos,ov_time_seek);
                }
                
          96 -> int ov_time_seek_page_lap(OggVorbis_File *vf,double pos){
                  return _ov_d_seek_lap(vf,pos,ov_time_seek_page);
                }


Top 10 Lines:

     Line      Count

     1809       3993
     1871       3981
     1791       3969
     2008       3950
     2335         96
      955         24
      994         12
     1000         12
     1011         12
     1229         12

Execution Summary:

       61   Executable lines in this file
       36   Lines executed
    59.02   Percent of the file executed

    16085   Total number of line executions
   263.69   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafCore\GprofCdt/../src/jp/ggaf/core/util/GgafLinearOctreeSpace.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                
                
                
                void GgafLinearOctreeSpace::dump() {
                    if (_pElemFirst == NULL) {
                        _TEXT_("x");
                    } else {
                        GgafLinearOctreeElem* pElem = _pElemFirst;
                        while (true) {
                            pElem->dump();
                
                            if (pElem == _pElemLast) {
                                break;
                            }
                            pElem = pElem -> _pNext;
                        }
                    }
                }
                
      299593 -> GgafLinearOctreeSpace::~GgafLinearOctreeSpace() {
                }


Top 10 Lines:

     Line      Count

       23     299593

Execution Summary:

        2   Executable lines in this file
        1   Lines executed
    50.00   Percent of the file executed

   299593   Total number of line executions
149796.50   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafCore\GprofCdt/../src/jp/ggaf/core/GgafOrder.cpp:
                #include "stdafx.h"
                using namespace std;
                
                using namespace GgafCore;
                
         131 -> GgafOrder::GgafOrder(unsigned long prm_id) {
                    _id = prm_id;
                    _pOrder_Next = NULL;
                    _pOrder_Prev = NULL;
                    _is_first_order_flg = false;
                    _is_last_order_flg = false;
                    _pObject_Creation = NULL;
                    _pFunc = NULL;
                    _pArg1 = NULL;
                    _pArg2 = NULL;
                    _pArg3 = NULL;
                    _progress = 0;
                }
                
         262 -> GgafOrder::~GgafOrder() {
                    //i _pObject_Creation HB
                    DELETE_POSSIBLE_NULL(_pObject_Creation);
                }
                


Top 10 Lines:

     Line      Count

       20        262
        6        131

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      393   Total number of line executions
   131.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafCore\GprofCdt/../src/jp/ggaf/core/actor/GgafGroupActor.cpp:
                #include "stdafx.h"
                using namespace std;
                
                using namespace GgafCore;
                
         116 -> GgafGroupActor::GgafGroupActor(actorkind prm_kind) : GgafActor("GROUP") {
                    _obj_class |= Obj_GgafGroupActor;
                    _class_name = "GgafGroupActor";
                
                    char aChar_strbit[33];
                    GgafUtil::strbin(prm_kind, aChar_strbit);
                    stringstream ss;
                    ss <<  "kind=" << aChar_strbit << "";
                    string name = ss.str();
                    strcpy(_name, name.c_str());
                
                    _kind = prm_kind;
                    setHitAble(false);
                    _pLordActor = NULL;
                }
                
                GgafLordActor* GgafGroupActor::getLordActor() {
                    if (_pLordActor == NULL) {
                        if (_pParent == NULL) {
                            _TRACE_("yxzGgafGroupActor::getLordActor ALordActorI("<<getName()<<")B(GgafUniverse)LordActor");
                            _pLordActor = GgafGod::_pGod->_pUniverse->getLordActor();
                        } else {
                            if (_pParent->_obj_class & Obj_GgafMainActor) {
                                _pLordActor = ((GgafMainActor*)(_pParent))->getLordActor();
                            } else if (_pParent->_obj_class & Obj_GgafGroupActor) {
                                _pLordActor = ((GgafGroupActor*)(_pParent))->getLordActor();
                            } else if (_pParent->_obj_class & Obj_GgafLordActor) {
                                return (GgafLordActor*)_pParent; //Actorc[_
                            }
                            _TRACE_("yxzGgafMainActor::getLordActor c[LordActorI("<<getName()<<")B(GgafUniverse)LordActor");
                            _pLordActor = GgafGod::_pGod->_pUniverse->getLordActor();
                        }
                    }
                    return _pLordActor;
                }
                
                void GgafGroupActor::setLordActor(GgafLordActor* prm_pLordActor) {
                    _pLordActor = prm_pLordActor;
                    if (_pSubFirst) {
                        GgafActor* pActor = getSubFirst();
                        while (true) {
                            if (pActor->_obj_class & Obj_GgafMainActor) {
                                ((GgafMainActor*)(pActor))->setLordActor(prm_pLordActor);
                            } else if (pActor->_obj_class & Obj_GgafGroupActor) {
                                ((GgafGroupActor*)(pActor))->setLordActor(prm_pLordActor);
                            }
                            if (pActor->_is_last_flg) {
                                break;
                            } else {
                                pActor = pActor->getNext();
                            }
                        }
                    }
                }
                
                GgafGod* GgafGroupActor::askGod() {
                    if (_pGod == NULL) {
                #ifdef MY_DEBUG
                        if (getParent() == NULL) {
                            throwGgafCriticalException("GgafGroupActor::askGod _yBII("<<getName()<<")");
                        }
                #endif
                        _pGod = getParent()->askGod();
                    }
                    return _pGod;
                }
                
         232 -> GgafGroupActor::~GgafGroupActor() {
                }


Top 10 Lines:

     Line      Count

       73        232
        6        116

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      348   Total number of line executions
   116.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafCore\GprofCdt/../src/jp/ggaf/core/util/GgafCurtain.cpp:
                #include "stdafx.h"
                using namespace std;
                
                using namespace GgafCore;
                
          16 -> GgafCurtain::GgafCurtain(GgafScene* prm_pScene) : GgafObject() {
                    _pScene = prm_pScene;
                    _curtain_length = 1.0f;
                    _now_curtain_length = 0.0f; //J
                    _state = OPENED;
                    _opening_velocity = 0.0f;
                    _closing_velocity = 0.0f;
                
                }
                
                void GgafCurtain::open(float prm_opening_velocity) {
                    _opening_velocity = prm_opening_velocity;
                    _state = OPEN;
                }
                
                void GgafCurtain::open() {
                    _now_curtain_length = 0.0f;
                    _state = OPENED;
                    processOpenDone();
                }
                
                void GgafCurtain::close(float prm_closing_velocity) {
                    _closing_velocity = prm_closing_velocity;
                    _state = CLOSE;
                }
                
                void GgafCurtain::close() {
                    _now_curtain_length = _curtain_length;
                    _state = CLOSED;
                    processCloseDone();
                }
                
                
                void GgafCurtain::behave() {
                
                    if (_state == OPEN) {
                        processOpenBegin();
                        _state = OPENING;
                    } else if (_state == OPENING) {
                        _now_curtain_length -= _opening_velocity;
                        if (_now_curtain_length < 0) {
                            _now_curtain_length = 0.0f;
                            _state = OPENED;
                            processOpenDone();
                        } else {
                            processOpening();
                        }
                
                    } else if (_state == CLOSE) {
                        processCloseBegin();
                        _state = CLOSING;
                    } else if (_state == CLOSING) {
                        _now_curtain_length += _closing_velocity;
                        if (_now_curtain_length > _curtain_length) {
                            _now_curtain_length = _curtain_length;
                            _state = CLOSED;
                            processCloseDone();
                        } else {
                            processClosing();
                        }
                    }
                
                }
          16 -> GgafCurtain::~GgafCurtain() {
                }
                


Top 10 Lines:

     Line      Count

        6         16
       69         16

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       32   Total number of line executions
    10.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafCore\GprofCdt/../src/jp/ggaf/core/scene/GgafMainScene.cpp:
                #include "stdafx.h"
                using namespace std;
                
                using namespace GgafCore;
                
          17 -> GgafMainScene::GgafMainScene(const char* prm_name) : GgafScene(prm_name) {
                    _obj_class |= Obj_GgafMainScene;
                    _class_name = "GgafMainScene";
                }
                
          17 -> GgafMainScene::~GgafMainScene() {
                }


Top 10 Lines:

     Line      Count

        6         17
       11         17

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       34   Total number of line executions
    11.33   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafCore\GprofCdt/../src/jp/ggaf/core/scene/GgafUniverse.cpp:
                #include "stdafx.h"
                using namespace std;
                
                using namespace GgafCore;
                
           1 -> GgafUniverse::GgafUniverse(const char* prm_name) : GgafMainScene(prm_name) {
                    _obj_class |= Obj_GgafUniverse;
                    _class_name = "GgafUniverse";
                
                }
                
           1 -> GgafUniverse::~GgafUniverse() {
                }


Top 10 Lines:

     Line      Count

        6          1
       12          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        2   Total number of line executions
     0.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafCore\GprofCdt/../src/jp/ggaf/core/util/GgafLinearOctree.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                
                
           1 -> GgafLinearOctree::GgafLinearOctree(int prm_level) {
                    _top_space_level = prm_level;
                    //
                    _paPow = NEW UINT32[(prm_level+1)+1];
                    _paPow[0] = 1;
                    for(int i = 1; i < (prm_level+1)+1; i++) {
                        _paPow[i] = _paPow[i-1] * 8;
                        //_TRACE_("_paPow["<<i<<"]="<<_paPow[i]);
                    }
                    //`Wz
                    _num_space = (int)((_paPow[_top_space_level+1] -1) / 7); //
                    _TRACE_("`Wzvf _num_space="<<_num_space);
                    _paSpace = NEW GgafLinearOctreeSpace[_num_space];
                    for (UINT32 i = 0; i < _num_space; i++) {
                        _paSpace[i]._my_index = i;
                    }
                    _pRegElemFirst = NULL;
                }
                
                void GgafLinearOctree::setRootSpace(int X1 ,int Y1 ,int Z1 ,int X2 ,int Y2 ,int Z2) {
                    _root_X1 = X1;
                    _root_Y1 = Y1;
                    _root_Z1 = Z1;
                    _root_X2 = X2;
                    _root_Y2 = Y2;
                    _root_Z2 = Z2;
                    _top_level_dX = ((_root_X2-_root_X1) / ((float)(1<<_top_space_level))) + 1;
                    _top_level_dY = ((_root_Y2-_root_Y1) / ((float)(1<<_top_space_level))) + 1;
                    _top_level_dZ = ((_root_Z2-_root_Z1) / ((float)(1<<_top_space_level))) + 1; //+1I[o[]T
                }
                
                void GgafLinearOctree::registElem(GgafLinearOctreeElem* prm_pElem, int tX1 ,int tY1 ,int tZ1 ,int tX2 ,int tY2 ,int tZ2) {
                    UINT32 index = getSpatialIndex(tX1, tY1, tZ1, tX2, tY2, tZ2);
                    if (index == 0xffffffff) {
                        return; //Oo^
                    }
                
                #ifdef MY_DEBUG
                    if (index > _num_space-1) {
                        throwGgafCriticalException(
                           "GgafLinearOctree::registElem() I[o[ !. \n"<<
                           "ElemObj="<<(((GgafActor*)(prm_pElem->_pObject))->getName())<<"(:"<<(prm_pElem->_pObject)<<")\n"<<
                           "Root=("<<_root_X1<<","<<_root_Y1<<","<<_root_Z1<<")-("<<_root_X2<<","<<_root_Y2<<","<<_root_Z2<<")\n"<<
                           "Elem=("<<tX1<<","<<tY1<<","<<tZ1<<")-("<<tX2<<","<<tY2<<","<<tZ2<<")\n"<<
                           "index="<<index<<" _num_space="<<_num_space
                        );
                    }
                #endif
                
                    if (prm_pElem->_pSpace_Current == NULL) {
                        //o^ElemXg
                        if (_pRegElemFirst == NULL) {
                            prm_pElem->_pRegLinkNext = NULL;
                            _pRegElemFirst = prm_pElem;
                        } else {
                            prm_pElem->_pRegLinkNext = _pRegElemFirst;
                            _pRegElemFirst = prm_pElem;
                        }
                    }
                
                    //WCfbNX
                    prm_pElem->_pLinearOctree = this;
                    prm_pElem->addElem(&(_paSpace[index]));
                
                
                //    if (index > _num_space-1) {
                //        //_TRACE_("over space!!");
                //        prm_pElem->extract();
                //    } else {
                //        prm_pElem->moveToSpace(_paSpace[index]);
                //    }
                }
                void GgafLinearOctree::clearElem() {
                    if (_pRegElemFirst == NULL) {
                        return;
                    }
                    GgafLinearOctreeElem* pElem = _pRegElemFirst;
                    while(true) {
                
                        pElem->extract();
                        pElem = pElem -> _pRegLinkNext;
                        if (pElem == NULL) {
                            break;
                        }
                
                    }
                    _pRegElemFirst = NULL;
                }
                
                UINT32 GgafLinearOctree::getSpatialIndex(int tX1 ,int tY1 ,int tZ1 ,int tX2 ,int tY2 ,int tZ2) {
                
                    //o
                    if (tX1 <= _root_X1)  { tX1 = _root_X1+1; }
                    if (tX2 >= _root_X2)  { tX2 = _root_X2-1; }
                    if (tY1 <= _root_Y1)  { tY1 = _root_Y1+1; }
                    if (tY2 >= _root_Y2)  { tY2 = _root_Y2-1; }
                    if (tZ1 <= _root_Z1)  { tZ1 = _root_Z1+1; }
                    if (tZ2 >= _root_Z2)  { tZ2 = _root_Z2-1; }
                
                    //WALevel0SO0xffffffff
                    if (tX1 >= tX2 || tY1 >= tY2 || tZ1 >= tZ2) {
                        return 0xffffffff;
                    }
                
                    //ABOX Level ALevel[g
                
                    //BOXOXYZW_Ax[g
                    UINT32 minnum_in_toplevel = getMortonOrderNumFromXYZindex(
                                                  (UINT32)((tX1 - _root_X1) / _top_level_dX),
                                                  (UINT32)((tY1 - _root_Y1) / _top_level_dY),
                                                  (UINT32)((tZ1 - _root_Z1) / _top_level_dZ)
                                                );
                
                    //BOXEXYZW_Ax[g
                    UINT32 maxnum_in_toplevel = getMortonOrderNumFromXYZindex(
                                                  (UINT32)((tX2 - _root_X1) / _top_level_dX),
                                                  (UINT32)((tY2 - _root_Y1) / _top_level_dY),
                                                  (UINT32)((tZ2 - _root_Z1) / _top_level_dZ)
                                                );                 //_root_X2,_root_Y2,_root_Z2 B
                
                
                    //BOXAx
                    UINT32 differ_bit_pos = maxnum_in_toplevel ^ minnum_in_toplevel;
                    UINT32 shift_num = 0;
                    for(UINT32 i = 0; i < (UINT32)_top_space_level; i++) {
                        if (((differ_bit_pos>>(i*3)) & 0x7) != 0 ) {
                            shift_num = i+1;
                        }
                    }
                    //xordiffer_bit_pos  E3rbgVtgA}XN &B111(&H7) ANDA&B000 uB
                    // differ_bit_pos  RrbgA3rbgH
                    //H3rbguAxg[uHB
                    //3rbgH(Vtgshift_num)x
                    //Level = 5AO6001AE6041BOX
                    //
                    //ex[gu lv0 lv1 lv2 lv3 lv4 lv5
                    //     6001 = 00 000 000 000 000 000 001 011 101 110 001
                    // XOR)6041 = 00 000 000 000 000 000 001 011 110 011 001
                    // -----------------------------------------------------
                    //      232 = 00 000 000 000 000 000 000 000 011 101 000
                    //
                    //                                                   111
                    //                                               111
                    //                                           111
                    //                                       111
                    //  AND)                             111     <--- sA3rbgH3
                    // ------------------------------------------------------
                    //                                   000 000 011 101 000
                    //                                    o   o   x   x   o      if (differ_bit_pos>>(i*3)) & 0x7 != 0 ) 
                    //                                    5   4   3   2   1   0   shift_num(Vtg)
                    //
                    //   LA60016041x1Ax2 xA
                    //   x3[guBA
                    //   uxvLv2mB
                    //   XOR0OVtg  shift_num = 3 B
                    //   AE3rbgVtg 0x7  ANDJKvB
                    //   v shift_num VtgAxI
                
                    //XOR
                    // 000 000 000 000 000 000 000 111  shift_num=1
                    //
                    //Level=5 x4(=x5H)
                    //Level=8 x7(=x8H)
                
                    // 000 000 000 111 110 000 101 111  shift_num=5
                    //
                    //Level=5 x0 [gx
                    //Level=8 x4
                
                    //
                    //Level = 5 
                    //shift_num   = 0 1 2 3 4 5
                    //Level = 5 4 3 2 1 0
                    //Level=8 
                    //shift_num   = 0 1 2 3 4 5 6 7 8
                    //Level = 8 7 6 5 4 3 2 1 0
                
                    //[g
                    UINT32 morton_order_space_num = minnum_in_toplevel>>(shift_num*3);
                    //srbg3rbgPA[g
                    //
                    // minnum_in_toplevel>>(shift_num*3); A
                    // minnum_in_toplevel=6001  6041
                    //        lv0 lv1 lv2 lv3 lv4 lv5          lv0 lv1 lv2
                    // 6001 = 000 001 011 101 110 001   -->    000 001 011 = 11
                    // 6041 = 000 001 011 110 011 001   -->    000 001 011 = 11
                    //                    ^^^ ^^^ ^^^
                    //                  (shift_num*3 rbg)
                    //
                    // srbgEVtg
                    // AO6001AE6041BOXALv2A[g11B
                    // zIndex
                
                    //(Vtg)[g`zvf
                    int index = (int)morton_order_space_num + (_paPow[_top_space_level-shift_num]-1)/7;
                    //(_paPow[_top_space_level-shift_num]-1)/7;
                    //A`zAxvfB
                    //a
                    //     r^k = r^0 + r^1 + r^2 + ... + r^n
                    //(1-r)r^k = (1-r)(r^0 + r^1 + r^2 + ... + r^n)
                    //          = (r^0 + r^1 + r^2 + ... + r^n) - (r^1 + r^2 + ... + r^n + r^(n+1))
                    //          = 1 - r^(n+1)
                    // r^k = (1 - r^(n+1)) / (1 - r)
                    //
                    //`8zvfxv r=8 
                    //(1 - 8^(n+1)) / (1-8)  =  (1-8^(n+1)) / -7  =  (8^(n+1) - 1) / 7 
                    //AvfA n = x-1 vZliexvfjA
                    //vfxvfIBB
                    //l +1 lAz0n +1 B
                    // shift_num = 3 ALevel(_top_space_level) = 5 
                    // 5 - 3 = 2 x 2
                    // n = 2 - 1 = 1   (8^(1+1) - 1) / 7 = 9 
                    //x2exAx1zvfv9B
                    //]x 2z 9+1 10nB
                    //z10Azvf-19B
                    //+1  -1 Axxzvf  (8^x - 1) / 7 
                
                
                #ifdef MY_DEBUG
                    if (index > _num_space-1) {
                
                        _TRACE_(
                           "GgafLinearOctree::registElem() I[o[ !. \n"<<
                           "Root=("<<_root_X1<<","<<_root_Y1<<","<<_root_Z1<<")-("<<_root_X2<<","<<_root_Y2<<","<<_root_Z2<<")\n"<<
                           "Elem=("<<tX1<<","<<tY1<<","<<tZ1<<")-("<<tX2<<","<<tY2<<","<<tZ2<<")\n"<<
                           "_top_level_dX="<<_top_level_dX<<" _top_level_dY="<<_top_level_dY<<" _top_level_dZ="<<_top_level_dZ<<"\n"<<
                           "minnum_in_toplevel="<<minnum_in_toplevel<<" maxnum_in_toplevel="<<maxnum_in_toplevel<<"\n"<<
                           "differ_bit_pos="<<differ_bit_pos<<" shift_num="<<shift_num<<" morton_order_space_num="<<morton_order_space_num<<"\n"<<
                           "index="<<index<<" _num_space="<<_num_space
                        );
                        _TRACE_("Min_X_index="<<((UINT32)((tX1 - _root_X1) / _top_level_dX)));
                        _TRACE_("Min_Y_index="<<((UINT32)((tY1 - _root_Y1) / _top_level_dY)));
                        _TRACE_("Min_Z_index="<<((UINT32)((tZ1 - _root_Z1) / _top_level_dZ)));
                        _TRACE_("Man_X_index="<<((UINT32)((tX2 - _root_X1) / _top_level_dX)));
                        _TRACE_("Man_Y_index="<<((UINT32)((tY2 - _root_Y1) / _top_level_dY)));
                        _TRACE_("Man_Z_index="<<((UINT32)((tZ2 - _root_Z1) / _top_level_dZ)));
                    }
                #endif
                
                
                    return index;
                }
                
                
           1 -> GgafLinearOctree::~GgafLinearOctree() {
                    DELETEARR_IMPOSSIBLE_NULL(_paSpace);
                    DELETEARR_IMPOSSIBLE_NULL(_paPow);
                }
                
                
                void GgafLinearOctree::putTree() {
                    char aChar_strbit[33];
                    int lv0_order_num = 0;
                    int lv1_order_num = 0;
                    int lv2_order_num = 0;
                    int lv3_order_num = 0;
                    int lv4_order_num = 0;
                    int lv5_order_num = 0;
                    int lv6_order_num = 0;
                    int lv7_order_num = 0;
                    int lv8_order_num = 0;
                
                    int lv0_order_pos = 0;
                
                    int LV0 = 0;
                
                
                    if (_paSpace[0]._kindinfobit == 0) {
                        _TRACE_("8I");
                    } else {
                        GgafUtil::strbin(_paSpace[LV0]._kindinfobit, aChar_strbit);
                        _TEXT_("LV0."<<lv0_order_num<<"(POS:"<<lv0_order_pos<<")["<<LV0<<"]="<<aChar_strbit<<" /GgafLinearOctreeElem->");
                        _paSpace[LV0].dump();
                        _TEXT_("\n");
                    }
                
                    UINT32 index_lv1_begin = LV0*8 + 1;
                    if (index_lv1_begin > _num_space-1) { return; }
                
                    for (UINT32 LV1 = index_lv1_begin, lv1_order_pos = 0; LV1 < index_lv1_begin+8; LV1++, lv1_order_num++, lv1_order_pos++) {
                        if (_paSpace[LV1]._kindinfobit == 0) { continue; }
                        GgafUtil::strbin(_paSpace[LV1]._kindinfobit, aChar_strbit);
                        _TEXT_("  LV1-"<<lv1_order_num<<"(POS:"<<lv1_order_pos<<")["<<LV1<<"]="<<aChar_strbit<<" /GgafLinearOctreeElem->");
                        _paSpace[LV1].dump();
                        _TEXT_("\n");
                        ////
                        UINT32 index_lv2_begin = LV1*8 + 1;
                        if (index_lv2_begin > _num_space-1) { continue; } //KwLv`FbN
                
                        for (UINT32 LV2 = index_lv2_begin, lv2_order_pos = 0; LV2 < index_lv2_begin+8; LV2++, lv2_order_num++, lv2_order_pos++) {
                            if (_paSpace[LV2]._kindinfobit == 0) { continue; }  //\
                            GgafUtil::strbin(_paSpace[LV1]._kindinfobit, aChar_strbit);
                            _TEXT_("    LV2-"<<lv2_order_num<<"(POS:"<<lv2_order_pos<<")["<<LV2<<"]="<<aChar_strbit<<" /GgafLinearOctreeElem->");
                            _paSpace[LV2].dump();
                            _TEXT_("\n");
                            ///
                            UINT32 index_lv3_begin = LV2*8 + 1;
                            if (index_lv3_begin > _num_space-1) { continue; } //KwLv`FbN
                            for (UINT32 LV3 = index_lv3_begin, lv3_order_pos = 0; LV3 < index_lv3_begin+8; LV3++, lv3_order_num++, lv3_order_pos++) {
                                if (_paSpace[LV3]._kindinfobit == 0) { continue; }  //\
                                GgafUtil::strbin(_paSpace[LV1]._kindinfobit, aChar_strbit);
                                _TEXT_("      LV3-"<<lv3_order_num<<"(POS:"<<lv3_order_pos<<")["<<LV3<<"]="<<aChar_strbit<<" /GgafLinearOctreeElem->");
                                _paSpace[LV3].dump();
                                _TEXT_("\n");
                                ///
                                UINT32 index_lv4_begin = LV3*8 + 1;
                                if (index_lv4_begin > _num_space-1) { continue; } //KwLv`FbN
                                for (UINT32 LV4 = index_lv4_begin, lv4_order_pos = 0; LV4 < index_lv4_begin+8; LV4++, lv4_order_num++, lv4_order_pos++) {
                                    if (_paSpace[LV4]._kindinfobit == 0) { continue; }  //\
                                    GgafUtil::strbin(_paSpace[LV1]._kindinfobit, aChar_strbit);
                                    _TEXT_("        LV4-"<<lv4_order_num<<"(POS:"<<lv4_order_pos<<")["<<LV4<<"]="<<aChar_strbit<<" /GgafLinearOctreeElem->");
                                    _paSpace[LV4].dump();
                                    _TEXT_("\n");
                                    ///
                                    UINT32 index_lv5_begin = LV4*8 + 1;
                                    if (index_lv5_begin > _num_space-1) { continue; } //KwLv`FbN
                                    for (UINT32 LV5 = index_lv5_begin, lv5_order_pos = 0; LV5 < index_lv5_begin+8; LV5++, lv5_order_num++, lv5_order_pos++) {
                                        if (_paSpace[LV5]._kindinfobit == 0) { continue; }  //\
                                        GgafUtil::strbin(_paSpace[LV1]._kindinfobit, aChar_strbit);
                                        _TEXT_("          LV5-"<<lv5_order_num<<"(POS:"<<lv5_order_pos<<")["<<LV5<<"]="<<aChar_strbit<<" /GgafLinearOctreeElem->");
                                        _paSpace[LV5].dump();
                                        _TEXT_("\n");
                                        ///
                                        UINT32 index_lv6_begin = LV5*8 + 1;
                                        if (index_lv6_begin > _num_space-1) { continue; } //KwLv`FbN
                                        for (UINT32 LV6 = index_lv6_begin, lv6_order_pos = 0; LV6 < index_lv6_begin+8; LV6++, lv6_order_num++, lv6_order_pos++) {
                                            if (_paSpace[LV6]._kindinfobit == 0) { continue; }  //\
                                            GgafUtil::strbin(_paSpace[LV1]._kindinfobit, aChar_strbit);
                                            _TEXT_("            LV6-"<<lv6_order_num<<"(POS:"<<lv6_order_pos<<")["<<LV6<<"]="<<aChar_strbit<<" /GgafLinearOctreeElem->");
                                            _paSpace[LV6].dump();
                                            _TEXT_("\n");
                                            ///
                                            UINT32 index_lv7_begin = LV6*8 + 1;
                                            if (index_lv7_begin > _num_space-1) { continue; } //KwLv`FbN
                                            for (UINT32 LV7 = index_lv7_begin, lv7_order_pos = 0; LV7 < index_lv7_begin+8; LV7++, lv7_order_num++, lv7_order_pos++) {
                                                if (_paSpace[LV7]._kindinfobit == 0) { continue; }  //\
                                                GgafUtil::strbin(_paSpace[LV1]._kindinfobit, aChar_strbit);
                                                _TEXT_("              LV7-"<<lv7_order_num<<"(POS:"<<lv7_order_pos<<")["<<LV7<<"]="<<aChar_strbit<<" /GgafLinearOctreeElem->");
                                                _paSpace[LV7].dump();
                                                _TEXT_("\n");
                                                ///
                                                UINT32 index_lv8_begin = LV7*8 + 1;
                                                if (index_lv8_begin > _num_space-1) { continue; } //KwLv`FbN
                                                for (UINT32 LV8 = index_lv8_begin, lv8_order_pos = 0; LV8 < index_lv8_begin+8; LV8++, lv8_order_num++, lv8_order_pos++) {
                                                    if (_paSpace[LV8]._kindinfobit == 0) { continue; }  //\
                                                    GgafUtil::strbin(_paSpace[LV1]._kindinfobit, aChar_strbit);
                                                    _TEXT_("                LV8-"<<lv8_order_num<<"(POS:"<<lv8_order_pos<<")["<<LV8<<"]="<<aChar_strbit<<" /GgafLinearOctreeElem->");
                                                    _paSpace[LV8].dump();
                                                    _TEXT_("\n");
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                


Top 10 Lines:

     Line      Count

        6          1
      250          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        2   Total number of line executions
     0.67   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafCore/include/jp/ggaf/core/util/GgafLinearOctreeSpace.h:
                #ifndef GGAFLINEAROCTREESPACE_H_
                #define GGAFLINEAROCTREESPACE_H_
                namespace GgafCore {
                
                /**
                 * `zpNX .
                 * @version 1.00
                 * @since 2009/11/23
                 * @author Masatoshi Tsuge
                 */
                class GgafLinearOctreeSpace {
                public:
                    /** `zgvf */
                    UINT32 _my_index;
                    /** vf */
                    UINT32 _kindinfobit;
                    /** vf */
                    GgafLinearOctreeElem* _pElemFirst;
                    /** vf */
                    GgafLinearOctreeElem* _pElemLast;
                
                    /**
                     * RXgN^
                     * @return
                     */
      299593 ->     GgafLinearOctreeSpace() {
                        _pElemFirst = NULL;
                        _pElemLast = NULL;
                        _kindinfobit = 0;
                        _my_index = 0xffffffff; //0xffffffff
                    }
                
                    void dump();
                
                    virtual ~GgafLinearOctreeSpace();
                };
                
                
                }
                #endif /*GGAFLINEAROCTREESPACE_H_*/
                


Top 10 Lines:

     Line      Count

       26     299593

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

   299593   Total number of line executions
299593.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafCore\GprofCdt/../src/jp/ggaf/core/util/GgafLinearOctreeElem.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                
                
        4645 -> GgafLinearOctreeElem::GgafLinearOctreeElem(GgafObject* prm_pObject, UINT32 prm_kindbit) {
                    _pSpace_Current = NULL;
                    _pNext = NULL;
                    _pPrev = NULL;
                    _pObject = prm_pObject;
                    _kindbit = prm_kindbit;
                    _pLinearOctree = NULL;
                    _pRegLinkNext = NULL;
                }
                
                void GgafLinearOctreeElem::extract() {
                    if(_pSpace_Current == NULL) {
                        //_TRACE_("GgafLinearOctreeElem::extract() B}H");
                        return;
                    }
                    //Zbg
                    UINT32 index = _pSpace_Current->_my_index;
                    while(true) {
                        //extract()AAvP[VWbNextract() gpB
                        //{c[Ao^ANAsv
                        if (_pLinearOctree->_paSpace[index]._kindinfobit == 0 ) {
                            break;
                        } else {
                            _pLinearOctree->_paSpace[index]._kindinfobit = 0;
                            _pLinearOctree->_paSpace[index]._pElemFirst = NULL;
                            _pLinearOctree->_paSpace[index]._pElemLast = NULL;
                        }
                
                        if (index == 0) {
                            break;
                        }
                        // evfJ
                        index = (index-1)>>3;
                    }
                    _pNext = NULL;
                    _pPrev = NULL;
                    _pSpace_Current = NULL;
                
                //    if (this == _pSpace_Current->_pElemFirst && this == _pSpace_Current->_pElemLast) {
                //        //
                //        _pSpace_Current->_pElemFirst = NULL;
                //        _pSpace_Current->_pElemLast = NULL;
                //        _pSpace_Current = NULL;
                //    } else if (this == _pSpace_Current->_pElemFirst) {
                //        //
                //        _pSpace_Current->_pElemFirst = _pNext;
                //        _pSpace_Current->_pElemFirst->_pPrev = NULL;
                //        _pNext = NULL;
                //        _pSpace_Current = NULL;
                //    } else if (this == _pSpace_Current->_pElemLast) {
                //        //
                //        _pSpace_Current->_pElemLast = _pPrev;
                //        _pSpace_Current->_pElemLast->_pNext = NULL;
                //        _pPrev = NULL;
                //        _pSpace_Current = NULL;
                //    } else {
                //        //
                //        _pPrev->_pNext = _pNext;
                //        _pNext->_pPrev = _pPrev;
                //        _pNext = NULL;
                //        _pPrev = NULL;
                //        _pSpace_Current = NULL;
                //    }
                }
                
                void GgafLinearOctreeElem::addElem(GgafLinearOctreeSpace* prm_pSpace_target) {
                    if (_pSpace_Current == prm_pSpace_target) {
                        //_TRACE_("addElem");
                        return;
                    } else {
                        if (prm_pSpace_target->_pElemFirst == NULL) {
                            //P
                            prm_pSpace_target->_pElemFirst = this;
                            prm_pSpace_target->_pElemLast = this;
                            _pNext = NULL;
                            _pPrev = NULL;
                            _pSpace_Current = prm_pSpace_target;
                        } else {
                            //
                            prm_pSpace_target->_pElemLast->_pNext = this;
                            _pPrev = prm_pSpace_target->_pElemLast;
                            _pNext = NULL;
                            prm_pSpace_target->_pElemLast = this;
                            _pSpace_Current = prm_pSpace_target;
                        }
                    }
                    //vf
                    UINT32 index = prm_pSpace_target->_my_index;
                    //evf
                    while(true) {
                        _pLinearOctree->_paSpace[index]._kindinfobit =
                                _pLinearOctree->_paSpace[index]._kindinfobit | this->_kindbit;
                        if (index == 0) {
                            break;
                        }
                        //evfJ
                        index = (index-1)>>3;
                    }
                }
                
                //void GgafLinearOctreeElem::moveToSpace(GgafLinearOctreeSpace* prm_pSpace_target) {
                //    if (prm_pSpace_target == _pSpace_Current) {
                //        return; //
                //    } else {
                //        if(_pSpace_Current) {
                //            extract(); //
                //        }
                //        addElem(prm_pSpace_target); //
                //        return;
                //    }
                //}
                
                void GgafLinearOctreeElem::dump() {
                    _TEXT_("o");
                }
                
        4647 -> GgafLinearOctreeElem::~GgafLinearOctreeElem() {
                }


Top 10 Lines:

     Line      Count

      122       4647
        6       4645

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

     9292   Total number of line executions
  3097.33   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafCore\GprofCdt/../src/jp/ggaf/core/actor/GgafDummyActor.cpp:
                #include "stdafx.h"
                using namespace std;
                
                using namespace GgafCore;
                
         146 -> GgafDummyActor::GgafDummyActor(const char* prm_name) : GgafMainActor(prm_name) {
                    _obj_class |= Obj_GgafDummyActor;
                    _class_name = "GgafDummyActor";
                    setHitAble(false);
                }
                
         146 -> GgafDummyActor::~GgafDummyActor() {
                }


Top 10 Lines:

     Line      Count

        6        146
       12        146

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      292   Total number of line executions
    97.33   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafCore\GprofCdt/../src/jp/ggaf/core/GgafGarbageBox.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                
                
                CRITICAL_SECTION GgafGarbageBox::CS;
                
           1 -> GgafGarbageBox::GgafGarbageBox() : GgafObject() {
                    _pDisusedActor = NEW GgafDisusedActor();
                    _pDisusedScene = NEW GgafDisusedScene();
                    ::InitializeCriticalSection(&CS);
                }
                
                void GgafGarbageBox::add(GgafActor* prm_pActor) {
                    ::EnterCriticalSection(&CS);
                    prm_pActor->_can_live_flg = false;
                    _pDisusedActor->addSubLast(prm_pActor->extract());
                    _TRACE_("S~(Actor) GgafGarbageBox::add("<<prm_pActor->getName()<<")");
                    ::LeaveCriticalSection(&CS);
                }
                
                void GgafGarbageBox::add(GgafScene* prm_pScene) {
                    ::EnterCriticalSection(&CS);
                    prm_pScene->_can_live_flg = false;
                    _pDisusedScene->addSubLast(prm_pScene->extract());
                    _TRACE_("S~(Scene) GgafGarbageBox::add("<<prm_pScene->getName()<<")");
                    ::LeaveCriticalSection(&CS);
                }
                
                void GgafGarbageBox::clean(int prm_num_cleaning) {
                    ::EnterCriticalSection(&CS);
                    _pDisusedActor->clean(prm_num_cleaning);
                    _pDisusedScene->clean(prm_num_cleaning);
                    ::LeaveCriticalSection(&CS);
                }
                
           2 -> GgafGarbageBox::~GgafGarbageBox() {
                    _TRACE_("GgafGarbageBox::~GgafGarbageBox() begin");
                    ::DeleteCriticalSection(&CS);
                    DELETE_IMPOSSIBLE_NULL(_pDisusedScene);
                    DELETE_IMPOSSIBLE_NULL(_pDisusedActor);
                    _TRACE_("GgafGarbageBox::~GgafGarbageBox() done");
                }
                


Top 10 Lines:

     Line      Count

       37          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafCore/include/jp/ggaf/core/actor/GgafDisusedActor.h:
                #ifndef GGAFDISUSEDACTOR_H_
                #define GGAFDISUSEDACTOR_H_
                namespace GgafCore {
                
                /**
                 * svAN^[.
                 * AN^[AN^[AxdeleteB<BR>
                 * xA_(GgafGod)AFps]T delete <BR>
                 * @version 1.00
                 * @since 2008/12/17
                 * @author Masatoshi Tsuge
                 */
                class GgafDisusedActor : public GgafActor {
                public:
           1 ->     GgafDisusedActor() :
                        GgafActor("DisusedActor") {
                    }
                    void initialize() override {
                    }
                    void processBehavior() override {
                    }
                    void processJudgement() override {
                    }
                    void processPreDraw() override {
                    }
                    void processDraw() override {
                    }
                    void processAfterDraw() override {
                    }
                    void onCatchEvent(UINT32 prm_no, void* prm_pSource) override {
                    }
                    void processFinal() override {
                    }
                    bool processHitChkLogic(GgafActor* prm_pOtherActor) override {
                        return false;
                    }
                    void onHit(GgafActor* prm_pOtherActor) override {
                    }
                    GgafGod* askGod() {
                        return NULL;
                    }
           2 ->     virtual ~GgafDisusedActor() {
                    }
                };
                
                }
                #endif /*GGAFDISUSEDACTOR_H_*/


Top 10 Lines:

     Line      Count

       42          2
       15          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        3   Total number of line executions
     1.50   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafCore/include/jp/ggaf/core/scene/GgafDisusedScene.h:
                #ifndef GGAFDISUSEDSCENE_H_
                #define GGAFDISUSEDSCENE_H_
                namespace GgafCore {
                
                /**
                 * svV[ .
                 * V[V[AxdeleteB<BR>
                 * xA_(GgafGod)AFps]T delete <BR>
                 * @version 1.00
                 * @since 2008/12/17
                 * @author Masatoshi Tsuge
                 */
                class GgafDisusedScene : public GgafScene {
                public:
           1 ->     GgafDisusedScene() :
                        GgafScene("DisusedScene") {
                        _obj_class |= Obj_GgafDisusedScene;
                        _class_name = "GgafDisusedScene";
                    }
                    void initialize() override {
                    }
                    void processBehavior() override {
                    }
                    void processJudgement() override {
                    }
                    void processPreDraw() override {
                    }
                    void processDraw() override {
                    }
                    void processAfterDraw() override {
                    }
                    void onCatchEvent(UINT32 prm_no, void* prm_pSource) override {
                    }
                    void processFinal() override {
                    }
           2 ->     virtual ~GgafDisusedScene() {
                    }
                };
                
                }
                #endif /*GGAFDISUSEDSCENE_H_*/


Top 10 Lines:

     Line      Count

       36          2
       15          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        3   Total number of line executions
     1.50   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafCore\GprofCdt/../src/jp/ggaf/core/actor/GgafActor.cpp:
                #include "stdafx.h"
                using namespace std;
                
                using namespace GgafCore;
                
        4986 -> GgafActor::GgafActor(const char* prm_name) :
                    GgafElement<GgafActor> (prm_name) {
                    TRACE("GgafActor::GgafActor("<<this<<") "<<prm_name);
                    _class_name = "GgafActor";
                    _obj_class = Obj_GgafActor;
                
                    _pStatus = NEW GgafStatus(12);
                    _pStatus->set(0, 0);
                    _pScene_Platform = NULL;
                    _pGod = NULL;
                    _can_hit_flg = false;
                    _can_hit_out_of_view = false;
                    _use_octree = false;
                    _pDependenceDispcher = NULL;
                #ifdef MY_DEBUG
                    _TRACE_("new "<<_class_name<<"("<<this<<")["<<prm_name<<"]");
                #else
                
                #endif
                
                }
                
        4987 -> GgafActor::~GgafActor() {
                    DELETE_IMPOSSIBLE_NULL(_pStatus);
                #ifdef MY_DEBUG
                    _TRACE_("delete "<<_class_name<<"("<<this<<")["<<getName()<<"]");
                #else
                    OutputDebugStringA("*\n");
                #endif
                }
                
                void GgafActor::setScenePlatform(GgafScene* prm_pScene_Platform) {
                    _pScene_Platform = prm_pScene_Platform;
                    if (_pSubFirst) {
                        _pActor_tmp = _pSubFirst;
                        while (true) {
                            _pActor_tmp->setScenePlatform(prm_pScene_Platform);
                            if (_pActor_tmp->_is_last_flg) {
                                break;
                            } else {
                                _pActor_tmp = _pActor_tmp->_pNext;
                            }
                        }
                    }
                }
                
                void GgafActor::setHitAble(bool prm_can_hit_flg, bool prm_can_hit_out_of_view_flg) {
                    TRACE("GgafActor::setHitAble() " << getName());
                    _can_hit_flg = prm_can_hit_flg;
                    _can_hit_out_of_view = prm_can_hit_out_of_view_flg;
                }
                
                void GgafActor::setHitAbleTree(bool prm_can_hit_flg, bool prm_can_hit_out_of_view_flg) {
                    TRACE("GgafActor::setHitAble() " << getName());
                    _can_hit_flg = prm_can_hit_flg;
                    _can_hit_out_of_view = prm_can_hit_out_of_view_flg;
                    if (_pSubFirst) {
                        _pActor_tmp = _pSubFirst;
                        while (true) {
                            _pActor_tmp->setHitAble(prm_can_hit_flg, prm_can_hit_out_of_view_flg);
                            if (_pActor_tmp->_is_last_flg) {
                                break;
                            } else {
                                _pActor_tmp = _pActor_tmp->_pNext;
                            }
                        }
                    }
                }
                
                
                GgafScene* GgafActor::getPlatformScene() {
                    if (_pScene_Platform == NULL) {
                        if (getParent()) {
                            _pScene_Platform = getParent()->getPlatformScene();
                        } else {
                            _pScene_Platform = NULL;
                        }
                    }
                    return _pScene_Platform;
                }
                
                void GgafActor::sayonara(frame prm_frame_offset) {
                    if (_pDependenceDispcher) {
                        inactivateDelay(prm_frame_offset);
                    } else {
                        end(prm_frame_offset);
                    }
                    GgafActor* pActor;
                    if (_pSubFirst) {
                        pActor = _pSubFirst;
                        while (true) {
                            pActor->sayonara(prm_frame_offset);
                            if (pActor->_is_last_flg) {
                                break;
                            } else {
                                pActor = pActor->_pNext;
                            }
                        }
                    }
                }
                
                void GgafActor::dump() {
                    _TRACE_("\t\t\t\t\t\t\t\t"<<_class_name<<"("<<this<<")["<<getName()<<"]@"<<_frame_of_behaving_since_onActive<<
                                                                                               "/"<<
                                                                                               _frame_of_behaving<<
                                                                                               "/"<<
                                                                                               _frame_of_life<<
                                                                                               ","<<
                                                                                               _was_initialize_flg<<
                                                                                               ","<<
                                                                                               _can_live_flg<<
                                                                                               _is_active_flg<<
                                                                                               ","<<
                                                                                               _will_activate_after_flg<<
                                                                                               "("<<_frame_of_life_when_activation<<")"<<
                                                                                               _on_change_to_active_flg<<
                                                                                               ","<<
                                                                                               _will_inactivate_after_flg<<
                                                                                               "("<<_frame_of_life_when_inactivation<<")"<<
                                                                                               _on_change_to_inactive_flg<<
                                                                                               ","<<
                                                                                               _will_end_after_flg<<
                                                                                               "("<<_frame_of_life_when_end<<")"<<
                                                                                               ","<<
                                                                                               _was_paused_flg<<
                                                                                               _was_paused_flg_in_next_frame<<
                                                                                               _will_mv_first_in_next_frame_flg<<
                                                                                               _will_mv_last_in_next_frame_flg
                                                                                               );
                
                    GgafActor* pActor_tmp = _pSubFirst;
                    if (_pSubFirst) {
                        while (true) {
                            pActor_tmp->dump("\t\t\t\t\t\t\t\tb");
                            if (pActor_tmp->_pNext) {
                                pActor_tmp = pActor_tmp->_pNext;
                            } else {
                                _TRACE_("yxz"<<_class_name<<"("<<this<<")["<<getName()<<"]nextNULL");
                                break;
                            }
                            if (pActor_tmp->_is_first_flg) {
                                _TRACE_("\t\t\t\t\t\t\t\t");
                                break;
                            }
                        }
                    }
                }
                
                void GgafActor::dump(string prm_parent) {
                    _TRACE_(prm_parent << _class_name<<"("<<this<<")["<<getName()<<"]@"<<_frame_of_behaving_since_onActive<<
                                                                                         "/"<<
                                                                                         _frame_of_behaving<<
                                                                                         "/"<<
                                                                                         _frame_of_life<<
                                                                                         ","<<
                                                                                         _was_initialize_flg<<
                                                                                         ","<<
                                                                                         _can_live_flg<<
                                                                                         _is_active_flg<<
                                                                                         ","<<
                                                                                         _will_activate_after_flg<<
                                                                                         "("<<_frame_of_life_when_activation<<")"<<
                                                                                         _on_change_to_active_flg<<
                                                                                         ","<<
                                                                                         _will_inactivate_after_flg<<
                                                                                         "("<<_frame_of_life_when_inactivation<<")"<<
                                                                                         _on_change_to_inactive_flg<<
                                                                                         ","<<
                                                                                         _will_end_after_flg<<
                                                                                         "("<<_frame_of_life_when_end<<")"<<
                                                                                         ","<<
                                                                                         _was_paused_flg<<
                                                                                         _was_paused_flg_in_next_frame<<
                                                                                         _will_mv_first_in_next_frame_flg<<
                                                                                         _will_mv_last_in_next_frame_flg
                                                                                         );
                
                    GgafActor* pActor_tmp = _pSubFirst;
                    if (_pSubFirst) {
                        while (true) {
                            pActor_tmp->dump(prm_parent + "b");
                            if (pActor_tmp->_pNext) {
                                pActor_tmp = pActor_tmp->_pNext;
                            } else {
                                _TRACE_("yxz"<<_class_name<<"("<<this<<")["<<getName()<<"]nextNULL");
                                break;
                            }
                            if (pActor_tmp->_is_first_flg) {
                                _TRACE_(prm_parent+"");
                                break;
                            }
                        }
                    }
                }
                


Top 10 Lines:

     Line      Count

       28       4987
        6       4986

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

     9973   Total number of line executions
  3324.33   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafCore/include/jp/ggaf/core/util/GgafStatus.h:
                #ifndef GGAFSTATUS_H_
                #define GGAFSTATUS_H_
                namespace GgafCore {
                
                /**
                 * Xe[XNX.
                 * lZbg\B
                 * @version 1.00
                 * @since 2009/07/22 a
                 * @author Masatoshi Tsuge
                 */
                class GgafStatus {
                
                    /**
                     * Xe[^Xl\ .
                     * ^ char, int, doubleB
                     */
                    struct VALUE {
                      char _char_val;
                      int _int_val;
                      double _double_val;
                      void* _ptr;
                    };
                
                public:
                    /** Xe[^X */
                    int _len;
                    /** Xe[^Xlz */
                    VALUE* _paValue;
                
                    /**
                     * Xe[^XZbg .
                     * @param n Xe[^XvfB
                     * @return
                     */
        4986 ->     GgafStatus(int n) {
                        _len = n;
                        _paValue = NEW VALUE[n];
                        for (int i = 0; i < n; i++) {
                            _paValue[i]._double_val = 0;
                            _paValue[i]._int_val = 0;
                            _paValue[i]._char_val = 0;
                            _paValue[i]._ptr = NULL;
                        }
                    }
                
                
                    void set(int n, char val) {
                        _paValue[n]._char_val = val;
                    }
                
                    void set(int n, int val) {
                        _paValue[n]._int_val = val;
                    }
                
                    void set(int n, double val) {
                        _paValue[n]._double_val = val;
                    }
                
                    void set(int n, void* p) {
                        _paValue[n]._ptr = p;
                    }
                
                    char plus(int n, char val) {
                        return _paValue[n]._char_val += val;
                    }
                
                    int plus(int n, int val) {
                        return _paValue[n]._int_val += val;
                    }
                
                    double plus(int n, double val) {
                        return _paValue[n]._double_val += val;
                    }
                
                    char minus(int n, char val) {
                        return _paValue[n]._char_val -= val;
                    }
                
                    int minus(int n, int val) {
                        return _paValue[n]._int_val -= val;
                    }
                
                    double minus(int n, double val) {
                        return _paValue[n]._double_val -= val;
                    }
                
                    char mul(int n, char val) {
                        return _paValue[n]._char_val *= val;
                    }
                
                    int mul(int n, int val) {
                        return _paValue[n]._int_val *= val;
                    }
                
                    double mul(int n, double val) {
                        return _paValue[n]._double_val *= val;
                    }
                
                    int get(int n) {
                        return _paValue[n]._int_val;
                    }
                
                    int getChar(int n) {
                        return _paValue[n]._char_val;
                    }
                
                    int getInt(int n) {
                        return _paValue[n]._int_val;
                    }
                
                    double getDouble(int n) {
                        return _paValue[n]._double_val;
                    }
                
                    void* getPtr(int n) {
                        return _paValue[n]._ptr;
                    }
                
        4987 ->     ~GgafStatus() {
                        delete[] _paValue;
                    }
                
                };
                
                }
                #endif /*GGAFSTATUS_H_*/
                


Top 10 Lines:

     Line      Count

      120       4987
       36       4986

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

     9973   Total number of line executions
  4986.50   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafCore\GprofCdt/../src/jp/ggaf/core/actor/GgafMainActor.cpp:
                #include "stdafx.h"
                using namespace std;
                
                using namespace GgafCore;
                
        4851 -> GgafMainActor::GgafMainActor(const char* prm_name) : GgafActor(prm_name) {
                    _obj_class |= Obj_GgafMainActor;
                    _class_name = "GgafMainActor";
                    _pGroupActor = NULL;
                    _pLordActor = NULL;
                    setHitAble(false);
                }
                
                GgafMainActor* GgafMainActor::extract() {
                    GgafMainActor* pActor = (GgafMainActor*)GgafActor::extract();
                    pActor->setLordActor(NULL); //AN^[Zbg
                    pActor->setScenePlatform(NULL); //V[Zbg
                    return pActor;
                }
                
                //bool GgafMainActor::isActive() {
                //    if (GgafActor::isActive() && getPlatformScene() && getPlatformScene()->isActive()) {
                //        return true;
                //    } else {
                //        return false;
                //    }
                //}
                
                void GgafMainActor::setLordActor(GgafLordActor* prm_pLordActor) {
                    _pLordActor = prm_pLordActor;
                    if (_pSubFirst) {
                        GgafActor* pActor = getSubFirst();
                        while (true) {
                            if (pActor->_obj_class & Obj_GgafMainActor) {
                                ((GgafMainActor*)(pActor))->setLordActor(prm_pLordActor);
                            } else if (pActor->_obj_class & Obj_GgafGroupActor) {
                                ((GgafGroupActor*)(pActor))->setLordActor(prm_pLordActor);
                            }
                            if (pActor->_is_last_flg) {
                                break;
                            } else {
                                pActor = pActor->getNext();
                            }
                        }
                    }
                }
                
                void GgafMainActor::setGroupActor(GgafGroupActor* prm_pGroupActor) {
                    _pGroupActor = prm_pGroupActor;
                    if (_pSubFirst) {
                        GgafActor* pActor = getSubFirst();
                        while (true) {
                            if (pActor->_obj_class & Obj_GgafMainActor) {
                                ((GgafMainActor*)(pActor))->setGroupActor(prm_pGroupActor);
                            } else if (pActor->_obj_class & Obj_GgafGroupActor) {
                                //X[
                                //c[GgafGroupActorAc[e
                            }
                            if (pActor->_is_last_flg) {
                                break;
                            } else {
                                pActor = pActor->getNext();
                            }
                        }
                    }
                }
                //setGroupActorK
                //\AGgafGroupActorB
                //TODO:AGgafGroupActor(088C6D48)r
                //
                //   bGgafGroupActor(088C6EA0)[kind=00000000000000000100000000000000]@13883,0,101,101,0(0)
                //   bbEnemyCirce(088C5E50)[EnemyCirce](-66856,-154236,26350)@13883,1,101,101,0(0)
                //   bbbGgafGroupActor(088C6D48)[kind=00000000000000000100000000000000]@13883,0,101,101,0(0)
                //   bbbbEnemyVesta(08826070)[EnemyVesta1](-197896,-154236,296217)@13883,1,101,101,0(0)
                //   bbbbEnemyVesta(088C2610)[EnemyVesta2](203010,-154759,157390)@13883,1,101,101,0(0)
                //   bbbbEnemyVesta(088C3150)[EnemyVesta3](64184,-154236,-243517)@13883,1,101,101,0(0)
                //   bbbbEnemyVesta(088C3C90)[EnemyVesta4](-336722,-153712,-104690)@13883,1,101,101,0(0)
                //   bbbbEnemyVesta(088C47D0)[EnemyVesta5](-66384,145763,26578)@13883,1,101,101,0(0)
                //   bbbbEnemyVesta(088C5310)[EnemyVesta6](-67327,-454235,26121)@13883,1,101,101,0(0)
                //   bbb
                //   bb
                //   b
                
                
                GgafGroupActor* GgafMainActor::getGroupActor() {
                    if (_pGroupActor == NULL) {
                #ifdef MY_DEBUG
                        if (_pParent == NULL) {
                            throwGgafCriticalException("GgafMainActor::getGroupActor AGroupActorI("<<getName()<<")");
                        }
                #endif
                        if (_pParent->_obj_class & Obj_GgafMainActor) {
                            _pGroupActor = ((GgafMainActor*)(_pParent))->getGroupActor();
                        } else if (_pParent->_obj_class & Obj_GgafGroupActor) {
                            return (GgafGroupActor*)_pParent;
                        }
                    }
                    return _pGroupActor;
                }
                
                
                GgafLordActor* GgafMainActor::getLordActor() {
                    if (_pLordActor == NULL) {
                        if (_pParent == NULL) {
                            _pLordActor = GgafGod::_pGod->_pUniverse->getLordActor(); //AN^[
                            _TRACE_("yxzGgafMainActor::getLordActor ALordActorI("<<getName()<<")B(Universe)LordActor");
                        } else {
                            if (_pParent->_obj_class & Obj_GgafMainActor) {
                                _pLordActor = ((GgafMainActor*)(_pParent))->getLordActor();
                            } else if (_pParent->_obj_class & Obj_GgafGroupActor) {
                                _pLordActor = ((GgafGroupActor*)(_pParent))->getLordActor();
                            } else if (_pParent->_obj_class & Obj_GgafLordActor) { //
                                return (GgafLordActor*)_pParent;
                            } else {
                                _pLordActor = NULL;
                            }
                           _pLordActor = GgafGod::_pGod->_pUniverse->getLordActor(); //AN^[
                            _TRACE_("yxzGgafMainActor::getLordActor c[LordActorI("<<getName()<<")B(Universe)LordActor");
                        }
                    }
                    return _pLordActor;
                }
                
                
                
                GgafGroupActor* GgafMainActor::addSubGroup(actorkind prm_kind, GgafMainActor* prm_pMainActor) {
                    if (prm_pMainActor->_pLordActor) {
                        //_TRACE_("yxzGgafLordActor::addSubGroup("<<getName()<<") "<<prm_pMainActor->_pLordActor->_pScene_Platform->getName()<<"V[BA"<<_pScene_Platform->getName()<<"V[");
                        prm_pMainActor->extract();
                    }
                    GgafGroupActor* pSubGroupActor = getSubGroupActor(prm_kind);
                    if (pSubGroupActor == NULL) {
                        pSubGroupActor = NEW GgafGroupActor(prm_kind);
                        addSubLast(pSubGroupActor);
                    } else {
                       //OK
                    }
                    pSubGroupActor->addSubLast(prm_pMainActor);
                    prm_pMainActor->setGroupActor(pSubGroupActor);
                    prm_pMainActor->setLordActor(getLordActor()); //AN^[Zbg
                    prm_pMainActor->setScenePlatform(getPlatformScene()); //V[Zbg
                    return pSubGroupActor;
                }
                
                GgafGroupActor* GgafMainActor::addSubGroup(GgafMainActor* prm_pMainActor) {
                    return addSubGroup(prm_pMainActor->_pStatus->get(STAT_DEFAULT_ACTOR_KIND), prm_pMainActor);
                }
                
                
                GgafGroupActor* GgafMainActor::getSubGroupActor(actorkind prm_kind) {
                    if (_pSubFirst == NULL) {
                        return NULL;
                    } else {
                        GgafActor* pSubActor = _pSubFirst;
                        GgafGroupActor* pSubGroupActor_ret = NULL;
                        do {
                            if (pSubActor->_obj_class & Obj_GgafGroupActor) {
                                pSubGroupActor_ret = (GgafGroupActor*)pSubActor;
                                if (pSubGroupActor_ret->_kind == prm_kind) {
                                    return pSubGroupActor_ret;
                                }
                            }
                            if (pSubActor->_is_last_flg) {
                                return NULL;
                            } else {
                                pSubActor = pSubActor->_pNext;
                            }
                        } while (true);
                    }
                }
                
                
                GgafGod* GgafMainActor::askGod() {
                    if (_pGod == NULL) {
                        if (_pParent == NULL) {
                            throwGgafCriticalException("GgafMainActor::askGod _yBII("<<getName()<<")");
                        }
                        _pGod = getParent()->askGod();
                    }
                    return _pGod;
                }
                
                actorkind GgafMainActor::getKind() {
                    return getGroupActor()->_kind;
                }
                
                
                
        4852 -> GgafMainActor::~GgafMainActor() {
                }


Top 10 Lines:

     Line      Count

      189       4852
        6       4851

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

     9703   Total number of line executions
  3234.33   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafCore\GprofCdt/../src/jp/ggaf/core/actor/GgafActorDispatcher.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                
         130 -> GgafActorDispatcher::GgafActorDispatcher(const char* prm_name) : GgafDummyActor(prm_name) {
                    _obj_class |= Obj_GgafActorDispatcher;
                    _class_name = "GgafActorDispatcher";
                    setHitAble(false);
                }
                
                
                void GgafActorDispatcher::addSubLast(GgafActor* prm_pSub) {
                
                    if (_pSubFirst == NULL) {
                        //p
                        _pStatus->set(STAT_DEFAULT_ACTOR_KIND, prm_pSub->_pStatus->get(STAT_DEFAULT_ACTOR_KIND));
                    } else {
                        if (_pStatus->get(STAT_DEFAULT_ACTOR_KIND) != prm_pSub->_pStatus->get(STAT_DEFAULT_ACTOR_KIND)) {
                            throwGgafCriticalException("GgafActorDispatcher::addSubLast AN^[o^B \n"<<
                                                       "z="<<_pStatus->get(STAT_DEFAULT_ACTOR_KIND)<<"[_pSubFirst="<<_pSubFirst->getName()<<"] \n"<<
                                                       "="<<prm_pSub->_pStatus->get(STAT_DEFAULT_ACTOR_KIND)<<"["<<prm_pSub->getName()<<"]");
                        }
                    }
                    prm_pSub->_pDependenceDispcher = this;
                    prm_pSub->inactivateImmediately();
                    GgafDummyActor::addSubLast(prm_pSub);
                }
                
                void GgafActorDispatcher::onReset() {
                    _TRACE_("GgafActorDispatcher::onReset() ["<<getName()<<"]");
                    if (_pSubFirst == NULL) {
                        return;
                    }
                    GgafMainActor* pActor = getSubFirst();
                    while (true) {
                        pActor->inactivate();
                        if (pActor->isLast()) {
                            break;
                        } else {
                            pActor = pActor->getNext();
                            continue;
                        }
                    }
                }
                
                
                
                //K
                //TODO:GgafActorDispatcherAGgafGroupActorpA
                //GgafGroupActorAN^[
                //AlB


Top 10 Lines:

     Line      Count

        5        130

Execution Summary:

        2   Executable lines in this file
        1   Lines executed
    50.00   Percent of the file executed

      130   Total number of line executions
    65.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafCore\GprofCdt/../src/jp/ggaf/core/GgafGod.cpp:
                #include "stdafx.h"
                using namespace std;
                
                using namespace GgafCore;
                
                GgafCriticalException* GgafGod::_pException_Factory = NULL;
                CRITICAL_SECTION GgafGod::CS1;
                CRITICAL_SECTION GgafGod::CS2;
                int GgafGod::_num_actor_drawing = 0;
                GgafGod* GgafGod::_pGod = NULL;
                DWORD GgafGod::_aaTime_OffsetOfNextFrame[3][60] = {
                        {17,17,16,17,17,16,17,17,16,17,17,16,17,17,16,17,17,16,17,17,16,17,17,16,17,17,16,17,17,16,17,17,16,17,17,16,17,17,16,17,17,16,17,17,16,17,17,16,17,17,16,17,17,16,17,17,16,17,17,16},
                        {25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25},
                        {33,33,34,33,33,34,33,33,34,33,33,34,33,33,34,33,33,34,33,33,34,33,33,34,33,33,34,33,33,34,33,33,34,33,33,34,33,33,34,33,33,34,33,33,34,33,33,34,33,33,34,33,33,34,33,33,34,33,33,34}
                };
                
           1 -> GgafGod::GgafGod() : GgafObject(),
                  _pUniverse(NULL),
                  _fps(0) {
                    TRACE("GgafGod::GgafGod");
                    _frame_of_God = 0;
                
                    _handleFactory01 = (HANDLE)::_beginthreadex(NULL, 0, GgafFactory::work, NULL, CREATE_SUSPENDED, &_thID01);
                
                    if (_handleFactory01 == 0) {
                        throwGgafCriticalException("GgafGod::GgafGod() Error! XbhsI");
                    }
                    ::InitializeCriticalSection(&(GgafGod::CS1));
                    ::InitializeCriticalSection(&(GgafGod::CS2));
                    ::ResumeThread(_handleFactory01);
                    ::SetThreadPriority(_handleFactory01, THREAD_PRIORITY_IDLE);
                    GgafGod::_pGod = this;
                    _time_at_beginning_frame = timeGetTime();
                    _expected_time_of_next_frame = (frame)(_time_at_beginning_frame + 3000); //3b
                    _time_prev = _time_at_beginning_frame;
                    _frame_of_visualize = 0;
                    _frame_of_prev_visualize = 0;
                    _is_behaved_flg = false;
                    _is_materialized_flg = false;
                    GgafFactory::_pGarbageBox = NEW GgafGarbageBox();
                    _is_being = false;
                    _can_be = true;
                    _was_cleaned = false;
                    _skip_count_of_frame = 0;
                    _max_skip_frame = (int)GGAF_PROPERTY(MAX_SKIP_FRAME);
                    _slowdown_mode = SLOWDOWN_MODE_DEFAULT;
                    _sync_frame_time = false;
                }
                
                void GgafGod::be() {
                    if (_can_be) {
                        _is_being = true;
                        if (_pUniverse == NULL) {
                            _pUniverse = createUniverse();
                #ifdef MY_DEBUG
                            if (_pUniverse == NULL) {
                                throwGgafCriticalException("GgafGod::be() Error! I");
                            }
                #endif
                            _pUniverse->_pGod = this;
                        }
                #ifdef MY_DEBUG
                        //HiXbhjO`FbN
                        if (_pException_Factory) {
                            throw *_pException_Factory;
                        }
                #endif
                
                        if (_is_behaved_flg == false) {
                            _is_behaved_flg = true;
                        ___BeginSynchronized; // ----->rJn
                            _frame_of_God++;
                            presentUniversalMoment();
                            executeUniversalJudge();
                        ___EndSynchronized; // <----- rI
                            //`^C~Ot[Z
                            if (_num_actor_drawing > GGAF_PROPERTY(DRAWNUM_TO_SLOWDOWN2)) {
                                _slowdown_mode = SLOWDOWN_MODE_30FPS;
                            } else if (_num_actor_drawing > GGAF_PROPERTY(DRAWNUM_TO_SLOWDOWN1)) {
                                _slowdown_mode = SLOWDOWN_MODE_40FPS;
                            } else {
                                _slowdown_mode = SLOWDOWN_MODE_DEFAULT;
                            }
                            _expected_time_of_next_frame += _aaTime_OffsetOfNextFrame[_slowdown_mode][_frame_of_God % 60];
                
                            //            //_expected_time_of_next_frame += _aTime_OffsetOfNextFrame[_frame_of_God % 60]; //\
                            //            if (_num_actor_drawing > 500) {
                            //                _expected_time_of_next_frame += (DWORD)(_aaTime_OffsetOfNextFrame[0][_frame_of_God % 60] * 2);
                            //            } else if (_num_actor_drawing > 400) {
                            //                _expected_time_of_next_frame += (DWORD)(_aaTime_OffsetOfNextFrame[0][_frame_of_God % 60] * 1.5);
                            //            } else {
                            //                _expected_time_of_next_frame += _aaTime_OffsetOfNextFrame[0][_frame_of_God % 60];
                
                
                            if (_expected_time_of_next_frame <= timeGetTime()) { //`^C~Ot[A
                                //makeUniversalMaterialize pX
                            } else {
                                //]TL
                                _is_materialized_flg = true;
                                makeUniversalMaterialize();
                            }
                        }
                
                        _time_at_beginning_frame = timeGetTime(); //
                
                        //fpsvZ
                        if (_time_at_beginning_frame - _time_prev >= 1000) {
                            _fps = (float)(_frame_of_visualize - _frame_of_prev_visualize) / (float)((_time_at_beginning_frame - _time_prev) / 1000.0f);
                            _time_prev = _time_at_beginning_frame;
                            _frame_of_prev_visualize = _frame_of_visualize;
                        }
                
                        if (_expected_time_of_next_frame <= _time_at_beginning_frame) { //`^C~Ot[A
                
                            if (_time_at_beginning_frame > _expected_time_of_next_frame + _aaTime_OffsetOfNextFrame[_slowdown_mode][_frame_of_God % 60]) {
                                //(t[H)XLbv
                                _skip_count_of_frame++;
                                if (_skip_count_of_frame >= _max_skip_frame && _sync_frame_time == false) {
                                    //XLbvMAX_SKIP_FRAMEt[P`B
                                    _skip_count_of_frame = 0;
                                    _frame_of_visualize++;
                                 ___BeginSynchronized; // ----->rJn
                                    if (_is_materialized_flg) {
                                        presentUniversalVisualize();
                                        finalizeUniversal();
                                    } else {
                                        makeUniversalMaterialize();
                                        presentUniversalVisualize();
                                        finalizeUniversal();
                                    }
                                 ___EndSynchronized; // <----- rI
                                } else {
                                    //XLbvfinalizeUniversal()
                                 ___BeginSynchronized; // ----->rJn
                                    finalizeUniversal();
                                 ___EndSynchronized; // <----- rI
                                }
                            } else {
                                //`iXLbvj
                                _sync_frame_time = false;
                                _frame_of_visualize++;
                             ___BeginSynchronized; // ----->rJn
                                if (_is_materialized_flg) {
                                    presentUniversalVisualize();
                                    finalizeUniversal();
                                } else {
                                    makeUniversalMaterialize();
                                    presentUniversalVisualize();
                                    finalizeUniversal();
                
                                }
                             ___EndSynchronized; // <----- rI
                            }
                            _is_behaved_flg = false;
                            _is_materialized_flg = false;
                        } else {//`^C~Ot[(]T)
                            Sleep(2); //HiXbhj
                        }
                        _is_being = false;
                    }
                    return;
                }
                
                void GgafGod::presentUniversalMoment() {
                    _pUniverse->nextFrame();
                    _pUniverse->behave();
                }
                
                void GgafGod::executeUniversalJudge() {
                    _pUniverse->settleBehavior();
                    _pUniverse->judge();
                }
                
                void GgafGod::makeUniversalMaterialize() {
                    _num_actor_drawing = 0;
                    _pUniverse->preDraw();
                    _pUniverse->draw();
                #ifdef MY_DEBUG
                    //afterDraw() fobO\gpB
                    _pUniverse->afterDraw();
                #endif
                }
                
                void GgafGod::presentUniversalVisualize() {
                    _pUniverse->dump();
                }
                
                void GgafGod::finalizeUniversal() {
                    _pUniverse->doFinally();
                }
                
                void GgafGod::clean() {
                    if (!_was_cleaned) {
                        _TRACE_("GgafGod::clean() start");
                        if (_pUniverse) {
                            _TRACE_("_pUniverse != NULL");
                            //H~
                            Sleep(10);
                            GgafFactory::_is_working_flg = false;
                            for (int i = 0; GgafFactory::_was_finished_flg == false; i++) {
                                Sleep(60); //H
                                if (i > 2000) {
                                    _TRACE_("GgafGod::~GgafGod() Q@AHBbreakBv");
                                }
                            }
                            //r
                            _TRACE_("GgafGod::~GgafGod() r`FbNEEE");
                            ___BeginSynchronized; // ----->rJn
                            ___EndSynchronized; // <----- rI
                            _TRACE_("GgafGod::~GgafGod() rOK");
                
                            CloseHandle(_handleFactory01);
                            DeleteCriticalSection(&(GgafGod::CS2));
                            DeleteCriticalSection(&(GgafGod::CS1));
                
                    #ifdef MY_DEBUG
                            //c[\\
                            _TRACE_("Dumping _pUniverse ...");
                            _pUniverse->dump();
                    #endif
                
                            //H|
                            _TRACE_("GgafFactory::clean()");
                            GgafFactory::clean();
                            //S~
                    #ifdef MY_DEBUG
                            _TRACE_("Dumping GgafFactory::_pGarbageBox->_pDisusedScene ...");
                            GgafFactory::_pGarbageBox->_pDisusedScene->dump();
                            _TRACE_("GgafFactory::_pGarbageBox->_pDisusedActor ...");
                            GgafFactory::_pGarbageBox->_pDisusedActor->dump();
                    #endif
                            _TRACE_("DELETE_IMPOSSIBLE_NULL(GgafFactory::_pGarbageBox);");
                            DELETE_IMPOSSIBLE_NULL(GgafFactory::_pGarbageBox);
                            //|
                            Sleep(20);
                            _TRACE_("DELETE_IMPOSSIBLE_NULL(_pUniverse);");
                            DELETE_IMPOSSIBLE_NULL(_pUniverse);
                        }
                
                        //HO _pException_Factory NB
                        _TRACE_("DELETE_POSSIBLE_NULL(_pException_Factory);");
                        DELETE_POSSIBLE_NULL(_pException_Factory);
                        _TRACE_("GgafGod::clean() end");
                    }
                }
                
                
           1 -> GgafGod::~GgafGod() {
                    clean();
                    _was_cleaned = true;
                }


Top 10 Lines:

     Line      Count

       17          1
      248          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        2   Total number of line executions
     0.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafCore\GprofCdt/../src/jp/ggaf/core/GgafProgress.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                
        1547 -> GgafProgress::GgafProgress(frame* prm_pFrame_behaving, int prm_num_progress) : GgafObject() ,
                _progress(-1),
                _progress_prev(-2),
                _progress_nextframe(-3),
                _pFrame_behaving(prm_pFrame_behaving)
                {
                    _num_progress = prm_num_progress;
                    _paFrame_ProgressChanged = NEW frame[_num_progress];
                    DWORD x = UINT_MAX/2;
                    for (int i = 0; i < _num_progress; i++) {
                        _paFrame_ProgressChanged[i] = x; //Lt[
                    }
                }
                
                int GgafProgress::get() {
                    return _progress;
                }
                void GgafProgress::set(int prm_progress) {
                #ifdef MY_DEBUG
                    if (prm_progress < 0 || prm_progress > _num_progress-1) {
                        throwGgafCriticalException("GgafProgress::set iIDOBprm_progress="<<prm_progress<<" _num_progress="<<_num_progress);
                    }
                #endif
                    _progress_prev = _progress;
                    _progress = prm_progress;
                    _progress_nextframe = prm_progress;
                    _paFrame_ProgressChanged[prm_progress] = (*_pFrame_behaving);
                }
                
                frame GgafProgress::getFrameWhenChanged(int prm_progress) {
                #ifdef MY_DEBUG
                    if (prm_progress < 0 || prm_progress > _num_progress-1) {
                        throwGgafCriticalException("GgafProgress::getFrameWhenChanged iIDOBprm_progress="<<prm_progress<<" _num_progress="<<_num_progress);
                    }
                #endif
                    return _paFrame_ProgressChanged[prm_progress];
                }
                
                frame GgafProgress::getFrameInProgress() {
                    return (*_pFrame_behaving)+1 - _paFrame_ProgressChanged[_progress];
                }
                
                
                void GgafProgress::change(int prm_progress) {
                #ifdef MY_DEBUG
                    if (prm_progress < 0 || prm_progress > _num_progress-1) {
                        throwGgafCriticalException("GgafProgress::change iIDOBprm_progress="<<prm_progress<<" _num_progress="<<_num_progress);
                    }
                #endif
                    _progress_nextframe = prm_progress;
                    _paFrame_ProgressChanged[prm_progress] = (*_pFrame_behaving)+1;
                }
                
                void GgafProgress::changeNext() {
                    _progress_nextframe = _progress+1;
                #ifdef MY_DEBUG
                    if (_progress_nextframe < 0 || _progress_nextframe > _num_progress-1) {
                        throwGgafCriticalException("GgafProgress::changeNext iIDOB_progress_nextframe="<<_progress_nextframe);
                    }
                #endif
                    _paFrame_ProgressChanged[_progress+1] = (*_pFrame_behaving)+1;
                }
                
                
                bool GgafProgress::wasChangedTo(int prm_progress) {
                #ifdef MY_DEBUG
                    if (prm_progress < 0 || prm_progress > _num_progress-1) {
                        throwGgafCriticalException("GgafProgress::wasChangedTo iIDOBprm_progress="<<prm_progress<<" _num_progress="<<_num_progress);
                    }
                #endif
                    if (_progress != _progress_prev) {
                        if (prm_progress == _progress) {
                            return true;
                        } else {
                            return false;
                        }
                    } else {
                        return false;
                    }
                }
                bool GgafProgress::isJustChanged() {
                    if (_progress != _progress_prev) {
                        return true;
                    } else {
                        return false;
                    }
                }
                
                bool GgafProgress::wasChangedFrom(int prm_progress) {
                #ifdef MY_DEBUG
                    if (prm_progress < 0 || prm_progress > _num_progress-1) {
                        throwGgafCriticalException("GgafProgress::wasChangedFrom iIDOBprm_progress="<<prm_progress<<" _num_progress="<<_num_progress);
                    }
                #endif
                    if (_progress != _progress_prev) {
                        if (prm_progress == _progress_prev) {
                            return true;
                        } else {
                            return false;
                        }
                    } else {
                        return false;
                    }
                }
                
                int GgafProgress::getChangedTo() {
                    if (_progress != _progress_prev) {
                        return _progress;
                    } else {
                        return 0; // = false
                    }
                }
                
                int GgafProgress::getFromChange() {
                    if (_progress != _progress_prev) {
                        return _progress_prev;
                    } else {
                        return 0; // = false
                    }
                }
                
                void GgafProgress::update() {
                    //if
                    _progress_prev = _progress;
                    _progress = _progress_nextframe;
                
                }
                
        3094 -> GgafProgress::~GgafProgress() {
                    DELETEARR_IMPOSSIBLE_NULL(_paFrame_ProgressChanged);
                
                }
                


Top 10 Lines:

     Line      Count

      133       3094
        5       1547

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

     4641   Total number of line executions
  1547.00   Average executions per line


*** File c:/cygwin/mingw/bin/../lib/gcc/mingw32/4.5.2/include/c++/bits/stl_tree.h:
                // RB tree implementation -*- C++ -*-
                
                // Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
                // Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 */
                
                /** @file stl_tree.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                #ifndef _STL_TREE_H
                #define _STL_TREE_H 1
                
                #include <bits/stl_algobase.h>
                #include <bits/allocator.h>
                #include <bits/stl_function.h>
                #include <bits/cpp_type_traits.h>
                
                _GLIBCXX_BEGIN_NAMESPACE(std)
                
                  // Red-black tree class, designed for use in implementing STL
                  // associative containers (set, multiset, map, and multimap). The
                  // insertion and deletion algorithms are based on those in Cormen,
                  // Leiserson, and Rivest, Introduction to Algorithms (MIT Press,
                  // 1990), except that
                  //
                  // (1) the header cell is maintained with links not only to the root
                  // but also to the leftmost node of the tree, to enable constant
                  // time begin(), and to the rightmost node of the tree, to enable
                  // linear time performance when used with the generic set algorithms
                  // (set_union, etc.)
                  // 
                  // (2) when a node being deleted has two children its successor node
                  // is relinked into its place, rather than copied, so that the only
                  // iterators invalidated are those referring to the deleted node.
                
                  enum _Rb_tree_color { _S_red = false, _S_black = true };
                
                  struct _Rb_tree_node_base
                  {
                    typedef _Rb_tree_node_base* _Base_ptr;
                    typedef const _Rb_tree_node_base* _Const_Base_ptr;
                
                    _Rb_tree_color	_M_color;
                    _Base_ptr		_M_parent;
                    _Base_ptr		_M_left;
                    _Base_ptr		_M_right;
                
                    static _Base_ptr
                    _S_minimum(_Base_ptr __x)
                    {
                      while (__x->_M_left != 0) __x = __x->_M_left;
                      return __x;
                    }
                
                    static _Const_Base_ptr
                    _S_minimum(_Const_Base_ptr __x)
                    {
                      while (__x->_M_left != 0) __x = __x->_M_left;
                      return __x;
                    }
                
                    static _Base_ptr
                    _S_maximum(_Base_ptr __x)
                    {
                      while (__x->_M_right != 0) __x = __x->_M_right;
                      return __x;
                    }
                
                    static _Const_Base_ptr
                    _S_maximum(_Const_Base_ptr __x)
                    {
                      while (__x->_M_right != 0) __x = __x->_M_right;
                      return __x;
                    }
                  };
                
                  template<typename _Val>
                    struct _Rb_tree_node : public _Rb_tree_node_base
       ##### ->     {
                      typedef _Rb_tree_node<_Val>* _Link_type;
                      _Val _M_value_field;
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      template<typename... _Args>
          36 ->         _Rb_tree_node(_Args&&... __args)
                	: _Rb_tree_node_base(),
                	  _M_value_field(std::forward<_Args>(__args)...) { }
                #endif
                    };
                
                  _GLIBCXX_PURE _Rb_tree_node_base*
                  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();
                
                  _GLIBCXX_PURE const _Rb_tree_node_base*
                  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();
                
                  _GLIBCXX_PURE _Rb_tree_node_base*
                  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();
                
                  _GLIBCXX_PURE const _Rb_tree_node_base*
                  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();
                
                  template<typename _Tp>
                    struct _Rb_tree_iterator
                    {
                      typedef _Tp  value_type;
                      typedef _Tp& reference;
                      typedef _Tp* pointer;
                
                      typedef bidirectional_iterator_tag iterator_category;
                      typedef ptrdiff_t                  difference_type;
                
                      typedef _Rb_tree_iterator<_Tp>        _Self;
                      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
                      typedef _Rb_tree_node<_Tp>*           _Link_type;
                
                      _Rb_tree_iterator()
                      : _M_node() { }
                
                      explicit
       13937 ->       _Rb_tree_iterator(_Link_type __x)
                      : _M_node(__x) { }
                
                      reference
                      operator*() const
                      { return static_cast<_Link_type>(_M_node)->_M_value_field; }
                
                      pointer
                      operator->() const
                      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }
                
                      _Self&
                      operator++()
                      {
                	_M_node = _Rb_tree_increment(_M_node);
                	return *this;
                      }
                
                      _Self
                      operator++(int)
                      {
                	_Self __tmp = *this;
                	_M_node = _Rb_tree_increment(_M_node);
                	return __tmp;
                      }
                
                      _Self&
                      operator--()
                      {
                	_M_node = _Rb_tree_decrement(_M_node);
                	return *this;
                      }
                
                      _Self
                      operator--(int)
                      {
                	_Self __tmp = *this;
                	_M_node = _Rb_tree_decrement(_M_node);
                	return __tmp;
                      }
                
                      bool
                      operator==(const _Self& __x) const
                      { return _M_node == __x._M_node; }
                
                      bool
                      operator!=(const _Self& __x) const
                      { return _M_node != __x._M_node; }
                
                      _Base_ptr _M_node;
                  };
                
                  template<typename _Tp>
                    struct _Rb_tree_const_iterator
                    {
                      typedef _Tp        value_type;
                      typedef const _Tp& reference;
                      typedef const _Tp* pointer;
                
                      typedef _Rb_tree_iterator<_Tp> iterator;
                
                      typedef bidirectional_iterator_tag iterator_category;
                      typedef ptrdiff_t                  difference_type;
                
                      typedef _Rb_tree_const_iterator<_Tp>        _Self;
                      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
                      typedef const _Rb_tree_node<_Tp>*           _Link_type;
                
                      _Rb_tree_const_iterator()
                      : _M_node() { }
                
                      explicit
                      _Rb_tree_const_iterator(_Link_type __x)
                      : _M_node(__x) { }
                
          36 ->       _Rb_tree_const_iterator(const iterator& __it)
                      : _M_node(__it._M_node) { }
                
                      reference
                      operator*() const
                      { return static_cast<_Link_type>(_M_node)->_M_value_field; }
                
                      pointer
                      operator->() const
                      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }
                
                      _Self&
                      operator++()
                      {
                	_M_node = _Rb_tree_increment(_M_node);
                	return *this;
                      }
                
                      _Self
                      operator++(int)
                      {
                	_Self __tmp = *this;
                	_M_node = _Rb_tree_increment(_M_node);
                	return __tmp;
                      }
                
                      _Self&
                      operator--()
                      {
                	_M_node = _Rb_tree_decrement(_M_node);
                	return *this;
                      }
                
                      _Self
                      operator--(int)
                      {
                	_Self __tmp = *this;
                	_M_node = _Rb_tree_decrement(_M_node);
                	return __tmp;
                      }
                
                      bool
                      operator==(const _Self& __x) const
                      { return _M_node == __x._M_node; }
                
                      bool
                      operator!=(const _Self& __x) const
                      { return _M_node != __x._M_node; }
                
                      _Base_ptr _M_node;
                    };
                
                  template<typename _Val>
                    inline bool
                    operator==(const _Rb_tree_iterator<_Val>& __x,
                               const _Rb_tree_const_iterator<_Val>& __y)
                    { return __x._M_node == __y._M_node; }
                
                  template<typename _Val>
                    inline bool
                    operator!=(const _Rb_tree_iterator<_Val>& __x,
                               const _Rb_tree_const_iterator<_Val>& __y)
                    { return __x._M_node != __y._M_node; }
                
                  void
                  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                                _Rb_tree_node_base* __x,
                                                _Rb_tree_node_base* __p,
                                                _Rb_tree_node_base& __header) throw ();
                
                  _Rb_tree_node_base*
                  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
                			       _Rb_tree_node_base& __header) throw ();
                
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc = allocator<_Val> >
                    class _Rb_tree
                    {
                      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other
                              _Node_allocator;
                
                    protected:
                      typedef _Rb_tree_node_base* _Base_ptr;
                      typedef const _Rb_tree_node_base* _Const_Base_ptr;
                
                    public:
                      typedef _Key key_type;
                      typedef _Val value_type;
                      typedef value_type* pointer;
                      typedef const value_type* const_pointer;
                      typedef value_type& reference;
                      typedef const value_type& const_reference;
                      typedef _Rb_tree_node<_Val>* _Link_type;
                      typedef const _Rb_tree_node<_Val>* _Const_Link_type;
                      typedef size_t size_type;
                      typedef ptrdiff_t difference_type;
                      typedef _Alloc allocator_type;
                
                      _Node_allocator&
                      _M_get_Node_allocator()
                      { return *static_cast<_Node_allocator*>(&this->_M_impl); }
                      
                      const _Node_allocator&
                      _M_get_Node_allocator() const
                      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }
                
                      allocator_type
                      get_allocator() const
                      { return allocator_type(_M_get_Node_allocator()); }
                
                    protected:
                      _Link_type
                      _M_get_node()
                      { return _M_impl._Node_allocator::allocate(1); }
                
                      void
                      _M_put_node(_Link_type __p)
                      { _M_impl._Node_allocator::deallocate(__p, 1); }
                
                #ifndef __GXX_EXPERIMENTAL_CXX0X__
                      _Link_type
                      _M_create_node(const value_type& __x)
                      {
                	_Link_type __tmp = _M_get_node();
                	__try
                	  { get_allocator().construct(&__tmp->_M_value_field, __x); }
                	__catch(...)
                	  {
                	    _M_put_node(__tmp);
                	    __throw_exception_again;
                	  }
                	return __tmp;
                      }
                
                      void
                      _M_destroy_node(_Link_type __p)
                      {
                	get_allocator().destroy(&__p->_M_value_field);
                	_M_put_node(__p);
                      }
                #else
                      template<typename... _Args>
                        _Link_type
                        _M_create_node(_Args&&... __args)
                	{
                	  _Link_type __tmp = _M_get_node();
                	  __try
                	    {
                	      _M_get_Node_allocator().construct(__tmp,
                					     std::forward<_Args>(__args)...);
                	    }
                	  __catch(...)
                	    {
                	      _M_put_node(__tmp);
                	      __throw_exception_again;
                	    }
                	  return __tmp;
                	}
                
                      void
                      _M_destroy_node(_Link_type __p)
                      {
                	_M_get_Node_allocator().destroy(__p);
                	_M_put_node(__p);
                      }
                #endif
                
                      _Link_type
                      _M_clone_node(_Const_Link_type __x)
                      {
                	_Link_type __tmp = _M_create_node(__x->_M_value_field);
                	__tmp->_M_color = __x->_M_color;
                	__tmp->_M_left = 0;
                	__tmp->_M_right = 0;
                	return __tmp;
                      }
                
                    protected:
                      template<typename _Key_compare, 
                	       bool _Is_pod_comparator = __is_pod(_Key_compare)>
                        struct _Rb_tree_impl : public _Node_allocator
       ##### ->         {
                	  _Key_compare		_M_key_compare;
                	  _Rb_tree_node_base 	_M_header;
                	  size_type 		_M_node_count; // Keeps track of size of tree.
                
       ##### -> 	  _Rb_tree_impl()
                	  : _Node_allocator(), _M_key_compare(), _M_header(),
                	    _M_node_count(0)
                	  { _M_initialize(); }
                
                	  _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)
                	  : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
                	    _M_node_count(0)
                	  { _M_initialize(); }
                
                	private:
                	  void
                	  _M_initialize()
                	  {
                	    this->_M_header._M_color = _S_red;
                	    this->_M_header._M_parent = 0;
                	    this->_M_header._M_left = &this->_M_header;
                	    this->_M_header._M_right = &this->_M_header;
                	  }	    
                	};
                
                      _Rb_tree_impl<_Compare> _M_impl;
                
                    protected:
                      _Base_ptr&
                      _M_root()
                      { return this->_M_impl._M_header._M_parent; }
                
                      _Const_Base_ptr
                      _M_root() const
                      { return this->_M_impl._M_header._M_parent; }
                
                      _Base_ptr&
                      _M_leftmost()
                      { return this->_M_impl._M_header._M_left; }
                
                      _Const_Base_ptr
                      _M_leftmost() const
                      { return this->_M_impl._M_header._M_left; }
                
                      _Base_ptr&
                      _M_rightmost()
                      { return this->_M_impl._M_header._M_right; }
                
                      _Const_Base_ptr
                      _M_rightmost() const
                      { return this->_M_impl._M_header._M_right; }
                
                      _Link_type
                      _M_begin()
                      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }
                
                      _Const_Link_type
                      _M_begin() const
                      {
                	return static_cast<_Const_Link_type>
                	  (this->_M_impl._M_header._M_parent);
                      }
                
                      _Link_type
                      _M_end()
                      { return static_cast<_Link_type>(&this->_M_impl._M_header); }
                
                      _Const_Link_type
                      _M_end() const
                      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }
                
                      static const_reference
                      _S_value(_Const_Link_type __x)
                      { return __x->_M_value_field; }
                
                      static const _Key&
                      _S_key(_Const_Link_type __x)
                      { return _KeyOfValue()(_S_value(__x)); }
                
                      static _Link_type
                      _S_left(_Base_ptr __x)
                      { return static_cast<_Link_type>(__x->_M_left); }
                
                      static _Const_Link_type
                      _S_left(_Const_Base_ptr __x)
                      { return static_cast<_Const_Link_type>(__x->_M_left); }
                
                      static _Link_type
                      _S_right(_Base_ptr __x)
                      { return static_cast<_Link_type>(__x->_M_right); }
                
                      static _Const_Link_type
                      _S_right(_Const_Base_ptr __x)
                      { return static_cast<_Const_Link_type>(__x->_M_right); }
                
                      static const_reference
                      _S_value(_Const_Base_ptr __x)
                      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }
                
                      static const _Key&
                      _S_key(_Const_Base_ptr __x)
                      { return _KeyOfValue()(_S_value(__x)); }
                
                      static _Base_ptr
                      _S_minimum(_Base_ptr __x)
                      { return _Rb_tree_node_base::_S_minimum(__x); }
                
                      static _Const_Base_ptr
                      _S_minimum(_Const_Base_ptr __x)
                      { return _Rb_tree_node_base::_S_minimum(__x); }
                
                      static _Base_ptr
                      _S_maximum(_Base_ptr __x)
                      { return _Rb_tree_node_base::_S_maximum(__x); }
                
                      static _Const_Base_ptr
                      _S_maximum(_Const_Base_ptr __x)
                      { return _Rb_tree_node_base::_S_maximum(__x); }
                
                    public:
                      typedef _Rb_tree_iterator<value_type>       iterator;
                      typedef _Rb_tree_const_iterator<value_type> const_iterator;
                
                      typedef std::reverse_iterator<iterator>       reverse_iterator;
                      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
                
                    private:
                      iterator
                      _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __y,
                		 const value_type& __v);
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 233. Insertion hints in associative containers.
                      iterator
                      _M_insert_lower(_Base_ptr __x, _Base_ptr __y, const value_type& __v);
                
                      iterator
                      _M_insert_equal_lower(const value_type& __x);
                
                      _Link_type
                      _M_copy(_Const_Link_type __x, _Link_type __p);
                
                      void
                      _M_erase(_Link_type __x);
                
                      iterator
                      _M_lower_bound(_Link_type __x, _Link_type __y,
                		     const _Key& __k);
                
                      const_iterator
                      _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
                		     const _Key& __k) const;
                
                      iterator
                      _M_upper_bound(_Link_type __x, _Link_type __y,
                		     const _Key& __k);
                
                      const_iterator
                      _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
                		     const _Key& __k) const;
                
                    public:
                      // allocation/deallocation
       ##### ->       _Rb_tree() { }
                
                      _Rb_tree(const _Compare& __comp,
                	       const allocator_type& __a = allocator_type())
                      : _M_impl(__comp, __a) { }
                
                      _Rb_tree(const _Rb_tree& __x)
                      : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
                      {
                	if (__x._M_root() != 0)
                	  {
                	    _M_root() = _M_copy(__x._M_begin(), _M_end());
                	    _M_leftmost() = _S_minimum(_M_root());
                	    _M_rightmost() = _S_maximum(_M_root());
                	    _M_impl._M_node_count = __x._M_impl._M_node_count;
                	  }
                      }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      _Rb_tree(_Rb_tree&& __x);
                #endif
                
       ##### ->       ~_Rb_tree()
                      { _M_erase(_M_begin()); }
                
                      _Rb_tree&
                      operator=(const _Rb_tree& __x);
                
                      // Accessors.
                      _Compare
                      key_comp() const
                      { return _M_impl._M_key_compare; }
                
                      iterator
                      begin()
                      { 
                	return iterator(static_cast<_Link_type>
                			(this->_M_impl._M_header._M_left));
                      }
                
                      const_iterator
                      begin() const
                      { 
                	return const_iterator(static_cast<_Const_Link_type>
                			      (this->_M_impl._M_header._M_left));
                      }
                
                      iterator
                      end()
                      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }
                
                      const_iterator
                      end() const
                      { 
                	return const_iterator(static_cast<_Const_Link_type>
                			      (&this->_M_impl._M_header));
                      }
                
                      reverse_iterator
                      rbegin()
                      { return reverse_iterator(end()); }
                
                      const_reverse_iterator
                      rbegin() const
                      { return const_reverse_iterator(end()); }
                
                      reverse_iterator
                      rend()
                      { return reverse_iterator(begin()); }
                
                      const_reverse_iterator
                      rend() const
                      { return const_reverse_iterator(begin()); }
                
                      bool
                      empty() const
                      { return _M_impl._M_node_count == 0; }
                
                      size_type
                      size() const
                      { return _M_impl._M_node_count; }
                
                      size_type
                      max_size() const
                      { return _M_get_Node_allocator().max_size(); }
                
                      void
                      swap(_Rb_tree& __t);      
                
                      // Insert/erase.
                      pair<iterator, bool>
                      _M_insert_unique(const value_type& __x);
                
                      iterator
                      _M_insert_equal(const value_type& __x);
                
                      iterator
                      _M_insert_unique_(const_iterator __position, const value_type& __x);
                
                      iterator
                      _M_insert_equal_(const_iterator __position, const value_type& __x);
                
                      template<typename _InputIterator>
                        void
                        _M_insert_unique(_InputIterator __first, _InputIterator __last);
                
                      template<typename _InputIterator>
                        void
                        _M_insert_equal(_InputIterator __first, _InputIterator __last);
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 130. Associative erase should return an iterator.
                      iterator
                      erase(iterator __position);
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 130. Associative erase should return an iterator.
                      const_iterator
                      erase(const_iterator __position);
                #else
                      void
                      erase(iterator __position);
                
                      void
                      erase(const_iterator __position);
                #endif
                      size_type
                      erase(const key_type& __x);
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 130. Associative erase should return an iterator.
                      iterator
                      erase(iterator __first, iterator __last);
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 130. Associative erase should return an iterator.
                      const_iterator
                      erase(const_iterator __first, const_iterator __last);
                #else
                      void
                      erase(iterator __first, iterator __last);
                
                      void
                      erase(const_iterator __first, const_iterator __last);
                #endif
                      void
                      erase(const key_type* __first, const key_type* __last);
                
                      void
                      clear()
                      {
                        _M_erase(_M_begin());
                        _M_leftmost() = _M_end();
                        _M_root() = 0;
                        _M_rightmost() = _M_end();
                        _M_impl._M_node_count = 0;
                      }
                
                      // Set operations.
                      iterator
                      find(const key_type& __k);
                
                      const_iterator
                      find(const key_type& __k) const;
                
                      size_type
                      count(const key_type& __k) const;
                
                      iterator
                      lower_bound(const key_type& __k)
                      { return _M_lower_bound(_M_begin(), _M_end(), __k); }
                
                      const_iterator
                      lower_bound(const key_type& __k) const
                      { return _M_lower_bound(_M_begin(), _M_end(), __k); }
                
                      iterator
                      upper_bound(const key_type& __k)
                      { return _M_upper_bound(_M_begin(), _M_end(), __k); }
                
                      const_iterator
                      upper_bound(const key_type& __k) const
                      { return _M_upper_bound(_M_begin(), _M_end(), __k); }
                
                      pair<iterator, iterator>
                      equal_range(const key_type& __k);
                
                      pair<const_iterator, const_iterator>
                      equal_range(const key_type& __k) const;
                
                      // Debugging.
                      bool
                      __rb_verify() const;
                    };
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    {
                      return __x.size() == __y.size()
                	     && std::equal(__x.begin(), __x.end(), __y.begin());
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	      const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    {
                      return std::lexicographical_compare(__x.begin(), __x.end(), 
                					  __y.begin(), __y.end());
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	      const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { return __y < __x; }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { return !(__y < __x); }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline bool
                    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { return !(__x < __y); }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline void
                    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                	 _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                    { __x.swap(__y); }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _Rb_tree(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&& __x)
                    : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
                    {
                      if (__x._M_root() != 0)
                	{
                	  _M_root() = __x._M_root();
                	  _M_leftmost() = __x._M_leftmost();
                	  _M_rightmost() = __x._M_rightmost();
                	  _M_root()->_M_parent = _M_end();
                
                	  __x._M_root() = 0;
                	  __x._M_leftmost() = __x._M_end();
                	  __x._M_rightmost() = __x._M_end();
                
                	  this->_M_impl._M_node_count = __x._M_impl._M_node_count;
                	  __x._M_impl._M_node_count = 0;
                	}
                    }
                #endif
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
                    {
                      if (this != &__x)
                	{
                	  // Note that _Key may be a constant type.
                	  clear();
                	  _M_impl._M_key_compare = __x._M_impl._M_key_compare;
                	  if (__x._M_root() != 0)
                	    {
                	      _M_root() = _M_copy(__x._M_begin(), _M_end());
                	      _M_leftmost() = _S_minimum(_M_root());
                	      _M_rightmost() = _S_maximum(_M_root());
                	      _M_impl._M_node_count = __x._M_impl._M_node_count;
                	    }
                	}
                      return *this;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)
                    {
                      bool __insert_left = (__x != 0 || __p == _M_end()
                			    || _M_impl._M_key_compare(_KeyOfValue()(__v), 
                						      _S_key(__p)));
                
                      _Link_type __z = _M_create_node(__v);
                
                      _Rb_tree_insert_and_rebalance(__insert_left, __z,
                				    const_cast<_Base_ptr>(__p),  
                				    this->_M_impl._M_header);
                      ++_M_impl._M_node_count;
                      return iterator(__z);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_insert_lower(_Base_ptr __x, _Base_ptr __p, const _Val& __v)
                    {
                      bool __insert_left = (__x != 0 || __p == _M_end()
                			    || !_M_impl._M_key_compare(_S_key(__p),
                						       _KeyOfValue()(__v)));
                
                      _Link_type __z = _M_create_node(__v);
                
                      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,  
                				    this->_M_impl._M_header);
                      ++_M_impl._M_node_count;
                      return iterator(__z);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_insert_equal_lower(const _Val& __v)
                    {
                      _Link_type __x = _M_begin();
                      _Link_type __y = _M_end();
                      while (__x != 0)
                	{
                	  __y = __x;
                	  __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
                	        _S_left(__x) : _S_right(__x);
                	}
                      return _M_insert_lower(__x, __y, __v);
                    }
                
                  template<typename _Key, typename _Val, typename _KoV,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
                    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
                    _M_copy(_Const_Link_type __x, _Link_type __p)
                    {
                      // Structural copy.  __x and __p must be non-null.
                      _Link_type __top = _M_clone_node(__x);
                      __top->_M_parent = __p;
                
                      __try
                	{
                	  if (__x->_M_right)
                	    __top->_M_right = _M_copy(_S_right(__x), __top);
                	  __p = __top;
                	  __x = _S_left(__x);
                
                	  while (__x != 0)
                	    {
                	      _Link_type __y = _M_clone_node(__x);
                	      __p->_M_left = __y;
                	      __y->_M_parent = __p;
                	      if (__x->_M_right)
                		__y->_M_right = _M_copy(_S_right(__x), __y);
                	      __p = __y;
                	      __x = _S_left(__x);
                	    }
                	}
                      __catch(...)
                	{
                	  _M_erase(__top);
                	  __throw_exception_again;
                	}
                      return __top;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_erase(_Link_type __x)
                    {
                      // Erase without rebalancing.
                      while (__x != 0)
                	{
                	  _M_erase(_S_right(__x));
                	  _Link_type __y = _S_left(__x);
                	  _M_destroy_node(__x);
                	  __x = __y;
                	}
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_lower_bound(_Link_type __x, _Link_type __y,
                		   const _Key& __k)
                    {
                      while (__x != 0)
                	if (!_M_impl._M_key_compare(_S_key(__x), __k))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                      return iterator(__y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::const_iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
                		   const _Key& __k) const
                    {
                      while (__x != 0)
                	if (!_M_impl._M_key_compare(_S_key(__x), __k))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                      return const_iterator(__y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_upper_bound(_Link_type __x, _Link_type __y,
                		   const _Key& __k)
                    {
                      while (__x != 0)
                	if (_M_impl._M_key_compare(__k, _S_key(__x)))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                      return iterator(__y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::const_iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
                		   const _Key& __k) const
                    {
                      while (__x != 0)
                	if (_M_impl._M_key_compare(__k, _S_key(__x)))
                	  __y = __x, __x = _S_left(__x);
                	else
                	  __x = _S_right(__x);
                      return const_iterator(__y);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::iterator,
                	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::iterator>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    equal_range(const _Key& __k)
                    {
                      _Link_type __x = _M_begin();
                      _Link_type __y = _M_end();
                      while (__x != 0)
                	{
                	  if (_M_impl._M_key_compare(_S_key(__x), __k))
                	    __x = _S_right(__x);
                	  else if (_M_impl._M_key_compare(__k, _S_key(__x)))
                	    __y = __x, __x = _S_left(__x);
                	  else
                	    {
                	      _Link_type __xu(__x), __yu(__y);
                	      __y = __x, __x = _S_left(__x);
                	      __xu = _S_right(__xu);
                	      return pair<iterator,
                		          iterator>(_M_lower_bound(__x, __y, __k),
                				    _M_upper_bound(__xu, __yu, __k));
                	    }
                	}
                      return pair<iterator, iterator>(iterator(__y),
                				      iterator(__y));
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::const_iterator,
                	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::const_iterator>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    equal_range(const _Key& __k) const
                    {
                      _Const_Link_type __x = _M_begin();
                      _Const_Link_type __y = _M_end();
                      while (__x != 0)
                	{
                	  if (_M_impl._M_key_compare(_S_key(__x), __k))
                	    __x = _S_right(__x);
                	  else if (_M_impl._M_key_compare(__k, _S_key(__x)))
                	    __y = __x, __x = _S_left(__x);
                	  else
                	    {
                	      _Const_Link_type __xu(__x), __yu(__y);
                	      __y = __x, __x = _S_left(__x);
                	      __xu = _S_right(__xu);
                	      return pair<const_iterator,
                		          const_iterator>(_M_lower_bound(__x, __y, __k),
                					  _M_upper_bound(__xu, __yu, __k));
                	    }
                	}
                      return pair<const_iterator, const_iterator>(const_iterator(__y),
                						  const_iterator(__y));
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)
                    {
                      if (_M_root() == 0)
                	{
                	  if (__t._M_root() != 0)
                	    {
                	      _M_root() = __t._M_root();
                	      _M_leftmost() = __t._M_leftmost();
                	      _M_rightmost() = __t._M_rightmost();
                	      _M_root()->_M_parent = _M_end();
                	      
                	      __t._M_root() = 0;
                	      __t._M_leftmost() = __t._M_end();
                	      __t._M_rightmost() = __t._M_end();
                	    }
                	}
                      else if (__t._M_root() == 0)
                	{
                	  __t._M_root() = _M_root();
                	  __t._M_leftmost() = _M_leftmost();
                	  __t._M_rightmost() = _M_rightmost();
                	  __t._M_root()->_M_parent = __t._M_end();
                	  
                	  _M_root() = 0;
                	  _M_leftmost() = _M_end();
                	  _M_rightmost() = _M_end();
                	}
                      else
                	{
                	  std::swap(_M_root(),__t._M_root());
                	  std::swap(_M_leftmost(),__t._M_leftmost());
                	  std::swap(_M_rightmost(),__t._M_rightmost());
                	  
                	  _M_root()->_M_parent = _M_end();
                	  __t._M_root()->_M_parent = __t._M_end();
                	}
                      // No need to swap header's color as it does not change.
                      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
                      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);
                      
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 431. Swapping containers with unequal allocators.
                      std::__alloc_swap<_Node_allocator>::
                	_S_do_it(_M_get_Node_allocator(), __t._M_get_Node_allocator());
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                			   _Compare, _Alloc>::iterator, bool>
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_insert_unique(const _Val& __v)
                    {
                      _Link_type __x = _M_begin();
                      _Link_type __y = _M_end();
                      bool __comp = true;
                      while (__x != 0)
                	{
                	  __y = __x;
                	  __comp = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x));
                	  __x = __comp ? _S_left(__x) : _S_right(__x);
                	}
                      iterator __j = iterator(__y);
                      if (__comp)
                	{
                	  if (__j == begin())
                	    return pair<iterator, bool>(_M_insert_(__x, __y, __v), true);
                	  else
                	    --__j;
                	}
                      if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))
                	return pair<iterator, bool>(_M_insert_(__x, __y, __v), true);
                      return pair<iterator, bool>(__j, false);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_insert_equal(const _Val& __v)
                    {
                      _Link_type __x = _M_begin();
                      _Link_type __y = _M_end();
                      while (__x != 0)
                	{
                	  __y = __x;
                	  __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?
                	        _S_left(__x) : _S_right(__x);
                	}
                      return _M_insert_(__x, __y, __v);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_insert_unique_(const_iterator __position, const _Val& __v)
                    {
                      // end()
                      if (__position._M_node == _M_end())
                	{
                	  if (size() > 0
                	      && _M_impl._M_key_compare(_S_key(_M_rightmost()), 
                					_KeyOfValue()(__v)))
                	    return _M_insert_(0, _M_rightmost(), __v);
                	  else
                	    return _M_insert_unique(__v).first;
                	}
                      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
                				      _S_key(__position._M_node)))
                	{
                	  // First, try before...
                	  const_iterator __before = __position;
                	  if (__position._M_node == _M_leftmost()) // begin()
                	    return _M_insert_(_M_leftmost(), _M_leftmost(), __v);
                	  else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), 
                					  _KeyOfValue()(__v)))
                	    {
                	      if (_S_right(__before._M_node) == 0)
                		return _M_insert_(0, __before._M_node, __v);
                	      else
                		return _M_insert_(__position._M_node,
                				  __position._M_node, __v);
                	    }
                	  else
                	    return _M_insert_unique(__v).first;
                	}
                      else if (_M_impl._M_key_compare(_S_key(__position._M_node),
                				      _KeyOfValue()(__v)))
                	{
                	  // ... then try after.
                	  const_iterator __after = __position;
                	  if (__position._M_node == _M_rightmost())
                	    return _M_insert_(0, _M_rightmost(), __v);
                	  else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
                					  _S_key((++__after)._M_node)))
                	    {
                	      if (_S_right(__position._M_node) == 0)
                		return _M_insert_(0, __position._M_node, __v);
                	      else
                		return _M_insert_(__after._M_node, __after._M_node, __v);
                	    }
                	  else
                	    return _M_insert_unique(__v).first;
                	}
                      else
                	// Equivalent keys.
                	return iterator(static_cast<_Link_type>
                			(const_cast<_Base_ptr>(__position._M_node)));
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    _M_insert_equal_(const_iterator __position, const _Val& __v)
                    {
                      // end()
                      if (__position._M_node == _M_end())
                	{
                	  if (size() > 0
                	      && !_M_impl._M_key_compare(_KeyOfValue()(__v),
                					 _S_key(_M_rightmost())))
                	    return _M_insert_(0, _M_rightmost(), __v);
                	  else
                	    return _M_insert_equal(__v);
                	}
                      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),
                				       _KeyOfValue()(__v)))
                	{
                	  // First, try before...
                	  const_iterator __before = __position;
                	  if (__position._M_node == _M_leftmost()) // begin()
                	    return _M_insert_(_M_leftmost(), _M_leftmost(), __v);
                	  else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),
                					   _S_key((--__before)._M_node)))
                	    {
                	      if (_S_right(__before._M_node) == 0)
                		return _M_insert_(0, __before._M_node, __v);
                	      else
                		return _M_insert_(__position._M_node,
                				  __position._M_node, __v);
                	    }
                	  else
                	    return _M_insert_equal(__v);
                	}
                      else
                	{
                	  // ... then try after.  
                	  const_iterator __after = __position;
                	  if (__position._M_node == _M_rightmost())
                	    return _M_insert_(0, _M_rightmost(), __v);
                	  else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),
                					   _KeyOfValue()(__v)))
                	    {
                	      if (_S_right(__position._M_node) == 0)
                		return _M_insert_(0, __position._M_node, __v);
                	      else
                		return _M_insert_(__after._M_node, __after._M_node, __v);
                	    }
                	  else
                	    return _M_insert_equal_lower(__v);
                	}
                    }
                
                  template<typename _Key, typename _Val, typename _KoV,
                           typename _Cmp, typename _Alloc>
                    template<class _II>
                      void
                      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
                      _M_insert_unique(_II __first, _II __last)
                      {
                	for (; __first != __last; ++__first)
                	  _M_insert_unique_(end(), *__first);
                      }
                
                  template<typename _Key, typename _Val, typename _KoV,
                           typename _Cmp, typename _Alloc>
                    template<class _II>
                      void
                      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
                      _M_insert_equal(_II __first, _II __last)
                      {
                	for (; __first != __last; ++__first)
                	  _M_insert_equal_(end(), *__first);
                      }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 130. Associative erase should return an iterator.
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(iterator __position)
                    {
                      iterator __result = __position;
                      ++__result;
                      _Link_type __y =
                	static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
                				(__position._M_node,
                				 this->_M_impl._M_header));
                      _M_destroy_node(__y);
                      --_M_impl._M_node_count;
                      return __result;
                    }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 130. Associative erase should return an iterator.
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(const_iterator __position)
                    {
                      const_iterator __result = __position;
                      ++__result;
                      _Link_type __y =
                	static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
                				(const_cast<_Base_ptr>(__position._M_node),
                				 this->_M_impl._M_header));
                      _M_destroy_node(__y);
                      --_M_impl._M_node_count;
                      return __result;
                    }
                #else
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(iterator __position)
                    {
                      _Link_type __y =
                	static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
                				(__position._M_node,
                				 this->_M_impl._M_header));
                      _M_destroy_node(__y);
                      --_M_impl._M_node_count;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    inline void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(const_iterator __position)
                    {
                      _Link_type __y =
                	static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
                				(const_cast<_Base_ptr>(__position._M_node),
                				 this->_M_impl._M_header));
                      _M_destroy_node(__y);
                      --_M_impl._M_node_count;
                    }
                #endif
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(const _Key& __x)
                    {
                      pair<iterator, iterator> __p = equal_range(__x);
                      const size_type __old_size = size();
                      erase(__p.first, __p.second);
                      return __old_size - size();
                    }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 130. Associative erase should return an iterator.
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(iterator __first, iterator __last)
                    {
                      if (__first == begin() && __last == end())
                        {
                	  clear();
                	  return end();
                        }
                      else
                        {
                	  while (__first != __last)
                	    erase(__first++);
                	  return __last;
                        }
                    }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 130. Associative erase should return an iterator.
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(const_iterator __first, const_iterator __last)
                    {
                      if (__first == begin() && __last == end())
                        {
                	  clear();
                	  return end();
                        }
                      else
                        {
                	  while (__first != __last)
                	    erase(__first++);
                	  return __last;
                        }
                    }
                #else
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(iterator __first, iterator __last)
                    {
                      if (__first == begin() && __last == end())
                	clear();
                      else
                	while (__first != __last)
                	  erase(__first++);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(const_iterator __first, const_iterator __last)
                    {
                      if (__first == begin() && __last == end())
                	clear();
                      else
                	while (__first != __last)
                	  erase(__first++);
                    }
                #endif
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    void
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    erase(const _Key* __first, const _Key* __last)
                    {
                      while (__first != __last)
                	erase(*__first++);
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    find(const _Key& __k)
                    {
                      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
                      return (__j == end()
                	      || _M_impl._M_key_compare(__k,
                					_S_key(__j._M_node))) ? end() : __j;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                		      _Compare, _Alloc>::const_iterator
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    find(const _Key& __k) const
                    {
                      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
                      return (__j == end()
                	      || _M_impl._M_key_compare(__k, 
                					_S_key(__j._M_node))) ? end() : __j;
                    }
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
                    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                    count(const _Key& __k) const
                    {
                      pair<const_iterator, const_iterator> __p = equal_range(__k);
                      const size_type __n = std::distance(__p.first, __p.second);
                      return __n;
                    }
                
                  _GLIBCXX_PURE unsigned int
                  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                                       const _Rb_tree_node_base* __root) throw ();
                
                  template<typename _Key, typename _Val, typename _KeyOfValue,
                           typename _Compare, typename _Alloc>
                    bool
                    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
                    {
                      if (_M_impl._M_node_count == 0 || begin() == end())
                	return _M_impl._M_node_count == 0 && begin() == end()
                	       && this->_M_impl._M_header._M_left == _M_end()
                	       && this->_M_impl._M_header._M_right == _M_end();
                
                      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
                      for (const_iterator __it = begin(); __it != end(); ++__it)
                	{
                	  _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
                	  _Const_Link_type __L = _S_left(__x);
                	  _Const_Link_type __R = _S_right(__x);
                
                	  if (__x->_M_color == _S_red)
                	    if ((__L && __L->_M_color == _S_red)
                		|| (__R && __R->_M_color == _S_red))
                	      return false;
                
                	  if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
                	    return false;
                	  if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
                	    return false;
                
                	  if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
                	    return false;
                	}
                
                      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
                	return false;
                      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
                	return false;
                      return true;
                    }
                
                _GLIBCXX_END_NAMESPACE
                
                #endif


Top 10 Lines:

     Line      Count

      170      13937
      134         36
      245         36

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

    14009   Total number of line executions
  1751.12   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafCore\GprofCdt/../src/jp/ggaf/core/actor/GgafLordActor.cpp:
                #include "stdafx.h"
                using namespace std;
                
                using namespace GgafCore;
                
          18 -> GgafLordActor::GgafLordActor(GgafScene* prm_pScene_Platform) : GgafActor(prm_pScene_Platform->getName()) {
                    _obj_class |= Obj_GgafLordActor;
                    _class_name = "GgafLordActor";
                
                    _pScene_Platform = prm_pScene_Platform;
                    setHitAble(false);
                }
                
                void GgafLordActor::remove() {
                    throwGgafCriticalException("[GgafLordActor::remove] Error! GgafLordActorremove()sI");
                }
                
                GgafGroupActor* GgafLordActor::addSubGroup(actorkind prm_kind, GgafMainActor* prm_pMainActor) {
                    if (prm_pMainActor->_pLordActor) {
                        //_TRACE_("yxzGgafLordActor::addSubGroup("<<getName()<<") "<<prm_pMainActor->_pLordActor->_pScene_Platform->getName()<<"V[BA"<<_pScene_Platform->getName()<<"V[");
                        prm_pMainActor->extract();
                    }
                    GgafGroupActor* pSubGroupActor = getSubGroupActor(prm_kind);
                    if (pSubGroupActor == NULL) {
                        pSubGroupActor = NEW GgafGroupActor(prm_kind);
                        addSubLast(pSubGroupActor);
                    } else {
                       //OK
                    }
                    pSubGroupActor->addSubLast(prm_pMainActor);
                    prm_pMainActor->setGroupActor(pSubGroupActor);
                    prm_pMainActor->setLordActor(this);
                    prm_pMainActor->setScenePlatform(_pScene_Platform);
                    return pSubGroupActor;
                }
                
                GgafGroupActor* GgafLordActor::addSubGroup(GgafMainActor* prm_pMainActor) {
                    return addSubGroup(prm_pMainActor->_pStatus->get(STAT_DEFAULT_ACTOR_KIND), prm_pMainActor);
                }
                
                
                
                GgafGroupActor* GgafLordActor::getSubGroupActor(actorkind prm_kind) {
                    if (_pSubFirst == NULL) {
                        return NULL;
                    } else {
                        GgafActor* pSubActor = _pSubFirst;
                        GgafGroupActor* pSubGroupActor_ret = NULL;
                        do {
                            if (pSubActor->_obj_class & Obj_GgafGroupActor) {
                                pSubGroupActor_ret = (GgafGroupActor*)pSubActor;
                                if (pSubGroupActor_ret->_kind == prm_kind) {
                                    return pSubGroupActor_ret;
                                }
                            }
                            if (pSubActor->_is_last_flg) {
                                return NULL;
                            } else {
                                pSubActor = pSubActor->_pNext;
                            }
                        } while (true);
                    }
                }
                
                /*
                 GgafGroupActor* GgafLordActor::getGroupActor(string prm_kind) {
                
                 }
                 */
                
                GgafGod* GgafLordActor::askGod() {
                    if (_pGod == NULL) {
                #ifdef MY_DEBUG
                        if (getPlatformScene() == NULL) {
                            throwGgafCriticalException("GgafLordActor::askGod _yBII("<<getName()<<")");
                        }
                #endif
                        _pGod = getPlatformScene()->askGod();
                    }
                    return _pGod;
                }
                
          36 -> GgafLordActor::~GgafLordActor() {
                }


Top 10 Lines:

     Line      Count

       83         36
        6         18

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       54   Total number of line executions
    18.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafCore/include/jp/ggaf/core/GgafNode.hpp:
                #ifndef GGAFNODE_H_
                #define GGAFNODE_H_
                namespace GgafCore {
                
                /**
                 * vfmoAXgc[\ev[gB.
                 *
                 * <B>yz</B><BR>
                 * <PRE STYLE="font-size:12px">
                 * @EEoEEE
                 * @@@
                 * (d)`abcd(`)
                 * @@@@@@
                 * @@@@@@@@@@@@@@@@@@@
                 * @@(g)efg(e)@@@@(k)hijk(h)
                 * @@@@@@@@@@@@@@@@@@@@@@@
                 * @@@@@@@@EEE@@@@@@@@@@@@@@@EEE
                 * </PRE>
                 * }\oB<BR>
                 * iu(d)`abcd(`)vvfiCX^Xjo|C^wB<BR>
                 * [u(d)vu(`)vAAXgAAB()<BR>
                 * }gCX^XubvAubv_evfAy`B<BR>
                 * <TABLE BORDER="1">
                 * <TR><TD>ubv</TD><TD>m[h</TD></TR>
                 * <TR><TD>u`v</TD><TD>(First)m[hB m[hAXgBu`v  _is_first_flg  true B(m[h false)</TD></TR>
                 * <TR><TD>udv</TD><TD>(Last)m[hB m[hAXgBudv  _is_last_flg  true B(m[h false)</TD></TR>
                 * <TR><TD>ucv</TD><TD>(Next)m[hB}EB_pNext|C^wvfB</TD></TR>
                 * <TR><TD>uav</TD><TD>O(Prev)m[hB_pPrev w|C^B</TD></TR>
                 * <TR><TD>uov</TD><TD>e(Parent)m[hBm[hAXgPKwm[hB_pParent |C^wvfBSm[hem[h|C^B</TD></TR>
                 * <TR><TD>uhCiCjCkv</TD><TD>ubvq(Sub)m[hB</TD></TR>
                 * <TR><TD>uhv</TD><TD> qm[huhvqm[hm[hAm[h _pSubFirst |C^wvfB</TD></TR>
                 * </TABLE>
                 * <BR>
                 *
                 * <B>ypz</B>
                 * <TABLE BORDER="1">
                 * <TR>
                 * <TD>um[hvuv</TD>
                 * <TD>m[hOm[hSwB</TD>
                 * </TR><TR>
                 * <TD>uzm[hvuzv</TD>
                 * <TD>m[hmc[Kw\Am[h<B></B>Sm[hwBm[hB</TD>
                 * </TR><TR>
                 * <TD>uc[v</TD>
                 * <TD>m[h_Am[h{zm[h\c[\wB</TD>
                 * </TR><TR>
                 * <TD>uc[m[hv</TD>
                 * <TD>m[h_Am[h{zm[h\c[\m[hSwB</TD>
                 * </TR><TR>
                 * <TD>uc[v</TD>
                 * <TD>m[hc[\SwB</TD>
                 * </TR><TR>
                 * <TD>um[hNXv</TD>
                 * <TD>GgafNodeNXAGgafNodeNXEpNXwB</TD>
                 * </TR><TR>
                 * <TD>uvuv</TD>
                 * <TD>m[hNXNXpW\B
                 * NXpW\uX[p[vuTuvuevuqv<B>uvuv</B>B<BR>
                 * uevuqv\em[hAqm[hc[\\Bij<BR>
                 * <BR>
                 * EHogehogeRRB<BR>
                 * @@ FHogehogeNXpARR<BR>
                 * ETuHogehogeRRB<BR>
                 * @@ Fc[\qm[hHogehogeNXIuWFNgRR<BR>
                 * </TD>
                 * </TR>
                 * </TABLE>
                 * @version 1.00
                 * @since 2008/09/08
                 * @author Masatoshi Tsuge
                 */
                
                template<class T>
                class GgafNode : public GgafObject {
                
                private:
                    /** [vp */
                    T* _pNodeTemp;
                
                public:
                    /** [r]m[h(50) */
                    char* _name;
                    /** [r]NX */
                    const char* _class_name;
                
                    /** [r]em[h */
                    T* _pParent;
                    /** [r]m[h */
                    T* _pNext;
                    /** [r]Om[h */
                    T* _pPrev;
                    /** [r]qm[hm[h */
                    T* _pSubFirst;
                    /** [r]m[htO (m[hm[h true)*/
                    bool _is_first_flg;
                    /** [r]m[htO (m[hm[h true)*/
                    bool _is_last_flg;
                
                public:
                    /**
                     * RXgN^
                     * @param prm_name m[hij[Nj
                     */
                    GgafNode(const char* prm_name);
                
                    /**
                     * fXgN^Bc[m[hB .
                     * m[hqm[hAqm[hgB<BR>
                     * m[hIm[hAm[hAEAOm[hIm[htOZbgAgB<BR>
                     * m[hm[hAm[hAEAm[hem[h  qm[hm[hA m[htOZbgAgB<BR>
                     * m[hm[hAm[hA\zB<BR>
                     * m[hAgwiPljAem[h  qm[hm[hiwjNULLXB<BR>
                     */
                    virtual ~GgafNode();
                
                    /**
                     * m[h .
                     * @return m[h
                     */
                    virtual char* getName(){
                        return _name;
                    }
                
                    /**
                     * NX .
                     * @return NX
                     */
                    virtual const char* getClassName() {
                        return _class_name;
                    }
                
                    /**
                     * m[h
                     */
                    //	virtual bool isNamed(const char* prm_name);
                
                    /**
                     * Pem[hB
                     * @param	prm_pParent	em[h
                     */
                    virtual void setParent(T* prm_pParent){
                        _pParent = prm_pParent;
                    }
                
                    /**
                     * c[m[hAXgAB .
                     * JAm[hiAj<BR>
                     * m[hqAB<BR>
                     * @return	T* m[h|C^
                     */
                    virtual T* extract();
                
                    /**
                     * m[hAIm[h .
                     * qm[hABm[hqm[hWB<BR>
                     *<PRE STYLE="font-size:18px">
                     * ----------------usOv
                     *       e
                     *       
                     * idj`abcdi`j
                     * -----------------------
                     *         }ubvA
                     * ----------------usv
                     *       e
                     *       
                     * idj`acdbi`j
                     * -----------------------
                     * </PRE>
                     */
                    virtual void moveLast();
                
                    /**
                     * m[hAm[h .
                     * qm[hABm[hqm[hWB<BR>
                     *<PRE STYLE="font-size:18px">
                     * ----------------usOv
                     * @@@e
                     * @@@
                     * (d)`abcd(`)
                     * -----------------------
                     *         }ubvA
                     * ----------------usv
                     * @@@e
                     * @@@
                     * (d)b`acd(b)
                     * -----------------------
                     * </PRE>
                     */
                    virtual void moveFirst();
                
                    /**
                     * m[hB
                     * @return	T*	m[h
                     */
                    virtual T* getNext() {
                        return _pNext;
                    }
                
                    /**
                     * Om[hB
                     * @return	T*	Om[h
                     */
                    virtual T* getPrev() {
                        return _pPrev;
                    }
                
                    /**
                     * Pem[hB
                     * @return	T*	em[h
                     */
                    virtual T* getParent();
                
                    /**
                     * em[hSB
                     * G[ <BR>
                     *  char* rsAdB<BR>
                     * t[sgpB<BR>
                     * @param	prm_parent_name	em[h
                     * @return	T*	em[h
                     */
                    virtual T* getParent(char* prm_parent_name);
                
                    /**
                     * m[hqm[h .
                     * }B<BR>
                     *<PRE STYLE="font-size:18px">
                     * ----------------usOv
                     *       b
                     *       
                     * (j)hij(h)
                     * -----------------------
                     *          }ubvAm[huwvaddSubLast 
                     *          
                     * ----------------usv
                     *       b
                     *       
                     * (w)hijw(h)
                     * -----------------------
                     * </PRE>
                     *
                     * @param   prm_pSub    CX^Xm[h|C^
                     */
                    virtual void addSubLast(T* prm_pSub);
                
                //    /**
                //     * qm[hm[hw .
                //     * G[<BR>
                //     *  char* rsAdB<BR>
                //     * t[sgpB<BR>
                //     * @param	prm_sub_actor_name	qm[h
                //     * @return	T*	qbgqm[hqm[h|C^
                //     */
                //    virtual T* getSub(char* prm_sub_actor_name);
                
                    /**
                     * qm[h .
                     * @param prm_pSub qm[h
                     * @return qm[hA NULL 
                     */
                    virtual T* getSub(T* prm_pSub);
                
                    /**
                     * qm[hO[vm[h .
                     * qm[hG[B
                     * @return	T*	qm[hm[h
                     */
                    virtual T* getSubFirst() {
                        return _pSubFirst;
                    }
                
                    /**
                     * qm[h`FbN .
                     *  char* rsAdB<BR>
                     * t[sgpB<BR>
                     * @param	prm_sub_actor_name	`FbNqm[h
                     * @return	bool true:^false:
                     */
                    virtual bool hasSub(char* prm_sub_actor_name);
                
                
                    /**
                     * qm[h .
                     * @return  T*  qm[h
                     */
                    virtual int getNumSub();
                
                
                    /**
                     * m[hm[h .
                     * @return	bool true:m[h^false:m[h
                     */
                    virtual bool isFirst() {
                        return _is_first_flg;
                    }
                
                    /**
                     * m[hm[h .
                     * @return	bool true:m[h^false:m[h
                     */
                    virtual bool isLast(){
                        return _is_last_flg;
                    }
                
                };
                
                //////////////////////////////////////////////////////////////////
                
                /**
                 * 
                 */
                template<class T>
        5004 -> GgafNode<T>::GgafNode(const char* prm_name) : GgafObject(),
                _pNodeTemp(NULL),
                _name(NULL),
                _class_name("GgafNode<T>"),
                _pParent(NULL),
                _pNext((T*)this),
                _pPrev((T*)this),
                _pSubFirst(NULL),
                _is_first_flg(false),
                _is_last_flg(false)
                {
                    _name = NEW char[51];
                    strcpy(_name, prm_name);
                    TRACE("template<class T> GgafNode<T>::GgafNode(" << _name << ")");
                }
                
                template<class T>
                T* GgafNode<T>::extract() {
                    if (_pParent) {
                        //AO
                        T* pMyNext = _pNext;
                        T* pMyPrev = _pPrev;
                        if (_is_first_flg && _is_last_flg) {
                            //A
                            _pParent->_pSubFirst = NULL;
                        } else {
                            //Ao
                            //m[hmqAwB
                            pMyPrev->_pNext = pMyNext;
                            pMyNext->_pPrev = pMyPrev;
                            if (_is_last_flg) {
                                pMyPrev->_is_last_flg = true;
                            }
                            if (_is_first_flg) {
                                pMyNext->_is_first_flg = true;
                                _pParent->_pSubFirst = pMyNext;
                            }
                        }
                        _pParent = NULL;
                        _pNext = (T*)this;
                        _pPrev = (T*)this;
                        _is_first_flg = true;
                        _is_last_flg = true;
                        return (T*)this;
                    } else {
                        //vf\bhA addSubLast() Ac[_KPB
                        //ec[_AlB
                        //TODO:AaddNext() vf\bhA
                        //     AYB
                        TRACE("[GgafNode<" << _class_name << ">::extract()] x " << getName() << "AB");
                        return (T*)this;
                    }
                }
                
                template<class T>
                void GgafNode<T>::moveLast() {
                    if (_is_last_flg) { //Im[h
                        return;
                    } else if (_is_first_flg) { //m[hAewm[h
                        _pParent->_pSubFirst = _pNext;
                        _pPrev->_is_last_flg = false;
                        _is_first_flg = false;
                        _is_last_flg = true;
                        _pNext->_is_first_flg = true;
                    } else { //m[h
                        //m[hmq
                        _pPrev->_pNext = _pNext;
                        _pNext->_pPrev = _pPrev;
                        //m[hm[h
                        _pParent->_pSubFirst->_pPrev->_is_last_flg = false;
                        _is_last_flg = true;
                        _pPrev = _pParent->_pSubFirst->_pPrev;
                        _pNext = _pParent->_pSubFirst;
                        _pParent->_pSubFirst->_pPrev->_pNext = (T*)this;
                        _pParent->_pSubFirst->_pPrev = (T*)this;
                    }
                }
                
                template<class T>
                void GgafNode<T>::moveFirst() {
                    if (_is_first_flg) { //m[h
                        return;
                    } else if (_is_last_flg) { //m[hAewm[hO
                        _pParent->_pSubFirst = (T*)this;
                        _pPrev->_is_last_flg = true;
                        _is_first_flg = true;
                        _is_last_flg = false;
                        _pNext->_is_first_flg = false;
                    } else { //m[h
                        //m[hmq
                        _pPrev->_pNext = _pNext;
                        _pNext->_pPrev = _pPrev;
                        //m[hm[h
                        _pParent->_pSubFirst->_is_first_flg = false;
                        _is_first_flg = true;
                        _pPrev = _pParent->_pSubFirst->_pPrev;
                        _pNext = _pParent->_pSubFirst;
                        _pParent->_pSubFirst->_pPrev->_pNext = (T*)this;
                        _pParent->_pSubFirst->_pPrev = (T*)this;
                        _pParent->_pSubFirst = (T*)this;
                    }
                }
                
                
                template<class T>
                T* GgafNode<T>::getParent() {
                #ifdef MY_DEBUG
                    if (_pParent == NULL) {
                        //_TRACE_("[GgafNode<" << _class_name << ">::getParent()] x em[hBNULLB");
                    }
                #endif
                    return (T*)_pParent;
                }
                
                template<class T>
                T* GgafNode<T>::getParent(char* prm_parent_name) {
                    _pNodeTemp = (T*)this;
                    while (true) {
                        _pNodeTemp = _pNodeTemp->_pParent;
                        if (_pNodeTemp == NULL) {
                #ifdef MY_DEBUG
                            //_TRACE_("[GgafNode<" << _class_name << ">::getParent("<<prm_parent_name<<")] x em[hkBNULLB");
                #endif
                            return NULL;
                        } else if (GgafUtil::strcmp_ascii(_pNodeTemp->_name, prm_parent_name) == 0) {
                            break;
                        }
                    }
                    return _pNodeTemp;
                }
                
                //template<class T>
                //T* GgafNode<T>::getSub(char* prm_sub_actor_name) {
                //#ifdef MY_DEBUG
                //    if (_pSubFirst == NULL) {
                //        throwGgafCriticalException("[GgafNode<" << _class_name << ">::getSub()] Error! _pSubFirstNULLB");
                //    }
                //#endif
                //    _pNodeTemp = _pSubFirst;
                //    do {
                //        if (GgafUtil::strcmp_ascii(_pNodeTemp->getName(), prm_sub_actor_name) == 0) {
                //            break;
                //        }
                //#ifdef MY_DEBUG
                //        if (_pNodeTemp->_is_last_flg) {
                //            throwGgafCriticalException("[GgafNode<" << _class_name << ">::getSub()] Error! qm[hB(prm_sub_actor_name=" << prm_sub_actor_name << ")");
                //        }
                //#endif
                //        _pNodeTemp = _pNodeTemp->_pNext;
                //    } while (true);
                //    return _pNodeTemp;
                //}
                
                template<class T>
                T* GgafNode<T>::getSub(T* prm_pSub) {
                    if (_pSubFirst == NULL) {
                        return NULL;
                    }
                    T* pNodeTemp = _pSubFirst;
                    do {
                        if (prm_pSub == pNodeTemp) {
                            break;
                        }
                        if (pNodeTemp->_is_last_flg) {
                            return NULL;
                        }
                        pNodeTemp = pNodeTemp->_pNext;
                    } while (true);
                    return pNodeTemp;
                }
                
                
                template<class T>
                bool GgafNode<T>::hasSub(char* prm_sub_actor_name) {
                    if (_pSubFirst == NULL) {
                        return false;
                    } else {
                        _pNodeTemp = _pSubFirst;
                        do {
                            if (GgafUtil::strcmp_ascii(_pNodeTemp->getName(), prm_sub_actor_name)) {
                                return true;
                            }
                            if (_pNodeTemp->_is_last_flg) {
                                return false;
                            } else {
                                _pNodeTemp = _pNodeTemp->_pNext;
                            }
                        } while (true);
                    }
                }
                
                template<class T>
                int GgafNode<T>::getNumSub() {
                    if (_pSubFirst == NULL) {
                        return 0;
                    }
                    int n = 1;
                    _pNodeTemp = _pSubFirst;
                    do {
                        if (_pNodeTemp->isLast()) {
                            break;
                        }
                        _pNodeTemp = _pNodeTemp->_pNext;
                        n++;
                    } while (true);
                    return n;
                }
                
                
                template<class T>
                void GgafNode<T>::addSubLast(T* prm_pSub) {
                #ifdef MY_DEBUG
                    if (prm_pSub->_pParent) {
                        throwGgafCriticalException("[GgafNode<" << _class_name << ">::addSubLast()] Error! m[h("
                                << prm_pSub->_pParent->_name << ")(this=" << _name << "/prm_pSub=" << prm_pSub->getName() << ")");
                    }
                #endif
                    prm_pSub->_pParent = (T*)this;
                    prm_pSub->_is_last_flg = true;
                    //prm_pSub->_pScene_Platform = _pScene_Platform;
                
                    if (_pSubFirst == NULL) {
                        prm_pSub->_is_first_flg = true;
                        _pSubFirst = prm_pSub;
                        _pSubFirst->_pNext = prm_pSub;
                        _pSubFirst->_pPrev = prm_pSub;
                    } else {
                        prm_pSub->_is_first_flg = false;
                        T* pSubLast = _pSubFirst->_pPrev;
                        pSubLast->_is_last_flg = false;
                        pSubLast->_pNext = prm_pSub;
                        prm_pSub->_pPrev = pSubLast;
                        prm_pSub->_pNext = _pSubFirst;
                        _pSubFirst->_pPrev = prm_pSub;
                    }
                
                }
                
                /*
                 template<class T>
                 bool GgafNode<T>::isNamed(const char* prm_name) {
                 char*::size_type iLen = prm_name.length();
                 if (prm_name.rfind('*') == iLen-1) {}
                
                
                 return _name;
                 }
                 */
                
                
                template<class T>
        5005 -> GgafNode<T>::~GgafNode() {
                    //q
                    if (_pSubFirst) {
                        //qdelete
                        if (_pSubFirst->_is_last_flg) {
                            //qm[hP
                            DELETE_IMPOSSIBLE_NULL(_pSubFirst);
                            _pSubFirst = NULL;
                        } else {
                            //qm[hQ
                            T* pSubLast = _pSubFirst->_pPrev;
                            T* pSubLastPrev = pSubLast->_pPrev;
                            while (true) {
                                DELETE_IMPOSSIBLE_NULL(pSubLast); //delete
                                if (pSubLastPrev->_is_first_flg) {
                                    DELETE_IMPOSSIBLE_NULL(_pSubFirst); //pSubLastPrev == _pSubFirst 
                                    _pSubFirst = NULL;
                                    break;
                                }
                                pSubLast = pSubLastPrev;
                                pSubLastPrev = pSubLastPrev->_pPrev;
                            }
                        }
                    }
                
                    //q
                    if (_pParent) {
                        //AO
                        T* pMyNext = _pNext;
                        T* pMyPrev = _pPrev;
                        if (_is_first_flg && _is_last_flg) {
                            //Am[hA
                            _pParent->_pSubFirst = NULL;
                            _pParent = NULL;
                            _pNext = (T*)this;
                            _pPrev = (T*)this;
                            _pSubFirst = NULL;
                        } else {
                            //Ao
                            //m[hmqAwB
                            pMyPrev->_pNext = pMyNext;
                            pMyNext->_pPrev = pMyPrev;
                            if (_is_last_flg) {
                                pMyPrev->_is_last_flg = true;
                            }
                            if (_is_first_flg) {
                                pMyNext->_is_first_flg = true;
                                _pParent->_pSubFirst = pMyNext;
                            }
                            _pParent = NULL;
                            _pNext = (T*)this;
                            _pPrev = (T*)this;
                            _pSubFirst = NULL;
                            _is_first_flg = true;
                            _is_last_flg = true;
                        }
                    }
                    DELETEARR_IMPOSSIBLE_NULL(_name);
                }
                
                }
                #endif /*GGAFNODE_H_*/


Top 10 Lines:

     Line      Count

      563       5005
      312       5004

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

    10009   Total number of line executions
  5004.50   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafCore/include/jp/ggaf/core/GgafElement.hpp:
                #ifndef GGAFELEMENT_H_
                #define GGAFELEMENT_H_
                namespace GgafCore {
                
                #define GGAF_NODE GgafCore::GgafNode<T>
                /** xt[ */
                #define GGAF_SAYONARA_DELAY (60*30)
                //GGAF_SAYONARA_DELAYSElementxt[A
                //AssB
                //Q\dgA
                //ASEA3DSEWKvA
                //AN^[qAN^[eAeAN^[WQA
                //AcB
                //{IAmSt[t[wB
                //GGAF_SAYONARA_DELAYZ
                //qeAceRsRBxB
                //ASE3DAG[ASEt[B
                //SEPAN^[PCA60*60B
                
                
                
                /**
                 * GgafNodeAlXJi^XNVXejB .
                 * t[A_(GgafGod)(GgafUniverse)A\bhodgB(GgafUniverse){templateB<BR>
                 * nextFrame() > behave() > settleBehavior() > judge() > [preDraw() > draw() > afterDraw()] > doFinally() <BR>
                 * LAnextFrame() doFinally() t[sB<BR>
                 * behave() settleBehavior() judge() tO(_is_active_flg) trueAA~tO(_was_paused_flg) false sB<BR>
                 * preDraw() draw() afterDraw() At[c]TsB<BR>
                 * t[c]TA_R\bhXLbvAMAX_SKIP_FRAME t[PsB<BR>
                 * L nextFrame() ` doFinally() I[o[ChBI[o[Chpe\bhR[obNz(processXxxxxx()) pB<BR>
                 * initialize() AL nextFrame() ` doFinally() oOCX^XPdgB<BR>
                 * AAtO(_can_live_flg)falseideletejAnextFrame() ` doFinally() SsB<BR>
                 * (NXGgafFactor)
                 * @version 1.00
                 * @since 2008/08/21
                 * @author Masatoshi Tsuge
                 */
                template<class T>
                class GgafElement : public GgafNode<T> {
                
                private:
                
                protected:
                
                public:
                    /** [r]_ */
                    GgafGod* _pGod;
                    /** [r]initializestO(true=s) */
                    bool _was_initialize_flg;
                
                    /** [r]m[ha(addSubjt[v(AA_was_paused_flg==true Z) */
                    frame _frame_of_life;
                    /** [r]m[ha(addSubjAUt[v(AA_was_paused_flg==true  _is_active_flg==false Z) */
                    frame _frame_of_behaving;
                    /** [r]m[hJn(onActive())Ut[v(AA_was_paused_flg==true  _is_active_flg==false Z) */
                    frame _frame_of_behaving_since_onActive;
                    /** [r]t[vZp */
                    frame _frameEnd;
                    /** [r]m[htO */
                    bool _is_active_flg;
                    /** [r]~tO */
                    bool _was_paused_flg;
                    /** [r]m[htO */
                    bool _can_live_flg;
                
                    /** [r]t[m[htOAt[t[Z _is_active_flg f */
                //    bool _is_active_flg_in_next_frame;
                    /** [r]t[~tOAt[t[Z _was_paused_flg f */
                    bool _was_paused_flg_in_next_frame;
                    /** [r]t[\tOAt[t[Z _can_live_flg f  */
                    //bool _can_live_flg_in_next_frame;
                
                    /** [r]ItO */
                    bool _will_end_after_flg;
                    /** [r]I\ _frame_of_life */
                    frame _frame_of_life_when_end;
                
                
                    /** [r]\tO */
                    bool _will_activate_after_flg;
                    /** [r]Jn\ _frame_of_life */
                    frame _frame_of_life_when_activation;
                
                    /** [r]\tO */
                    bool _will_inactivate_after_flg;
                    /** [r]I\ _frame_of_life */
                    frame _frame_of_life_when_inactivation;
                
                    /** [r]m[h(_is_active_flg  false  true)uPt[ZbgtO */
                    bool _on_change_to_active_flg;
                    /** [r]m[h~(_is_active_flg  true  false)uPt[ZbgtO */
                    bool _on_change_to_inactive_flg;
                
                    /** [r]m[h\tOAt[t[ZAm[hm[h */
                    bool _will_mv_first_in_next_frame_flg;
                    /** [r]m[h\tOAt[t[ZAm[hm[h */
                    bool _will_mv_last_in_next_frame_flg;
                
                    bool _is_already_reset;
                
                    GgafProgress* _pPrg;
                
                    /**
                     * RXgN^
                     * @param prm_name m[hij[Nj
                     */
                    GgafElement(const char* prm_name);
                
                    /**
                     * fXgN^Bc[m[hB .
                     */
                    virtual ~GgafElement();
                
                    /**
                     * |(c[) .
                     * _]TA_B<BR>
                     * zm[hm[htO(_can_live_flg) false m[h prm_num_cleaning  delete B<BR>
                     * @param prm_num_cleaning IuWFNg
                     */
                    virtual void clean(int prm_num_cleaning);
                
                    /**
                     * m[h(P) .
                     * CX^XAoOAKPoB<BR>
                     * Finitialize()oAreset() oB
                     */
                    virtual void initialize() = 0;
                
                    /**
                     * m[ht[ZAt[Jn(c[) .
                     * lXtOXVs <BR>
                     * _is_active_flg_in_next_frame _was_paused_flg_in_next_frame _can_live_flg_in_next_frame <BR>
                     * _is_active_flg _was_paused_flg _can_live_flg fiRs[jB<BR>
                     * A_will_mv_first_in_next_frame_flg, _will_mv_last_in_next_frame_flg  true A<BR>
                     * Am[hm[hAm[hsB<BR>
                     * Azm[hS nextFrame() AIsB<BR>
                     * _(GgafGod)s\bhAWbNgpB<BR>
                     * _(GgafGod)A(GgafUniverse) nextFrame() sA behave() sB<BR>
                     */
                    virtual void nextFrame();
                
                    /**
                     * m[ht[U(c[) .
                     * ASm[hWsB<BR>
                     * stOA<BR>
                     * tOAtOZbgA~tOAZbg<BR>
                     * i _is_active_flg && !_was_paused_flg && _can_live_flg j <BR>
                     * behave()  z processBehavior() R[Azm[hS behave() AIsB<BR>
                     * _(GgafGod)s\bhAWbN{\bhosB<BR>
                     * NXR[ processBehavior() I[o[ChIWWbNB <BR>
                     * _(GgafGod)A(GgafUniverse) behave() sA settleBehavior() sB<BR>
                     */
                    virtual void behave();
                
                    /**
                     * (P) .
                     * A behave() OPR[obNB<BR>
                     * KvI[o[ChB<BR>
                     * R[^C~O
                     * @
                     * nextFrame() AOt[tOuvAt[tOuvA
                     * nextFrame() At[tOuvAt[Z R[obN
                     * AAPt[
                     * Ot[(0t[)tOAluvB
                     * A nextFrame() AnextFrame() R[obNB
                     */
                    virtual void onActive() {
                    }
                
                    /**
                     * (P) .
                     * PR[obNB<BR>
                     * o^C~Ot[ZB behave() OsB<BR>
                     * KvI[o[ChB<BR>
                     */
                    virtual void onInactive() {
                    }
                
                    /**
                     * m[ht[U(c[) .
                     * ASm[hWsvB<BR>
                     * XVWAlXXe[^XXVsI<BR>
                     * stOAbehave()AtOAtOZbgA~tOAZbgB<BR>
                     *  ( _is_active_flg && !_was_paused_flg && _can_live_flg )B <BR>
                     * settleBehavior()Az processSettlementBehavior() R[Azm[hS settleBehavior() AIsB<BR>
                     * _(GgafGod)s\bhAWbN{\bhosB<BR>
                     * NXR[ processSettlementBehavior() I[o[ChWbNB <BR>
                     * _(GgafGod)A(GgafUniverse) settleBehavior() sA judge() sB<BR>
                     */
                    virtual void settleBehavior();
                
                
                    /**
                     * m[ht[(c[) .
                     * Am[hlXsvB<BR>
                     * Sm[hWXe[^XXVSOsB<BR>
                     * stOAbehave()A<BR>
                     * tOAtOZbgA~tOAZbg<BR>
                     *  ( _is_active_flg && !_was_paused_flg && _can_live_flg ) <BR>
                     * judge()  z processJudgement() R[Azm[hS judge() AIsB<BR>
                     * _(GgafGod)s\bhAWbN{\bhosB<BR>
                     * NXR[ processJudgement() I[o[ChWbN <BR>
                     * _(GgafGod)A(GgafUniverse) judge() sA<BR>
                     * _(GgafGod)At[c]T preDraw()  doFinally() sB<BR>
                     */
                    virtual void judge();
                
                    /**
                     * m[ht[`O(c[)it[XLbvoBj .
                     * tOAtOZbgA<BR>
                     * ( _is_active_flg && _can_live_flg) <BR>
                     * processPreDraw() R[Azm[hS preDraw() AIsB<BR>
                     * _(GgafGod)s\bhAWbNgpB<BR>
                     * NXR[ processPreDraw() I[o[ChWbN <BR>
                     * _(GgafGod)A(GgafUniverse) preDraw() sA draw() sB<BR>
                     */
                    virtual void preDraw();
                
                    /**
                     * m[ht[`{(c[)it[XLbvoBj .
                     * tOAtOZbgA<BR>
                     * ( _is_active_flg && _can_live_flg) <BR>
                     * processDraw() R[Azm[hS draw() AIsB<BR>
                     * _(GgafGod)s\bhAWbNgpB<BR>
                     * NXR[ processDraw() I[o[ChWbN <BR>
                     * _(GgafGod)A(GgafUniverse) draw() sA afterDraw() sB<BR>
                     */
                    virtual void draw();
                
                    /**
                     * m[ht[`(c[)it[XLbvoBj .
                     * tOAtOZbg<BR>
                     * ( _is_active_flg && _can_live_flg) <BR>
                     * processAfterDraw() R[Azm[hS afterDraw() AIsB<BR>
                     * _(GgafGod)s\bhAWbNgpB<BR>
                     * NXR[ processAfterDraw() I[o[ChWbN <BR>
                     * _(GgafGod)A(GgafUniverse) afterDraw() sA doFinally() sB<BR>
                     */
                    virtual void afterDraw();
                
                    /**
                     * m[ht[I(c[) .
                     * WAA`IAsnsvB<BR>
                     * tOAtOZbgA~tOAZbg<BR>
                     * i_is_active_flg && !_was_paused_flg && _can_live_flgj <BR>
                     * processFinally() R[Azm[hS doFinally() AIsB<BR>
                     * _(GgafGod)s\bhAWbNgpB<BR>
                     * NXR[ processFinally() I[o[ChWbN <BR>
                     * _(GgafGod)A(GgafUniverse) doFinally() sA<BR>
                     * t[c]T clean() sB<BR>
                     *  nextFrame() sB<BR>
                     */
                    virtual void doFinally();
                
                
                    /**
                     * t[UB([U[pAP) .
                     * behave() R[obNB<BR>
                     * oNXI[o[ChAm[hUB<BR>
                     * zUAWvZB<BR>
                     * {oR[obNASm[hAnextFrame() sB<BR>
                     */
                    virtual void processBehavior() = 0;
                
                    /**
                     * t[UB(t[[NpAP) .
                     */
                    virtual void processSettlementBehavior() {}
                
                    /**
                     * t[fB([U[pAP) .
                     * judge() R[obNB<BR>
                     * oI[o[ChAm[hfLqB<BR>
                     * {oR[obNASm[hAprocessBehavior() sB<BR>
                     * {o}AprocessBehavior() WSA
                     * {ogzB<BR>
                     */
                    virtual void processJudgement() = 0;
                
                    /**
                     * m[ht[`OB(t[[NpAP) .
                     * preDraw() R[obNB AA_(GgafGod)`XLbvAt[oB<BR>
                     * oI[o[ChAm[h`OB<BR>
                     * `OAwi`B<BR>
                     * {oR[obNASm[hAprocessJudgement() sB<BR>
                     * A{osAprocessDraw()AprocessAfterDraw() oB
                     */
                    virtual void processPreDraw() {};
                
                    /**
                     * m[ht[`{B(t[[Np^[U[pAP) .
                     * draw() R[obNB AApreDraw() l_(GgafGod)`XLbvAt[oB<BR>
                     * oI[o[ChAm[h`{B<BR>
                     * `{LN^Awi`zB
                     * {oR[obNASm[hAprocessPreDraw() sB<BR>
                     */
                    virtual void processDraw() = 0;
                
                    /**
                     * m[ht[\LqB(t[[NpAP) .
                     * afterDraw() R[obNB AApreDraw() l_(GgafGod)`XLbvAt[oB<BR>
                     * oI[o[ChAm[h\B<BR>
                     * \AOC[tF[hGtFNgAO\\B<BR>
                     * {oR[obNASm[hAprocessDraw() sB<BR>
                     */
                    virtual void processAfterDraw() {};
                
                    /**
                     * m[ht[I[B([U[pAP) .
                     * doFinally() R[obNB<BR>
                     * oNXI[o[ChAm[hI[B<BR>
                     * I[AtOsB<BR>
                     * zUAWvZBB<BR>
                     * {oR[obNASm[hAprocessJudgement() s `IB<BR>
                     */
                    virtual void processFinal() = 0;
                
                    /**
                     * m[hem[hSCxgbZ[Wm .
                     * CxgAonCatchEvent(UINT32, void) KvB
                     * @param prm_no CxgbZ[W
                     * @param prm_pSource  Cxgpp|C^
                     */
                    virtual void throwEventToLowerTree(UINT32 prm_no, void* prm_pSource);
                
                    /**
                     * zm[hSCxgbZ[Wm .
                     * CxgAonCatchEvent(UINT32, void) KvB
                     * @param prm_no CxgbZ[W
                     * @param prm_pSource  Cxgpp|C^
                     */
                    virtual void throwEventToUpperTree(UINT32 prm_no, void* prm_pSource);
                
                    /**
                     * zm[hCxgbZ[Wm .
                     * CxgAonCatchEvent(UINT32, void*) KvB
                     *  void* A{\bhsIuWFNg|C^nB
                     * @param prm_no CxgbZ[W
                     */
                    virtual void throwEventToLowerTree(UINT32 prm_no) {
                        throwEventToLowerTree(prm_no, this);
                    }
                
                    /**
                     * m[hem[hSCxgbZ[Wm .
                     * CxgAonCatchEvent(UINT32, void*) KvB
                     *  void* A{\bhsIuWFNg|C^nB
                     * @param prm_no CxgbZ[W
                     */
                    virtual void throwEventToUpperTree(UINT32 prm_no) {
                        throwEventToUpperTree(prm_no, this);
                    }
                
                    /**
                     * Cxg .
                     * @param prm_no CxgbZ[W
                     * @param prm_pSource  Cxgpp|C^
                     */
                    virtual void onCatchEvent(UINT32 prm_no, void* prm_pSource) = 0;
                
                
                    virtual bool isDisappear();
                    /**
                     * _y .
                     * @return  o_
                     */
                    virtual GgafGod* askGod() = 0;
                
                    //==================J\bhS==================>
                    /**
                     * (c[ER[obNL) .
                     * mAt[\tOB<BR>
                     * At[B<BR>
                     * gzm[hSAI activateTree() sB<BR>
                     * {\bhsAwt[xB<BR>
                     * m[h processBehavior()  g activateTree() oR[hA^XNVXedgA<BR>
                     * processBehavior()sAsB<BR>
                     * m[hsAprocessFinal() gpzB<BR>
                     * <B>[]</B>m[hAB<BR>
                     */
                    virtual void activateTree();
                
                    /**
                     * (PER[obNL) .
                     * m[ht[\tOB<BR>
                     * zm[heB
                     * {\bhsAwt[xB<BR>
                     */
                    virtual void activate();
                
                    /**
                     * (PER[obNL).
                     * Nt[ activate() s\B<BR>
                     * gzm[hSAI activateDelay(UINT32) sB<BR>
                     * activateDelay(1) Aactivate() B<BR>
                     * {\bhsAwt[xB<BR>
                     * @param prm_frame_offset xt[(1`)
                     */
                    virtual void activateDelay(frame prm_frame_offset = 1);
                
                
                    virtual void activateTreeDelay(frame prm_frame_offset = 1);
                
                
                    virtual void activateOnlyFor(frame prm_frame_offset = 1);
                    /**
                     * (PEER[obN) .
                     * m[hABO{\bhgpB<BR>
                     * onActive() R[obNsB<BR>
                     * AOgp_AgpKvB<BR>
                     * wt[xcm[hLBA<BR>
                     * wt[xAm[h\A<BR>
                     * m[hWbNAum[hEEEvAitOjA<BR>
                     * t[B<BR>
                     * m[heAc[\lgpB<BR>
                     */
                    virtual void activateImmediately();
                
                    /**
                     * (c[EER[obN)
                     * gzm[hSAI activateImmediately() sB<BR>
                     * activateImmediately() vQB<BR>
                     * gpAm[helgpB<BR>
                     */
                    virtual void activateTreeImmediately();
                    //===================
                    /**
                     * (c[ER[obNL) .
                     * mAt[\tOB<BR>
                     * At[B<BR>
                     * gzm[hSAI inactivate() sB<BR>
                     * {\bhsAwt[xB<BR>
                     */
                    virtual void inactivateTree();
                
                    /**
                     * (PER[obNL) .
                     * m[ht[\tOB<BR>
                     * zm[heB
                     * {\bhsAwt[xB<BR>
                     */
                    virtual void inactivate();
                
                    /**
                     * \(c[ER[obNL) .
                     * Nt[ inactivateTree() s\B<BR>
                     * gzm[hSAI inactivateDelay(UINT32) sB<BR>
                     * inactivateDelay(1) AinactivateTree() B<BR>
                     * {\bhsAwt[xB<BR>
                     * @param prm_frame_offset xt[(1`)
                     */
                    virtual void inactivateDelay(frame prm_frame_offset = 1);
                
                
                
                    virtual void inactivateTreeDelay(frame prm_frame_offset = 1);
                
                    /**
                     * (PEER[obN)  .
                     * m[hABOA{\bhgpB<BR>
                     * onInactive() R[obNsB<BR>
                     * AOgp_AgpKvB<BR>
                     * wt[xcm[hLBA<BR>
                     * wt[xAm[h\A<BR>
                     * m[hWbNAum[hEEEvAitOjA<BR>
                     * t[B<BR>
                     * m[heAc[\lgpB<BR>
                     */
                    virtual void inactivateImmediately();
                
                    /**
                     * (c[EER[obN)  .
                     * gzm[hSAI inactivateImmediately() sB<BR>
                     * inactivateImmediately() vQB<BR>
                     * gpAm[helgpB<BR>
                     */
                    virtual void inactivateTreeImmediately();
                
                    //===================
                    /**
                     * ~(c[) .
                     * mAt[~\tOB<BR>
                     * At[~B<BR>
                     * gzm[hSAI pause() sB<BR>
                     * {\bhsAwt[x~B<BR>
                     */
                    virtual void pauseTree();
                
                    /**
                     * ~(P) .
                     * m[ht[~\tOB<BR>
                     * zm[heB
                     * {\bhsAwt[x~B<BR>
                     */
                    virtual void pause();
                
                    /**
                     * ~(PE) .
                     * m[hA~i _was_paused_flg = true jBA{\bhgpB<BR>
                     * A_gpKvB<BR>
                     * VtOAwt[xcm[hLBA<BR>
                     * wt[xAm[h\A<BR>
                     * m[hWbNAum[h~EEEvAitOjA<BR>
                     * t[B<BR>
                     * m[heAc[\lgpB<BR>
                     */
                    virtual void pauseImmediately();
                
                    /**
                     * ~(c[E) .
                     * gzm[hSAI pauseImmediately() sB<BR>
                     * pauseImmediately() vQB<BR>
                     * gpAm[helgpB<BR>
                     */
                    virtual void pauseTreeImmediately();
                
                    //===================
                    /**
                     * ~(c[) .
                     * mAt[~\tOB<BR>
                     * At[~B<BR>
                     * gzm[hSAI unpause() sB<BR>
                     * {\bhsAwt[x~B<BR>
                     */
                    virtual void unpauseTree();
                    /**
                     * ~(P) .
                     * m[ht[~\tOB<BR>
                     * zm[heB
                     * {\bhsAwt[x~B<BR>
                     */
                    virtual void unpause();
                
                    /**
                     * ~(c[E) .
                     * gzm[hSAI unpauseImmediately() sB<BR>
                     * unpauseImmediately() vQB<BR>
                     * gpAm[helgpB<BR>
                     */
                    virtual void unpauseTreeImmediately();
                
                    /**
                     * ~(PE) .
                     * m[hA~i _was_paused_flg = false jBA{\bhgpB<BR>
                     * A_gpKvB<BR>
                     * VtOAwt[xcm[hLBA<BR>
                     * wt[xAm[h\A<BR>
                     * m[hWbNAum[h~EEEvAitOjA<BR>
                     * t[B<BR>
                     * m[heAc[\lgpB<BR>
                     */
                    virtual void unpauseImmediately();
                    //===================
                    /**
                     * Zbg .
                     * sB<BR>
                     * @ t[Ao`FbN<BR>
                     *   EoB   A<BR>
                     *   EQoB return<BR>
                     * A t[JE^Zbg<BR>
                     *   EgetBehaveingFrame()  0 B<BR>
                     *   EgetActivePartFrame()  0 B<BR>
                     * B  onReset() oB<BR>
                     * : initialize() oAP reset() IoB<BR>
                     * <pre>
                     *  initialize(), onReset(), onActive() g
                     * ZbgAH
                     * initialize() EEE APOR[BgpzB
                     * onReset()    EEE Ainitialize() APR[BAreset() R[B
                     * onActive()   EEE Ainitialize()  Pt[ behave() OR[B B
                     * m[h(AN^[V[)CtTCNgB
                     *
                     * EPTCNm[h(AN^[V[)
                     * AuIv}ABAgB
                     * initialize(), onReset(), onActive() OePsAZbgB
                     * AN^[AIZV[Y\zB
                     * Ainitialize() AIuWFNgB
                     *
                     * EonActive() gp
                     * m[hAu\()vAgB
                     * A\() ` \() Am[hPTCNvA
                     * initialize() EEE A
                     * onActive()   EEE Zbg
                     * gLqB inacivate()Aactivate() ZbgsB
                     * onActive() R[At[JE^uZbgvB
                     * GepIAN^[AY\zB
                     *
                     * EonReset() gp
                     * m[hAu\()vTOi\jA
                     * ATCNiZbgjTOm[h
                     * initialize() EEE A
                     * onReset()    EEE Zbg
                     * gLqB reset() ZbgsB
                     * onReset() R[obNAt[JE^uZbgvB
                     * V[AAN^[AY\zB
                     *
                     * EonActive() onReset() gpB
                     * \() ` \() Am[hPTCNvA
                     * initialize() EEE A
                     * onActive()   EEE `
                     * onReset()    EEE Zbg
                     * gLqB inacivate()Aactivate()  onActive() R[B
                     * reset() ZbgsB
                     * @Y\zB
                     * </pre>
                     */
                    virtual void reset();
                
                    /**
                     * Zbgic[j .
                     * c[SIuWFNg reset() sB
                     */
                    virtual void resetTree();
                
                    /**
                     * Zbg([U[p) .
                     * reset() AresetTree() soB
                     * ZbgANXI[o[ChB
                     */
                    virtual void onReset() {}
                
                
                    /**
                     * IB(c[) .
                     * m[ht[uIvBiItOj <BR>
                     * c[m[hSAAI(end())mB<br>
                     * em[hIAqm[hIB<BR>
                     * ItOxB~ end() doB<BR>
                     * P\t[IB<BR>
                     * uIvIAUtO(_is_active_flg)AtO(_can_live_flg) A
                     * t[AZbg\tOB<BR>
                     * _can_live_flg AZbgAS~(GgafGarbageBox) B<BR>
                     * _(GgafGod)]Tv clean() \bhA<BR>
                     * GgafGarbageBoxGgafDisusedActor zm[h delete B<BR>
                     * A{osP\t[AdeletesA<BR>
                     * GgafDisusedActor zBi^XNOjB<BR>
                     * t[~ delete B<BR>
                     * CX^XIiIoOjB<BR>
                     * @param prm_frame_offset IP\t[(1`)
                     */
                    virtual void end(frame prm_frame_offset = 1);
                
                    /**
                     * c[m[hIm[h(P) .
                     * t[(nextFrame())c[m[hZm[hO[vIVtgB<BR>
                     * <B>[]</B>JsB<BR>
                     */
                    virtual void moveLast() {
                        _will_mv_last_in_next_frame_flg = true;
                    }
                
                    virtual void moveLastImmediately() {
                        GGAF_NODE::moveLast();
                    }
                    /**
                     * c[m[hm[h(P) .
                     * t[(nextFrame())c[m[hZm[hO[vVtgB<BR>
                     * <B>[]</B>JsB<BR>
                     */
                    virtual void moveFirst() {
                        _will_mv_first_in_next_frame_flg = true;
                    }
                
                    virtual void moveFirstImmediately() {
                        GGAF_NODE::moveFirst();
                    }
                //    /**
                //     * c[(P)
                //     * extract() bp[AmF`FbNtBgpB
                //     * @return  T* Em[h|C^
                //     */
                //    virtual T* extract() override;
                
                
                    /**
                     *  .
                     * AonActive() I[o[ChALqB<BR>
                     * m[hmA{\bhB<BR>
                     * @return  bool true:^false:
                     */
                    virtual bool onChangeToActive();
                
                    /**
                     * ~ .
                     * AonInactive() I[o[ChALqB<BR>
                     * m[hmA{\bhB<BR>
                     * @return  bool true:^false:
                     */
                    virtual bool onChangeToInactive();
                
                    /**
                     * \
                     * @return  bool true:\^false:s
                     */
                    virtual bool canLive() {
                        return _can_live_flg;
                    }
                
                    /**
                     * 
                     * @return  bool true:^false:
                     */
                //    virtual bool isActive();
                
                    /**
                     * U\i~j
                     * @return  bool true:U\i~j^false:Us
                     */
                    virtual bool canBehave();
                
                    /**
                     */
                    virtual bool wasPause();
                
                    /**
                     * I
                     * @return
                     */
                    virtual bool wasDeclaredEnd();
                
                    /**
                     * UZt[ .
                     * ZbgAlB<BR>
                     * 1 Frame ` lB0 Frame{BAOI<BR>
                     * RXgN^AA initialize()  0 Frame B<BR>
                     * s onActive()AprocessBehavior()AprocessJudgement()  1 B<BR>
                     * ~AUt[ZB<BR>
                     * uUvAcanBehave() == true B<BR>
                     * @return Ut[v
                     */
                    virtual UINT32 getBehaveingFrame();
                
                    /**
                     * onActive()UZt[ .
                     * pIuWFNgAxg(delete)A<BR>
                     *  inactivate() A o activate() JzB<BR>
                     * getBehaveingFrame() ^C~OZAonActive()ZbgB<BR>
                     * @return onActive()Ut[
                     */
                    virtual UINT32 getActivePartFrame();
                
                
                    /**
                     * oUt[B
                     * O relativeFrame(int) sitrue/falsejt[ot[BB
                     * oAgetBehaveingFrame() == Ot[APxosijB
                     * FqArelativeFrame(int) oAot[B
                     * @param   prm_frameEnd    Ut[
                     * @return  bool    true:ot[B/false:B
                     */
                    virtual bool relativeFrame(frame prm_frameEnd);
                
                
                
                
                    /**
                     * zSIuWFNgws .
                     * zIuWFNgiAN^[V[j|C^A|C^ pFuncPnB<BR>
                     * |C^ pFunc QAexecDownFunction o prm1(P)|C^nB<BR>
                     * |C^ pFunc RAexecDownFunction o prm2(Q)|C^nB<BR>
                     * zIuWFNggpB<BR>
                     * AC++_gB<BR>
                     *
                     * gp<BR>
                     * XXXXScene zIuWFNgSAN^[(AGgafDx9GeometricActor)o _X A
                     * XXXXSceneo _velo lZB<BR>
                     * XXXXScene NXTvL<BR>
                     * <code><pre>
                     *
                     * class XXXXScene : public GgafScene {
                     *
                     *     int _velo;
                     *
                     *     static void addX(GgafObject* pThat, void* p1, void* p2) { //p1_velon
                     *         if (pThat->_obj_class >= Obj_GgafScene) {
                     *             return; //V[
                     *         }
                     *         GgafActor* pActor = (GgafActor*)pThat;
                     *         if (pActor->_obj_class & Obj_GgafDx9GeometricActor) {
                     *             //GgafDx9GeometricActor _X Z
                     *             ((GgafDx9GeometricActor*)pActor)->_X += (*((int*)p1));
                     *         }
                     *     }
                     *
                     *     void processBehavior() {
                     *         //zAN^[SaddXs
                     *         execDownFunction(XXXXScene::addX, _velo, NULL);
                     *     }
                     * }
                     *
                     * </pre></code>
                     * @param pFunc IuWFNgs
                     * @param prm1 nP
                     * @param prm2 nQ
                     */
                    virtual void execDownFunction(void (*pFunc)(GgafObject*, void*, void*), void* prm1, void* prm2);
                
                
                    virtual void useProgress(int prm_num = 10) {
                        if (_pPrg == NULL) {
                            _pPrg = NEW GgafProgress(&_frame_of_behaving, prm_num);
                        } else {
                            _TRACE_("["<<GGAF_NODE::getName()<<"]  useProgress Bprm_num="<<prm_num);
                        }
                    }
                
                };
                
                ///////////////////////////////////////////////////////////////// 
                
                template<class T>
        5004 -> GgafElement<T>::GgafElement(const char* prm_name) : GgafCore::GgafNode<T>(prm_name),
                _pGod(NULL),
                _was_initialize_flg(false),
                _frame_of_life(0),
                _frame_of_behaving(0),
                _frame_of_behaving_since_onActive(0),
                _frameEnd(0),
                _is_active_flg(true),
                _was_paused_flg(false),
                _can_live_flg(true),
                //_is_active_flg_in_next_frame(true),
                _was_paused_flg_in_next_frame(false),
                //_can_live_flg_in_next_frame(true),
                _will_end_after_flg(false),
                _frame_of_life_when_end(MAXDWORD),
                _will_activate_after_flg(false),
                _frame_of_life_when_activation(0),
                _will_inactivate_after_flg(false),
                _frame_of_life_when_inactivation(0),
                _on_change_to_active_flg(false),
                _on_change_to_inactive_flg(false),
                _will_mv_first_in_next_frame_flg(false),
                _will_mv_last_in_next_frame_flg(false),
                _is_already_reset(false),
                _pPrg(NULL)
                {
                
                }
                
                template<class T>
                void GgafElement<T>::nextFrame() {
                    TRACE("GgafElement::nextFrame BEGIN _frame_of_behaving=" << _frame_of_behaving << " name=" << GgafNode<T>::_name << " class="
                            << GgafNode<T>::_class_name);
                    _was_paused_flg  = _was_paused_flg_in_next_frame;
                    if (_was_paused_flg) {
                        return;
                    }
                    //moveLast\
                    if (_will_mv_last_in_next_frame_flg) {
                        _will_mv_last_in_next_frame_flg = false;
                        GGAF_NODE::moveLast();
                        return;
                        //returndvBnextFrame() QdsB
                        //m[hAAKx nextFrame() @KB
                    }
                
                
                    //I
                    if (_will_end_after_flg && _frame_of_life_when_end == _frame_of_life+1) { // _frame_of_life i+1
                       // _is_active_flg_in_next_frame = false;
                        _can_live_flg = false;
                    }
                
                    //_can_live_flg    = _can_live_flg_in_next_frame;
                
                    _on_change_to_active_flg = false;
                    _on_change_to_inactive_flg = false;
                    _frame_of_life++;
                    if (_can_live_flg) {
                
                        if(_was_initialize_flg == false) {
                            initialize();       //
                            _was_initialize_flg = true;
                            reset(); //Zbg
                        }
                
                
                        if (_is_active_flg && _frame_of_life == 1) {
                            //AonActive()B
                            _on_change_to_active_flg = true;
                            //t[ZonActive()
                            _frame_of_behaving++;
                            _frame_of_behaving_since_onActive = 1;
                            onActive(); //R[obN
                            _frame_of_life_when_activation = 0;
                            _will_activate_after_flg = false;
                        } else if (_will_activate_after_flg) {
                            if (_is_active_flg) { //
                                _frame_of_behaving++;
                                _frame_of_behaving_since_onActive++;
                            } else if(_frame_of_life == _frame_of_life_when_activation) {
                                //activate
                                if (_is_active_flg == false) {//_is_active_flg = false  true  
                                    _is_active_flg = true; //tOON!!!
                                    _on_change_to_active_flg = true;
                                    //t[ZonActive()
                                    _frame_of_behaving++;
                                    _frame_of_behaving_since_onActive = 1;
                                    onActive(); //R[obN
                                    _frame_of_life_when_activation = 0;
                                    _will_activate_after_flg = false;
                                } else {                      //
                                    _frame_of_behaving++;
                                    _frame_of_behaving_since_onActive++;
                                }
                            }
                        } else {
                            _frame_of_behaving++;
                            _frame_of_behaving_since_onActive++;
                        }
                
                        if (_will_inactivate_after_flg) {
                            if (_frame_of_life == _frame_of_life_when_inactivation) {
                                _frame_of_life_when_inactivation = 0;
                                _will_inactivate_after_flg = false;
                                //inactivate
                                if (_is_active_flg == true) { //_is_active_flg = true  false 
                                    _is_active_flg = false;//tOOFF!!!
                                    _on_change_to_inactive_flg = true;
                                    onInactive(); //R[obN
                
                                } else {
                                    //
                                }
                            } else {
                
                            }
                        }
                        _is_already_reset = false;
                    }
                
                    //znextFrame()s
                    if (GGAF_NODE::_pSubFirst) {
                        T* pElementTemp = GGAF_NODE::_pSubFirst;
                        while(true) {
                
                            if (pElementTemp->_is_last_flg) {
                                pElementTemp->nextFrame();
                                if (pElementTemp->_can_live_flg == false) {
                                    GgafFactory::_pGarbageBox->add(pElementTemp); //S~
                                }
                                break;
                            } else {
                                pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                pElementTemp->GGAF_NODE::_pPrev->nextFrame();
                                if (pElementTemp->GGAF_NODE::_pPrev->_can_live_flg == false) {
                                    GgafFactory::_pGarbageBox->add(pElementTemp->GGAF_NODE::_pPrev); //S~
                                }
                            }
                        }
                    }
                
                
                    if (_will_mv_first_in_next_frame_flg) {
                        _will_mv_first_in_next_frame_flg = false;
                        GGAF_NODE::moveFirst();
                        //moveFirstdvB
                        // nextFrame() QdsB
                    }
                
                    // if
                    if (_pPrg) {
                        _pPrg->update();
                    }
                    TRACE("GgafElement::nextFrame END _frame_of_behaving="<<_frame_of_behaving<<" name="<<GgafNode<T>::_name<<" class="<<GgafNode<T>::_class_name);
                }
                
                template<class T>
                void GgafElement<T>::behave() {
                //    if(_was_initialize_flg == false) {
                //        initialize();
                //        _was_initialize_flg = true;
                //    }
                
                    if (_is_active_flg && !_was_paused_flg && _can_live_flg) {
                        if (_was_initialize_flg) {
                            _frameEnd = 0;
                            processBehavior();    //[U[p
                        }
                        if (GGAF_NODE::_pSubFirst) {
                            T* pElementTemp = GGAF_NODE::_pSubFirst;
                            while(true) {
                                pElementTemp->behave();
                                if (pElementTemp->_is_last_flg) {
                                    break;
                                } else {
                                    pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                }
                            }
                        }
                    }
                }
                
                template<class T>
                void GgafElement<T>::settleBehavior() {
                //    if(_was_initialize_flg == false) {
                //        initialize();
                //        _was_initialize_flg = true;
                //    }
                
                    //if (_is_active_flg && !_was_paused_flg && _can_live_flg) {
                    if (_is_active_flg && _can_live_flg) {
                        if (_was_initialize_flg) {
                            _frameEnd = 0;
                            processSettlementBehavior(); //t[[Np
                        }
                        if (GGAF_NODE::_pSubFirst) {
                            T* pElementTemp = GGAF_NODE::_pSubFirst;
                            while(true) {
                                pElementTemp->settleBehavior();
                                if (pElementTemp->_is_last_flg) {
                                    break;
                                } else {
                                    pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                }
                            }
                        }
                    }
                }
                
                
                template<class T>
                void GgafElement<T>::judge() {
                //    if(_was_initialize_flg == false) {
                //        initialize();
                //        _was_initialize_flg = true;
                //    }
                
                    if (_is_active_flg && !_was_paused_flg && _can_live_flg) {
                        if (_was_initialize_flg) {
                            _frameEnd = 0;
                            processJudgement();    //[U[p
                        }
                        if (GGAF_NODE::_pSubFirst) {
                            T* pElementTemp = GGAF_NODE::_pSubFirst;
                            while(true) {
                                pElementTemp->judge();
                                if (pElementTemp->_is_last_flg) {
                                    break;
                                } else {
                                    pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                }
                            }
                        }
                    }
                }
                
                template<class T>
                void GgafElement<T>::preDraw() {
                //    if(_was_initialize_flg == false) {
                //        initialize();
                //        _was_initialize_flg = true;
                //    }
                
                    if (_is_active_flg && _can_live_flg) {
                        if (_was_initialize_flg) {
                            _frameEnd = 0;
                            processPreDraw();
                        }
                        if (GGAF_NODE::_pSubFirst) {
                            T* pElementTemp = GGAF_NODE::_pSubFirst;
                            while(true) {
                                pElementTemp->preDraw();
                                if (pElementTemp->_is_last_flg) {
                                    break;
                                } else {
                                    pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                }
                            }
                        }
                    }
                }
                
                template<class T>
                void GgafElement<T>::draw() {
                    if (_is_active_flg && _can_live_flg) {
                        if (_was_initialize_flg) {
                            _frameEnd = 0;
                            processDraw();
                        }
                        if (GGAF_NODE::_pSubFirst) {
                            T* pElementTemp = GGAF_NODE::_pSubFirst;
                            while(true) {
                                pElementTemp->draw();
                                if (pElementTemp->_is_last_flg) {
                                    break;
                                } else {
                                    pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                }
                            }
                        }
                    }
                }
                
                template<class T>
                void GgafElement<T>::afterDraw() {
                    if (_is_active_flg && _can_live_flg) {
                        if (_was_initialize_flg) {
                            _frameEnd = 0;
                            processAfterDraw();
                        }
                        if (GGAF_NODE::_pSubFirst) {
                            T* pElementTemp = GGAF_NODE::_pSubFirst;
                            while(true) {
                                pElementTemp->afterDraw();
                                if (pElementTemp->_is_last_flg) {
                                    break;
                                } else {
                                    pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                }
                            }
                        }
                    }
                }
                
                
                template<class T>
                void GgafElement<T>::doFinally() {
                //    if(_was_initialize_flg == false) {
                //        initialize();
                //        _was_initialize_flg = true;
                //    }
                
                    if (_is_active_flg && !_was_paused_flg && _can_live_flg) {
                        if (_was_initialize_flg) {
                            _frameEnd = 0;
                            processFinal();
                        }
                        if (GGAF_NODE::_pSubFirst) {
                            T* pElementTemp = GGAF_NODE::_pSubFirst;
                            while(true) {
                                pElementTemp->doFinally();
                                if (pElementTemp->_is_last_flg) {
                                    break;
                                } else {
                                    pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                }
                            }
                        }
                    }
                }
                
                template<class T>
                void GgafElement<T>::reset() {
                    if (_can_live_flg) {
                        if(_was_initialize_flg == false) {
                            initialize();       //
                            _was_initialize_flg = true;
                        }
                        if (_is_already_reset == false) {
                            _frame_of_behaving = 0;
                            _frame_of_behaving_since_onActive = 0;
                            onReset();
                            _is_already_reset = true;
                        }
                    }
                }
                
                
                template<class T>
                void GgafElement<T>::resetTree() {
                    if (_can_live_flg) {
                        if(_was_initialize_flg == false) {
                            initialize();       //
                            _was_initialize_flg = true;
                        }
                        if (_is_already_reset == false) {
                            _frame_of_behaving = 0;
                            _frame_of_behaving_since_onActive = 0;
                            onReset();
                            _is_already_reset = true;
                        }
                        if (GGAF_NODE::_pSubFirst) {
                            T* pElementTemp = GGAF_NODE::_pSubFirst;
                            while(true) {
                                pElementTemp->resetTree();
                                if (pElementTemp->_is_last_flg) {
                                    break;
                                } else {
                                    pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                }
                            }
                        }
                    }
                }
                
                template<class T>
                void GgafElement<T>::activate() {
                    if (_can_live_flg) {
                        activateDelay(1);
                    }
                }
                
                template<class T>
                void GgafElement<T>::activateTree() {
                    if (_can_live_flg) {
                        activateDelay(1);
                        if (GGAF_NODE::_pSubFirst) {
                            T* pElementTemp = GGAF_NODE::_pSubFirst;
                            while(true) {
                                pElementTemp->activateTree();
                                if (pElementTemp->_is_last_flg) {
                                    break;
                                } else {
                                    pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                }
                            }
                        }
                    }
                }
                
                template<class T>
                void GgafElement<T>::activateImmediately() {
                    if (_can_live_flg) {
                        _is_active_flg = true;
                    }
                }
                
                template<class T>
                void GgafElement<T>::activateTreeImmediately() {
                    if (_can_live_flg) {
                        activateImmediately();
                        if (GGAF_NODE::_pSubFirst) {
                            T* pElementTemp = GGAF_NODE::_pSubFirst;
                            while(true) {
                                pElementTemp->activateTreeImmediately();
                                if (pElementTemp->_is_last_flg) {
                                    break;
                                } else {
                                    pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                }
                            }
                        }
                    }
                }
                
                template<class T>
                void GgafElement<T>::activateDelay(frame prm_frame_offset) {
                    if (_can_live_flg) {
                        //inactivateDelay()s
                        //inactivateDelay()B
                        _will_inactivate_after_flg = false;
                
                        //activateDelay()sAwZt[ijB
                        //(inactivateDelay() Dl)
                        _will_activate_after_flg = true;
                        _frame_of_life_when_activation = _frame_of_life + prm_frame_offset;
                    }
                }
                template<class T>
                void GgafElement<T>::activateOnlyFor(frame prm_frame_offset) {
                    if (_can_live_flg) {
                        _will_activate_after_flg = true;
                        _frame_of_life_when_activation = _frame_of_life + 1;
                        _will_inactivate_after_flg = true;
                        _frame_of_life_when_inactivation = _frame_of_life + prm_frame_offset;
                    }
                }
                
                
                template<class T>
                void GgafElement<T>::activateTreeDelay(frame prm_frame_offset) {
                    if (_can_live_flg) {
                        activateDelay(prm_frame_offset);
                        if (GGAF_NODE::_pSubFirst) {
                            T* pElementTemp = GGAF_NODE::_pSubFirst;
                            while(true) {
                                pElementTemp->activateTree();
                                if (pElementTemp->_is_last_flg) {
                                    break;
                                } else {
                                    pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                }
                            }
                        }
                    }
                }
                
                template<class T>
                void GgafElement<T>::inactivate() {
                    if (_can_live_flg) {
                        inactivateDelay(1);
                    }
                }
                
                template<class T>
                void GgafElement<T>::inactivateTree() {
                    if (_can_live_flg) {
                        inactivateDelay(1);
                        if (GGAF_NODE::_pSubFirst) {
                            T* pElementTemp = GGAF_NODE::_pSubFirst;
                            while(true) {
                                pElementTemp->inactivateTree();
                                if (pElementTemp->_is_last_flg) {
                                    break;
                                } else {
                                    pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                }
                            }
                        }
                    }
                }
                
                template<class T>
                void GgafElement<T>::inactivateDelay(frame prm_frame_offset) {
                    if (_can_live_flg) {
                        //activateDelay()sB
                        _will_activate_after_flg = false;
                
                        if (_will_inactivate_after_flg) {
                            //inactivateDelay()sA inactivate L
                            if (_frame_of_life_when_inactivation < _frame_of_life + prm_frame_offset) {
                                //wZt[xB
                                return;
                            }
                        }
                        _will_inactivate_after_flg = true;
                        _frame_of_life_when_inactivation = _frame_of_life + prm_frame_offset;
                    }
                }
                
                template<class T>
                void GgafElement<T>::inactivateTreeDelay(frame prm_frame_offset) {
                    if (_can_live_flg) {
                        inactivateDelay(prm_frame_offset);
                        if (GGAF_NODE::_pSubFirst) {
                            T* pElementTemp = GGAF_NODE::_pSubFirst;
                            while(true) {
                                pElementTemp->inactivateTreeDelay(prm_frame_offset);
                                if (pElementTemp->_is_last_flg) {
                                    break;
                                } else {
                                    pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                }
                            }
                        }
                    }
                }
                
                template<class T>
                void GgafElement<T>::inactivateImmediately() {
                    if (_can_live_flg) {
                        _is_active_flg = false;
                    }
                }
                
                template<class T>
                void GgafElement<T>::inactivateTreeImmediately() {
                    if (_can_live_flg) {
                        inactivateImmediately();
                        if (GGAF_NODE::_pSubFirst) {
                            T* pElementTemp = GGAF_NODE::_pSubFirst;
                            while(true) {
                                pElementTemp->inactivateTreeImmediately();
                                if (pElementTemp->_is_last_flg) {
                                    break;
                                } else {
                                    pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                }
                            }
                        }
                    }
                }
                
                template<class T>
                void GgafElement<T>::pauseTree() {
                    if (_can_live_flg) {
                        _was_paused_flg_in_next_frame = true;
                        //_is_active_flg = false;
                        if (GGAF_NODE::_pSubFirst) {
                            T* pElementTemp = GGAF_NODE::_pSubFirst;
                            while(true) {
                                pElementTemp->pauseTree();
                                if (pElementTemp->_is_last_flg) {
                                    break;
                                } else {
                                    pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                }
                            }
                        }
                    }
                }
                
                template<class T>
                void GgafElement<T>::pause() {
                    if (_can_live_flg) {
                        _was_paused_flg_in_next_frame = true;
                    }
                }
                
                template<class T>
                void GgafElement<T>::pauseTreeImmediately() {
                    if (_can_live_flg) {
                        _was_paused_flg = true;
                        _was_paused_flg_in_next_frame = true;
                        if (GGAF_NODE::_pSubFirst) {
                            T* pElementTemp = GGAF_NODE::_pSubFirst;
                            while(true) {
                                pElementTemp->pauseTreeImmediately();
                                if (pElementTemp->_is_last_flg) {
                                    break;
                                } else {
                                    pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                }
                            }
                        }
                    }
                }
                
                template<class T>
                void GgafElement<T>::pauseImmediately() {
                    if (_can_live_flg) {
                        _was_paused_flg = true;
                        _was_paused_flg_in_next_frame = true;
                    }
                }
                
                template<class T>
                void GgafElement<T>::unpauseTree() {
                    if (_can_live_flg) {
                        _was_paused_flg_in_next_frame = false;
                        if (GGAF_NODE::_pSubFirst) {
                            T* pElementTemp = GGAF_NODE::_pSubFirst;
                            while(true) {
                                pElementTemp->unpauseTree();
                                if (pElementTemp->_is_last_flg) {
                                    break;
                                } else {
                                    pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                }
                            }
                        }
                    }
                }
                
                template<class T>
                void GgafElement<T>::unpause() {
                    if (_can_live_flg) {
                        _was_paused_flg_in_next_frame = false;
                    }
                }
                
                template<class T>
                void GgafElement<T>::unpauseTreeImmediately() {
                    if (_can_live_flg) {
                        _was_paused_flg = false;
                        _was_paused_flg_in_next_frame = false;
                        if (GGAF_NODE::_pSubFirst) {
                            T* pElementTemp = GGAF_NODE::_pSubFirst;
                            while(true) {
                                pElementTemp->unpauseTreeImmediately();
                                if (pElementTemp->_is_last_flg) {
                                    break;
                                } else {
                                    pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                }
                            }
                        }
                    }
                }
                
                template<class T>
                void GgafElement<T>::unpauseImmediately() {
                    if (_can_live_flg) {
                        _was_paused_flg = false;
                        _was_paused_flg_in_next_frame = false;
                    }
                }
                template<class T>
                void GgafElement<T>::end(frame prm_frame_offset) {
                    if (_will_end_after_flg) {
                        //end()sAend()L
                        if (_frame_of_life_when_end < _frame_of_life + prm_frame_offset + GGAF_SAYONARA_DELAY) {
                            //wxt[wB
                            return;
                        }
                    }
                    _will_end_after_flg = true;
                    _frame_of_life_when_end = _frame_of_life + prm_frame_offset + GGAF_SAYONARA_DELAY;
                    inactivateDelay(prm_frame_offset); //wt[inactivates
                    if (GGAF_NODE::_pSubFirst) {
                        T* pElementTemp = GGAF_NODE::_pSubFirst;
                        while(true) {
                            if (prm_frame_offset > 2) {
                                pElementTemp->end(prm_frame_offset-1); //o[end
                            } else {
                                pElementTemp->end(prm_frame_offset);
                            }
                            if (pElementTemp->_is_last_flg) {
                                break;
                            } else {
                                pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                            }
                        }
                    }
                }
                
                
                //template<class T>
                //bool GgafElement<T>::isActive() {
                //    if (_can_live_flg && _is_active_flg) {
                //        return true;
                //    } else {
                //        return false;
                //    }
                //}
                
                template<class T>
                bool GgafElement<T>::onChangeToActive() {
                    if (_can_live_flg && _on_change_to_active_flg) {
                        return true;
                    } else {
                        return false;
                    }
                }
                
                template<class T>
                bool GgafElement<T>::onChangeToInactive() {
                    if (_can_live_flg && _on_change_to_inactive_flg) {
                        return true;
                    } else {
                        return false;
                    }
                }
                
                template<class T>
                bool GgafElement<T>::canBehave() {
                    if (_can_live_flg && _is_active_flg && !_was_paused_flg) {
                        return true;
                    } else {
                        return false;
                    }
                }
                
                
                template<class T>
                bool GgafElement<T>::wasPause() {
                    if (_was_paused_flg) {
                        return true;
                    } else {
                        return false;
                    }
                }
                
                template<class T>
                bool GgafElement<T>::wasDeclaredEnd() {
                    if (_will_end_after_flg || _can_live_flg == false) {
                        return true;
                    } else {
                        return false;
                    }
                }
                
                template<class T>
                bool GgafElement<T>::relativeFrame(frame prm_frameEnd) {
                    if (_frame_of_behaving == _frameEnd) {
                        _frameEnd += prm_frameEnd;
                        return true;
                    } else {
                        return false;
                    }
                }
                
                
                //template<class T>
                //T* GgafElement<T>::extract() {
                //    if (_can_live_flg) {
                //        return GGAF_NODE::extract();
                //    } else {
                //        //_TRACE_("[GgafElement<"<<GGAF_NODE::_class_name<<">::extract()] x "<<GGAF_NODE::getName()<<"AB");
                //        return GGAF_NODE::extract();
                //    }
                //}
                
                template<class T>
                void GgafElement<T>::clean(int prm_num_cleaning) {
                    if (GGAF_NODE::_pSubFirst == NULL) {
                        return;
                    }
                
                    T* pElementTemp = GGAF_NODE::_pSubFirst->_pPrev;
                    T* pWk;
                
                    while(GgafFactory::_cnt_cleaned < prm_num_cleaning) {
                
                        if (pElementTemp->_pSubFirst) {
                            //qq
                            pElementTemp->clean(prm_num_cleaning);
                            if (GgafFactory::_cnt_cleaned >= prm_num_cleaning) {
                                break;
                            }
                        }
                
                        if (pElementTemp->_is_first_flg) { //
                            if (pElementTemp->_pSubFirst) {
                                //qq
                                pElementTemp->clean(prm_num_cleaning);
                                if (GgafFactory::_cnt_cleaned >= prm_num_cleaning) {
                                    break;
                                }
                            }
                            if (pElementTemp->_can_live_flg == false) {
                                DELETE_IMPOSSIBLE_NULL(pElementTemp);
                                GgafFactory::_cnt_cleaned++;
                            }
                            break;
                        } else {
                            pWk = pElementTemp;
                            if (pWk->_pSubFirst) {
                                //qq
                                pWk->clean(prm_num_cleaning);
                                if (GgafFactory::_cnt_cleaned >= prm_num_cleaning) {
                                    break;
                                }
                            }
                            pElementTemp = pElementTemp->_pPrev;
                            if (pWk->_can_live_flg == false) {
                                DELETE_IMPOSSIBLE_NULL(pWk);
                                GgafFactory::_cnt_cleaned++;
                            }
                        }
                    }
                }
                
                
                template<class T>
                UINT32 GgafElement<T>::getBehaveingFrame() {
                   return _frame_of_behaving;
                }
                
                template<class T>
                UINT32 GgafElement<T>::getActivePartFrame() {
                   return _frame_of_behaving_since_onActive;
                }
                template<class T>
                void GgafElement<T>::execDownFunction(void (*pFunc)(GgafObject*, void*, void*), void* prm1, void* prm2) {
                    if (_can_live_flg) {
                        if (_was_initialize_flg) {
                            pFunc(this, prm1, prm2);
                        }
                        if (GGAF_NODE::_pSubFirst) {
                            T* pElementTemp = GGAF_NODE::_pSubFirst;
                            while(true) {
                                pElementTemp->execDownFunction(pFunc, prm1, prm2);
                                if (pElementTemp->_is_last_flg) {
                                    break;
                                } else {
                                    pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                }
                            }
                        }
                    }
                }
                
                template<class T>
                void GgafElement<T>::throwEventToLowerTree(UINT32 prm_no, void* prm_pSource) {
                    if (_can_live_flg) {
                        if (_was_initialize_flg) {
                            _frameEnd = 0;
                            onCatchEvent(prm_no, prm_pSource);
                        }
                        if (GGAF_NODE::_pSubFirst) {
                            T* pElementTemp = GGAF_NODE::_pSubFirst;
                            while(true) {
                                pElementTemp->throwEventToLowerTree(prm_no, this);
                                if (pElementTemp->_is_last_flg) {
                                    break;
                                } else {
                                    pElementTemp = pElementTemp->GGAF_NODE::_pNext;
                                }
                            }
                        }
                    }
                }
                
                template<class T>
                void GgafElement<T>::throwEventToUpperTree(UINT32 prm_no, void* prm_pSource) {
                    if (_can_live_flg) {
                        if (_was_initialize_flg) {
                            _frameEnd = 0;
                            onCatchEvent(prm_no, prm_pSource);
                        }
                        if (GGAF_NODE::_pParent) {
                            T* pElementTemp = GGAF_NODE::_pParent;
                            pElementTemp->throwEventToUpperTree(prm_no, this);
                        } else {
                            //
                        }
                    }
                }
                
                
                template<class T>
                bool GgafElement<T>::isDisappear() {
                    if (_is_active_flg == false) {
                //    if (_will_inactivate_after_flg ||
                //        _is_active_flg_in_next_frame == false ||
                //        _will_end_after_flg ) {
                        return true;
                    } else {
                        return false;
                    }
                }
                
                
                template<class T>
        5005 -> GgafElement<T>::~GgafElement() {
                    DELETE_POSSIBLE_NULL(_pPrg);
                }
                
                }
                #endif /*GGAFELEMENT_H_*/


Top 10 Lines:

     Line      Count

     1708       5005
      812       5004

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

    10009   Total number of line executions
  5004.50   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafCore\GprofCdt/../src/jp/ggaf/core/scene/GgafScene.cpp:
                #include "stdafx.h"
                using namespace std;
                
                using namespace GgafCore;
                
                //GgafGroupActor* GgafScene::_apGroupActor01[MAX_GROUPACTOR_PER_SCENE];
                //GgafGroupActor* GgafScene::_apGroupActor02[MAX_GROUPACTOR_PER_SCENE];
                
          18 -> GgafScene::GgafScene(const char* prm_name) : GgafElement<GgafScene> (prm_name) {
                    TRACE("GgafScene::GgafScene() " << prm_name);
                    _class_name = "GgafScene";
                    _obj_class = Obj_GgafScene;
                
                    _pLordActor = NEW GgafLordActor(this);
                
                #ifdef MY_DEBUG
                    _TRACE_("new "<<_class_name<<"("<<this<<")["<<prm_name<<"]");
                #else
                
                #endif
                }
                
          18 -> GgafScene::~GgafScene() {
                
                #ifdef MY_DEBUG
                    _TRACE_("delete "<<_class_name<<"("<<this<<")["<<getName()<<"]");
                #else
                    OutputDebugStringA("*\n");
                #endif
                    DELETE_POSSIBLE_NULL(_pLordActor);
                }
                
                void GgafScene::nextFrame() {
                    TRACE("GgafScene::nextFrame() " << getName());
                    GgafElement<GgafScene>::nextFrame();
                    _pLordActor->nextFrame();
                
                }
                
                void GgafScene::behave() {
                    TRACE("GgafScene::behave() " << getName());
                    GgafElement<GgafScene>::behave();
                    _pLordActor->behave();
                }
                
                void GgafScene::settleBehavior() {
                    TRACE("GgafScene::settleBehavior() " << getName());
                    GgafElement<GgafScene>::settleBehavior();
                    _pLordActor->settleBehavior();
                }
                
                void GgafScene::judge() {
                    TRACE("GgafScene::judge() " << getName());
                    GgafElement<GgafScene>::judge();
                    _pLordActor->judge();
                }
                
                void GgafScene::preDraw() {
                    TRACE("GgafScene::preDraw() " << getName());
                    GgafElement<GgafScene>::preDraw();
                    _pLordActor->preDraw();
                }
                
                void GgafScene::draw() {
                    TRACE("GgafScene::draw() " << getName());
                    GgafElement<GgafScene>::draw();
                    _pLordActor->draw();
                }
                
                void GgafScene::afterDraw() {
                    TRACE("GgafScene::afterDraw() " << getName());
                    GgafElement<GgafScene>::afterDraw();
                    _pLordActor->afterDraw();
                }
                
                void GgafScene::throwEventToLowerTree(UINT32 prm_no, void* prm_pSource) {
                    GgafElement<GgafScene>::throwEventToLowerTree(prm_no, prm_pSource);
                    _pLordActor->throwEventToLowerTree(prm_no, prm_pSource);
                }
                
                void GgafScene::doFinally() {
                    GgafElement<GgafScene>::doFinally();
                    _pLordActor->doFinally();
                }
                
                void GgafScene::activateTree() {
                    GgafElement<GgafScene>::activateTree();
                    _pLordActor->activateTree();
                }
                
                void GgafScene::activateDelay(frame prm_frame_offset) {
                    GgafElement<GgafScene>::activateDelay(prm_frame_offset);
                    _pLordActor->activateDelay(prm_frame_offset);
                }
                
                void GgafScene::activate() {
                    GgafElement<GgafScene>::activate();
                    _pLordActor->activate();
                }
                
                void GgafScene::activateTreeImmediately() {
                    GgafElement<GgafScene>::activateTreeImmediately();
                    _pLordActor->activateTreeImmediately();
                }
                
                void GgafScene::activateImmediately() {
                    GgafElement<GgafScene>::activateImmediately();
                    _pLordActor->activateImmediately();
                }
                
                void GgafScene::inactivateTree() {
                    GgafElement<GgafScene>::inactivateTree();
                    _pLordActor->inactivateTree();
                }
                
                void GgafScene::inactivateDelay(frame prm_frame_offset) {
                    GgafElement<GgafScene>::inactivateDelay(prm_frame_offset);
                    _pLordActor->inactivateDelay(prm_frame_offset);
                }
                
                void GgafScene::inactivate() {
                    GgafElement<GgafScene>::inactivate();
                    _pLordActor->inactivate();
                }
                
                void GgafScene::inactivateTreeImmediately() {
                    GgafElement<GgafScene>::inactivateTreeImmediately();
                    _pLordActor->inactivateTreeImmediately();
                }
                
                void GgafScene::inactivateImmediately() {
                    GgafElement<GgafScene>::inactivateImmediately();
                    _pLordActor->inactivateImmediately();
                }
                
                void GgafScene::pauseTree() {
                    GgafElement<GgafScene>::pauseTree();
                    _pLordActor->pauseTree();
                }
                
                void GgafScene::pause() {
                    GgafElement<GgafScene>::pause();
                    _pLordActor->pause();
                }
                
                void GgafScene::pauseTreeImmediately() {
                    GgafElement<GgafScene>::pauseTreeImmediately();
                    _pLordActor->pauseTreeImmediately();
                }
                
                void GgafScene::pauseImmediately() {
                    GgafElement<GgafScene>::pauseImmediately();
                    _pLordActor->pauseImmediately();
                }
                
                void GgafScene::unpauseTree() {
                    GgafElement<GgafScene>::unpauseTree();
                    _pLordActor->unpauseTree();
                }
                
                void GgafScene::unpause() {
                    GgafElement<GgafScene>::unpause();
                    _pLordActor->unpause();
                }
                
                void GgafScene::unpauseTreeImmediately() {
                    GgafElement<GgafScene>::unpauseTreeImmediately();
                    _pLordActor->unpauseTreeImmediately();
                }
                
                void GgafScene::unpauseImmediately() {
                    GgafElement<GgafScene>::unpauseImmediately();
                    _pLordActor->unpauseImmediately();
                }
                
                void GgafScene::execDownFunction(void (*pFunc)(GgafObject*, void*, void*), void* prm1, void* prm2) {
                    GgafElement<GgafScene>::execDownFunction(pFunc, prm1, prm2);
                    _pLordActor->execDownFunction(pFunc, prm1, prm2);
                }
                
                void GgafScene::reset() {
                    GgafElement<GgafScene>::reset();
                    _pLordActor->reset();
                
                }
                void GgafScene::resetTree() {
                    GgafElement<GgafScene>::resetTree();
                    _pLordActor->resetTree();
                }
                
                
                void GgafScene::end(frame prm_frame_offset) {
                    _pLordActor->end(prm_frame_offset);
                    GgafElement<GgafScene>::end(prm_frame_offset);
                    //dvBtS~s|C^B
                }
                
                void GgafScene::clean(int prm_num_cleaning) {
                    if (_pLordActor) {
                        _pLordActor->clean(prm_num_cleaning);
                        if (_pLordActor->_pSubFirst == NULL) {
                            DELETE_IMPOSSIBLE_NULL(_pLordActor);
                        }
                    } else {
                        GgafElement<GgafScene>::clean(prm_num_cleaning);
                    }
                }
                
                GgafLordActor* GgafScene::getLordActor() {
                    return _pLordActor;
                }
                
                //void GgafScene::executeHitChkGroupActors(actorkind prm_actorkindmask01, actorkind prm_actorkindmask02) {
                //    static GgafScene* pScene;
                //    pScene = this;
                //    static GgafGroupActor* pGroupActor;
                //    pGroupActor = NULL;
                //    static int index01, index02;
                //    index01 = 0;
                //    index02 = 0;
                //
                //    do {
                //        pGroupActor = (GgafGroupActor*)(pScene->getLordActor()->_pSubFirst);
                //        if (pGroupActor) {
                //            do {
                //                if ((pGroupActor->_kind & prm_actorkindmask01) > 0) {
                //                    _apGroupActor01[index01] = pGroupActor;
                //                    index01++;
                //                }
                //                if ((pGroupActor->_kind & prm_actorkindmask02) > 0) {
                //                    _apGroupActor02[index02] = pGroupActor;
                //                    index02++;
                //                }
                //                if (pGroupActor->_is_last_flg) {
                //                    break;
                //                } else {
                //                    pGroupActor = (GgafGroupActor*)(pGroupActor->_pNext);
                //                    continue;
                //                }
                //            } while (true);
                //        }
                //
                //        if (pScene->_pSubFirst) {
                //            pScene = pScene->_pSubFirst;
                //            continue;
                //        }
                //
                //        loop: if (pScene->_is_last_flg) {
                //            if (pScene == this) {
                //                break;
                //            } else {
                //                if (pScene->_pParent == this) {
                //                    break;
                //                } else {
                //                    pScene = pScene->_pParent;
                //                    goto loop;
                //                }
                //            }
                //        } else {
                //            pScene = pScene->_pNext;
                //            continue;
                //        }
                //    } while (true);
                //
                //    for (int i = 0; i < index01; i++) {
                //        for (int j = 0; j < index02; j++) {
                //            if (_apGroupActor01[i] == _apGroupActor02[j]) {
                //                _apGroupActor01[i]->executeHitChk_RoundRobin2(_apGroupActor02[j]);
                //            } else {
                //                _apGroupActor01[i]->executeHitChk_RoundRobin(_apGroupActor02[j]);
                //            }
                //        }
                //    }
                //}
                
                
                
                GgafGod* GgafScene::askGod() {
                    if (_pGod == NULL) {
                        _pGod = getParent()->askGod();
                    }
                    return _pGod;
                }
                
                void GgafScene::dump() {
                    _TRACE_(""<<_class_name<<"("<<this<<")["<<getName()<<"]@"<<_frame_of_behaving_since_onActive<<
                                                                                "/"<<
                                                                                _frame_of_behaving<<
                                                                                "/"<<
                                                                                _frame_of_life<<
                                                                                ","<<
                                                                                _was_initialize_flg<<
                                                                                ","<<
                                                                                _can_live_flg<<
                                                                                _is_active_flg<<
                                                                                ","<<
                                                                                _will_activate_after_flg<<
                                                                                "("<<_frame_of_life_when_activation<<")"<<
                                                                                _on_change_to_active_flg<<
                                                                                ","<<
                                                                                _will_inactivate_after_flg<<
                                                                                "("<<_frame_of_life_when_inactivation<<")"<<
                                                                                _on_change_to_inactive_flg<<
                                                                                ","<<
                                                                                _will_end_after_flg<<
                                                                                "("<<_frame_of_life_when_end<<")"<<
                                                                                ","<<
                                                                                 _was_paused_flg<<
                                                                                _was_paused_flg_in_next_frame<<
                                                                                _will_mv_first_in_next_frame_flg<<
                                                                                _will_mv_last_in_next_frame_flg
                                                                                );
                    if (_pLordActor) {
                        _pLordActor->dump();
                        GgafScene* pScene_tmp = _pSubFirst;
                        if (_pSubFirst) {
                            while (true) {
                                pScene_tmp->dump("\t");
                                if (pScene_tmp->_pNext) {
                                    pScene_tmp = pScene_tmp->_pNext;
                                } else {
                                    _TRACE_("yxz"<<_class_name<<"("<<this<<")["<<getName()<<"]nextNULL");
                                    break;
                                }
                                if (pScene_tmp->_is_first_flg) {
                                    break;
                                }
                            }
                        }
                    }
                }
                
                void GgafScene::dump(string prm_parent) {
                    _TRACE_(prm_parent+""<<_class_name<<"("<<this<<")["<<getName()<<"]@"<<_frame_of_behaving_since_onActive<<
                                                                                           "/"<<
                                                                                           _frame_of_behaving<<
                                                                                           "/"<<
                                                                                           _frame_of_life<<
                                                                                           ","<<
                                                                                           _was_initialize_flg<<
                                                                                           ","<<
                                                                                           _can_live_flg<<
                                                                                           _is_active_flg<<
                                                                                           ","<<
                                                                                           _will_activate_after_flg<<
                                                                                           "("<<_frame_of_life_when_activation<<")"<<
                                                                                           _on_change_to_active_flg<<
                                                                                           ","<<
                                                                                           _will_inactivate_after_flg<<
                                                                                           "("<<_frame_of_life_when_inactivation<<")"<<
                                                                                           _on_change_to_inactive_flg<<
                                                                                           ","<<
                                                                                           _will_end_after_flg<<
                                                                                           "("<<_frame_of_life_when_end<<")"<<
                                                                                           ","<<
                                                                                           _was_paused_flg<<
                                                                                           _was_paused_flg_in_next_frame<<
                                                                                           _will_mv_first_in_next_frame_flg<<
                                                                                           _will_mv_last_in_next_frame_flg
                                                                                           );
                    if (_pLordActor) {
                        _pLordActor->dump(prm_parent + "\t\t\t\t\t\t\t\t");
                        GgafScene* pScene_tmp = _pSubFirst;
                        if (_pSubFirst) {
                            while (true) {
                                pScene_tmp->dump(prm_parent + "\t");
                                if (pScene_tmp->_pNext) {
                                    pScene_tmp = pScene_tmp->_pNext;
                                } else {
                                    _TRACE_("yxz"<<_class_name<<"("<<this<<")["<<getName()<<"]nextNULL");
                                    break;
                                }
                                if (pScene_tmp->_is_first_flg) {
                                    break;
                                }
                            }
                        }
                    }
                }
                


Top 10 Lines:

     Line      Count

        9         18
       23         18

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       36   Total number of line executions
    12.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafCore\GprofCdt/../src/DetectMemoryLeaks.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                
                std::_MAP_<std::size_t, std::string> detectMemoryLeaksMemoryMap;
                bool detectMemoryLeaksFlag = false;
                
                void *
                operator new(std::size_t size, const char* strFileName, int nLineNum)
                throw (std::bad_alloc)
       ##### -> {
                    void * address = malloc(size);
                    if (address == 0) {
                        TRACE(strFileName << ":" << nLineNum << " bad_alloc....");
                        throw std::bad_alloc();
                    } else {
                        if (detectMemoryLeaksFlag) {
                            //TRACE("new: " << strFileName << ":" << nLineNum << " size=" << size << " address=" << address );
                            std::ostringstream oss;
                            oss << strFileName << ":" << nLineNum << " size=" << size << " address=" << address;
                            //detectMemoryLeaksMemoryMap.insert(detectMemoryLeaksMemoryMap.end(), std::pair<std::size_t, std::string>((std::size_t)address, oss.str()));
                            detectMemoryLeaksMemoryMap.insert(std::pair<std::size_t, std::string>((std::size_t)address, oss.str()));
                        }
                        return address;
                    }
                }
                
                void *
                operator new[](std::size_t size, const char* strFileName, int nLineNum)
                throw (std::bad_alloc)
       ##### -> {
                    void * address = malloc(size);
                    if (address == 0) {
                        TRACE(strFileName << ":" << nLineNum << " bad_alloc....");
                        throw std::bad_alloc();
                    } else {
                        if (detectMemoryLeaksFlag) {
                            //TRACE("new[]: " << strFileName << ":" << nLineNum << " size=" << size << " address=" << address);
                            std::ostringstream oss;
                            oss << strFileName << ":" << nLineNum << " size=" << size << " address=" << address;
                            detectMemoryLeaksMemoryMap.insert(std::pair<std::size_t, std::string>((std::size_t)address, oss.str()));
                        }
                        return address;
                    }
                }
                
       41578 -> void operator delete(void * address) {
                    if (address == 0) // Depends on environment.
                    return;
                
                    if (detectMemoryLeaksFlag) {
                        //_TRACE_("delete: " << " address=" << address );
                        std::_MAP_<std::size_t, std::string>::iterator it = detectMemoryLeaksMemoryMap.begin();
                        std::_MAP_<std::size_t, std::string>::iterator itEnd = detectMemoryLeaksMemoryMap.end();
                        std::size_t checkAddress = (std::size_t)address;
                        for (; it != itEnd; it++) {
                            if (it->first == checkAddress) {
                                detectMemoryLeaksMemoryMap.erase(it);
                                break;
                            }
                        }
                    }
                    free(address);
                }
                
       43498 -> void operator delete[](void * address) {
                    if (address == 0) // Depends on environment.
                    return;
                
                    if (detectMemoryLeaksFlag) {
                        //_TRACE_("delete[]: " << " address=" << address);
                        std::_MAP_<std::size_t, std::string>::iterator it = detectMemoryLeaksMemoryMap.begin();
                        std::_MAP_<std::size_t, std::string>::iterator itEnd = detectMemoryLeaksMemoryMap.end();
                        std::size_t checkAddress = (std::size_t)address;
                        for (; it != itEnd; it++) {
                            if (it->first == checkAddress) {
                                detectMemoryLeaksMemoryMap.erase(it);
                                break;
                            }
                        }
                    }
                    free(address);
                }
                
       ##### -> void detectMemoryLeaksStart(std::ostream& ros) {
                    //ros << "[detect memory leaks] start" << std::endl;
                    _TRACE_("[detect memory leaks] start");
                    detectMemoryLeaksFlag = true;
                }
                
       ##### -> void detectMemoryLeaksEnd(std::ostream& ros) {
                    //ros << "[detect memory leaks] end" << std::endl;
                    _TRACE_("[detect memory leaks] end");
                    if (detectMemoryLeaksMemoryMap.size() > 0) {
                        //ros << "memory leaks ..." << std::endl;
                        _TRACE_("memory leaks ...");
                        std::_MAP_<std::size_t, std::string>::iterator it = detectMemoryLeaksMemoryMap.begin();
                        std::_MAP_<std::size_t, std::string>::iterator itEnd = detectMemoryLeaksMemoryMap.end();
                        for (; it != itEnd; it++) {
                            //ros << "  " << it->second << std::endl;
                            _TRACE_("  " << it->second);
                        }
                    } else {
                        //ros << "memory leak is nothing." << std::endl;
                        _TRACE_("memory leak is nothing.");
                    }
                    detectMemoryLeaksFlag = false;
                    detectMemoryLeaksMemoryMap.clear();
                }


Top 10 Lines:

     Line      Count

       66      43498
       47      41578

Execution Summary:

        8   Executable lines in this file
        6   Lines executed
    75.00   Percent of the file executed

    85076   Total number of line executions
 10634.50   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafCore\GprofCdt/../src/jp/ggaf/core/GgafObject.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                
                int GgafObject::_iSeq = 0;
                
       30650 -> GgafObject::GgafObject() {
                    _obj_class = 0;
                    _id = (_iSeq++);
                }
                
                string GgafObject::toString() {
                    //TODO:java
                    return "";
                }
                
       30655 -> GgafObject::~GgafObject() {
                }


Top 10 Lines:

     Line      Count

       17      30655
        7      30650

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

    61305   Total number of line executions
 20435.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/sound/IkdLib/PCMDecoder.cpp:
                #include "stdafx.h"
                
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace Dix;
                
                // PCMDecoder.cpp
                //
                
                //#include <memory.h>
                //#include "PCMDecoder.h"
                //#include <string.h>
                
                //namespace Dix {
                    //! RXgN^
           8 ->     PCMDecoder::PCMDecoder() :
                        isLoop_			( false ),
                        isReady_		( false ),
                        channelNum_		( 0 ),
                        samplingRate_	( 0 ),
                        bitRate_		( 0 )
                    {
                    }
                
                    //! fXgN^
           8 ->     PCMDecoder::~PCMDecoder() {
                    }
                
                    //! NA
                    void PCMDecoder::clear() {
                        isLoop_ = false;
                        isReady_ = false;
                        channelNum_ = 0;
                        samplingRate_ = 0;
                        bitRate_ = 0;
                    }
                
                    //! [vtO
                    bool PCMDecoder::isLoop() {
                        return isLoop_;
                    }
                
                    //! H
                    bool PCMDecoder::isReady() {
                        return isReady_;
                    }
                
                    //! [v
                    void PCMDecoder::setLoop( bool isLoop ) {
                        isLoop_ = isLoop;
                    }
                
                    //! WAVEFORMATEX\
                    bool PCMDecoder::getWaveFormatEx( WAVEFORMATEX& waveFormatEx ) {
                        if ( isReady() == false ) {
                            return false;
                        }
                
                        waveFormatEx.wFormatTag			= WAVE_FORMAT_PCM;
                        waveFormatEx.nChannels			= channelNum_;
                        waveFormatEx.nSamplesPerSec		= samplingRate_;
                        waveFormatEx.wBitsPerSample		= bitRate_;
                        waveFormatEx.nBlockAlign		= channelNum_ * bitRate_ / 8;
                        waveFormatEx.nAvgBytesPerSec	= waveFormatEx.nSamplesPerSec * waveFormatEx.nBlockAlign;
                        waveFormatEx.cbSize				= 0;
                
                        return true;
                    }
                
                    //! tO
                    void PCMDecoder::setReady( bool isReady ) {
                        isReady_ = isReady;
                    }
                
                    //! `l
                    void PCMDecoder::setChannelNum( unsigned int channelNum ) {
                        channelNum_ = channelNum;
                    }
                
                    //! TvO[g
                    void PCMDecoder::setSamplingRate( unsigned int samplingRate ) {
                        samplingRate_ = samplingRate;
                    }
                
                    //! rbg[g
                    void PCMDecoder::setBitRate( unsigned int bitRate ) {
                        bitRate_ = bitRate;
                    }
                
                //}


Top 10 Lines:

     Line      Count

       17          8
       27          8

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       16   Total number of line executions
     5.33   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/manager/GgafDx9TextureConnection.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                
          27 -> GgafDx9TextureConnection::GgafDx9TextureConnection(char* prm_idstr, GgafDx9Texture* prm_pResource)
                    :GgafResourceConnection<GgafDx9Texture>(prm_idstr, prm_pResource) {
                    TRACE3("GgafDx9TextureConnectionFRXgN^ prm_idstr="<<prm_idstr);
                }
                
                void GgafDx9TextureConnection::processReleaseResource(GgafDx9Texture* prm_pResource) {
                    DELETE_IMPOSSIBLE_NULL(prm_pResource);
                }
                


Top 10 Lines:

     Line      Count

        7         27

Execution Summary:

        2   Executable lines in this file
        1   Lines executed
    50.00   Percent of the file executed

       27   Total number of line executions
    13.50   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9Core/include/jp/ggaf/dx9core/manager/GgafDx9TextureConnection.h:
                #ifndef GGAFDX9TEXTURECONNECTION_H_
                #define GGAFDX9TEXTURECONNECTION_H_
                namespace GgafDx9Core {
                
                /**
                 * eNX`RlNV.
                 * @version 1.00
                 * @since 2009/01/27
                 * @author Masatoshi Tsuge
                 */
                class GgafDx9TextureConnection : public GgafCore::GgafResourceConnection<GgafDx9Texture> {
                
                public:
                
                    /**
                     * RXgN^<BR>
                     * @param prm_idstr eNX`
                     * @param prm_pResource eNX`
                     */
                    GgafDx9TextureConnection(char* prm_idstr, GgafDx9Texture* prm_pResource);
                
                    void processReleaseResource(GgafDx9Texture* prm_pResource);
                
          54 ->     virtual ~GgafDx9TextureConnection() {
                    }
                };
                
                }
                #endif /*GGAFDX9TEXTURECONNECTION_H_*/


Top 10 Lines:

     Line      Count

       24         54

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       54   Total number of line executions
    54.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/texture/GgafDx9Texture.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                
          27 -> GgafDx9Texture::GgafDx9Texture(char* prm_texture_name) : GgafObject() {
                    TRACE("GgafDx9Texture::GgafDx9Texture(" << prm_texture_name << ")");
                    _pIDirect3DBaseTexture9 = NULL;
                    _pD3DXIMAGE_INFO = NEW D3DXIMAGE_INFO();
                
                    _texture_name = NEW char[51];
                    strcpy(_texture_name, prm_texture_name);
                    string texture_name = string(_texture_name);
                    string texture_file_name = GGAFDX9_PROPERTY(DIR_TEXTURE) + texture_name;
                
                    //eNX`t@C "cubemap"  "CubeMap" A}bveNX`
                    if (texture_name.find("cubemap") == string::npos && texture_name.find("CubeMap") == string::npos) {
                        //QDeNX`
                        LPDIRECT3DTEXTURE9 pIDirect3DTexture9;
                        HRESULT hr = D3DXCreateTextureFromFileEx(
                                         GgafDx9God::_pID3DDevice9, // [in] LPDIRECT3DDEVICE9 pDevice,
                                         texture_file_name.c_str(), // [in] LPCTSTR pSrcFile,
                                         D3DX_DEFAULT,              // [in] UINT Width,
                                         D3DX_DEFAULT,              // [in] UINT Height,
                                         0,                         // [in] UINT MipLevels,  //D3DX_DEFAULT,
                                         0,                         // [in] DWORD Usage,
                                         D3DFMT_UNKNOWN,            // [in] D3DFORMAT Format,
                                         D3DPOOL_DEFAULT,           // [in] D3DPOOL Pool, //D3DPOOL_DEFAULT
                                         D3DX_DEFAULT,              // [in] DWORD Filter, D3DX_FILTER_POINT{PiC. D3DX_FILTER_LINEAR
                                         D3DX_DEFAULT,              // [in] DWORD MipFilter,
                                         0,                         // [in] D3DCOLOR ColorKey,
                                         _pD3DXIMAGE_INFO,          // [out] D3DXIMAGE_INFO *pSrcInfo,
                                         NULL,                      // [in] PALETTEENTRY *pPalette,
                                         &pIDirect3DTexture9        // [out] LPDIRECT3DTEXTURE9* ppTexture
                                    );
                        if (hr != D3D_OK) {
                            _TRACE_("[GgafDx9TextureManager::createResource] D3DXCreateTextureFromFileExsB="<<prm_texture_name);
                            //speNX`"GgafDx9IlligalTexture.png"
                            string texture_file_name2 = GGAFDX9_PROPERTY(DIR_TEXTURE) + "GgafDx9IlligalTexture.png";
                            HRESULT hr2 = D3DXCreateTextureFromFileEx(
                                             GgafDx9God::_pID3DDevice9, // [in] LPDIRECT3DDEVICE9 pDevice,
                                             texture_file_name2.c_str(),// [in] LPCTSTR pSrcFile,
                                             D3DX_DEFAULT,              // [in] UINT Width,
                                             D3DX_DEFAULT,              // [in] UINT Height,
                                             D3DX_DEFAULT,              // [in] UINT MipLevels,
                                             0,                         // [in] DWORD Usage,
                                             D3DFMT_UNKNOWN,            // [in] D3DFORMAT Format,
                                             D3DPOOL_DEFAULT,           // [in] D3DPOOL Pool, //D3DPOOL_DEFAULT
                                             D3DX_FILTER_POINT,         // [in] DWORD Filter, D3DX_FILTER_POINT{PiC
                                             D3DX_DEFAULT,              // [in] DWORD MipFilter,
                                             0,                         // [in] D3DCOLOR ColorKey,
                                             _pD3DXIMAGE_INFO,          // [out] D3DXIMAGE_INFO *pSrcInfo,
                                             NULL,                      // [in] PALETTEENTRY *pPalette,
                                             &pIDirect3DTexture9        // [out] GgafDx9TextureConnection* *ppTextureCon
                                          );
                            checkDxException(hr2, D3D_OK, "[GgafDx9TextureManager::createResource] D3DXCreateTextureFromFileExsB="<<prm_texture_name);
                        }
                        _pIDirect3DBaseTexture9 = pIDirect3DTexture9;
                        Sleep(1); //HCgB
                    } else {
                        //}bveNX`
                        LPDIRECT3DCUBETEXTURE9 pIDirect3DCubeTexture9;
                        HRESULT hr = D3DXCreateCubeTextureFromFileEx(
                                            GgafDx9God::_pID3DDevice9,     // [in ] LPDIRECT3DDEVICE9 pDevice,
                                            texture_file_name.c_str(),     // [in ] LPCTSTR pSrcFile,
                                            D3DX_DEFAULT,                  // [in ] UINT Size,
                                            D3DX_DEFAULT,                  // [in ] UINT MipLevels,
                                            0,                             // [in ] DWORD Usage,
                                            D3DFMT_UNKNOWN,                // [in ] D3DFORMAT Format,
                                            D3DPOOL_DEFAULT,               // [in ] D3DPOOL Pool,
                                            D3DX_DEFAULT,                  // [in ] DWORD Filter,
                                            D3DX_DEFAULT,                  // [in ] DWORD MipFilter,
                                            0,                             // [in ] D3DCOLOR ColorKey,
                                            _pD3DXIMAGE_INFO,              // [out] D3DXIMAGE_INFO * pSrcInfo,
                                            NULL,                          // [out] PALETTEENTRY * pPalette,
                                            &pIDirect3DCubeTexture9        // [out] LPDIRECT3DCUBETEXTURE9 * ppCubeTexture
                                    );
                        checkDxException(hr, D3D_OK, "[GgafDx9TextureManager::createResource] D3DXCreateCubeTextureFromFileExB="<<prm_texture_name);
                        _pIDirect3DBaseTexture9 = pIDirect3DCubeTexture9;
                        Sleep(1); //HCgB
                    }
                    TRACE3(" GgafDx9TextureManager::processCreateResource "<<prm_idstr<<" eNX`B");
                }
                
          54 -> GgafDx9Texture::~GgafDx9Texture() {
                    TRACE3("GgafDx9Texture::~GgafDx9Texture() " << _texture_name << " start-->");
                    DELETEARR_IMPOSSIBLE_NULL(_texture_name);
                    DELETE_IMPOSSIBLE_NULL(_pD3DXIMAGE_INFO);
                    RELEASE_IMPOSSIBLE_NULL(_pIDirect3DBaseTexture9);
                }
                


Top 10 Lines:

     Line      Count

       86         54
        7         27

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       81   Total number of line executions
    27.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/model/GgafDx9Model.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                
          26 -> GgafDx9Model::GgafDx9Model(char* prm_model_name) : GgafObject() {
                    TRACE3("GgafDx9Model::GgafDx9Model(" << prm_model_name << ")");
                    _id = GgafDx9ModelManager::getNextId();
                    _model_name = NEW char[51];
                    strcpy(_model_name, prm_model_name);
                    _paD3DMaterial9_default = NULL;
                    _dwNumMaterials = 0;
                    _papTextureCon = NULL;
                    _fBoundingSphereRadius = 0;
                    _fPowerBlink = -1.0f;
                    _fBlinkThreshold = 1.1f;
                    _frame_blinker = 0;
                    _pTextureBlinker = NEW GgafDx9TextureBlinker(this);
                    _is_init_model = false;
                    _set_num = 1; //ftHg`P
                    TRACE3("GgafDx9Model::GgafDx9Model(" << prm_model_name << ") _id="<<_id);
                }
                
          26 -> GgafDx9Model::~GgafDx9Model() {
                    _TRACE_("GgafDx9Model::~GgafDx9Model() " << _model_name << " ");
                    DELETEARR_POSSIBLE_NULL(_model_name);
                    DELETEARR_POSSIBLE_NULL(_paD3DMaterial9_default);
                    DELETE_IMPOSSIBLE_NULL(_pTextureBlinker);
                }
                


Top 10 Lines:

     Line      Count

        7         26
       25         26

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       52   Total number of line executions
    17.33   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/effect/GgafDx9Effect.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                
          11 -> GgafDx9Effect::GgafDx9Effect(char* prm_effect_name) : GgafObject() {
                    TRACE4("GgafDx9Effect::GgafDx9Effect(" << prm_effect_name << ")");
                    _effect_name = NEW char[51];
                    strcpy(_effect_name, prm_effect_name);
                
                    ID3DXBuffer* pError = NULL;
                #ifdef _DEBUG
                    DWORD dwFlags = D3DXSHADER_DEBUG; //|D3DXSHADER_SKIPOPTIMIZATION;//|D3DXSHADER_FORCE_PS_SOFTWARE_NOOPT|D3DXSHADER_FORCE_VS_SOFTWARE_NOOPT|D3DXSHADER_SKIPOPTIMIZATION;
                #else
                    DWORD dwFlags = D3DXSHADER_SKIPVALIDATION;
                #endif
                
                //#ifdef _DEBUG
                //    DWORD dwFlags = D3DXSHADER_DEBUG|D3DXFX_NOT_CLONEABLE;
                //#else
                //    DWORD dwFlags = D3DXSHADER_SKIPVALIDATION|D3DXFX_NOT_CLONEABLE;
                //#endif
                
                //#ifdef _DEBUG
                //    DWORD dwFlags = D3DXSHADER_PARTIALPRECISION|D3DXSHADER_DEBUG|D3DXSHADER_PREFER_FLOW_CONTROL|D3DXFX_NOT_CLONEABLE;
                //#else
                //    DWORD dwFlags = D3DXSHADER_SKIPVALIDATION|D3DXSHADER_PARTIALPRECISION|D3DXSHADER_PREFER_FLOW_CONTROL|D3DXFX_NOT_CLONEABLE;
                //#endif
                
                    string effect_file_name = GGAFDX9_PROPERTY(DIR_EFFECT) + string(prm_effect_name) + ".fx";
                //    if (prm_effect_name == "HoshiBoshiEffect") {
                //        dwFlags = D3DXSHADER_DEBUG|D3DXSHADER_SKIPOPTIMIZATION;
                //    }
                    HRESULT hr = D3DXCreateEffectFromFile(
                                     GgafDx9God::_pID3DDevice9, // [in] LPDIRECT3DDEVICE9 pDevice
                                     effect_file_name.c_str(),  // [in] LPCTSTR pSrcFile
                                     0,                         // [in] CONST D3DXMACRO* pDefines
                                     0,                         // [in] LPD3DXINCLUDE pInclude
                                     dwFlags,                   // [in] DWORD Flags
                                     0,                         // [in] LPD3DXEFFECTPOOL pPool
                                     &_pID3DXEffect,         // [out] LPD3DXEFFECT* ppEffect
                                     &pError                    // [out] LPD3DXBUFFER *ppCompilationxErrors
                                );
                    if (hr != D3D_OK && pError == NULL) {
                        throwGgafCriticalException("GgafDx9Effect::GgafDx9Effect "<<effect_file_name<<" EEE");
                    }
                    checkDxException(hr, D3D_OK, "GgafDx9Effect::GgafDx9Effect ["<<effect_file_name<<"]\n"<<(const char*)(pError->GetBufferPointer()));
                    _TRACE_(" GgafDx9Effect::GgafDx9Effect "<<prm_effect_name<<" GtFNgBADD:"<<this);
                    _h_alpha_master = _pID3DXEffect->GetParameterByName( NULL, "g_alpha_master" ); //}X^[
                    _begin = false;
                }
                
          11 -> GgafDx9Effect::~GgafDx9Effect() {
                    TRACE4("GgafDx9Effect::~GgafDx9Effect("<<_effect_name<<") Adr:"<<this);
                    _pID3DXEffect->EndPass();
                    _pID3DXEffect->End();
                    DELETEARR_IMPOSSIBLE_NULL(_effect_name);
                    RELEASE_IMPOSSIBLE_NULL(_pID3DXEffect);  //
                }
                


Top 10 Lines:

     Line      Count

        7         11
       54         11

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       22   Total number of line executions
     7.33   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/sound/CWaveDecorder.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                /****************************************************************
                 *			wavefR[_NX
                 *	@author		Ander/Echigo-ya koubou
                 ****************************************************************/
                /**
                 @brief		MM I/O
                 */
                int CWaveDecorder::readMMIO(void) {
                    MMCKINFO ckIn; // chunk info. for general use.
                    PCMWAVEFORMAT pcmWaveFormat; // Temp PCM structure to load in.
                
                    m_pwfx = NULL;
                
                    if ((0 != mmioDescend(m_hmmioIn, &m_ckInRiff, NULL, 0))) {
                        return false;
                    }
                
                    if ((m_ckInRiff.ckid != FOURCC_RIFF) || (m_ckInRiff.fccType != mmioFOURCC('W', 'A', 'V', 'E'))) {
                        return false;
                    }
                
                    // Search the input file for for the 'fmt ' chunk.
                    ckIn.ckid = mmioFOURCC('f', 'm', 't', ' ');
                    if (0 != mmioDescend(m_hmmioIn, &ckIn, &m_ckInRiff, MMIO_FINDCHUNK)) {
                        return false;
                    }
                
                    // Expect the 'fmt' chunk to be at least as large as <PCMWAVEFORMAT>;
                    // if there are extra parameters at the end, we'll ignore them
                    if (ckIn.cksize < (LONG)sizeof(PCMWAVEFORMAT)) {
                        return false;
                    }
                
                    // Read the 'fmt ' chunk into <pcmWaveFormat>.
                    if (mmioRead(m_hmmioIn, (HPSTR) & pcmWaveFormat, sizeof(pcmWaveFormat)) != sizeof(pcmWaveFormat)) {
                        return false;
                    }
                
                    // Allocate the waveformatex, but if its not pcm format, read the next
                    // word, and thats how many extra bytes to allocate.
                    if (pcmWaveFormat.wf.wFormatTag == WAVE_FORMAT_PCM) {
                        m_pwfx = NEW WAVEFORMATEX;
                
                        // Copy the bytes from the pcm structure to the waveformatex structure
                        memcpy(m_pwfx, &pcmWaveFormat, sizeof(pcmWaveFormat));
                        m_pwfx->cbSize = 0;
                    } else {
                        // Read in length of extra bytes.
                        WORD cbExtraBytes = 0L;
                        if (mmioRead(m_hmmioIn, (CHAR*) &cbExtraBytes, sizeof(WORD)) != sizeof(WORD)) {
                            return false;
                        }
                
                        m_pwfx = (WAVEFORMATEX*)NEW CHAR[ sizeof(WAVEFORMATEX) + cbExtraBytes ];
                
                        // Copy the bytes from the pcm structure to the waveformatex structure
                        memcpy(m_pwfx, &pcmWaveFormat, sizeof(pcmWaveFormat));
                        m_pwfx->cbSize = cbExtraBytes;
                
                        // Now, read those extra bytes into the structure, if cbExtraAlloc != 0.
                        if (mmioRead(m_hmmioIn,
                                     (CHAR*) ( ((BYTE*) &(m_pwfx->cbSize)) + sizeof(WORD) ),
                                     cbExtraBytes
                                    ) != cbExtraBytes) {
                            DELETE_IMPOSSIBLE_NULL(m_pwfx);
                            m_pwfx = NULL;
                            return false;
                        }
                    }
                
                    // Ascend the input file out of the 'fmt ' chunk.
                    if (0 != mmioAscend(m_hmmioIn, &ckIn, 0)) {
                        DELETE_IMPOSSIBLE_NULL(m_pwfx);
                        m_pwfx = NULL;
                        return false;
                    }
                
                    return true;
                }
                
          92 -> CWaveDecorder::~CWaveDecorder(void) {
                    Close();
                }
                
          92 -> CWaveDecorder::CWaveDecorder(void) :
                    m_pwfx(NULL), m_hmmioIn(NULL) {
                }
                
                /**
                 @brief		Wavet@CJ
                 */
                int CWaveDecorder::Open(LPSTR lpszFilename) {
                    if (NULL == (m_hmmioIn = mmioOpen(lpszFilename, NULL, MMIO_ALLOCBUF | MMIO_READ))) {
                        return false;
                    }
                
                    if (!readMMIO()) {
                        mmioClose(m_hmmioIn, 0);
                        return false;
                    }
                
                    if (!SetPosition(0)) {
                        Close();
                        return false;
                    }
                
                    return true;
                }
                /**
                 @brief		Wavet@C
                 */
                void CWaveDecorder::Close(void) {
                    if (m_pwfx) {
                        DELETE_POSSIBLE_NULL(m_pwfx);
                        mmioClose(m_hmmioIn, 0);
                    }
                }
                
                /**
                 @brief		obt@ouw
                 @param		lPosition		obt@ou(offsetw)
                 */
                int CWaveDecorder::SetPosition(long lPosition) {
                    // Seek to the data
                    if (-1 == mmioSeek(m_hmmioIn, m_ckInRiff.dwDataOffset + sizeof(FOURCC) + lPosition, SEEK_SET)) {
                        return false;
                    }
                
                    // Search the input file for for the 'data' chunk.
                    m_ckIn.ckid = mmioFOURCC('d', 'a', 't', 'a');
                    if (0 != mmioDescend(m_hmmioIn, &m_ckIn, &m_ckInRiff, MMIO_FINDCHUNK)) {
                        return false;
                    }
                
                    return true;
                }
                
                /**
                 @brief		Wavef[^]
                 @return		0F]oCg^FNG
                 */
                long CWaveDecorder::GetWave(LPBYTE lpDest, long lSize) {
                    long lReadSize = 0;
                    MMIOINFO mmioinfoIn; // current status of <hmmioIn>
                
                    if (0 != mmioGetInfo(m_hmmioIn, &mmioinfoIn, 0)) {
                        return -1L;
                    }
                
                    UINT cbDataIn = lSize;
                    if (cbDataIn > m_ckIn.cksize) {
                        cbDataIn = m_ckIn.cksize;
                    }
                
                    m_ckIn.cksize -= cbDataIn;
                
                    for (DWORD cT = 0; cT < cbDataIn; cT++) {
                        // Copy the bytes from the io to the buffer.
                        if (mmioinfoIn.pchNext == mmioinfoIn.pchEndRead) {
                            if (0 != mmioAdvance(m_hmmioIn, &mmioinfoIn, MMIO_READ)) {
                                return -1L;
                            }
                
                            if (mmioinfoIn.pchNext == mmioinfoIn.pchEndRead) {
                                return -1L;
                            }
                        }
                
                        // Actual copy.
                        *(lpDest + cT) = *((BYTE*)mmioinfoIn.pchNext);
                        mmioinfoIn.pchNext++;
                    }
                
                    if (0 != mmioSetInfo(m_hmmioIn, &mmioinfoIn, 0)) {
                        return -1L;
                    }
                
                    lReadSize = cbDataIn;
                
                    return lReadSize;
                }
                
                /**
                 @brief		Wavef[^TCY
                 */
                DWORD CWaveDecorder::GetWaveSize(void) {
                    return m_ckIn.cksize;
                }
                
                /**
                 @brief		WaveFormat
                 */
                WAVEFORMATEX* CWaveDecorder::GetWaveFormat(void) {
                    return m_pwfx;
                }
                


Top 10 Lines:

     Line      Count

       86         92
       90         92

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      184   Total number of line executions
    61.33   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/sound/IkdLib/PCMPlayer.cpp:
                #include "stdafx.h"
                
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace Dix;
                
                // PCMPlayer.cpp
                //
                //#include "GgafDx9CommonHeader.h"
                //#include "PCMPlayer.h"
                //#include <process.h>
                //#include <stdio.h>
                
                #ifdef _MSC_VER
                
                #else
                #define NULL 0
                #endif
                
                namespace {
                    double playTime_g = 1;	// 1 sec.
                }
                
                //namespace Dix {
       ##### ->     PCMPlayer::PCMPlayer() :
                        pDS8_			( NULL ),
                        pDSBuffer_		( NULL ),
                        pPCMDecoder_   ( NULL ),
                        waveFormat_     (),
                        DSBufferDesc_   (),
                        isReady_		( false ),
                        threadHandle_	( 0 ),
                        isTerminate_	( false ),
                        isLoop_			( true ),
                        state_			( STATE_NONE )
                    {
                        clear();
                    }
                
       ##### ->     PCMPlayer::PCMPlayer( IDirectSound8* pDS8 ) :
                        pDS8_			( pDS8 ),
                        pDSBuffer_		( NULL ),
                        pPCMDecoder_   ( NULL ),
                        waveFormat_     (),
                        DSBufferDesc_   (),
                        isReady_		( false ),
                        threadHandle_	( 0 ),
                        isTerminate_	( false ),
                        isLoop_			( true ),
                        state_			( STATE_NONE )
                    {
                        clear();
                    }
                
           4 ->     PCMPlayer::PCMPlayer( IDirectSound8* pDS8, PCMDecoder* spDecoder ) :
                        pDS8_			( pDS8 ),
                        pDSBuffer_		( NULL ),
                        pPCMDecoder_   ( NULL ),
                        waveFormat_     (),
                        DSBufferDesc_   (),
                        isReady_		( false ),
                        threadHandle_	( 0 ),
                        isTerminate_	( false ),
                        isLoop_			( true ),
                        state_			( STATE_NONE )
                    {
                        clear();
                        setDecoder( spDecoder );
                    }
                
           8 ->     PCMPlayer::~PCMPlayer() {
                        //A
                        //X}[g|C^OdeleteRelease
                        _TRACE_("PCMPlayer::~PCMPlayer() begin");
                        _TRACE_("terminateThread();");
                        terminateThread();
                        _TRACE_("RELEASE_IMPOSSIBLE_NULL(pDSBuffer_);");
                        RELEASE_IMPOSSIBLE_NULL(pDSBuffer_);
                        _TRACE_("DELETE_IMPOSSIBLE_NULL(pPCMDecoder_);");
                        DELETE_IMPOSSIBLE_NULL(pPCMDecoder_);
                        _TRACE_("PCMPlayer::~PCMPlayer() end");
                    }
                
                    //! NA
                    void PCMPlayer::clear() {
                        terminateThread();
                        memset( &DSBufferDesc_, 0, sizeof( DSBufferDesc_ ) );
                        memset( &waveFormat_, 0, sizeof( waveFormat_ ) );
                        if (pDSBuffer_) {
                            RELEASE_IMPOSSIBLE_NULL(pDSBuffer_);
                            pDSBuffer_ = NULL;
                        }
                        isReady_ = false;
                        state_ = STATE_NONE;
                    }
                
                    //! Xbh~
                    void PCMPlayer::terminateThread() {
                        isTerminate_ = true;
                        if ( threadHandle_ != 0 ) {
                            bool end = false;
                            while( !end ) {
                                DWORD flag = WaitForSingleObject( (HANDLE)(__int64)threadHandle_, 100 );
                                switch( flag ) {
                                case WAIT_OBJECT_0:
                                    // XbhI
                                    end = true;
                                    break;
                                case WAIT_TIMEOUT:
                                    // I@
                                    break;
                                case WAIT_FAILED:
                                    // s
                                    end = true;
                                    break;
                                }
                                //Sleep(1);
                            }
                        }
                        isTerminate_ = false;
                        threadHandle_ = 0;
                    }
                
                    //! foCX
                    void PCMPlayer::setDevice(IDirectSound8* pDS8 ) {
                        pDS8_ = pDS8;
                    }
                
                
                    //! PCMfR[_
                    bool PCMPlayer::setDecoder( PCMDecoder* pcmDecoder ) {
                        if ( pDS8_ == NULL || pcmDecoder == NULL || pcmDecoder->isReady() == false ) {
                            isReady_ = false;
                            return false;
                        }
                
                        state_ = STATE_STOP;
                
                        if ( !pcmDecoder->getWaveFormatEx( waveFormat_ ) ) {
                            return false;
                        }
                
                        DSBufferDesc_.dwSize = sizeof( DSBUFFERDESC );
                        DSBufferDesc_.dwFlags = DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY | DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLPOSITIONNOTIFY;
                        DSBufferDesc_.dwBufferBytes = waveFormat_.nAvgBytesPerSec * playTime_g;
                        DSBufferDesc_.dwReserved = 0;
                        DSBufferDesc_.lpwfxFormat = &waveFormat_;
                        DSBufferDesc_.guid3DAlgorithm = GUID_NULL;
                
                        // N[
                        pPCMDecoder_ = pcmDecoder->createClone();
                
                        // ZJ_obt@
                        if ( pDSBuffer_ == NULL ) {
                            IDirectSoundBuffer*	 ptmpBuf = 0;
                            if ( SUCCEEDED( pDS8_->CreateSoundBuffer( &DSBufferDesc_, &ptmpBuf, NULL ) ) ) {
                                ptmpBuf->QueryInterface( IID_IDirectSoundBuffer8 , (void**)&pDSBuffer_);
                            }
                            else {
                                clear();
                                return false;
                            }
                            ptmpBuf->Release();
                        }
                
                        // obt@
                        if ( initializeBuffer() == false ) {
                            return false;
                        }
                
                        // obt@Rs[Xbh
                        if ( threadHandle_ == 0 ) {
                            threadHandle_ = (unsigned int)_beginthread( PCMPlayer::streamThread, 0, (void*)this );
                        }
                
                        isReady_ = true;
                
                        return true;
                    }
                
                    //! obt@
                    bool PCMPlayer::initializeBuffer() {
                        if (pPCMDecoder_ == NULL) {
                            return false;
                        }
                
                        pPCMDecoder_->setHead();	// o
                        HRESULT hr = pDSBuffer_->SetCurrentPosition( 0 );
                        checkDxException(hr, DS_OK , "PCMPlayer::initializeBuffer()  SetCurrentPosition( 0 ) sB");
                        // obt@bNf[^
                        for (int i = 0; i < 10; i++) { //POs
                                                       // DSBLOCK_ENTIREBUFFER iSbN)
                                                       //dg^C~OslB
                                                       //TODO:@B
                                                       //TODO:HHBThobt@bNs[B
                
                            void* AP1 = 0, *AP2 = 0;
                            DWORD AB1 = 0, AB2  = 0;
                            hr = pDSBuffer_->Lock( 0, 0, &AP1, &AB1, &AP2, &AB2, DSBLOCK_ENTIREBUFFER );
                            //checkDxException(hr, DS_OK , "PCMPlayer::initializeBuffer() Lock sB"); //NHB
                                                                                                                   //  NA[NB
                            if ( SUCCEEDED(hr) ) {
                                pPCMDecoder_->getSegment( (char*)AP1, AB1, 0, 0 );
                                hr = pDSBuffer_->Unlock( AP1, AB1, AP2, AB2 );
                                checkDxException(hr, DS_OK , "PCMPlayer::initializeBuffer() Unlock sB");
                                break;
                            } else {
                                //bNs
                                if (i < 10) {
                                    _TRACE_("PCMPlayer::initializeBuffer() Locks i="<<i<<" ");
                                    _TRACE_("hr="<<hr<<" "<<DXGetErrorString(hr)<<" "<<DXGetErrorDescription(hr));
                                    hr = pDSBuffer_->Unlock( AP1, AB1, AP2, AB2 );
                                    Sleep(5);
                                    continue; //
                                } else {
                                    //
                                    _TRACE_("PCMPlayer::initializeBuffer() Lock");
                                    clear();
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                
                    //! Xg[Xbh
                    void PCMPlayer::streamThread( void* playerPtr ) {
                        PCMPlayer* player = (PCMPlayer*)playerPtr;
                        unsigned int size = player->DSBufferDesc_.dwBufferBytes / 2;
                        unsigned int flag = 0;
                        DWORD point = 0;
                        void* AP1 = 0, *AP2 = 0;
                        DWORD AB1 = 0, AB2  = 0;
                
                        DWORD finishPos = 0;
                        DWORD prePlayPos = 0;
                
                        unsigned int writeSize = 0;
                        bool isEnd = false;
                        bool waitFinish = false;
                
                        while( player->isTerminate_ == false ) {
                            switch ( player->getState() ) {
                            case STATE_PLAY:	// 
                                // Xg[
                                // u`FbN
                                player->pDSBuffer_->GetCurrentPosition( &point, 0 );
                                if ( flag == 0 && point >= size ) {
                                    // O
                                    if ( SUCCEEDED( player->pDSBuffer_->Lock( 0, size, &AP1, &AB1, &AP2, &AB2, 0 ) ) ) {
                                        player->pPCMDecoder_->getSegment( (char*)AP1, AB1, &writeSize, &isEnd );
                                        player->pDSBuffer_->Unlock( AP1, AB1, AP2, AB2 );
                                        flag = 1;
                                    }
                
                                    // IIu
                                    if ( isEnd == true && waitFinish == false ) {
                                        finishPos = writeSize;
                                        player->pDSBuffer_->GetCurrentPosition( &prePlayPos, 0 );
                                        waitFinish = true;
                                    }
                                }
                                else if ( flag == 1 && point < size ) {
                                    // 
                                    if ( SUCCEEDED( player->pDSBuffer_->Lock( size, size * 2, &AP1, &AB1, &AP2, &AB2, 0 ) ) ) {
                                        player->pPCMDecoder_->getSegment( (char*)AP1, AB1, &writeSize, &isEnd );
                                        player->pDSBuffer_->Unlock( AP1, AB1, AP2, AB2 );
                                        flag = 0;
                                    }
                
                                    // INorify
                                    if ( isEnd == true && waitFinish == false ) {
                                        finishPos = size + writeSize;
                                        player->pDSBuffer_->GetCurrentPosition( &prePlayPos, 0 );
                                        waitFinish = true;
                                    }
                                }
                                break;
                
                            case STATE_STOP:
                                flag = 0;	// ~On
                                isEnd = false;
                                finishPos = 0;
                                prePlayPos = 0;
                                break;
                
                            case STATE_PAUSE:
                                break;
                
                            default:
                                break;
                            }
                
                            // Iu`FbN
                            if ( isEnd == true ) {
                                DWORD curPlayPos;
                                player->pDSBuffer_->GetCurrentPosition( &curPlayPos, 0 );
                                if ( curPlayPos < prePlayPos ) {
                                    // obt@[vu
                                    //if ( prePlayPos <= finishPos ) {
                                    if ( prePlayPos <= finishPos || finishPos <= curPlayPos ) {
                                        // I
                                        player->stop();
                                    }
                                } else {
                                    if ( prePlayPos <= finishPos && finishPos <= curPlayPos ) {
                                        // I
                                        player->stop();
                                    }
                                }
                                prePlayPos = curPlayPos;
                            }
                
                            Sleep( 100 );
                        }
                    }
                
                    //! 
                    bool PCMPlayer::play( bool isLoop ) {
                        if ( isReady() == false ) {
                            return false;
                        }
                        isLoop_ = isLoop;
                        pPCMDecoder_->setLoop( isLoop );
                        pDSBuffer_->Play( 0, 0, DSBPLAY_LOOPING );
                        state_ = STATE_PLAY;
                        return true;
                    }
                
                    //! ~
                    void PCMPlayer::pause() {
                        if ( state_ == STATE_PLAY ) {
                            // ~
                            pDSBuffer_->Stop();
                            state_ = STATE_PAUSE;
                        }
                        else {
                            // ~
                            play( isLoop_ );
                        }
                    }
                
                    //! ~
                    void PCMPlayer::stop() {
                        if ( isReady() == false ) {
                            return;
                        }
                        state_ = STATE_STOP;
                        pDSBuffer_->Stop();
                
                        // obt@o
                        bool r = initializeBuffer();
                        _TRACE_("PCMPlayer::stop() initializeBuffer() = "<<r);
                    }
                
                    //! 
                    void PCMPlayer::setVolume( int volume ) {
                        if ( isReady() == true ) {
                            pDSBuffer_->SetVolume( volume );
                        }
                    }
                
                    //! pu
                    void PCMPlayer::setPan( int pan ) {
                        if ( isReady() == true ) {
                            pDSBuffer_->SetPan( pan );
                        }
                    }
                
                    //! H
                    bool PCMPlayer::isReady() {
                        return isReady_;
                    }
                
                    //! H
                    bool PCMPlayer::isPlaying() {
                        return ( state_ == STATE_PLAY );
                    }
                
                    //! 
                    PCMPlayer::STATE PCMPlayer::getState() {
                        return state_;
                    }
                
                //}


Top 10 Lines:

     Line      Count

       72          8
       56          4

Execution Summary:

        5   Executable lines in this file
        4   Lines executed
    80.00   Percent of the file executed

       12   Total number of line executions
     2.40   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/sound/IkdLib/OggDecoder.cpp:
                #include "stdafx.h"
                
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace Dix;
                
                // OggDecoder.cpp
                //
                
                //#pragma comment ( lib, "ogg_static.lib" )
                //#pragma comment ( lib, "vorbis_static.lib" )
                //#pragma comment ( lib, "vorbisfile_static.lib" )
                
                //#include "OggDecoder.h"
                //#include <memory.h>
                //#include <crtdbg.h>
                
                namespace {
                    const unsigned int requestSize_g = 4096;	// P
                }
                
                //namespace Dix {
                    //! RXgN^
           4 ->     OggDecoder::OggDecoder() {
                        pOggVorbisResource_ = NULL;
                    }
                
           4 ->     OggDecoder::OggDecoder(OggVorbisResource* pOggVorbisResource ) {
                        pOggVorbisResource_ = NULL;
                        setResource( pOggVorbisResource );
                    }
                
                    //! fXgN^
          16 ->     OggDecoder::~OggDecoder() {
                        DELETE_IMPOSSIBLE_NULL(pOggVorbisResource_);
                        clear();
                    }
                
                    //! NA
                    void OggDecoder::clear() {
                        PCMDecoder::clear();
                    }
                
                    //! ZOg
                    bool OggDecoder::getSegment( char* buffer, unsigned int size, unsigned int* writeSize, bool* isEnd ) {
                        if ( isReady() == false ) {
                            return false;
                        }
                
                        if ( buffer == 0 ) {
                            if ( isEnd ) *isEnd = true;
                            if ( writeSize ) *writeSize = 0;
                            return false;
                        }
                
                        OggVorbis_File& ovf_ = pOggVorbisResource_->getOggVorbisFile();
                
                        if ( isEnd ) *isEnd = false;
                
                        memset( buffer, 0, size );
                        unsigned int requestSize = requestSize_g;
                        int bitstream = 0;
                        int readSize = 0;
                        unsigned int comSize = 0;
                        bool isAdjust = false;
                
                        if ( size < requestSize ) {
                            requestSize = size;
                            isAdjust = true;	// iK
                        }
                
                        while( 1 ) {
                            readSize = ov_read( &ovf_, (char*)( buffer + comSize ), requestSize, 0, 2, 1, &bitstream );
                            if ( readSize == 0 ) {
                                // t@CGhB
                                if ( isLoop() == true ) {
                                    // [vu
                                    ov_time_seek( &ovf_, 0.0 );
                                }
                                else {
                                    // [vt@CGhBI
                                    if ( isEnd ) *isEnd = true;
                                    if ( writeSize )
                                        *writeSize = comSize;
                                    return true;
                                }
                            }
                
                            comSize += readSize;
                
                //			if (comSize <= size) {
                //				_TRACE_("obt@I[o[");
                //			}
                            //_ASSERT( comSize <= size );	// obt@I[o[
                
                            if ( comSize  >= size ) {
                                // obt@sI
                                if ( writeSize ) *writeSize = comSize;
                                return true;
                            }
                
                            if ( size - comSize < requestSize_g ) {
                                isAdjust = true;	// iK
                                requestSize = size - comSize;
                            }
                        }
                
                        if ( writeSize ) *writeSize = 0;
                        return false;	// G[
                    }
                
                    //! o
                    void OggDecoder::setHead() {
                        if ( isReady() == true ) {
                            ov_time_seek( &pOggVorbisResource_->getOggVorbisFile(), 0.0 );
                        }
                    }
                
                    //! N[
                    PCMDecoder* OggDecoder::createClone() {
                        OggDecoder* spObj = NEW OggDecoder;
                        if ( pOggVorbisResource_->isReady() == false ) {
                            return spObj;  // 
                        }
                
                        spObj->setResource( pOggVorbisResource_ );
                
                        return spObj;
                    }
                
                    //! TEhZbg
                    bool OggDecoder::setResource(OggVorbisResource* pOggVorbisResource ) {
                        clear();
                        if (pOggVorbisResource == NULL || pOggVorbisResource->isReady() == false ) {
                            return false;
                        }
                
                        pOggVorbisResource_ = pOggVorbisResource->createClone();
                        if ( pOggVorbisResource_ == NULL ) {
                            // N[s
                            return false;
                        }
                        // Ogg{i[
                        vorbis_info *info = ov_info( &pOggVorbisResource_->getOggVorbisFile(), -1 );
                        setChannelNum( info->channels );
                        setBitRate( 16 );
                        setSamplingRate( info->rate );
                        setReady( true );
                        return true;
                    }
                //}


Top 10 Lines:

     Line      Count

       35         16
       25          4
       29          4

Execution Summary:

        4   Executable lines in this file
        3   Lines executed
    75.00   Percent of the file executed

       24   Total number of line executions
     6.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/sound/IkdLib/OggVorbisFile.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace Dix;
                
                // OggVorbisFile.cpp
                //
                //#include "GgafDx9CommonHeader.h"
                //#include "OggVorbisFile.h"
                //#include "string.h"
                
                #pragma warning ( disable : 4267 )
                #pragma warning ( disable : 4244 )
                #pragma warning ( disable : 4996 )
                
                
                //namespace Dix {
           8 ->     OggVorbisFile::OggVorbisFile() {
                    }
                
           4 ->     OggVorbisFile::OggVorbisFile( const char* filePath ) {
                        if (open( filePath )) {
                            //OK
                        } else {
                            throwGgafCriticalException(filePath << " open sB");
                        }
                    }
                
          24 ->     OggVorbisFile::~OggVorbisFile() {
                    }
                
                    //! NA
                    void OggVorbisFile::clear() {
                        memset( filePath_, 0, sizeof( filePath_ ) );
                        OggVorbisResource::clear();
                    }
                
                    //! SN[
                    OggVorbisResource* OggVorbisFile::createClone() {
                        OggVorbisFile* obj = NEW OggVorbisFile;
                        if ( obj->open( filePath_ ) == false ) {
                            return 0;
                        }
                        return obj;
                    }
                
                    //! Oggt@CI[v
                    bool OggVorbisFile::open( const char* filePath ) {
                
                        clear();
                
                        // Oggt@CI[v
                        if ( ov_fopen( (char*)filePath, &oggVorbisFile_ ) != 0 ) {
                            // s
                            clear();
                            return false;
                        }
                
                        strcpy( filePath_, filePath );
                        isReady_ = true;
                
                        return true;
                    }
                //}


Top 10 Lines:

     Line      Count

       30         24
       19          8
       22          4

Execution Summary:

        4   Executable lines in this file
        3   Lines executed
    75.00   Percent of the file executed

       36   Total number of line executions
     9.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9Core/include/jp/ggaf/dx9core/sound/IkdLib/OggVorbisResource.h:
                // {vOA<BR>
                // u~ij[Rv http://marupeke296.com/index.html <BR>
                // TCgRec uOgg Vorbisv http://marupeke296.com/OGG_main.html <BR>
                // TvvOIWiB<BR>
                // XgpB<BR>
                //                                            2009/01/13 Masatoshi Tsuge<BR>
                
                // OggVorbisResource.h
                //
                
                #ifndef IKD_DIX_OGGVORBISRESOURCE_H
                #define IKD_DIX_OGGVORBISRESOURCE_H
                
                #include "vorbis/vorbisfile.h"
                
                namespace Dix {
                    class OggVorbisResource {
                    public:
          12 ->         OggVorbisResource() : isReady_( false ){
                            memset( &oggVorbisFile_, 0, sizeof( OggVorbis_File ) );
                        }
                
          12 ->         virtual ~OggVorbisResource(){
                            clear();
                        }
                
                        // NA
                        virtual void clear() {
                            ov_clear( &oggVorbisFile_ );
                            memset( &oggVorbisFile_, 0, sizeof( OggVorbis_File ) );
                            isReady_ = false;
                        }
                
                        // OggVorbis_File\
                        virtual OggVorbis_File& getOggVorbisFile() {
                            return oggVorbisFile_;
                        }
                
                        // SN[
                        virtual OggVorbisResource* createClone() = 0;
                
                        // H
                        bool isReady() {
                            return isReady_;
                        }
                
                    protected:
                        OggVorbis_File	oggVorbisFile_;	// OggVorbis_File\
                        bool			isReady_;		// H
                    };
                }
                
                #endif


Top 10 Lines:

     Line      Count

       19         12
       23         12

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

       24   Total number of line executions
    12.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/manager/GgafDx9SeConnection.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
          92 -> GgafDx9SeConnection::GgafDx9SeConnection(char* prm_idstr, GgafDx9Se* prm_pGgafDx9Se) :
                    GgafResourceConnection<GgafDx9Se> (prm_idstr, prm_pGgafDx9Se) {
                }
                
                void GgafDx9SeConnection::processReleaseResource(GgafDx9Se* prm_pResource) {
                    DELETE_IMPOSSIBLE_NULL(prm_pResource);
                }
                


Top 10 Lines:

     Line      Count

        6         92

Execution Summary:

        2   Executable lines in this file
        1   Lines executed
    50.00   Percent of the file executed

       92   Total number of line executions
    46.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9Core/include/jp/ggaf/dx9core/manager/GgafDx9SeConnection.h:
                #ifndef GGAFDX9SECONNECTION_H_
                #define GGAFDX9SECONNECTION_H_
                namespace GgafDx9Core {
                
                /**
                 * GgafDx9SeRlNV.
                 * @version 1.00
                 * @since 2009/01/30
                 * @author Masatoshi Tsuge
                 */
                class GgafDx9SeConnection : public GgafCore::GgafResourceConnection<GgafDx9Se> {
                
                public:
                
                    /**
                     * RXgN^<BR>
                     * @param prm_idstr TEhGtFNg
                     * @param prm_pGgafDx9Se TEhGtFNgIuWFNgil|C^j
                     */
                    GgafDx9SeConnection(char* prm_idstr, GgafDx9Se* prm_pGgafDx9Se);
                
                    void processReleaseResource(GgafDx9Se* prm_pResource);
                
         184 ->     virtual ~GgafDx9SeConnection() {
                    }
                };
                
                }
                #endif /*GGAFDX9SECONNECTION_H_*/


Top 10 Lines:

     Line      Count

       24        184

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      184   Total number of line executions
   184.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/manager/GgafDx9BgmConnection.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
           4 -> GgafDx9BgmConnection::GgafDx9BgmConnection(char* prm_idstr, GgafDx9Bgm* prm_pGgafDx9Bgm) :
                    GgafResourceConnection<GgafDx9Bgm> (prm_idstr, prm_pGgafDx9Bgm) {
                }
                
                void GgafDx9BgmConnection::processReleaseResource(GgafDx9Bgm* prm_pResource) {
                    DELETE_IMPOSSIBLE_NULL(prm_pResource);
                }
                


Top 10 Lines:

     Line      Count

        6          4

Execution Summary:

        2   Executable lines in this file
        1   Lines executed
    50.00   Percent of the file executed

        4   Total number of line executions
     2.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9Core/include/jp/ggaf/dx9core/manager/GgafDx9BgmConnection.h:
                #ifndef GGAFDX9BGMCONNECTION_H_
                #define GGAFDX9BGMCONNECTION_H_
                namespace GgafDx9Core {
                
                /**
                 * GgafDx9BgmRlNV.
                 * @version 1.00
                 * @since 2009/01/30
                 * @author Masatoshi Tsuge
                 */
                class GgafDx9BgmConnection : public GgafCore::GgafResourceConnection<GgafDx9Bgm> {
                
                public:
                
                    /**
                     * RXgN^<BR>
                     * @param prm_idstr OGG(t@C)
                     * @param prm_pGgafDx9Bgm OGG
                     */
                    GgafDx9BgmConnection(char* prm_idstr, GgafDx9Bgm* prm_pGgafDx9Bgm);
                
                    void processReleaseResource(GgafDx9Bgm* prm_pResource);
                
           8 ->     virtual ~GgafDx9BgmConnection() {
                    }
                };
                
                }
                #endif /*GGAFDX9BGMCONNECTION_H_*/


Top 10 Lines:

     Line      Count

       24          8

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        8   Total number of line executions
     8.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/manager/GgafDx9ModelConnection.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
          26 -> GgafDx9ModelConnection::GgafDx9ModelConnection(char* prm_idstr, GgafDx9Model* prm_pModel) :
                    GgafResourceConnection<GgafDx9Model> (prm_idstr, prm_pModel) {
                }
                
                void GgafDx9ModelConnection::processReleaseResource(GgafDx9Model* prm_pResource) {
                    prm_pResource->release(); //dv
                    DELETE_IMPOSSIBLE_NULL(prm_pResource);
                }
                


Top 10 Lines:

     Line      Count

        6         26

Execution Summary:

        2   Executable lines in this file
        1   Lines executed
    50.00   Percent of the file executed

       26   Total number of line executions
    13.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9Core/include/jp/ggaf/dx9core/manager/GgafDx9ModelConnection.h:
                #ifndef GGAFDX9MODELCONNECTION_H_
                #define GGAFDX9MODELCONNECTION_H_
                namespace GgafDx9Core {
                
                /**
                 * fRlNV.
                 * @version 1.00
                 * @since 2009/02/01
                 * @author Masatoshi Tsuge
                 */
                class GgafDx9ModelConnection : public GgafCore::GgafResourceConnection<GgafDx9Model> {
                public:
                
                    /**
                     * RXgN^<BR>
                     * @param prm_idstr f
                     * @param prm_pModel \[Xf
                     */
                    GgafDx9ModelConnection(char* prm_idstr, GgafDx9Model* prm_pModel);
                
                    void processReleaseResource(GgafDx9Model* prm_pResource);
                
          52 ->     virtual ~GgafDx9ModelConnection() {
                    }
                };
                
                }
                #endif /*GGAFDX9MODELCONNECTION_H_*/


Top 10 Lines:

     Line      Count

       23         52

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       52   Total number of line executions
    52.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/model/GgafDx9RectUV.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
         294 -> GgafDx9RectUV::GgafDx9RectUV() : GgafObject() {
                }
                
         294 -> GgafDx9RectUV::~GgafDx9RectUV() {
                }


Top 10 Lines:

     Line      Count

        6        294
        9        294

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      588   Total number of line executions
   196.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/util/XFile/framework/Frm_Mesh.cpp:
                #include "stdafx.h"
                /////////////////////////////////////////////////////////
                // Frm_Mesh.cpp
                //
                //
                /////////////////////////////////////////////////////////
                
                //#include "jp/ggaf/core/util/XFile/framework/frm_mesh.h"
                
                using namespace Frm;
                
          19 -> Bone::~Bone(void) {
                    if (_Vertices != 0)
                        delete[] _Vertices;
                    if (_Weights != 0)
                        delete[] _Weights;
                    while (!_Bones.empty()) {
                        delete _Bones.back();
                        _Bones.pop_back();
                    }
                }
                
                Bone* Bone::IsName(std::string &BoneName) {
                    if (strcmp(_Name.c_str(), BoneName.c_str()) == 0)
                        return this;
                
                    if (_Bones.empty())
                        return 0;
                
                    for (std::list<Bone*>::iterator i = _Bones.begin(); i != _Bones.end(); i++)
                        if ((*i)->IsName(BoneName) != 0)
                            return (*i)->IsName(BoneName);
                    return 0;
                }
                
                void Bone::UpdateIndices(uint16 pIndex) {
                    for (uint32 i = 0; i < _nVertices; i++)
                        _Vertices[i] += pIndex;
                }
                
          21 -> Mesh::~Mesh(void) {
                    if (_Vertices != 0)
                        delete[] _Vertices;
                    if (_Faces != 0)
                        delete[] _Faces;
                    if (_Normals != 0)
                        delete[] _Normals;
                    if (_TextureCoords != 0)
                        delete[] _TextureCoords;
                    while (!_Materials.empty()) {
                        delete _Materials.back();
                        _Materials.pop_back();
                    }
                    if (_FaceMaterials != 0)
                        delete[] _FaceMaterials;
                    while (!_Subsets.empty()) {
                        delete[] _Subsets.back()->Faces;
                        delete _Subsets.back();
                        _Subsets.pop_back();
                    }
                    //add tsuge begin
                    if (_FaceNormals != 0) {
                        delete[] _FaceNormals;
                    }
                    //sdd tsuge end
                }
                
                void Mesh::UpdateIndices(void) {
                    for (uint32 i = 0; i < _nFaces; i++) {
                        _Faces[i].data[0] += _FirstVertex;
                        _Faces[i].data[1] += _FirstVertex;
                        _Faces[i].data[2] += _FirstVertex;
                
                        _FaceMaterials[i] += _FirstMaterial;
                    }
                
                    if (_nNormals != 0)
                        for (uint32 i = 0; i < _nFaces; i++) {
                            _FaceNormals[i].data[0] += _FirstNormal;
                            _FaceNormals[i].data[1] += _FirstNormal;
                            _FaceNormals[i].data[2] += _FirstNormal;
                        }
                }
                
                void Mesh::CreateSubsets(void) {
                    uint32 FaceCount;
                    Subset* MeshSubset;
                
                    //For each material
                    for (uint32 i = 0; i < _Materials.size(); i++) {
                        //We count the number of faces using this material
                        FaceCount = 0;
                        for (uint32 j = 0; j < _nFaces; j++)
                            if (_FaceMaterials[j] == i)
                                ++FaceCount;
                        //We initialise the mesh subset
                        MeshSubset = NEW Subset;
                        MeshSubset->Size = FaceCount;
                        MeshSubset->Faces = NEW Face[FaceCount];
                        int k = 0;
                        //We fill in the Mesh subset
                        for (uint32 j = 0; j < _nFaces; j++)
                            if (_FaceMaterials[j] == i)
                                MeshSubset->Faces[k++] = _Faces[j];
                        //And we add that subset to the list
                        _Subsets.push_back(MeshSubset);
                    }
                }
                
                /*************************************************
                 NEW- NEW- NEW- NEW- NEW- NEW- NEW- NEW- NEW- NEW*/
                
       ##### -> Animation::~Animation(void) {
                    while (!_Scalings.empty()) {
                        delete _Scalings.back();
                        _Scalings.pop_back();
                    }
                    while (!_Rotations.empty()) {
                        delete _Rotations.back();
                        _Rotations.pop_back();
                    }
                    while (!_Translations.empty()) {
                        delete _Translations.back();
                        _Translations.pop_back();
                    }
                    while (!_Matrices.empty()) {
                        delete _Matrices.back();
                        _Matrices.pop_back();
                    }
                }
                
       ##### -> AnimationSet::~AnimationSet(void) {
                    while (!_Animations.empty()) {
                        delete _Animations.back();
                        _Animations.pop_back();
                    }
                }
                
                Animation* AnimationSet::FindAnimation(std::string &pText) {
                    for (std::list<Animation*>::iterator i = _Animations.begin(); i
                            != _Animations.end(); i++)
                        if ((*i)->IsName(pText) != 0)
                            return (*i)->IsName(pText);
                    return 0;
                }
                
                /*************************************************/
                
          13 -> Model3D::~Model3D(void) {
                    //tsuge modify begin
                
                    //if (_Skeletton != 0)
                    //    delete _Skeletton;
                
                    //_toplevel_SkelettonsXgA
                    //delete svB
                    while (!_toplevel_Skelettons.empty()) {
                        delete _toplevel_Skelettons.back();
                        _toplevel_Skelettons.pop_back();
                    }
                    //tsuge modify end
                
                    while (!_Meshes.empty()) {
                        delete _Meshes.back();
                        _Meshes.pop_back();
                    }
                    while (!_AnimationSets.empty()) {
                        delete _AnimationSets.back();
                        _AnimationSets.pop_back();
                    }
                }
                
                Mesh* Model3D::IsMeshName(std::string &pText) {
                    for (std::list<Mesh*>::iterator i = _Meshes.begin(); i != _Meshes.end(); i++)
                        if ((*i)->IsName(pText) != 0)
                            return (*i)->IsName(pText);
                    return 0;
                }
                
                void Model3D::ConcatenateMeshes(void) {
                    //We only concatenate when there are at least two meshes
                    if (_Meshes.size() < 2)
                        return;
                
                    _TRACE_("Concatenating Meshes ...");
                
                    Mesh* ConcatMesh = NEW Mesh;
                    Mesh* LastMesh = _Meshes.back();
                
                    ConcatMesh->_Name = "ConcatMesh";
                
                    //We create the NEW mesh.
                    //We get the dimensions of the NEW mesh
                    ConcatMesh->_nVertices = LastMesh->_FirstVertex + LastMesh->_nVertices;
                    ConcatMesh->_nFaces = LastMesh->_FirstFace + LastMesh->_nFaces;
                    ConcatMesh->_nTextureCoords = LastMesh->_FirstTextureCoord + LastMesh->_nTextureCoords;
                    ConcatMesh->_nNormals = LastMesh->_FirstNormal + LastMesh->_nNormals;
                    //add tsuge begin
                    ConcatMesh->_nMaterials = LastMesh->_FirstMaterial + LastMesh->_nMaterials;
                    //addtsuge end
                
                
                    //Here we have a control:
                    //Texture coordinates must be as numerous as Vertices or there must be none
                    //Normal vectors must be as numerous as Vertices or there must be none
                    if ((ConcatMesh->_nTextureCoords < ConcatMesh->_nVertices) && (ConcatMesh->_nTextureCoords != 0)) {
                        ConcatMesh->_nTextureCoords = ConcatMesh->_nVertices;
                    }
                    if ((ConcatMesh->_nNormals < ConcatMesh->_nVertices) && (ConcatMesh->_nNormals != 0)) {
                        ConcatMesh->_nNormals = ConcatMesh->_nVertices;
                    }
                
                    _TRACE_("Final number of Vertices:"<< ConcatMesh->_nVertices);
                    _TRACE_("Final number of Faces:"<< ConcatMesh->_nFaces);
                    _TRACE_("Final number of TextureCoords:"<< ConcatMesh->_nTextureCoords);
                    _TRACE_("Final number of Normals:"<< ConcatMesh->_nNormals);
                    _TRACE_("Final number of Materials:"<< ConcatMesh->_nMaterials);
                
                    //We create all the arrays:
                    // - Vertices and Faces
                    // - Material indices per face
                    // - Texture Coords
                    // - Normal vectors and Face Allocation of Normal vectors
                    ConcatMesh->_Vertices = NEW Frm::Vertex[ConcatMesh->_nVertices];
                    memset(ConcatMesh->_Vertices, 0, ConcatMesh->_nVertices
                            * sizeof(Frm::Vertex));
                    ConcatMesh->_Faces = NEW Frm::Face[ConcatMesh->_nFaces];
                    memset(ConcatMesh->_Faces, 0, ConcatMesh->_nFaces * sizeof(Frm::Face));
                    ConcatMesh->_FaceMaterials = NEW uint16[ConcatMesh->_nFaces];
                    memset(ConcatMesh->_FaceMaterials, 0, ConcatMesh->_nFaces * sizeof(uint16));
                    if (ConcatMesh->_nTextureCoords != 0) {
                        ConcatMesh->_TextureCoords
                                = NEW Frm::TCoord[ConcatMesh->_nTextureCoords];
                        memset(ConcatMesh->_TextureCoords, 0, ConcatMesh->_nTextureCoords
                                * sizeof(Frm::TCoord));
                    }
                    if (ConcatMesh->_nNormals != 0) {
                        ConcatMesh->_Normals = NEW Frm::vector<float>[ConcatMesh->_nNormals];
                        ConcatMesh->_FaceNormals = NEW Frm::Face[ConcatMesh->_nFaces];
                        memset(ConcatMesh->_Normals, 0, ConcatMesh->_nNormals
                                * sizeof(Frm::vector<float>));
                        memset(ConcatMesh->_FaceNormals, 0, ConcatMesh->_nFaces
                                * sizeof(Frm::Face));
                    }
                
                    //We fill up the arrays with each array from the _Meshes container
                    for (std::list<Mesh*>::iterator i = _Meshes.begin(); i != _Meshes.end(); i++) {
                        (*i)->UpdateIndices();
                        memcpy(&(ConcatMesh->_Vertices[(*i)->_FirstVertex]), (*i)->_Vertices,
                                (*i)->_nVertices * sizeof(Frm::Vertex));
                        memcpy(&(ConcatMesh->_Faces[(*i)->_FirstFace]), (*i)->_Faces,
                                (*i)->_nFaces * sizeof(Frm::Face));
                        memcpy(&(ConcatMesh->_FaceMaterials[(*i)->_FirstFace]),
                                (*i)->_FaceMaterials, (*i)->_nFaces * sizeof(uint16));
                        if ((*i)->_nTextureCoords != 0)
                            memcpy(&(ConcatMesh->_TextureCoords[(*i)->_FirstTextureCoord]),
                                    (*i)->_TextureCoords, (*i)->_nTextureCoords
                                            * sizeof(Frm::TCoord));
                        if ((*i)->_nNormals != 0) {
                            memcpy(&(ConcatMesh->_Normals[(*i)->_FirstNormal]), (*i)->_Normals,
                                    (*i)->_nNormals * sizeof(Frm::vector<float>));
                            memcpy(&(ConcatMesh->_FaceNormals[(*i)->_FirstFace]),
                                    (*i)->_FaceNormals, (*i)->_nFaces * sizeof(Frm::Face));
                        }
                        while (!(*i)->_Materials.empty()) {
                            ConcatMesh->_Materials.push_back((*i)->_Materials.front());
                            (*i)->_Materials.pop_front();
                        }
                    }
                
                    ////////////////////////////////////////////////////////////
                    //OK. We now process the bone hierarchy to update the
                    //skinning indices
                
                    _TRACE_("Adapting the Bone hierarchy ...");
                    if (_Skeletton != 0)
                        UpdateBoneIndices(_Skeletton);
                    //TODO: B_toplevel_SkelettonsH
                
                    _TRACE_("Bone hierarchy adapted.");
                
                    //We eventually delete all the previous meshes
                    while (!_Meshes.empty()) {
                        delete _Meshes.back();
                        _Meshes.pop_back();
                    }
                
                    //and push the NEW concatenated one
                    _Meshes.push_back(ConcatMesh);
                
                    //We create the subsets
                    ConcatMesh->CreateSubsets();
                
                    _TRACE_("All meshes are concatenated.");
                }
                
                void Model3D::UpdateBoneIndices(Bone* &pBone) {
                    Mesh* BoneMesh = IsMeshName(pBone->_MeshName);
                    if (BoneMesh != 0)
                        pBone->UpdateIndices(BoneMesh->_FirstVertex);
                    pBone->_MeshName = "ConcatMesh";
                    if (!pBone->_Bones.empty())
                        for (std::list<Bone*>::iterator i = pBone->_Bones.begin(); i
                                != pBone->_Bones.end(); i++)
                            UpdateBoneIndices(*i);
                }
                
                /*************************************************
                 NEW- NEW- NEW- NEW- NEW- NEW- NEW- NEW- NEW- NEW*/
                
                AnimationSet* Model3D::FindAnimationSet(std::string &pText) {
                    for (std::list<AnimationSet*>::iterator i = _AnimationSets.begin(); i
                            != _AnimationSets.end(); i++)
                        if ((*i)->IsName(pText) != 0)
                            return (*i)->IsName(pText);
                    return 0;
                }
                /*************************************************/
                


Top 10 Lines:

     Line      Count

       41         21
       12         19
      149         13

Execution Summary:

        6   Executable lines in this file
        5   Lines executed
    83.33   Percent of the file executed

       53   Total number of line executions
     8.83   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/model/GgafDx9D3DXMeshModel.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
           1 -> GgafDx9D3DXMeshModel::GgafDx9D3DXMeshModel(char* prm_model_name, DWORD prm_dwOptions) : GgafDx9Model(prm_model_name) {
                    TRACE("GgafDx9D3DXMeshModel::GgafDx9D3DXMeshModel(" << prm_model_name << ")");
                    _pID3DXMesh = NULL;
                    _dwNumMaterials = 0L;
                    _dwOptions = prm_dwOptions;
                
                    //foCCXXgAeNX`A_A}eA
                    //void GgafDx9ModelManager::restoreD3DXMeshModel(GgafDx9D3DXMeshModel*)
                    //sBvQB
                }
                
                HRESULT GgafDx9D3DXMeshModel::draw(GgafDx9DrawableActor* prm_pActor_Target, int prm_draw_set_num) {
                    TRACE4("GgafDx9D3DXMeshModel::draw("<<prm_pActor_Target->getName()<<")");
                
                    //AN^[
                    GgafDx9D3DXMeshActor* pTargetActor = (GgafDx9D3DXMeshActor*)prm_pActor_Target;
                    //MeshActorGtFNgbp
                    GgafDx9MeshEffect* pMeshEffect = (GgafDx9MeshEffect*)prm_pActor_Target->_pGgafDx9Effect;
                    //GtFNg
                    ID3DXEffect* pID3DXEffect = pMeshEffect->_pID3DXEffect;
                
                    GgafDx9God::_pID3DDevice9->SetFVF(GgafDx9D3DXMeshActor::FVF);
                    HRESULT hr;
                
                    for (DWORD i = 0; i < _dwNumMaterials; i++) {
                        if (GgafDx9ModelManager::_pModelLastDraw != this || _dwNumMaterials != 1) {
                            if (_papTextureCon[i]) {
                                //eNX`Zbg
                                GgafDx9God::_pID3DDevice9->SetTexture(0, _papTextureCon[i]->refer()->_pIDirect3DBaseTexture9);
                            } else {
                                _TRACE_("GgafDx9D3DXMeshModel::draw("<<prm_pActor_Target->getName()<<") eNX`Bwhite.pngB");
                                //eNX`
                                GgafDx9God::_pID3DDevice9->SetTexture(0, NULL);
                            }
                            //}eAZbg
                            //GgafDx9God::_pID3DDevice9->SetMaterial(&(pTargetActor->_paD3DMaterial9[i]));
                            hr = pID3DXEffect->SetValue(pMeshEffect->_h_colMaterialDiffuse, &(pTargetActor->_paD3DMaterial9[i].Diffuse), sizeof(D3DCOLORVALUE) );
                            checkDxException(hr, D3D_OK, "GgafDx9D3DXMeshModel::draw() SetValue(g_colMaterialDiffuse) sB");
                
                
                            hr = pID3DXEffect->SetFloat(pMeshEffect->_h_tex_blink_power, _fPowerBlink);
                            checkDxException(hr, D3D_OK, "GgafDx9D3DXMeshModel::draw() SetFloat(_h_tex_blink_power) sB");
                            hr = pID3DXEffect->SetFloat(pMeshEffect->_h_tex_blink_threshold, _fBlinkThreshold);
                            checkDxException(hr, D3D_OK, "GgafDx9D3DXMeshModel::draw() SetFloat(_h_tex_blink_threshold) sB");
                        }
                
                        //`
                        if ((GgafDx9EffectManager::_pEffect_Active != pMeshEffect || GgafDx9DrawableActor::_hash_technique_last_draw != prm_pActor_Target->_hash_technique) && i == 0) {
                            if (GgafDx9EffectManager::_pEffect_Active) {
                                TRACE4("EndPass("<<GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect<<"): /_pEffect_Active="<<GgafDx9EffectManager::_pEffect_Active->_effect_name<<"("<<GgafDx9EffectManager::_pEffect_Active<<")");
                                hr = GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect->EndPass();
                                checkDxException(hr, D3D_OK, "GgafDx9D3DXMeshModel::draw() EndPass() sB");
                                hr = GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect->End();
                                checkDxException(hr, D3D_OK, "GgafDx9D3DXMeshModel::draw() End() sB");
                
                #ifdef MY_DEBUG
                                if (GgafDx9EffectManager::_pEffect_Active->_begin == false) {
                                    throwGgafCriticalException("begin  "<<(GgafDx9EffectManager::_pEffect_Active==NULL?"NULL":GgafDx9EffectManager::_pEffect_Active->_effect_name)<<"");
                                } else {
                                    GgafDx9EffectManager::_pEffect_Active->_begin = false;
                                }
                #endif
                
                            }
                            TRACE4("SetTechnique("<<pTargetActor->_technique<<"): /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pMeshEffect->_effect_name);
                            hr = pID3DXEffect->SetTechnique(pTargetActor->_technique);
                            checkDxException(hr, S_OK, "GgafDx9D3DXMeshModel::draw() SetTechnique("<<pTargetActor->_technique<<") sB");
                
                            TRACE4("BeginPass("<<pID3DXEffect<<"): /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pMeshEffect->_effect_name<<"("<<pMeshEffect<<")");
                            UINT numPass;
                            hr = pID3DXEffect->Begin( &numPass, D3DXFX_DONOTSAVESTATE );
                            checkDxException(hr, D3D_OK, "GgafDx9D3DXMeshModel::draw() Begin() sB");
                            hr = pID3DXEffect->BeginPass(0);
                            checkDxException(hr, D3D_OK, "GgafDx9D3DXMeshModel::draw() BeginPass(0) sB");
                
                #ifdef MY_DEBUG
                            if (pMeshEffect->_begin == true) {
                                throwGgafCriticalException("End  "<<(GgafDx9EffectManager::_pEffect_Active==NULL?"NULL":GgafDx9EffectManager::_pEffect_Active->_effect_name)<<"");
                            } else {
                                pMeshEffect->_begin = true;
                            }
                #endif
                
                        } else {
                            hr = pID3DXEffect->CommitChanges();
                            checkDxException(hr, D3D_OK, "GgafDx9D3DXMeshModel::draw() CommitChanges() sB");
                        }
                        TRACE4("DrawSubset: /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pMeshEffect->_effect_name);
                        hr = _pID3DXMesh->DrawSubset(i);  //\bhB
                        GgafGod::_num_actor_drawing++;
                    }
                    //O`ff
                    GgafDx9ModelManager::_pModelLastDraw = this;
                    GgafDx9EffectManager::_pEffect_Active = pMeshEffect;
                    GgafDx9DrawableActor::_hash_technique_last_draw = prm_pActor_Target->_hash_technique;
                
                    return D3D_OK;
                }
                
                //VF[_[O
                //        if (pTargetActor->_SX == LEN_UNIT &&
                //            pTargetActor->_SY == LEN_UNIT &&
                //            pTargetActor->_SZ == LEN_UNIT)
                //        {
                //            hr = _pID3DXMesh->DrawSubset(i); //\bhI
                //        } else {
                //            //gkAJgXtH[_@Kij
                //            GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);
                //            hr = _pID3DXMesh->DrawSubset(i); //\bhI
                //            GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_NORMALIZENORMALS, FALSE);
                //        }
                
                
                void GgafDx9D3DXMeshModel::restore() {
                    TRACE3("GgafDx9D3DXMeshModel::restore() " << _model_name << " start");
                    GgafDx9God::_pModelManager->restoreD3DXMeshModel(this);
                    TRACE3("GgafDx9D3DXMeshModel::restore() " << _model_name << " end");
                }
                
                void GgafDx9D3DXMeshModel::onDeviceLost() {
                    TRACE3("GgafDx9D3DXMeshModel::onDeviceLost() " << _model_name << " start");
                    //foCXXgB
                    release();
                    TRACE3("GgafDx9D3DXMeshModel::onDeviceLost() " << _model_name << " end");
                }
                
                void GgafDx9D3DXMeshModel::release() {
                    TRACE3("GgafDx9D3DXMeshModel::release() " << _model_name << " start");
                    if (_pID3DXMesh == NULL) {
                        _TRACE_("x [GgafDx9D3DXMeshModel::release()]  "<<_model_name<<"  _pID3DXMesh IuWFNg release I");
                    }
                    //eNX`
                    if (_papTextureCon) {
                        for (int i = 0; i < (int)_dwNumMaterials; i++) {
                            if (_papTextureCon[i]) {
                                TRACE3("close() _papTextureCon["<<i<<"]->"<<(_papTextureCon[i]->getIdStr()));
                                _papTextureCon[i]->close();
                            }
                        }
                    }
                    DELETEARR_IMPOSSIBLE_NULL(_papTextureCon); //eNX`z
                    RELEASE_IMPOSSIBLE_NULL(_pID3DXMesh);
                
                    //TODO:eNXoDELETE
                    DELETEARR_IMPOSSIBLE_NULL(_paD3DMaterial9_default);
                
                    TRACE3("GgafDx9D3DXMeshModel::release() " << _model_name << " end");
                }
                
           2 -> GgafDx9D3DXMeshModel::~GgafDx9D3DXMeshModel() {
                    //release();
                    //GgafDx9ModelConnection::processReleaseResource(GgafDx9Model* prm_pResource) o
                }


Top 10 Lines:

     Line      Count

      155          2
        6          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/manager/GgafDx9TextureManager.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
           1 -> GgafDx9TextureManager::GgafDx9TextureManager(const char* prm_manager_name) :
                    GgafResourceManager<GgafDx9Texture> (prm_manager_name) {
                }
                
                GgafDx9Texture* GgafDx9TextureManager::processCreateResource(char* prm_idstr, void* prm_p) {
                    GgafDx9Texture* pResourceTexture;
                    pResourceTexture = NEW GgafDx9Texture(prm_idstr);
                    TRACE3(" GgafDx9TextureManager::processCreateResource "<<prm_idstr<<" eNX`B");
                    return pResourceTexture;
                }
                
                GgafResourceConnection<GgafDx9Texture>* GgafDx9TextureManager::processCreateConnection(char* prm_idstr, GgafDx9Texture* prm_pResource) {
                    TRACE3(" GgafDx9TextureManager::processCreateConnection "<<prm_idstr<<" JnB");
                    GgafDx9TextureConnection* pConnection = NEW GgafDx9TextureConnection(prm_idstr, prm_pResource);
                    TRACE3(" GgafDx9TextureManager::processCreateConnection "<<prm_idstr<<" IB");
                    return pConnection;
                }
                


Top 10 Lines:

     Line      Count

        6          1

Execution Summary:

        2   Executable lines in this file
        1   Lines executed
    50.00   Percent of the file executed

        1   Total number of line executions
     0.50   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9Core/include/jp/ggaf/dx9core/manager/GgafDx9TextureManager.h:
                #ifndef GGAFDX9TEXTUREMANAGER_H_
                #define GGAFDX9TEXTUREMANAGER_H_
                namespace GgafDx9Core {
                
                /**
                 * GgafDx9TextureConnection NX .
                 *  GgafDx9TextureConnection IuWFNgo^AgB
                 * @version 1.00
                 * @since 2009/01/26
                 * @author Masatoshi Tsuge
                 */
                class GgafDx9TextureManager : public GgafCore::GgafResourceManager<GgafDx9Texture> {
                
                public:
                
                    /**
                     * RXgN^
                     * @param prm_manager_name }l[W(eK{)
                     */
                    GgafDx9TextureManager(const char* prm_manager_name);
                
                    /**
                     * I[o[Ch
                     */
                    GgafDx9Texture* processCreateResource(char* prm_idstr, void* prm_p);
                
                    /**
                     * I[o[Ch
                     */
                    GgafCore::GgafResourceConnection<GgafDx9Texture>* processCreateConnection(char* prm_idstr, GgafDx9Texture* prm_pResource);
                
           2 ->     virtual ~GgafDx9TextureManager() {
                    }
                };
                
                }
                #endif /*GGAFDX9TEXTUREMANAGER_H_*/


Top 10 Lines:

     Line      Count

       32          2

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     2.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/model/GgafDx9PointSpriteModel.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                DWORD GgafDx9PointSpriteModel::FVF = (D3DFVF_XYZ | D3DFVF_PSIZE | D3DFVF_DIFFUSE | D3DFVF_TEX1);
                
           1 -> GgafDx9PointSpriteModel::GgafDx9PointSpriteModel(char* prm_model_name) : GgafDx9Model(prm_model_name) {
                    TRACE3("GgafDx9PointSpriteModel::GgafDx9PointSpriteModel(" << _model_name << ")");
                    _pIDirect3DVertexBuffer9 = NULL;
                
                    //foCCXXgAeNX`A_A}eA
                    //void GgafDx9ModelManager::restorePointSpriteModel(GgafDx9PointSpriteModel*)
                    //sBvQB
                }
                
                //`
                HRESULT GgafDx9PointSpriteModel::draw(GgafDx9DrawableActor* prm_pActor_Target, int prm_draw_set_num) {
                    TRACE4("GgafDx9PointSpriteModel::draw("<<prm_pActor_Target->getName()<<") this="<<getName());
                
                    //Actor
                    GgafDx9PointSpriteActor* pTargetActor = (GgafDx9PointSpriteActor*)prm_pActor_Target;
                    //PointSpriteActorGtFNgbp
                    GgafDx9PointSpriteEffect* pPointSpriteEffect = (GgafDx9PointSpriteEffect*)prm_pActor_Target->_pGgafDx9Effect;
                    //GtFNg
                    ID3DXEffect* pID3DXEffect = pPointSpriteEffect->_pID3DXEffect;
                
                    //`UV
                    HRESULT hr;
                    if (GgafDx9ModelManager::_pModelLastDraw != this) {
                        GgafDx9God::_pID3DDevice9->SetStreamSource(0, _pIDirect3DVertexBuffer9, 0, _size_vertex_unit);
                        GgafDx9God::_pID3DDevice9->SetFVF(GgafDx9PointSpriteModel::FVF);
                        GgafDx9God::_pID3DDevice9->SetTexture(0, _papTextureCon[0]->refer()->_pIDirect3DBaseTexture9);
                
                        hr = pID3DXEffect->SetFloat(pPointSpriteEffect->_h_tex_blink_power, _fPowerBlink);
                        checkDxException(hr, D3D_OK, "GgafDx9PointSpriteActor::draw() SetFloat(_h_tex_blink_power) sB");
                        hr = pID3DXEffect->SetFloat(pPointSpriteEffect->_h_tex_blink_threshold, _fBlinkThreshold);
                        checkDxException(hr, D3D_OK, "GgafDx9PointSpriteActor::draw() SetFloat(_h_tex_blink_threshold) sB");
                        hr = pID3DXEffect->SetFloat(pPointSpriteEffect->_hTexSize, _fTexSize);
                //                _TRACE_("_fTexSize="<<_fTexSize);
                        checkDxException(hr, D3D_OK, "GgafDx9PointSpriteActor::draw() SetFloat(_hTexSize) sB");
                        hr = pID3DXEffect->SetInt(pPointSpriteEffect->_hTextureSplitRowcol, _texture_split_rowcol);
                //                _TRACE_("_texture_split_rowcol="<<_texture_split_rowcol);
                        checkDxException(hr, D3D_OK, "GgafDx9PointSpriteActor::draw() SetInt(_hTextureSplitRowcol) sB");
                
                    }
                
                
                    if (GgafDx9EffectManager::_pEffect_Active != pPointSpriteEffect || GgafDx9DrawableActor::_hash_technique_last_draw != prm_pActor_Target->_hash_technique)  {
                        if (GgafDx9EffectManager::_pEffect_Active) {
                            TRACE4("EndPass("<<GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect<<"): /_pEffect_Active="<<GgafDx9EffectManager::_pEffect_Active->_effect_name<<"("<<GgafDx9EffectManager::_pEffect_Active<<")");
                            hr = GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect->EndPass();
                            checkDxException(hr, D3D_OK, "GgafDx9PointSpriteActor::draw() EndPass() sB");
                            hr = GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect->End();
                            checkDxException(hr, D3D_OK, "GgafDx9PointSpriteActor::draw() End() sB");
                
                #ifdef MY_DEBUG
                            if (GgafDx9EffectManager::_pEffect_Active->_begin == false) {
                                throwGgafCriticalException("begin  "<<(GgafDx9EffectManager::_pEffect_Active==NULL?"NULL":GgafDx9EffectManager::_pEffect_Active->_effect_name)<<"");
                            } else {
                                GgafDx9EffectManager::_pEffect_Active->_begin = false;
                            }
                #endif
                
                        }
                        TRACE4("SetTechnique("<<pTargetActor->_technique<<"): /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pPointSpriteEffect->_effect_name);
                        hr = pID3DXEffect->SetTechnique(pTargetActor->_technique);
                        checkDxException(hr, S_OK, "GgafDx9PointSpriteActor::draw() SetTechnique("<<pTargetActor->_technique<<") sB");
                
                        TRACE4("BeginPass("<<pID3DXEffect<<"): /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pPointSpriteEffect->_effect_name<<"("<<pPointSpriteEffect<<")");
                        UINT numPass;
                        hr = pID3DXEffect->Begin( &numPass, D3DXFX_DONOTSAVESTATE );
                        checkDxException(hr, D3D_OK, "GgafDx9PointSpriteActor::draw() Begin() sB");
                        hr = pID3DXEffect->BeginPass(0);
                        checkDxException(hr, D3D_OK, "GgafDx9PointSpriteActor::draw() BeginPass(0) sB");
                
                #ifdef MY_DEBUG
                        if (pPointSpriteEffect->_begin == true) {
                            throwGgafCriticalException("End  "<<(GgafDx9EffectManager::_pEffect_Active==NULL?"NULL":GgafDx9EffectManager::_pEffect_Active->_effect_name)<<"");
                        } else {
                            pPointSpriteEffect->_begin = true;
                        }
                #endif
                
                    } else {
                        hr = pID3DXEffect->CommitChanges();
                        checkDxException(hr, D3D_OK, "GgafDx9PointSpriteModel::draw() CommitChanges() sB");
                    }
                    TRACE4("DrawPrimitive: /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pPointSpriteEffect->_effect_name);
                    GgafDx9God::_pID3DDevice9->DrawPrimitive(D3DPT_POINTLIST, 0, _vertices_num);
                
                    //O`f
                    GgafDx9ModelManager::_pModelLastDraw = this;
                    GgafDx9EffectManager::_pEffect_Active = pPointSpriteEffect;
                    GgafDx9DrawableActor::_hash_technique_last_draw = prm_pActor_Target->_hash_technique;
                    //O`UVWi|C^j
                    GgafGod::_num_actor_drawing++;
                    return D3D_OK;
                }
                
                void GgafDx9PointSpriteModel::restore() {
                    TRACE3("GgafDx9PointSpriteModel::restore() " << _model_name << " start");
                    GgafDx9God::_pModelManager->restorePointSpriteModel(this);
                    TRACE3("GgafDx9PointSpriteModel::restore() " << _model_name << " end");
                }
                
                void GgafDx9PointSpriteModel::onDeviceLost() {
                    TRACE3("GgafDx9PointSpriteModel::onDeviceLost() " << _model_name << " start");
                    release();
                    TRACE3("GgafDx9PointSpriteModel::onDeviceLost() " << _model_name << " end");
                }
                
                void GgafDx9PointSpriteModel::release() {
                    TRACE3("GgafDx9PointSpriteModel::release() " << _model_name << " start");
                    RELEASE_IMPOSSIBLE_NULL(_pIDirect3DVertexBuffer9);
                    DELETEARR_IMPOSSIBLE_NULL(_paVtxBuffer_org);
                    if (_papTextureCon) {
                        if (_papTextureCon[0]) {
                            _papTextureCon[0]->close();
                        }
                    }
                    DELETEARR_IMPOSSIBLE_NULL(_papTextureCon);
                    //TODO:eNXoDELETE
                    DELETEARR_IMPOSSIBLE_NULL(_paD3DMaterial9_default);
                    TRACE3("GgafDx9PointSpriteModel::release() " << _model_name << " end");
                }
                
           2 -> GgafDx9PointSpriteModel::~GgafDx9PointSpriteModel() {
                    //release();
                    //GgafDx9ModelConnection::processReleaseResource(GgafDx9Model* prm_pResource) o
                }
                


Top 10 Lines:

     Line      Count

      128          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/model/GgafDx9MeshSetModel.cpp:
                #include "stdafx.h"
                
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                DWORD GgafDx9MeshSetModel::FVF = (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_PSIZE | D3DFVF_DIFFUSE | D3DFVF_TEX1  );
                int GgafDx9MeshSetModel::_draw_set_num_LastDraw = -1;
                //LPDIRECT3DVERTEXBUFFER9 _pIDirect3DVertexBuffer9 = NULL;
                
          10 -> GgafDx9MeshSetModel::GgafDx9MeshSetModel(char* prm_model_name) : GgafDx9Model(prm_model_name) {
                    TRACE3("GgafDx9MeshSetModel::GgafDx9MeshSetModel(" << _model_name << ")");
                    _pModel3D = NULL;
                    _pMeshesFront = NULL;
                    // prm_model_name  "xxxxxx" or "8/xxxxx" AnB
                    // `Zbg8B
                    // [t^[QbgfAfAflcB
                    // f`ZbgwoB8
                    char nm[51];
                    strcpy(nm, prm_model_name);
                    const char* pT = strtok(nm, "/" );
                    int num = (int)strtol(pT, NULL, 10);
                    pT = strtok(NULL, "/");
                    if (pT == NULL) {
                        _TRACE_("GgafDx9MeshSetModel("<<prm_model_name<<") ZbgAW15ZbgB");
                        _set_num = 15;
                    } else {
                        _set_num = num;
                        if (_set_num > 15) {
                            _TRACE_("GgafDx9MeshSetModel("<<prm_model_name<<") `ZbgI[o[B15ZbgB}H _set_num="<<_set_num<<"B");
                        }
                    }
                    _pIDirect3DVertexBuffer9 = NULL;
                    _pIDirect3DIndexBuffer9 = NULL;
                    _pa_nMaterialListGrp = NULL;
                    _paVtxBuffer_org = NULL;
                    _paIdxBuffer_org = NULL;
                    _papaIndexParam = NULL;
                    //foCCXXgAeNX`A_A}eAo[
                    //void GgafDx9ModelManager::restoreMeshSetModel(GgafDx9MeshSetModel*)
                    //sBvQB
                    _TRACE_("GgafDx9MeshSetModel::GgafDx9MeshSetModel(" << _model_name << ") End");
                }
                
                //`
                HRESULT GgafDx9MeshSetModel::draw(GgafDx9DrawableActor* prm_pActor_Target, int prm_draw_set_num) {
                    TRACE4("GgafDx9MeshSetModel::draw("<<prm_pActor_Target->getName()<<") this="<<getName());
                    //AN^[
                    GgafDx9MeshSetActor* pTargetActor = (GgafDx9MeshSetActor*)prm_pActor_Target;
                    //MeshSetActorGtFNgbp
                    GgafDx9MeshSetEffect* pMeshSetEffect = (GgafDx9MeshSetEffect*)prm_pActor_Target->_pGgafDx9Effect;
                    //GtFNg
                    ID3DXEffect* pID3DXEffect = pMeshSetEffect->_pID3DXEffect;
                
                    HRESULT hr;
                    UINT material_no;
                
                    //fAZbg_obt@ACfbNXobt@XLbv
                    if (GgafDx9ModelManager::_pModelLastDraw  != this) {
                        //_obt@CfbNXobt@
                        GgafDx9God::_pID3DDevice9->SetStreamSource(0, _pIDirect3DVertexBuffer9,  0, _size_vertex_unit);
                        GgafDx9God::_pID3DDevice9->SetFVF(GgafDx9MeshSetModel::FVF);
                        GgafDx9God::_pID3DDevice9->SetIndices(_pIDirect3DIndexBuffer9);
                
                        hr = pID3DXEffect->SetFloat(pMeshSetEffect->_h_tex_blink_power, _fPowerBlink);
                        checkDxException(hr, D3D_OK, "GgafDx9MeshSetModel::draw() SetFloat(_h_tex_blink_power) sB");
                        hr = pID3DXEffect->SetFloat(pMeshSetEffect->_h_tex_blink_threshold, _fBlinkThreshold);
                        checkDxException(hr, D3D_OK, "GgafDx9MeshSetModel::draw() SetFloat(_h_tex_blink_threshold) sB");
                    }
                
                
                    //`
                    for (UINT material_grp_index = 0; material_grp_index < _pa_nMaterialListGrp[prm_draw_set_num-1]; material_grp_index++) {
                        // TODO
                        //fAZbgA}eANOPAeNX`XLbv
                        if (GgafDx9ModelManager::_pModelLastDraw  != this      ||
                            //GgafDx9MeshSetModel::_draw_set_num_LastDraw != draw_set_num ||
                            _pa_nMaterialListGrp[prm_draw_set_num-1] != 1)
                        {
                            material_no = _papaIndexParam[prm_draw_set_num-1][material_grp_index].MaterialNo;
                            if (_papTextureCon[material_no]) {
                                //eNX`s0WX^Zbg
                                GgafDx9God::_pID3DDevice9->SetTexture(0, _papTextureCon[material_no]->refer()->_pIDirect3DBaseTexture9);
                            } else {
                                _TRACE_("GgafDx9MeshSetModel::draw("<<prm_pActor_Target->getName()<<") eNX`Bwhite.pngB");
                                //eNX`
                                GgafDx9God::_pID3DDevice9->SetTexture(0, NULL);
                            }
                            //MaterialDiffuseGgafDx9MeshSetActor}eAB}eAFPFB
                            //RGgafDx9MeshSetActoryGgafDx9MeshSetActor}eAJ[zQ
                        }
                
                
                        if (material_grp_index == 0 && (GgafDx9EffectManager::_pEffect_Active != pMeshSetEffect || GgafDx9DrawableActor::_hash_technique_last_draw != prm_pActor_Target->_hash_technique)) {
                            if (GgafDx9EffectManager::_pEffect_Active) {
                                TRACE4("EndPass("<<GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect<<"): /_pEffect_Active="<<GgafDx9EffectManager::_pEffect_Active->_effect_name<<"("<<GgafDx9EffectManager::_pEffect_Active<<")");
                                hr = GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect->EndPass();
                                checkDxException(hr, D3D_OK, "GgafDx9MeshSetModel::draw() EndPass() sB");
                                hr = GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect->End();
                                checkDxException(hr, D3D_OK, "GgafDx9MeshSetModel::draw() End() sB");
                
                #ifdef MY_DEBUG
                                if (GgafDx9EffectManager::_pEffect_Active->_begin == false) {
                                    throwGgafCriticalException("begin  "<<(GgafDx9EffectManager::_pEffect_Active==NULL?"NULL":GgafDx9EffectManager::_pEffect_Active->_effect_name)<<"");
                                } else {
                                    GgafDx9EffectManager::_pEffect_Active->_begin = false;
                                }
                #endif
                
                            }
                            TRACE4("SetTechnique("<<pTargetActor->_technique<<"): /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pMeshSetEffect->_effect_name);
                            hr = pID3DXEffect->SetTechnique(pTargetActor->_technique);
                            checkDxException(hr, S_OK, "GgafDx9MeshSetModel::draw() SetTechnique("<<pTargetActor->_technique<<") sB");
                
                            TRACE4("BeginPass("<<pID3DXEffect<<"): /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pMeshSetEffect->_effect_name<<"("<<pMeshSetEffect<<")");
                            UINT numPass;
                            hr = pID3DXEffect->Begin( &numPass, D3DXFX_DONOTSAVESTATE );
                            checkDxException(hr, D3D_OK, "GgafDx9MeshSetModel::draw() Begin() sB");
                            hr = pID3DXEffect->BeginPass(0);
                            checkDxException(hr, D3D_OK, "GgafDx9MeshSetModel::draw() BeginPass(0) sB");
                
                #ifdef MY_DEBUG
                            if (pMeshSetEffect->_begin == true) {
                                throwGgafCriticalException("End  "<<(GgafDx9EffectManager::_pEffect_Active==NULL?"NULL":GgafDx9EffectManager::_pEffect_Active->_effect_name)<<"");
                            } else {
                                pMeshSetEffect->_begin = true;
                            }
                #endif
                
                        } else {
                            hr = pID3DXEffect->CommitChanges();
                            checkDxException(hr, D3D_OK, "GgafDx9MeshSetModel::draw() CommitChanges() sB");
                        }
                        TRACE4("DrawIndexedPrimitive: /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pMeshSetEffect->_effect_name);
                        GgafDx9God::_pID3DDevice9->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,
                                                        _papaIndexParam[prm_draw_set_num-1][material_grp_index].BaseVertexIndex,
                                                        _papaIndexParam[prm_draw_set_num-1][material_grp_index].MinIndex,
                                                        _papaIndexParam[prm_draw_set_num-1][material_grp_index].NumVertices,
                                                        _papaIndexParam[prm_draw_set_num-1][material_grp_index].StartIndex,
                                                        _papaIndexParam[prm_draw_set_num-1][material_grp_index].PrimitiveCount);
                        GgafGod::_num_actor_drawing++;
                    }
                    GgafDx9ModelManager::_pModelLastDraw = this;
                    GgafDx9MeshSetModel::_draw_set_num_LastDraw = prm_draw_set_num;
                    GgafDx9EffectManager::_pEffect_Active = pMeshSetEffect;
                    GgafDx9DrawableActor::_hash_technique_last_draw = prm_pActor_Target->_hash_technique;
                    return D3D_OK;
                }
                
                void GgafDx9MeshSetModel::restore() {
                    TRACE3("GgafDx9MeshSetModel::restore() " << _model_name << " start");
                    GgafDx9God::_pModelManager->restoreMeshSetModel(this);
                    TRACE3("GgafDx9MeshSetModel::restore() " << _model_name << " end");
                }
                
                void GgafDx9MeshSetModel::onDeviceLost() {
                    TRACE3("GgafDx9MeshSetModel::onDeviceLost() " << _model_name << " start");
                    release();
                    TRACE3("GgafDx9MeshSetModel::onDeviceLost() " << _model_name << " end");
                }
                
                void GgafDx9MeshSetModel::release() {
                    TRACE3("GgafDx9MeshSetModel::release() " << _model_name << " start");
                
                    //eNX`
                    if (_papTextureCon) {
                        for (int i = 0; i < (int)_dwNumMaterials; i++) {
                            if (_papTextureCon[i]) {
                                TRACE3("close() _papTextureCon["<<i<<"]->"<<(_papTextureCon[i]->getIdStr()));
                                _papTextureCon[i]->close();
                            }
                        }
                    }
                    DELETEARR_IMPOSSIBLE_NULL(_papTextureCon); //eNX`z
                    RELEASE_IMPOSSIBLE_NULL(_pIDirect3DVertexBuffer9);
                    RELEASE_IMPOSSIBLE_NULL(_pIDirect3DIndexBuffer9);
                
                    DELETEARR_IMPOSSIBLE_NULL(_paVtxBuffer_org);
                    DELETEARR_IMPOSSIBLE_NULL(_paIdxBuffer_org);
                
                    DELETE_IMPOSSIBLE_NULL(_pModel3D);
                    //_pMeshesFront  _pModel3D DELETEKv
                    _pMeshesFront = NULL;
                    for (int i = 0; i < _set_num; i++) {
                        DELETEARR_IMPOSSIBLE_NULL(_papaIndexParam[i]);
                    }
                    DELETEARR_IMPOSSIBLE_NULL(_papaIndexParam);
                    DELETEARR_IMPOSSIBLE_NULL(_pa_nMaterialListGrp);
                
                    //TODO:eNXoDELETE
                    DELETEARR_IMPOSSIBLE_NULL(_paD3DMaterial9_default);
                
                    TRACE3("GgafDx9MeshSetModel::release() " << _model_name << " end");
                
                }
          20 -> GgafDx9MeshSetModel::~GgafDx9MeshSetModel() {
                    //release();
                    //GgafDx9ModelConnection::processReleaseResource(GgafDx9Model* prm_pResource) o
                }
                


Top 10 Lines:

     Line      Count

      196         20
       11         10

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       30   Total number of line executions
    10.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/model/GgafDx9BoardSetModel.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                DWORD GgafDx9BoardSetModel::FVF = (D3DFVF_XYZ | D3DFVF_PSIZE | D3DFVF_TEX1);
                int GgafDx9BoardSetModel::_draw_set_num_LastDraw = -1;
           4 -> GgafDx9BoardSetModel::GgafDx9BoardSetModel(char* prm_model_name) : GgafDx9Model(prm_model_name) {
                    TRACE3("GgafDx9BoardSetModel::GgafDx9BoardSetModel(" << _model_name << ")");
                
                    _fSize_BoardSetModelWidthPx = 32.0f;
                    _fSize_BoardSetModelHeightPx = 32.0f;
                    _row_texture_split = 1;
                    _col_texture_split = 1;
                    _pattno_max = 1;
                
                    _pIDirect3DVertexBuffer9 = NULL;
                    _pIDirect3DIndexBuffer9 = NULL;
                    _paRectUV = NULL;
                
                    char nm[51];
                    strcpy(nm, prm_model_name);
                    const char* pT = strtok(nm, "/" );
                    int num = (int)strtol(pT, NULL, 10);
                    pT = strtok(NULL, "/");
                    if (pT == NULL) {
                        _TRACE_("GgafDx9BoardSetModel("<<prm_model_name<<") `ZbgA28ZbgB");
                        _set_num = 28;
                    } else {
                        _set_num = num;
                        if (_set_num > 28) {
                            _TRACE_("GgafDx9BoardSetModel("<<prm_model_name<<") `ZbgI[o[B28ZbgAZbgB}H_set_num="<<_set_num);
                        }
                    }
                    //foCCXXgAeNX`A_A}eA
                    //void GgafDx9ModelManager::restoreBoardSetModel(GgafDx9BoardSetModel*)
                    //sBvQB
                }
                
                //`
                HRESULT GgafDx9BoardSetModel::draw(GgafDx9DrawableActor* prm_pActor_Target, int prm_draw_set_num) {
                    TRACE4("GgafDx9BoardSetModel::draw("<<prm_pActor_Target->getName()<<") this="<<getName());
                
                    //Actor
                    GgafDx9BoardSetActor* pTargetActor = (GgafDx9BoardSetActor*)prm_pActor_Target;
                    //BoardSetActorGtFNgbp
                    GgafDx9BoardSetEffect* pBoardSetEffect = (GgafDx9BoardSetEffect*)prm_pActor_Target->_pGgafDx9Effect;
                    //GtFNg
                    ID3DXEffect* pID3DXEffect = pBoardSetEffect->_pID3DXEffect;
                
                    HRESULT hr;
                    //f_obt@AXLbv
                    if (GgafDx9ModelManager::_pModelLastDraw  != this) {
                        GgafDx9God::_pID3DDevice9->SetStreamSource(0, _pIDirect3DVertexBuffer9, 0, _size_vertex_unit);
                        GgafDx9God::_pID3DDevice9->SetFVF(GgafDx9BoardSetModel::FVF);
                        GgafDx9God::_pID3DDevice9->SetTexture(0, _papTextureCon[0]->refer()->_pIDirect3DBaseTexture9);
                        GgafDx9God::_pID3DDevice9->SetIndices(_pIDirect3DIndexBuffer9);
                
                        hr = pID3DXEffect->SetFloat(pBoardSetEffect->_h_tex_blink_power, _fPowerBlink);
                        checkDxException(hr, D3D_OK, "GgafDx9BoardSetActor::draw() SetFloat(_h_tex_blink_power) sB");
                        hr = pID3DXEffect->SetFloat(pBoardSetEffect->_h_tex_blink_threshold, _fBlinkThreshold);
                        checkDxException(hr, D3D_OK, "GgafDx9BoardSetActor::draw() SetFloat(_h_tex_blink_threshold) sB");
                    }
                
                    if (GgafDx9EffectManager::_pEffect_Active != pBoardSetEffect || GgafDx9DrawableActor::_hash_technique_last_draw != prm_pActor_Target->_hash_technique)  {
                        if (GgafDx9EffectManager::_pEffect_Active) {
                           TRACE4("EndPass("<<GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect<<"): /_pEffect_Active="<<GgafDx9EffectManager::_pEffect_Active->_effect_name<<"("<<GgafDx9EffectManager::_pEffect_Active<<")");
                            hr = GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect->EndPass();
                            checkDxException(hr, D3D_OK, "GgafDx9BoardSetActor::draw() EndPass() sB");
                            hr = GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect->End();
                            checkDxException(hr, D3D_OK, "GgafDx9BoardSetActor::draw() End() sB");
                
                #ifdef MY_DEBUG
                            if (GgafDx9EffectManager::_pEffect_Active->_begin == false) {
                                throwGgafCriticalException("begin  "<<(GgafDx9EffectManager::_pEffect_Active==NULL?"NULL":GgafDx9EffectManager::_pEffect_Active->_effect_name)<<"");
                            } else {
                                GgafDx9EffectManager::_pEffect_Active->_begin = false;
                            }
                #endif
                
                        }
                        TRACE4("SetTechnique("<<pTargetActor->_technique<<"): /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pBoardSetEffect->_effect_name);
                        hr = pID3DXEffect->SetTechnique(pTargetActor->_technique);
                        checkDxException(hr, S_OK, "GgafDx9BoardSetActor::draw() SetTechnique("<<pTargetActor->_technique<<") sB");
                
                        TRACE4("BeginPass("<<pID3DXEffect<<"): /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pBoardSetEffect->_effect_name<<"("<<pBoardSetEffect<<")");
                        UINT numPass;
                        hr = pID3DXEffect->Begin( &numPass, D3DXFX_DONOTSAVESTATE );
                        checkDxException(hr, D3D_OK, "GgafDx9BoardSetActor::draw() Begin() sB");
                        hr = pID3DXEffect->BeginPass(0);
                        checkDxException(hr, D3D_OK, "GgafDx9BoardSetActor::draw() BeginPass(0) sB");
                
                #ifdef MY_DEBUG
                        if (pBoardSetEffect->_begin == true) {
                            throwGgafCriticalException("End  "<<(GgafDx9EffectManager::_pEffect_Active==NULL?"NULL":GgafDx9EffectManager::_pEffect_Active->_effect_name)<<"");
                        } else {
                            pBoardSetEffect->_begin = true;
                        }
                #endif
                
                    } else {
                        hr = pID3DXEffect->CommitChanges();
                        checkDxException(hr, D3D_OK, "GgafDx9BoardSetModel::draw() CommitChanges() sB");
                    }
                    TRACE4("DrawIndexedPrimitive: /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pBoardSetEffect->_effect_name);
                    GgafDx9God::_pID3DDevice9->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,
                                                                    _paIndexParam[prm_draw_set_num-1].BaseVertexIndex,
                                                                    _paIndexParam[prm_draw_set_num-1].MinIndex,
                                                                    _paIndexParam[prm_draw_set_num-1].NumVertices,
                                                                    _paIndexParam[prm_draw_set_num-1].StartIndex,
                                                                    _paIndexParam[prm_draw_set_num-1].PrimitiveCount);
                
                    //O`f
                    GgafDx9ModelManager::_pModelLastDraw = this;
                    GgafDx9BoardSetModel::_draw_set_num_LastDraw = prm_draw_set_num;
                    GgafDx9EffectManager::_pEffect_Active = pBoardSetEffect;
                    GgafDx9DrawableActor::_hash_technique_last_draw = prm_pActor_Target->_hash_technique;
                    GgafGod::_num_actor_drawing++;
                    return D3D_OK;
                }
                
                void GgafDx9BoardSetModel::restore() {
                    TRACE3("GgafDx9BoardSetModel::restore() " << _model_name << " start");
                    GgafDx9God::_pModelManager->restoreBoardSetModel(this);
                    TRACE3("GgafDx9BoardSetModel::restore() " << _model_name << " end");
                }
                
                void GgafDx9BoardSetModel::onDeviceLost() {
                    TRACE3("GgafDx9BoardSetModel::onDeviceLost() " << _model_name << " start");
                    release();
                    TRACE3("GgafDx9BoardSetModel::onDeviceLost() " << _model_name << " end");
                }
                
                void GgafDx9BoardSetModel::release() {
                    TRACE3("GgafDx9BoardSetModel::release() " << _model_name << " start");
                    RELEASE_IMPOSSIBLE_NULL(_pIDirect3DVertexBuffer9);
                    RELEASE_IMPOSSIBLE_NULL(_pIDirect3DIndexBuffer9);
                    if (_papTextureCon) {
                        if (_papTextureCon[0]) {
                            _papTextureCon[0]->close();
                        }
                    }
                    DELETEARR_IMPOSSIBLE_NULL(_papTextureCon);
                    DELETEARR_IMPOSSIBLE_NULL(_paRectUV);
                    DELETEARR_IMPOSSIBLE_NULL(_paIndexParam);
                    //TODO:eNXoDELETE
                    DELETEARR_IMPOSSIBLE_NULL(_paD3DMaterial9_default);
                    TRACE3("GgafDx9BoardSetModel::release() " << _model_name << " end");
                }
                
           8 -> GgafDx9BoardSetModel::~GgafDx9BoardSetModel() {
                    //release();
                    //GgafDx9ModelConnection::processReleaseResource(GgafDx9Model* prm_pResource) o
                }
                


Top 10 Lines:

     Line      Count

      151          8
        8          4

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       12   Total number of line executions
     4.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/model/GgafDx9BoardModel.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                DWORD GgafDx9BoardModel::FVF = (D3DFVF_XYZ | D3DFVF_TEX1);
                
           2 -> GgafDx9BoardModel::GgafDx9BoardModel(char* prm_model_name) :
                    GgafDx9Model(prm_model_name) {
                    TRACE3("GgafDx9BoardModel::GgafDx9BoardModel(" << _model_name << ")");
                    _fSize_BoardModelWidthPx = 32.0f;
                    _fSize_BoardModelHeightPx = 32.0f;
                    _row_texture_split = 1;
                    _col_texture_split = 1;
                    _pattno_max = 1;
                    _pIDirect3DVertexBuffer9 = NULL;
                    _paRectUV = NULL;
                
                    //foCCXXgAeNX`A_A}eA
                    //void GgafDx9ModelManager::restoreBoardModel(GgafDx9BoardModel*)
                    //sB
                }
                
                HRESULT GgafDx9BoardModel::draw(GgafDx9DrawableActor* prm_pActor_Target, int prm_draw_set_num) {
                    TRACE4("GgafDx9BoardModel::draw("<<prm_pActor_Target->getName()<<") this="<<getName());
                    //TODO NA
                    //GgafDx9God::_pID3DDevice9->Clear(0, NULL, D3DCLEAR_ZBUFFER, 0x000000, 1.0, 0);
                    //TODO NAlNB
                
                    //Actor
                    GgafDx9BoardActor* pTargetActor = (GgafDx9BoardActor*)prm_pActor_Target;
                    //BoardActorGtFNgbp
                    GgafDx9BoardEffect* pBoardEffect = (GgafDx9BoardEffect*)prm_pActor_Target->_pGgafDx9Effect;
                    //GtFNg
                    ID3DXEffect* pID3DXEffect = pBoardEffect->_pID3DXEffect;
                    //`UV
                    GgafDx9RectUV* pRectUV_Active = _paRectUV + (pTargetActor->_pUvFlipper->_pattno_uvflip_now);
                
                    HRESULT hr;
                    if (GgafDx9ModelManager::_pModelLastDraw != this) {
                        GgafDx9God::_pID3DDevice9->SetStreamSource(0, _pIDirect3DVertexBuffer9, 0, _size_vertex_unit);
                        GgafDx9God::_pID3DDevice9->SetFVF(GgafDx9BoardModel::FVF);
                        GgafDx9God::_pID3DDevice9->SetTexture(0, _papTextureCon[0]->refer()->_pIDirect3DBaseTexture9);
                        //GgafDx9God::_pID3DDevice9->SetTexture(1, _papTextureCon[0]->refer()->_pIDirect3DBaseTexture9);
                
                        hr = pID3DXEffect->SetFloat(pBoardEffect->_h_tex_blink_power, _fPowerBlink);
                        checkDxException(hr, D3D_OK, "GgafDx9BoardModel::draw() SetFloat(_h_tex_blink_power) sB");
                        hr = pID3DXEffect->SetFloat(pBoardEffect->_h_tex_blink_threshold, _fBlinkThreshold);
                        checkDxException(hr, D3D_OK, "GgafDx9BoardModel::draw() SetFloat(_h_tex_blink_threshold) sB");
                    }
                    hr = pID3DXEffect->SetFloat(pBoardEffect->_hOffsetU, pRectUV_Active->_aUV[0].tu);
                    checkDxException(hr, D3D_OK, "GgafDx9BoardModel::draw() SetFloat(_hOffsetU) sB");
                    hr = pID3DXEffect->SetFloat(pBoardEffect->_hOffsetV, pRectUV_Active->_aUV[0].tv);
                    checkDxException(hr, D3D_OK, "GgafDx9BoardModel::draw() SetFloat(_hOffsetV) sB");
                
                
                    if (GgafDx9EffectManager::_pEffect_Active != pBoardEffect || GgafDx9DrawableActor::_hash_technique_last_draw != prm_pActor_Target->_hash_technique) {
                        if (GgafDx9EffectManager::_pEffect_Active) {
                            TRACE4("EndPass("<<GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect<<"): /_pEffect_Active="<<GgafDx9EffectManager::_pEffect_Active->_effect_name<<"("<<GgafDx9EffectManager::_pEffect_Active<<")");
                            hr = GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect->EndPass();
                            checkDxException(hr, D3D_OK, "GgafDx9BoardModel::draw() EndPass() sB");
                            hr = GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect->End();
                            checkDxException(hr, D3D_OK, "GgafDx9BoardModel::draw() End() sB");
                
                #ifdef MY_DEBUG
                            if (GgafDx9EffectManager::_pEffect_Active->_begin == false) {
                                throwGgafCriticalException("begin  "<<(GgafDx9EffectManager::_pEffect_Active==NULL?"NULL":GgafDx9EffectManager::_pEffect_Active->_effect_name)<<"");
                            } else {
                                GgafDx9EffectManager::_pEffect_Active->_begin = false;
                            }
                #endif
                
                        }
                        TRACE4("SetTechnique("<<pTargetActor->_technique<<"): /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pBoardEffect->_effect_name);
                        hr = pID3DXEffect->SetTechnique(pTargetActor->_technique);
                        checkDxException(hr, S_OK, "GgafDx9BoardModel::draw() SetTechnique("<<pTargetActor->_technique<<") sB");
                
                        TRACE4("BeginPass("<<pID3DXEffect<<"): /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pBoardEffect->_effect_name);
                        UINT numPass;
                        hr = pID3DXEffect->Begin( &numPass, D3DXFX_DONOTSAVESTATE );
                        checkDxException(hr, D3D_OK, "GgafDx9BoardModel::draw() Begin() sB");
                        hr = pID3DXEffect->BeginPass(0);
                        checkDxException(hr, D3D_OK, "GgafDx9BoardModel::draw() BeginPass(0) sB");
                
                #ifdef MY_DEBUG
                        if (pBoardEffect->_begin == true) {
                            throwGgafCriticalException("End  "<<(GgafDx9EffectManager::_pEffect_Active==NULL?"NULL":GgafDx9EffectManager::_pEffect_Active->_effect_name)<<"");
                        } else {
                            pBoardEffect->_begin = true;
                        }
                #endif
                
                    } else {
                        hr = pID3DXEffect->CommitChanges();
                        checkDxException(hr, D3D_OK, "GgafDx9BoardModel::draw() CommitChanges() sB");
                    }
                    TRACE4("DrawPrimitive: /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pBoardEffect->_effect_name<<"("<<pBoardEffect<<")");
                    GgafDx9God::_pID3DDevice9->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);
                    //O`f
                    GgafDx9ModelManager::_pModelLastDraw = this;
                    GgafDx9EffectManager::_pEffect_Active = pBoardEffect;
                    GgafDx9DrawableActor::_hash_technique_last_draw = prm_pActor_Target->_hash_technique;
                    //O`UVWi|C^j
                    GgafGod::_num_actor_drawing++;
                    return D3D_OK;
                
                }
                
                void GgafDx9BoardModel::restore() {
                    TRACE3("GgafDx9BoardModel::restore() " << _model_name << " start");
                    GgafDx9God::_pModelManager->restoreBoardModel(this);
                    TRACE3("GgafDx9BoardModel::restore() " << _model_name << " end");
                }
                
                void GgafDx9BoardModel::release() {
                    TRACE3("GgafDx9BoardModel::release() " << _model_name << " start");
                    RELEASE_IMPOSSIBLE_NULL(_pIDirect3DVertexBuffer9);
                    if (_papTextureCon) {
                        if (_papTextureCon[0]) {
                            _papTextureCon[0]->close();
                        }
                    }
                    DELETEARR_IMPOSSIBLE_NULL(_papTextureCon);
                    DELETEARR_IMPOSSIBLE_NULL(_paRectUV);
                    //TODO:eNXoDELETE
                    DELETEARR_IMPOSSIBLE_NULL(_paD3DMaterial9_default);
                    TRACE3("GgafDx9BoardModel::release() " << _model_name << " end");
                }
                
                void GgafDx9BoardModel::onDeviceLost() {
                    TRACE3("GgafDx9BoardModel::onDeviceLost() " << _model_name << " start");
                    release();
                    TRACE3("GgafDx9BoardModel::onDeviceLost() " << _model_name << " end");
                }
                
           4 -> GgafDx9BoardModel::~GgafDx9BoardModel() {
                    //release();
                    //GgafDx9ModelConnection::processReleaseResource(GgafDx9Model* prm_pResource) o
                }


Top 10 Lines:

     Line      Count

      136          4
        8          2

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        6   Total number of line executions
     2.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/model/GgafDx9SpriteSetModel.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                DWORD GgafDx9SpriteSetModel::FVF = (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_PSIZE | D3DFVF_TEX1);
                int GgafDx9SpriteSetModel::_draw_set_num_LastDraw = -1;
           3 -> GgafDx9SpriteSetModel::GgafDx9SpriteSetModel(char* prm_model_name) : GgafDx9Model(prm_model_name) {
                    TRACE3("GgafDx9SpriteSetModel::GgafDx9SpriteSetModel(" << _model_name << ")");
                
                    _fSize_SpriteSetModelWidthPx = 32.0f;
                    _fSize_SpriteSetModelHeightPx = 32.0f;
                    _row_texture_split = 1;
                    _col_texture_split = 1;
                    _pattno_uvflip_Max = 0;
                    _pIDirect3DVertexBuffer9 = NULL;
                    _pIDirect3DIndexBuffer9 = NULL;
                    _paRectUV = NULL;
                
                    char nm[51];
                    strcpy(nm, prm_model_name);
                    const char* pT = strtok(nm, "/" );
                    int num = (int)strtol(pT, NULL, 10);
                    pT = strtok(NULL, "/");
                    if (pT == NULL) {
                        _TRACE_("GgafDx9SpriteSetModel("<<prm_model_name<<") `ZbgB18ZbgB");
                        _set_num = 18;
                    } else {
                        _set_num = num;
                        if (_set_num > 18) {
                            _TRACE_("GgafDx9SpriteSetModel("<<prm_model_name<<") `ZbgI[o[B18ZbgZbgB}H _set_num="<<_set_num<<"B");
                        }
                    }
                
                
                    //foCCXXgAeNX`A_A}eA
                    //void GgafDx9ModelManager::restoreSpriteSetModel(GgafDx9SpriteSetModel*)
                    //sBvQB
                }
                
                //`
                HRESULT GgafDx9SpriteSetModel::draw(GgafDx9DrawableActor* prm_pActor_Target, int prm_draw_set_num) {
                    TRACE4("GgafDx9SpriteSetModel::draw("<<prm_pActor_Target->getName()<<") this="<<getName());
                
                    //Actor
                    GgafDx9SpriteSetActor* pTargetActor = (GgafDx9SpriteSetActor*)prm_pActor_Target;
                    //SpriteSetActorGtFNgbp
                    GgafDx9SpriteSetEffect* pSpriteSetEffect = (GgafDx9SpriteSetEffect*)prm_pActor_Target->_pGgafDx9Effect;
                    //GtFNg
                    ID3DXEffect* pID3DXEffect = pSpriteSetEffect->_pID3DXEffect;
                
                    static HRESULT hr;
                    //f_obt@AXLbv
                    if (GgafDx9ModelManager::_pModelLastDraw  != this) {
                        GgafDx9God::_pID3DDevice9->SetStreamSource(0, _pIDirect3DVertexBuffer9, 0, _size_vertex_unit);
                        GgafDx9God::_pID3DDevice9->SetFVF(GgafDx9SpriteSetModel::FVF);
                        GgafDx9God::_pID3DDevice9->SetTexture(0, _papTextureCon[0]->refer()->_pIDirect3DBaseTexture9);
                        GgafDx9God::_pID3DDevice9->SetIndices(_pIDirect3DIndexBuffer9);
                
                        hr = pID3DXEffect->SetFloat(pSpriteSetEffect->_h_tex_blink_power, _fPowerBlink);
                        checkDxException(hr, D3D_OK, "GgafDx9SpriteSetActor::draw() SetFloat(_h_tex_blink_power) sB");
                        hr = pID3DXEffect->SetFloat(pSpriteSetEffect->_h_tex_blink_threshold, _fBlinkThreshold);
                        checkDxException(hr, D3D_OK, "GgafDx9SpriteSetActor::draw() SetFloat(_h_tex_blink_threshold) sB");
                    }
                
                    if (GgafDx9EffectManager::_pEffect_Active != pSpriteSetEffect || GgafDx9DrawableActor::_hash_technique_last_draw != prm_pActor_Target->_hash_technique)  {
                        if (GgafDx9EffectManager::_pEffect_Active) {
                            TRACE4("EndPass("<<GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect<<"): /_pEffect_Active="<<GgafDx9EffectManager::_pEffect_Active->_effect_name<<"("<<GgafDx9EffectManager::_pEffect_Active<<")");
                            hr = GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect->EndPass();
                            checkDxException(hr, D3D_OK, "GgafDx9SpriteSetActor::draw() EndPass() sB");
                            hr = GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect->End();
                            checkDxException(hr, D3D_OK, "GgafDx9SpriteSetActor::draw() End() sB");
                
                #ifdef MY_DEBUG
                            if (GgafDx9EffectManager::_pEffect_Active->_begin == false) {
                                throwGgafCriticalException("begin  "<<(GgafDx9EffectManager::_pEffect_Active==NULL?"NULL":GgafDx9EffectManager::_pEffect_Active->_effect_name)<<"");
                            } else {
                                GgafDx9EffectManager::_pEffect_Active->_begin = false;
                            }
                #endif
                
                        }
                        TRACE4("SetTechnique("<<pTargetActor->_technique<<"): /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pSpriteSetEffect->_effect_name);
                        hr = pID3DXEffect->SetTechnique(pTargetActor->_technique);
                        checkDxException(hr, S_OK, "GgafDx9SpriteSetActor::draw() SetTechnique("<<pTargetActor->_technique<<") sB");
                
                        TRACE4("BeginPass("<<pID3DXEffect<<"): /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pSpriteSetEffect->_effect_name<<"("<<pSpriteSetEffect<<")");
                        UINT numPass;
                        hr = pID3DXEffect->Begin( &numPass, D3DXFX_DONOTSAVESTATE );
                        checkDxException(hr, D3D_OK, "GgafDx9SpriteSetActor::draw() Begin() sB");
                        hr = pID3DXEffect->BeginPass(0);
                        checkDxException(hr, D3D_OK, "GgafDx9SpriteSetActor::draw() BeginPass(0) sB");
                
                #ifdef MY_DEBUG
                        if (pSpriteSetEffect->_begin == true) {
                            throwGgafCriticalException("End  "<<(GgafDx9EffectManager::_pEffect_Active==NULL?"NULL":GgafDx9EffectManager::_pEffect_Active->_effect_name)<<"");
                        } else {
                            pSpriteSetEffect->_begin = true;
                        }
                #endif
                
                    } else {
                        hr = pID3DXEffect->CommitChanges();
                        checkDxException(hr, D3D_OK, "GgafDx9SpriteSetModel::draw() CommitChanges() sB");
                    }
                    TRACE4("DrawPrimitive: /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pSpriteSetEffect->_effect_name);
                    GgafDx9God::_pID3DDevice9->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,
                                                                    _paIndexParam[prm_draw_set_num - 1].BaseVertexIndex,
                                                                    _paIndexParam[prm_draw_set_num - 1].MinIndex,
                                                                    _paIndexParam[prm_draw_set_num - 1].NumVertices,
                                                                    _paIndexParam[prm_draw_set_num - 1].StartIndex,
                                                                    _paIndexParam[prm_draw_set_num - 1].PrimitiveCount);
                
                    //O`f
                    GgafDx9ModelManager::_pModelLastDraw = this;
                    GgafDx9SpriteSetModel::_draw_set_num_LastDraw = prm_draw_set_num;
                    GgafDx9EffectManager::_pEffect_Active = pSpriteSetEffect;
                    GgafDx9DrawableActor::_hash_technique_last_draw = prm_pActor_Target->_hash_technique;
                    GgafGod::_num_actor_drawing++;
                    return D3D_OK;
                }
                
                void GgafDx9SpriteSetModel::restore() {
                    TRACE3("GgafDx9SpriteSetModel::restore() " << _model_name << " start");
                    GgafDx9God::_pModelManager->restoreSpriteSetModel(this);
                    TRACE3("GgafDx9SpriteSetModel::restore() " << _model_name << " end");
                }
                
                void GgafDx9SpriteSetModel::onDeviceLost() {
                    TRACE3("GgafDx9SpriteSetModel::onDeviceLost() " << _model_name << " start");
                    release();
                    TRACE3("GgafDx9SpriteSetModel::onDeviceLost() " << _model_name << " end");
                }
                
                void GgafDx9SpriteSetModel::release() {
                    TRACE3("GgafDx9SpriteSetModel::release() " << _model_name << " start");
                    RELEASE_IMPOSSIBLE_NULL(_pIDirect3DVertexBuffer9);
                    RELEASE_IMPOSSIBLE_NULL(_pIDirect3DIndexBuffer9);
                    if (_papTextureCon) {
                        if (_papTextureCon[0]) {
                            _papTextureCon[0]->close();
                        }
                    }
                    DELETEARR_IMPOSSIBLE_NULL(_papTextureCon);
                    DELETEARR_IMPOSSIBLE_NULL(_paRectUV);
                    DELETEARR_IMPOSSIBLE_NULL(_paIndexParam);
                    //TODO:eNXoDELETE
                    DELETEARR_IMPOSSIBLE_NULL(_paD3DMaterial9_default);
                    TRACE3("GgafDx9SpriteSetModel::release() " << _model_name << " end");
                }
                
           6 -> GgafDx9SpriteSetModel::~GgafDx9SpriteSetModel() {
                    //release();
                    //GgafDx9ModelConnection::processReleaseResource(GgafDx9Model* prm_pResource) o
                }
                


Top 10 Lines:

     Line      Count

      152          6
        8          3

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        9   Total number of line executions
     3.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/model/GgafDx9SpriteModel.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                DWORD GgafDx9SpriteModel::FVF = (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_DIFFUSE | D3DFVF_TEX1);
                
           2 -> GgafDx9SpriteModel::GgafDx9SpriteModel(char* prm_model_name) : GgafDx9Model(prm_model_name) {
                    TRACE3("GgafDx9SpriteModel::GgafDx9SpriteModel(" << _model_name << ")");
                
                    _fSize_SpriteModelWidthPx = 32.0f;
                    _fSize_SpriteModelHeightPx = 32.0f;
                    _row_texture_split = 1;
                    _col_texture_split = 1;
                    _pattno_uvflip_Max = 0;
                    _pIDirect3DVertexBuffer9 = NULL;
                    _paRectUV = NULL;
                
                    //foCCXXgAeNX`A_A}eA
                    //void GgafDx9ModelManager::restoreSpriteModel(GgafDx9SpriteModel*)
                    //sBvQB
                }
                
                //`
                HRESULT GgafDx9SpriteModel::draw(GgafDx9DrawableActor* prm_pActor_Target, int prm_draw_set_num) {
                    TRACE4("GgafDx9SpriteModel::draw("<<prm_pActor_Target->getName()<<") this="<<getName());
                
                    //Actor
                    GgafDx9SpriteActor* pTargetActor = (GgafDx9SpriteActor*)prm_pActor_Target;
                    //SpriteActorGtFNgbp
                    GgafDx9SpriteEffect* pSpriteEffect = (GgafDx9SpriteEffect*)prm_pActor_Target->_pGgafDx9Effect;
                    //GtFNg
                    ID3DXEffect* pID3DXEffect = pSpriteEffect->_pID3DXEffect;
                
                    //`UV
                    GgafDx9RectUV* pRectUV_Active;
                    pRectUV_Active = _paRectUV + (pTargetActor->_pUvFlipper->_pattno_uvflip_now);
                
                    static HRESULT hr;
                    if (GgafDx9ModelManager::_pModelLastDraw != this) {
                        GgafDx9God::_pID3DDevice9->SetStreamSource(0, _pIDirect3DVertexBuffer9, 0, _size_vertex_unit);
                        GgafDx9God::_pID3DDevice9->SetFVF(GgafDx9SpriteModel::FVF);
                        GgafDx9God::_pID3DDevice9->SetTexture(0, _papTextureCon[0]->refer()->_pIDirect3DBaseTexture9);
                
                        hr = pID3DXEffect->SetFloat(pSpriteEffect->_h_tex_blink_power, _fPowerBlink);
                        checkDxException(hr, D3D_OK, "GgafDx9SpriteActor::draw() SetFloat(_h_tex_blink_power) sB");
                        hr = pID3DXEffect->SetFloat(pSpriteEffect->_h_tex_blink_threshold, _fBlinkThreshold);
                        checkDxException(hr, D3D_OK, "GgafDx9SpriteActor::draw() SetFloat(_h_tex_blink_threshold) sB");
                    }
                    hr = pID3DXEffect->SetFloat(pSpriteEffect->_hOffsetU, pRectUV_Active->_aUV[0].tu);
                    checkDxException(hr, D3D_OK, "GgafDx9SpriteModel::draw() SetFloat(_hOffsetU) sB");
                    hr = pID3DXEffect->SetFloat(pSpriteEffect->_hOffsetV, pRectUV_Active->_aUV[0].tv);
                    checkDxException(hr, D3D_OK, "GgafDx9SpriteModel::draw() SetFloat(_hOffsetV) sB");
                
                    if (GgafDx9EffectManager::_pEffect_Active != pSpriteEffect || GgafDx9DrawableActor::_hash_technique_last_draw != prm_pActor_Target->_hash_technique)  {
                        if (GgafDx9EffectManager::_pEffect_Active) {
                            TRACE4("EndPass("<<GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect<<"): /_pEffect_Active="<<GgafDx9EffectManager::_pEffect_Active->_effect_name<<"("<<GgafDx9EffectManager::_pEffect_Active<<")");
                            hr = GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect->EndPass();
                            checkDxException(hr, D3D_OK, "GgafDx9SpriteActor::draw() EndPass() sB");
                            hr = GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect->End();
                            checkDxException(hr, D3D_OK, "GgafDx9SpriteActor::draw() End() sB");
                
                #ifdef MY_DEBUG
                            if (GgafDx9EffectManager::_pEffect_Active->_begin == false) {
                                throwGgafCriticalException("begin  "<<(GgafDx9EffectManager::_pEffect_Active==NULL?"NULL":GgafDx9EffectManager::_pEffect_Active->_effect_name)<<"");
                            } else {
                                GgafDx9EffectManager::_pEffect_Active->_begin = false;
                            }
                #endif
                
                        }
                
                        TRACE4("SetTechnique("<<pTargetActor->_technique<<"): /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pSpriteEffect->_effect_name);
                        hr = pID3DXEffect->SetTechnique(pTargetActor->_technique);
                        checkDxException(hr, S_OK, "GgafDx9SpriteActor::draw() SetTechnique("<<pTargetActor->_technique<<") sB");
                
                        TRACE4("BeginPass("<<pID3DXEffect<<"): /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pSpriteEffect->_effect_name<<"("<<pSpriteEffect<<")");
                        UINT numPass;
                        hr = pID3DXEffect->Begin( &numPass, D3DXFX_DONOTSAVESTATE );
                        checkDxException(hr, D3D_OK, "GgafDx9SpriteActor::draw() Begin() sB");
                        hr = pID3DXEffect->BeginPass(0);
                        checkDxException(hr, D3D_OK, "GgafDx9SpriteActor::draw() BeginPass(0) sB");
                
                
                #ifdef MY_DEBUG
                        if (pSpriteEffect->_begin == true) {
                            throwGgafCriticalException("End  "<<(GgafDx9EffectManager::_pEffect_Active==NULL?"NULL":GgafDx9EffectManager::_pEffect_Active->_effect_name)<<"");
                        } else {
                            pSpriteEffect->_begin = true;
                        }
                #endif
                
                
                    } else {
                        hr = pID3DXEffect->CommitChanges();
                        checkDxException(hr, D3D_OK, "GgafDx9SpriteModel::draw() CommitChanges() sB");
                    }
                    TRACE4("DrawPrimitive: /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pSpriteEffect->_effect_name);
                    GgafDx9God::_pID3DDevice9->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);
                
                    //O`f
                    GgafDx9ModelManager::_pModelLastDraw = this;
                    GgafDx9EffectManager::_pEffect_Active = pSpriteEffect;
                    GgafDx9DrawableActor::_hash_technique_last_draw = prm_pActor_Target->_hash_technique;
                    //O`UVWi|C^j
                    GgafGod::_num_actor_drawing++;
                    return D3D_OK;
                }
                
                void GgafDx9SpriteModel::restore() {
                    TRACE3("GgafDx9SpriteModel::restore() " << _model_name << " start");
                    GgafDx9God::_pModelManager->restoreSpriteModel(this);
                    TRACE3("GgafDx9SpriteModel::restore() " << _model_name << " end");
                }
                
                void GgafDx9SpriteModel::onDeviceLost() {
                    TRACE3("GgafDx9SpriteModel::onDeviceLost() " << _model_name << " start");
                    release();
                    TRACE3("GgafDx9SpriteModel::onDeviceLost() " << _model_name << " end");
                }
                
                void GgafDx9SpriteModel::release() {
                    TRACE3("GgafDx9SpriteModel::release() " << _model_name << " start");
                    RELEASE_IMPOSSIBLE_NULL(_pIDirect3DVertexBuffer9);
                    if (_papTextureCon) {
                        if (_papTextureCon[0]) {
                            _papTextureCon[0]->close();
                        }
                    }
                    DELETEARR_IMPOSSIBLE_NULL(_papTextureCon);
                    DELETEARR_IMPOSSIBLE_NULL(_paRectUV);
                    //TODO:eNXoDELETE
                    DELETEARR_IMPOSSIBLE_NULL(_paD3DMaterial9_default);
                    TRACE3("GgafDx9SpriteModel::release() " << _model_name << " end");
                }
                
           4 -> GgafDx9SpriteModel::~GgafDx9SpriteModel() {
                    //release();
                    //GgafDx9ModelConnection::processReleaseResource(GgafDx9Model* prm_pResource) o
                }
                


Top 10 Lines:

     Line      Count

      137          4
        8          2

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        6   Total number of line executions
     2.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/model/GgafDx9MeshModel.cpp:
                #include "stdafx.h"
                
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                DWORD GgafDx9MeshModel::FVF = (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_DIFFUSE | D3DFVF_TEX1);
                //LPDIRECT3DVERTEXBUFFER9 _pIDirect3DVertexBuffer9 = NULL;
                
           3 -> GgafDx9MeshModel::GgafDx9MeshModel(char* prm_model_name) : GgafDx9Model(prm_model_name) {
                    TRACE3("GgafDx9MeshModel::GgafDx9MeshModel(" << _model_name << ")");
                    _pModel3D = NULL;
                    _pMeshesFront = NULL;
                
                    _pIDirect3DVertexBuffer9 = NULL;
                    _pIDirect3DIndexBuffer9 = NULL;
                    _paVtxBuffer_org = NULL;
                    _paIdxBuffer_org = NULL;
                    _paIndexParam = NULL;
                    //foCCXXgAeNX`A_A}eA
                    //void GgafDx9ModelManager::restoreMeshModel(GgafDx9MeshModel*)
                    //sBvQB
                }
                
                //`
                HRESULT GgafDx9MeshModel::draw(GgafDx9DrawableActor* prm_pActor_Target, int prm_draw_set_num) {
                    //AN^[
                    //GgafDx9MeshActor* pTargetActor = (GgafDx9MeshActor*)prm_pActor_Target;
                    GgafDx9DrawableActor* pTargetActor = prm_pActor_Target;
                    //MeshActorGtFNgbp
                    GgafDx9MeshEffect* pMeshEffect = (GgafDx9MeshEffect*)prm_pActor_Target->_pGgafDx9Effect;
                    //GtFNg
                    ID3DXEffect* pID3DXEffect = pMeshEffect->_pID3DXEffect;
                
                    HRESULT hr;
                    UINT material_no;
                    if (GgafDx9ModelManager::_pModelLastDraw != this) {
                        //_obt@CfbNXobt@
                        GgafDx9God::_pID3DDevice9->SetStreamSource(0, _pIDirect3DVertexBuffer9,  0, _size_vertex_unit);
                        GgafDx9God::_pID3DDevice9->SetFVF(GgafDx9MeshModel::FVF);
                        GgafDx9God::_pID3DDevice9->SetIndices(_pIDirect3DIndexBuffer9);
                
                        hr = pID3DXEffect->SetFloat(pMeshEffect->_h_tex_blink_power, _fPowerBlink);
                        checkDxException(hr, D3D_OK, "GgafDx9MeshModel::draw() SetFloat(_h_tex_blink_power) sB");
                        hr = pID3DXEffect->SetFloat(pMeshEffect->_h_tex_blink_threshold, _fBlinkThreshold);
                        checkDxException(hr, D3D_OK, "GgafDx9MeshModel::draw() SetFloat(_h_tex_blink_threshold) sB");
                    }
                
                    //`
                    for (UINT i = 0; i < _nMaterialListGrp; i++) {
                        material_no = _paIndexParam[i].MaterialNo;
                        if (GgafDx9ModelManager::_pModelLastDraw != this || _nMaterialListGrp != 1) {
                            if (_papTextureCon[material_no]) {
                                //eNX`s0WX^Zbg
                                GgafDx9God::_pID3DDevice9->SetTexture(0, _papTextureCon[material_no]->refer()->_pIDirect3DBaseTexture9);
                            } else {
                                _TRACE_("GgafDx9MeshModel::draw("<<prm_pActor_Target->getName()<<") eNX`Bwhite.pngB");
                                //eNX`
                                GgafDx9God::_pID3DDevice9->SetTexture(0, NULL);
                            }
                        }
                        hr = pID3DXEffect->SetValue(pMeshEffect->_h_colMaterialDiffuse, &(pTargetActor->_paD3DMaterial9[material_no].Diffuse), sizeof(D3DCOLORVALUE) );
                        checkDxException(hr, D3D_OK, "GgafDx9MeshModel::draw() SetValue(g_colMaterialDiffuse) sB");
                
                        if ((GgafDx9EffectManager::_pEffect_Active != pMeshEffect || GgafDx9DrawableActor::_hash_technique_last_draw != prm_pActor_Target->_hash_technique) && i == 0) {
                            //{f`
                            if (GgafDx9EffectManager::_pEffect_Active) {
                                TRACE4("O_pEffect_Active != pMeshEffect (" <<(GgafDx9EffectManager::_pEffect_Active->_effect_name)<<"!="<<(pMeshEffect->_effect_name)<<")");
                                TRACE4("EndPass("<<GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect<<"): /_pEffect_Active="<<GgafDx9EffectManager::_pEffect_Active->_effect_name<<"("<<GgafDx9EffectManager::_pEffect_Active<<")");
                                hr = GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect->EndPass();
                                checkDxException(hr, D3D_OK, "GgafDx9MeshModel::draw() EndPass() sB");
                                hr = GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect->End();
                                checkDxException(hr, D3D_OK, "GgafDx9MeshModel::draw() End() sB");
                
                #ifdef MY_DEBUG
                                if (GgafDx9EffectManager::_pEffect_Active->_begin == false) {
                                    throwGgafCriticalException("begin  "<<(GgafDx9EffectManager::_pEffect_Active==NULL?"NULL":GgafDx9EffectManager::_pEffect_Active->_effect_name)<<"");
                                } else {
                                    GgafDx9EffectManager::_pEffect_Active->_begin = false;
                                }
                #endif
                
                            }
                            TRACE4("SetTechnique("<<pTargetActor->_technique<<"): /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pMeshEffect->_effect_name);
                            hr = pID3DXEffect->SetTechnique(pTargetActor->_technique);
                            checkDxException(hr, S_OK, "GgafDx9MeshModel::draw() SetTechnique("<<pTargetActor->_technique<<") sB");
                
                            TRACE4("BeginPass("<<pID3DXEffect<<"): /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pMeshEffect->_effect_name<<"("<<pMeshEffect<<")");
                            UINT numPass;
                            hr = pID3DXEffect->Begin( &numPass, D3DXFX_DONOTSAVESTATE );
                            checkDxException(hr, D3D_OK, "GgafDx9MeshModel::draw() Begin() sB");
                            hr = pID3DXEffect->BeginPass(0);
                            checkDxException(hr, D3D_OK, "GgafDx9MeshModel::draw() BeginPass(0) sB");
                
                #ifdef MY_DEBUG
                            if (pMeshEffect->_begin == true) {
                                throwGgafCriticalException("End  "<<(GgafDx9EffectManager::_pEffect_Active==NULL?"NULL":GgafDx9EffectManager::_pEffect_Active->_effect_name)<<"");
                            } else {
                                pMeshEffect->_begin = true;
                            }
                #endif
                
                        } else {
                            //O`f
                            hr = pID3DXEffect->CommitChanges(); //}eAR~bgB
                            checkDxException(hr, D3D_OK, "GgafDx9MeshModel::draw() CommitChanges() sB");
                        }
                        TRACE4("DrawIndexedPrimitive: /actor="<<pTargetActor->getName()<<"/model="<<_model_name<<" effect="<<pMeshEffect->_effect_name);
                        GgafDx9God::_pID3DDevice9->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,
                                                                        _paIndexParam[i].BaseVertexIndex,
                                                                        _paIndexParam[i].MinIndex,
                                                                        _paIndexParam[i].NumVertices,
                                                                        _paIndexParam[i].StartIndex,
                                                                        _paIndexParam[i].PrimitiveCount);
                        GgafGod::_num_actor_drawing++;
                    }
                    GgafDx9ModelManager::_pModelLastDraw = this;
                    GgafDx9EffectManager::_pEffect_Active = pMeshEffect;
                    GgafDx9DrawableActor::_hash_technique_last_draw = prm_pActor_Target->_hash_technique;
                    return D3D_OK;
                }
                
                void GgafDx9MeshModel::restore() {
                    TRACE3("GgafDx9MeshModel::restore() " << _model_name << " start");
                    GgafDx9God::_pModelManager->restoreMeshModel(this);
                    TRACE3("GgafDx9MeshModel::restore() " << _model_name << " end");
                }
                
                void GgafDx9MeshModel::onDeviceLost() {
                    TRACE3("GgafDx9MeshModel::onDeviceLost() " << _model_name << " start");
                    release();
                    TRACE3("GgafDx9MeshModel::onDeviceLost() " << _model_name << " end");
                }
                
                void GgafDx9MeshModel::release() {
                    TRACE3("GgafDx9MeshModel::release() " << _model_name << " start");
                
                    _TRACE_("GgafDx9MeshModel::release() " << _model_name << " start");
                    //eNX`
                    if (_papTextureCon) {
                        for (int i = 0; i < (int)_dwNumMaterials; i++) {
                            if (_papTextureCon[i]) {
                                TRACE3("close() _papTextureCon["<<i<<"]->"<<(_papTextureCon[i]->getIdStr()));
                                _papTextureCon[i]->close();
                            }
                        }
                    }
                    DELETEARR_IMPOSSIBLE_NULL(_papTextureCon); //eNX`z
                
                    RELEASE_IMPOSSIBLE_NULL(_pIDirect3DVertexBuffer9);
                    RELEASE_IMPOSSIBLE_NULL(_pIDirect3DIndexBuffer9);
                
                    DELETEARR_IMPOSSIBLE_NULL(_paVtxBuffer_org);
                    DELETEARR_IMPOSSIBLE_NULL(_paIdxBuffer_org);
                    DELETE_IMPOSSIBLE_NULL(_pModel3D);
                    //_pMeshesFront  _pModel3D DELETEKv
                    _pMeshesFront = NULL;
                    DELETEARR_IMPOSSIBLE_NULL(_paIndexParam);
                
                    //TODO:eNXoDELETE
                    DELETEARR_IMPOSSIBLE_NULL(_paD3DMaterial9_default);
                
                
                    TRACE3("GgafDx9MeshModel::release() " << _model_name << " end");
                
                }
           6 -> GgafDx9MeshModel::~GgafDx9MeshModel() {
                    //release();
                    //GgafDx9ModelConnection::processReleaseResource(GgafDx9Model* prm_pResource) o
                }
                


Top 10 Lines:

     Line      Count

      167          6
       10          3

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        9   Total number of line executions
     3.00   Average executions per line


*** File c:/cygwin/mingw/bin/../lib/gcc/mingw32/4.5.2/include/c++/bits/stl_vector.h:
                // Vector implementation -*- C++ -*-
                
                // Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
                // Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this  software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file stl_vector.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                #ifndef _STL_VECTOR_H
                #define _STL_VECTOR_H 1
                
                #include <bits/stl_iterator_base_funcs.h>
                #include <bits/functexcept.h>
                #include <bits/concept_check.h>
                #include <initializer_list>
                
                _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)
                
                  /// See bits/stl_deque.h's _Deque_base for an explanation.
                  template<typename _Tp, typename _Alloc>
                    struct _Vector_base
                    {
                      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;
                
                      struct _Vector_impl 
                      : public _Tp_alloc_type
           1 ->       {
                	typename _Tp_alloc_type::pointer _M_start;
                	typename _Tp_alloc_type::pointer _M_finish;
                	typename _Tp_alloc_type::pointer _M_end_of_storage;
                
       ##### -> 	_Vector_impl()
                	: _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
                	{ }
                
           1 -> 	_Vector_impl(_Tp_alloc_type const& __a)
                	: _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
                	{ }
                      };
                      
                    public:
                      typedef _Alloc allocator_type;
                
                      _Tp_alloc_type&
                      _M_get_Tp_allocator()
                      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
                
                      const _Tp_alloc_type&
                      _M_get_Tp_allocator() const
                      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
                
                      allocator_type
                      get_allocator() const
                      { return allocator_type(_M_get_Tp_allocator()); }
                
       ##### ->       _Vector_base()
                      : _M_impl() { }
                
                      _Vector_base(const allocator_type& __a)
                      : _M_impl(__a) { }
                
           1 ->       _Vector_base(size_t __n, const allocator_type& __a)
                      : _M_impl(__a)
                      {
                	this->_M_impl._M_start = this->_M_allocate(__n);
                	this->_M_impl._M_finish = this->_M_impl._M_start;
                	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                      }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      _Vector_base(_Vector_base&& __x)
                      : _M_impl(__x._M_get_Tp_allocator())
                      {
                	this->_M_impl._M_start = __x._M_impl._M_start;
                	this->_M_impl._M_finish = __x._M_impl._M_finish;
                	this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
                	__x._M_impl._M_start = 0;
                	__x._M_impl._M_finish = 0;
                	__x._M_impl._M_end_of_storage = 0;
                      }
                #endif
                
           1 ->       ~_Vector_base()
                      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
                		      - this->_M_impl._M_start); }
                
                    public:
                      _Vector_impl _M_impl;
                
                      typename _Tp_alloc_type::pointer
                      _M_allocate(size_t __n)
                      { return __n != 0 ? _M_impl.allocate(__n) : 0; }
                
                      void
                      _M_deallocate(typename _Tp_alloc_type::pointer __p, size_t __n)
                      {
                	if (__p)
                	  _M_impl.deallocate(__p, __n);
                      }
                    };
                
                
                  /**
                   *  @brief A standard container which offers fixed time access to
                   *  individual elements in any order.
                   *
                   *  @ingroup sequences
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>, including the
                   *  <a href="tables.html#68">optional sequence requirements</a> with the
                   *  %exception of @c push_front and @c pop_front.
                   *
                   *  In some terminology a %vector can be described as a dynamic
                   *  C-style array, it offers fast and efficient access to individual
                   *  elements in any order and saves the user from worrying about
                   *  memory and size allocation.  Subscripting ( @c [] ) access is
                   *  also provided as with C-style arrays.
                  */
                  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
                    class vector : protected _Vector_base<_Tp, _Alloc>
                    {
                      // Concept requirements.
                      typedef typename _Alloc::value_type                _Alloc_value_type;
                      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
                      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
                      
                      typedef _Vector_base<_Tp, _Alloc>			 _Base;
                      typedef typename _Base::_Tp_alloc_type		 _Tp_alloc_type;
                
                    public:
                      typedef _Tp					 value_type;
                      typedef typename _Tp_alloc_type::pointer           pointer;
                      typedef typename _Tp_alloc_type::const_pointer     const_pointer;
                      typedef typename _Tp_alloc_type::reference         reference;
                      typedef typename _Tp_alloc_type::const_reference   const_reference;
                      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
                      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
                      const_iterator;
                      typedef std::reverse_iterator<const_iterator>  const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		 reverse_iterator;
                      typedef size_t					 size_type;
                      typedef ptrdiff_t					 difference_type;
                      typedef _Alloc                        		 allocator_type;
                
                    protected:
                      using _Base::_M_allocate;
                      using _Base::_M_deallocate;
                      using _Base::_M_impl;
                      using _Base::_M_get_Tp_allocator;
                
                    public:
                      // [23.2.4.1] construct/copy/destroy
                      // (assign() and get_allocator() are also listed in this section)
                      /**
                       *  @brief  Default constructor creates no elements.
                       */
       ##### ->       vector()
                      : _Base() { }
                
                      /**
                       *  @brief  Creates a %vector with no elements.
                       *  @param  a  An allocator object.
                       */
                      explicit
                      vector(const allocator_type& __a)
                      : _Base(__a) { }
                
                      /**
                       *  @brief  Creates a %vector with copies of an exemplar element.
                       *  @param  n  The number of elements to initially create.
                       *  @param  value  An element to copy.
                       *  @param  a  An allocator.
                       *
                       *  This constructor fills the %vector with @a n copies of @a value.
                       */
                      explicit
           1 ->       vector(size_type __n, const value_type& __value = value_type(),
                	     const allocator_type& __a = allocator_type())
                      : _Base(__n, __a)
                      { _M_fill_initialize(__n, __value); }
                
                      /**
                       *  @brief  %Vector copy constructor.
                       *  @param  x  A %vector of identical element and allocator types.
                       *
                       *  The newly-created %vector uses a copy of the allocation
                       *  object used by @a x.  All the elements of @a x are copied,
                       *  but any extra memory in
                       *  @a x (for fast expansion) will not be copied.
                       */
                      vector(const vector& __x)
                      : _Base(__x.size(), __x._M_get_Tp_allocator())
                      { this->_M_impl._M_finish =
                	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
                				      this->_M_impl._M_start,
                				      _M_get_Tp_allocator());
                      }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      /**
                       *  @brief  %Vector move constructor.
                       *  @param  x  A %vector of identical element and allocator types.
                       *
                       *  The newly-created %vector contains the exact contents of @a x.
                       *  The contents of @a x are a valid, but unspecified %vector.
                       */
                      vector(vector&& __x)
                      : _Base(std::forward<_Base>(__x)) { }
                
                      /**
                       *  @brief  Builds a %vector from an initializer list.
                       *  @param  l  An initializer_list.
                       *  @param  a  An allocator.
                       *
                       *  Create a %vector consisting of copies of the elements in the
                       *  initializer_list @a l.
                       *
                       *  This will call the element type's copy constructor N times
                       *  (where N is @a l.size()) and do no memory reallocation.
                       */
                      vector(initializer_list<value_type> __l,
                	     const allocator_type& __a = allocator_type())
                      : _Base(__a)
                      {
                	_M_range_initialize(__l.begin(), __l.end(),
                			    random_access_iterator_tag());
                      }
                #endif
                
                      /**
                       *  @brief  Builds a %vector from a range.
                       *  @param  first  An input iterator.
                       *  @param  last  An input iterator.
                       *  @param  a  An allocator.
                       *
                       *  Create a %vector consisting of copies of the elements from
                       *  [first,last).
                       *
                       *  If the iterators are forward, bidirectional, or
                       *  random-access, then this will call the elements' copy
                       *  constructor N times (where N is distance(first,last)) and do
                       *  no memory reallocation.  But if only input iterators are
                       *  used, then this will do at most 2N calls to the copy
                       *  constructor, and logN memory reallocations.
                       */
                      template<typename _InputIterator>
                        vector(_InputIterator __first, _InputIterator __last,
                	       const allocator_type& __a = allocator_type())
                	: _Base(__a)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_initialize_dispatch(__first, __last, _Integral());
                	}
                
                      /**
                       *  The dtor only erases the elements, and note that if the
                       *  elements themselves are pointers, the pointed-to memory is
                       *  not touched in any way.  Managing the pointer is the user's
                       *  responsibility.
                       */
           1 ->       ~vector()
                      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                		      _M_get_Tp_allocator()); }
                
                      /**
                       *  @brief  %Vector assignment operator.
                       *  @param  x  A %vector of identical element and allocator types.
                       *
                       *  All the elements of @a x are copied, but any extra memory in
                       *  @a x (for fast expansion) will not be copied.  Unlike the
                       *  copy constructor, the allocator object is not copied.
                       */
                      vector&
                      operator=(const vector& __x);
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      /**
                       *  @brief  %Vector move assignment operator.
                       *  @param  x  A %vector of identical element and allocator types.
                       *
                       *  The contents of @a x are moved into this %vector (without copying).
                       *  @a x is a valid, but unspecified %vector.
                       */
                      vector&
                      operator=(vector&& __x)
                      {
                	// NB: DR 1204.
                	// NB: DR 675.
                	this->clear();
                	this->swap(__x);
                	return *this;
                      }
                
                      /**
                       *  @brief  %Vector list assignment operator.
                       *  @param  l  An initializer_list.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  initializer list @a l.
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.  Old data may be lost.
                       */
                      vector&
                      operator=(initializer_list<value_type> __l)
                      {
                	this->assign(__l.begin(), __l.end());
                	return *this;
                      }
                #endif
                
                      /**
                       *  @brief  Assigns a given value to a %vector.
                       *  @param  n  Number of elements to be assigned.
                       *  @param  val  Value to be assigned.
                       *
                       *  This function fills a %vector with @a n copies of the given
                       *  value.  Note that the assignment completely changes the
                       *  %vector and that the resulting %vector's size is the same as
                       *  the number of elements assigned.  Old data may be lost.
                       */
                      void
                      assign(size_type __n, const value_type& __val)
                      { _M_fill_assign(__n, __val); }
                
                      /**
                       *  @brief  Assigns a range to a %vector.
                       *  @param  first  An input iterator.
                       *  @param  last   An input iterator.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  range [first,last).
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.  Old data may be lost.
                       */
                      template<typename _InputIterator>
                        void
                        assign(_InputIterator __first, _InputIterator __last)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_assign_dispatch(__first, __last, _Integral());
                	}
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      /**
                       *  @brief  Assigns an initializer list to a %vector.
                       *  @param  l  An initializer_list.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  initializer list @a l.
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.  Old data may be lost.
                       */
                      void
                      assign(initializer_list<value_type> __l)
                      { this->assign(__l.begin(), __l.end()); }
                #endif
                
                      /// Get a copy of the memory allocation object.
                      using _Base::get_allocator;
                
                      // iterators
                      /**
                       *  Returns a read/write iterator that points to the first
                       *  element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
                      begin()
                      { return iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
                      begin() const
                      { return const_iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
                      end()
                      { return iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %vector.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
                      end() const
                      { return const_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the
                       *  last element in the %vector.  Iteration is done in reverse
                       *  element order.
                       */
                      reverse_iterator
                      rbegin()
                      { return reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %vector.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one
                       *  before the first element in the %vector.  Iteration is done
                       *  in reverse element order.
                       */
                      reverse_iterator
                      rend()
                      { return reverse_iterator(begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %vector.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const
                      { return const_reverse_iterator(begin()); }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
                      cbegin() const
                      { return const_iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %vector.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
                      cend() const
                      { return const_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %vector.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      crbegin() const
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %vector.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      crend() const
                      { return const_reverse_iterator(begin()); }
                #endif
                
                      // [23.2.4.2] capacity
                      /**  Returns the number of elements in the %vector.  */
                      size_type
                      size() const
                      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
                
                      /**  Returns the size() of the largest possible %vector.  */
                      size_type
                      max_size() const
                      { return _M_get_Tp_allocator().max_size(); }
                
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  new_size  Number of elements the %vector should contain.
                       *  @param  x  Data with which new elements should be populated.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  the %vector is extended and new elements are populated with
                       *  given data.
                       */
                      void
                      resize(size_type __new_size, value_type __x = value_type())
                      {
                	if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                	else
                	  insert(end(), __new_size - size(), __x);
                      }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      /**  A non-binding request to reduce capacity() to size().  */
                      void
                      shrink_to_fit()
                      { std::__shrink_to_fit<vector>::_S_do_it(*this); }
                #endif
                
                      /**
                       *  Returns the total number of elements that the %vector can
                       *  hold before needing to allocate more memory.
                       */
                      size_type
                      capacity() const
                      { return size_type(this->_M_impl._M_end_of_storage
                			 - this->_M_impl._M_start); }
                
                      /**
                       *  Returns true if the %vector is empty.  (Thus begin() would
                       *  equal end().)
                       */
                      bool
                      empty() const
                      { return begin() == end(); }
                
                      /**
                       *  @brief  Attempt to preallocate enough memory for specified number of
                       *          elements.
                       *  @param  n  Number of elements required.
                       *  @throw  std::length_error  If @a n exceeds @c max_size().
                       *
                       *  This function attempts to reserve enough memory for the
                       *  %vector to hold the specified number of elements.  If the
                       *  number requested is more than max_size(), length_error is
                       *  thrown.
                       *
                       *  The advantage of this function is that if optimal code is a
                       *  necessity and the user can determine the number of elements
                       *  that will be required, the user can reserve the memory in
                       *  %advance, and thus prevent a possible reallocation of memory
                       *  and copying of %vector data.
                       */
                      void
                      reserve(size_type __n);
                
                      // element access
                      /**
                       *  @brief  Subscript access to the data contained in the %vector.
                       *  @param n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      reference
                      operator[](size_type __n)
                      { return *(this->_M_impl._M_start + __n); }
                
                      /**
                       *  @brief  Subscript access to the data contained in the %vector.
                       *  @param n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
                      operator[](size_type __n) const
                      { return *(this->_M_impl._M_start + __n); }
                
                    protected:
                      /// Safety check used only from at().
                      void
                      _M_range_check(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range(__N("vector::_M_range_check"));
                      }
                
                    public:
                      /**
                       *  @brief  Provides access to the data contained in the %vector.
                       *  @param n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the vector.  The
                       *  function throws out_of_range if the check fails.
                       */
                      reference
                      at(size_type __n)
                      {
                	_M_range_check(__n);
                	return (*this)[__n]; 
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %vector.
                       *  @param n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the vector.  The
                       *  function throws out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	_M_range_check(__n);
                	return (*this)[__n];
                      }
                
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %vector.
                       */
                      reference
                      front()
                      { return *begin(); }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %vector.
                       */
                      const_reference
                      front() const
                      { return *begin(); }
                
                      /**
                       *  Returns a read/write reference to the data at the last
                       *  element of the %vector.
                       */
                      reference
                      back()
                      { return *(end() - 1); }
                      
                      /**
                       *  Returns a read-only (constant) reference to the data at the
                       *  last element of the %vector.
                       */
                      const_reference
                      back() const
                      { return *(end() - 1); }
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 464. Suggestion for new member functions in standard containers.
                      // data access
                      /**
                       *   Returns a pointer such that [data(), data() + size()) is a valid
                       *   range.  For a non-empty %vector, data() == &front().
                       */
                      pointer
                      data()
                      { return pointer(this->_M_impl._M_start); }
                
                      const_pointer
                      data() const
                      { return const_pointer(this->_M_impl._M_start); }
                
                      // [23.2.4.3] modifiers
                      /**
                       *  @brief  Add data to the end of the %vector.
                       *  @param  x  Data to be added.
                       *
                       *  This is a typical stack operation.  The function creates an
                       *  element at the end of the %vector and assigns the given data
                       *  to it.  Due to the nature of a %vector this operation can be
                       *  done in constant time if the %vector has preallocated space
                       *  available.
                       */
                      void
                      push_back(const value_type& __x)
                      {
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  {
                	    this->_M_impl.construct(this->_M_impl._M_finish, __x);
                	    ++this->_M_impl._M_finish;
                	  }
                	else
                	  _M_insert_aux(end(), __x);
                      }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      void
                      push_back(value_type&& __x)
                      { emplace_back(std::move(__x)); }
                
                      template<typename... _Args>
                        void
                        emplace_back(_Args&&... __args);
                #endif
                
                      /**
                       *  @brief  Removes last element.
                       *
                       *  This is a typical stack operation. It shrinks the %vector by one.
                       *
                       *  Note that no data is returned, and if the last element's
                       *  data is needed, it should be retrieved before pop_back() is
                       *  called.
                       */
                      void
                      pop_back()
                      {
                	--this->_M_impl._M_finish;
                	this->_M_impl.destroy(this->_M_impl._M_finish);
                      }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      /**
                       *  @brief  Inserts an object in %vector before specified iterator.
                       *  @param  position  An iterator into the %vector.
                       *  @param  args  Arguments.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert an object of type T constructed
                       *  with T(std::forward<Args>(args)...) before the specified location.
                       *  Note that this kind of operation could be expensive for a %vector
                       *  and if it is frequently used the user should consider using
                       *  std::list.
                       */
                      template<typename... _Args>
                        iterator
                        emplace(iterator __position, _Args&&... __args);
                #endif
                
                      /**
                       *  @brief  Inserts given value into %vector before specified iterator.
                       *  @param  position  An iterator into the %vector.
                       *  @param  x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given value before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(iterator __position, const value_type& __x);
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      /**
                       *  @brief  Inserts given rvalue into %vector before specified iterator.
                       *  @param  position  An iterator into the %vector.
                       *  @param  x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given rvalue before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(iterator __position, value_type&& __x)
                      { return emplace(__position, std::move(__x)); }
                
                      /**
                       *  @brief  Inserts an initializer_list into the %vector.
                       *  @param  position  An iterator into the %vector.
                       *  @param  l  An initializer_list.
                       *
                       *  This function will insert copies of the data in the 
                       *  initializer_list @a l into the %vector before the location
                       *  specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      void
                      insert(iterator __position, initializer_list<value_type> __l)
                      { this->insert(__position, __l.begin(), __l.end()); }
                #endif
                
                      /**
                       *  @brief  Inserts a number of copies of given data into the %vector.
                       *  @param  position  An iterator into the %vector.
                       *  @param  n  Number of elements to be inserted.
                       *  @param  x  Data to be inserted.
                       *
                       *  This function will insert a specified number of copies of
                       *  the given data before the location specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      void
                      insert(iterator __position, size_type __n, const value_type& __x)
                      { _M_fill_insert(__position, __n, __x); }
                
                      /**
                       *  @brief  Inserts a range into the %vector.
                       *  @param  position  An iterator into the %vector.
                       *  @param  first  An input iterator.
                       *  @param  last   An input iterator.
                       *
                       *  This function will insert copies of the data in the range
                       *  [first,last) into the %vector before the location specified
                       *  by @a pos.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      template<typename _InputIterator>
                        void
                        insert(iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_insert_dispatch(__position, __first, __last, _Integral());
                	}
                
                      /**
                       *  @brief  Remove element at given position.
                       *  @param  position  Iterator pointing to element to be erased.
                       *  @return  An iterator pointing to the next element (or end()).
                       *
                       *  This function will erase the element at the given position and thus
                       *  shorten the %vector by one.
                       *
                       *  Note This operation could be expensive and if it is
                       *  frequently used the user should consider using std::list.
                       *  The user is also cautioned that this function only erases
                       *  the element, and that if the element is itself a pointer,
                       *  the pointed-to memory is not touched in any way.  Managing
                       *  the pointer is the user's responsibility.
                       */
                      iterator
                      erase(iterator __position);
                
                      /**
                       *  @brief  Remove a range of elements.
                       *  @param  first  Iterator pointing to the first element to be erased.
                       *  @param  last  Iterator pointing to one past the last element to be
                       *                erased.
                       *  @return  An iterator pointing to the element pointed to by @a last
                       *           prior to erasing (or end()).
                       *
                       *  This function will erase the elements in the range [first,last) and
                       *  shorten the %vector accordingly.
                       *
                       *  Note This operation could be expensive and if it is
                       *  frequently used the user should consider using std::list.
                       *  The user is also cautioned that this function only erases
                       *  the elements, and that if the elements themselves are
                       *  pointers, the pointed-to memory is not touched in any way.
                       *  Managing the pointer is the user's responsibility.
                       */
                      iterator
                      erase(iterator __first, iterator __last);
                
                      /**
                       *  @brief  Swaps data with another %vector.
                       *  @param  x  A %vector of the same element and allocator types.
                       *
                       *  This exchanges the elements between two vectors in constant time.
                       *  (Three pointers, so it should be quite fast.)
                       *  Note that the global std::swap() function is specialized such that
                       *  std::swap(v1,v2) will feed to this function.
                       */
                      void
                      swap(vector& __x)
                      {
                	std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
                	std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
                	std::swap(this->_M_impl._M_end_of_storage,
                		  __x._M_impl._M_end_of_storage);
                
                	// _GLIBCXX_RESOLVE_LIB_DEFECTS
                	// 431. Swapping containers with unequal allocators.
                	std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
                						    __x._M_get_Tp_allocator());
                      }
                
                      /**
                       *  Erases all the elements.  Note that this function only erases the
                       *  elements, and that if the elements themselves are pointers, the
                       *  pointed-to memory is not touched in any way.  Managing the pointer is
                       *  the user's responsibility.
                       */
                      void
                      clear()
                      { _M_erase_at_end(this->_M_impl._M_start); }
                
                    protected:
                      /**
                       *  Memory expansion handler.  Uses the member allocation function to
                       *  obtain @a n bytes of memory, and then copies [first,last) into it.
                       */
                      template<typename _ForwardIterator>
                        pointer
                        _M_allocate_and_copy(size_type __n,
                			     _ForwardIterator __first, _ForwardIterator __last)
                        {
                	  pointer __result = this->_M_allocate(__n);
                	  __try
                	    {
                	      std::__uninitialized_copy_a(__first, __last, __result,
                					  _M_get_Tp_allocator());
                	      return __result;
                	    }
                	  __catch(...)
                	    {
                	      _M_deallocate(__result, __n);
                	      __throw_exception_again;
                	    }
                	}
                
                
                      // Internal constructor functions follow.
                
                      // Called by the range constructor to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
                        {
                	  this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
                	  this->_M_impl._M_end_of_storage =
                	    this->_M_impl._M_start + static_cast<size_type>(__n);
                	  _M_fill_initialize(static_cast<size_type>(__n), __value);
                	}
                
                      // Called by the range constructor to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
                			       __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                	  _M_range_initialize(__first, __last, _IterCategory());
                	}
                
                      // Called by the second initialize_dispatch above
                      template<typename _InputIterator>
                        void
                        _M_range_initialize(_InputIterator __first,
                			    _InputIterator __last, std::input_iterator_tag)
                        {
                	  for (; __first != __last; ++__first)
                	    push_back(*__first);
                	}
                
                      // Called by the second initialize_dispatch above
                      template<typename _ForwardIterator>
                        void
                        _M_range_initialize(_ForwardIterator __first,
                			    _ForwardIterator __last, std::forward_iterator_tag)
                        {
                	  const size_type __n = std::distance(__first, __last);
                	  this->_M_impl._M_start = this->_M_allocate(__n);
                	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                	  this->_M_impl._M_finish =
                	    std::__uninitialized_copy_a(__first, __last,
                					this->_M_impl._M_start,
                					_M_get_Tp_allocator());
                	}
                
                      // Called by the first initialize_dispatch above and by the
                      // vector(n,value,a) constructor.
                      void
                      _M_fill_initialize(size_type __n, const value_type& __value)
                      {
                	std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, 
                				      _M_get_Tp_allocator());
                	this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
                      }
                
                
                      // Internal assign functions follow.  The *_aux functions do the actual
                      // assignment work for the range versions.
                
                      // Called by the range assign to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
                        { _M_fill_assign(__n, __val); }
                
                      // Called by the range assign to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
                			   __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                	  _M_assign_aux(__first, __last, _IterCategory());
                	}
                
                      // Called by the second assign_dispatch above
                      template<typename _InputIterator>
                        void
                        _M_assign_aux(_InputIterator __first, _InputIterator __last,
                		      std::input_iterator_tag);
                
                      // Called by the second assign_dispatch above
                      template<typename _ForwardIterator>
                        void
                        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                		      std::forward_iterator_tag);
                
                      // Called by assign(n,t), and the range assign when it turns out
                      // to be the same thing.
                      void
                      _M_fill_assign(size_type __n, const value_type& __val);
                
                
                      // Internal insert functions follow.
                
                      // Called by the range insert to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
                			   __true_type)
                        { _M_fill_insert(__pos, __n, __val); }
                
                      // Called by the range insert to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_insert_dispatch(iterator __pos, _InputIterator __first,
                			   _InputIterator __last, __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                	  _M_range_insert(__pos, __first, __last, _IterCategory());
                	}
                
                      // Called by the second insert_dispatch above
                      template<typename _InputIterator>
                        void
                        _M_range_insert(iterator __pos, _InputIterator __first,
                			_InputIterator __last, std::input_iterator_tag);
                
                      // Called by the second insert_dispatch above
                      template<typename _ForwardIterator>
                        void
                        _M_range_insert(iterator __pos, _ForwardIterator __first,
                			_ForwardIterator __last, std::forward_iterator_tag);
                
                      // Called by insert(p,n,x), and the range insert when it turns out to be
                      // the same thing.
                      void
                      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
                
                      // Called by insert(p,x)
                #ifndef __GXX_EXPERIMENTAL_CXX0X__
                      void
                      _M_insert_aux(iterator __position, const value_type& __x);
                #else
                      template<typename... _Args>
                        void
                        _M_insert_aux(iterator __position, _Args&&... __args);
                #endif
                
                      // Called by the latter.
                      size_type
                      _M_check_len(size_type __n, const char* __s) const
                      {
                	if (max_size() - size() < __n)
                	  __throw_length_error(__N(__s));
                
                	const size_type __len = size() + std::max(size(), __n);
                	return (__len < size() || __len > max_size()) ? max_size() : __len;
                      }
                
                      // Internal erase functions follow.
                
                      // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
                      // _M_assign_aux.
                      void
                      _M_erase_at_end(pointer __pos)
                      {
                	std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
                	this->_M_impl._M_finish = __pos;
                      }
                    };
                
                
                  /**
                   *  @brief  Vector equality comparison.
                   *  @param  x  A %vector.
                   *  @param  y  A %vector of the same type as @a x.
                   *  @return  True iff the size and elements of the vectors are equal.
                   *
                   *  This is an equivalence relation.  It is linear in the size of the
                   *  vectors.  Vectors are considered equivalent if their sizes are equal,
                   *  and if corresponding elements compare equal.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return (__x.size() == __y.size()
                	      && std::equal(__x.begin(), __x.end(), __y.begin())); }
                
                  /**
                   *  @brief  Vector ordering relation.
                   *  @param  x  A %vector.
                   *  @param  y  A %vector of the same type as @a x.
                   *  @return  True iff @a x is lexicographically less than @a y.
                   *
                   *  This is a total ordering relation.  It is linear in the size of the
                   *  vectors.  The elements must be comparable with @c <.
                   *
                   *  See std::lexicographical_compare() for how the determination is made.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return std::lexicographical_compare(__x.begin(), __x.end(),
                					  __y.begin(), __y.end()); }
                
                  /// Based on operator==
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return __y < __x; }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__y < __x); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__x < __y); }
                
                  /// See std::vector::swap().
                  template<typename _Tp, typename _Alloc>
                    inline void
                    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
                    { __x.swap(__y); }
                
                _GLIBCXX_END_NESTED_NAMESPACE
                
                #endif /* _STL_VECTOR_H */


Top 10 Lines:

     Line      Count

       75          1
       84          1
      110          1
      131          1
      227          1
      312          1

Execution Summary:

        9   Executable lines in this file
        9   Lines executed
   100.00   Percent of the file executed

        6   Total number of line executions
     0.67   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9Core/include/jp/ggaf/dx9core/util/XFile/framework/../framework/frm_Material.h:
                /////////////////////////////////////////////////////////
                // Frm_Material.h
                //
                //
                /////////////////////////////////////////////////////////
                
                #ifndef FRM_MATERIAL_H
                #define FRM_MATERIAL_H
                
                #include "../framework/frm_types.h"
                
                namespace Frm {
                
          19 -> class Material {
                public:
                    //tsuge add bigin --->
          19 ->     Material() {
                    }
                    //<--- tsuge add bigin
                
                    bool IsName(std::string &pText) {
                        if (strcmp(pText.c_str(), _Name.c_str()) == 0)
                            return true;
                        return false;
                    }
                    std::string _Name;
                    Color4 _FaceColor;
                    float _power;
                    Color3 _SpecularColor, _EmissiveColor;
                    uint16 _TextID;
                    std::string _TextureName;
                };
                
                }
                #endif


Top 10 Lines:

     Line      Count

       14         19
       17         19

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

       38   Total number of line executions
    19.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/manager/GgafDx9EffectConnection.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                
          11 -> GgafDx9EffectConnection::GgafDx9EffectConnection(char* prm_idstr, GgafDx9Effect* prm_pEffect)
                	:GgafResourceConnection<GgafDx9Effect>(prm_idstr, prm_pEffect) {
                }
                
                void GgafDx9EffectConnection::processReleaseResource(GgafDx9Effect* prm_pResource) {
                	DELETE_IMPOSSIBLE_NULL(prm_pResource);
                }
                


Top 10 Lines:

     Line      Count

        7         11

Execution Summary:

        2   Executable lines in this file
        1   Lines executed
    50.00   Percent of the file executed

       11   Total number of line executions
     5.50   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9Core/include/jp/ggaf/dx9core/manager/GgafDx9EffectConnection.h:
                #ifndef GGAFDX9EFFECTCONNECTION_H_
                #define GGAFDX9EFFECTCONNECTION_H_
                namespace GgafDx9Core {
                
                /**
                 * fNX.
                 * L(AN^[)`FNXB<BR>
                 * @version 1.00
                 * @since 2009/02/09
                 * @author Masatoshi Tsuge
                 */
                class GgafDx9EffectConnection : public GgafCore::GgafResourceConnection<GgafDx9Effect> {
                
                public:
                
                    /**
                     * RXgN^<BR>
                     * @param prm_idstr GtFNg(t@C)
                     * @param prm_pEffect GtFNg
                     */
                    GgafDx9EffectConnection(char* prm_idstr, GgafDx9Effect* prm_pEffect);
                
                    /**
                     * I[o[Ch
                     */
                    void processReleaseResource(GgafDx9Effect* prm_pResource);
                
                    /**
                     * fXgN^<BR>
                     */
          22 ->     virtual ~GgafDx9EffectConnection() {
                    }
                };
                
                }
                #endif /*GGAFDX9EFFECTCONNECTION_H_*/


Top 10 Lines:

     Line      Count

       31         22

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       22   Total number of line executions
    22.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/effect/GgafDx9PointSpriteEffect.cpp:
                #include "stdafx.h"
                
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
           1 -> GgafDx9PointSpriteEffect::GgafDx9PointSpriteEffect(char* prm_effect_name) : GgafDx9Effect(prm_effect_name) {
                    //VF[_[O[o
                    HRESULT hr;
                //    //VIEWs
                //    hr = _pID3DXEffect->SetMatrix( "g_matView", &GgafDx9God::_vMatrixView );
                //    checkDxException(hr, D3D_OK, "GgafDx9PointSpriteEffect::GgafDx9PointSpriteEffect SetMatrix(g_matView) sB");
                    //es
                    hr = _pID3DXEffect->SetMatrix("g_matProj", &P_CAM->_vMatrixProj );
                    checkDxException(hr, D3D_OK, "GgafDx9PointSpriteEffect::GgafDx9PointSpriteEffect SetMatrix(g_matProj) sB");
                    hr = _pID3DXEffect->SetFloat("g_dist_CamZ_default", -(P_CAM->_cameraZ_org));
                    checkDxException(hr, D3D_OK, "GgafDx9PointSpriteEffect::GgafDx9PointSpriteEffect SetFloat(g_dist_CamZ_default) sB");
                    hr = _pID3DXEffect->SetFloat("g_zn", P_CAM->_zn);
                    checkDxException(hr, D3D_OK, "GgafDx9PointSpriteEffect::GgafDx9PointSpriteEffect SetFloat(g_zn) sB");
                    hr = _pID3DXEffect->SetFloat("g_zf", P_CAM->_zf);
                    checkDxException(hr, D3D_OK, "GgafDx9PointSpriteEffect::GgafDx9SpriteEffect SetFloat(g_zf) sB");
                
                    //_TRACE_("GgafDx9PointSpriteEffect::GgafDx9PointSpriteEffect g_dist_CamZ_default="<<P_CAM->_zn<<" g_dist_CamZ_default="<<( -(P_CAM->_cameraZ_org))<<"");
                    //checkDxException(hr, D3D_OK, "GgafDx9PointSpriteEffect::GgafDx9PointSpriteEffect SetFloat(g_zn) sB");
                    //VF[_[nh
                    _h_matView  = _pID3DXEffect->GetParameterByName( NULL, "g_matView" );
                    _h_matWorld = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld" );
                    _hAlpha    = _pID3DXEffect->GetParameterByName( NULL, "g_hAlpha" );
                    _h_tex_blink_power = _pID3DXEffect->GetParameterByName( NULL, "g_tex_blink_power" );
                    _h_tex_blink_threshold = _pID3DXEffect->GetParameterByName( NULL, "g_tex_blink_threshold" );
                    _h_dist_VpFrontPlane = _pID3DXEffect->GetParameterByName( NULL, "g_dist_VpFrontPlane" );
                    _hTexSize = _pID3DXEffect->GetParameterByName( NULL, "g_TexSize" );
                    _hTextureSplitRowcol = _pID3DXEffect->GetParameterByName( NULL, "g_TextureSplitRowcol" );
                    _hUvFlipPtnNo = _pID3DXEffect->GetParameterByName( NULL, "g_UvFlipPtnNo" );
                }
                
                void GgafDx9PointSpriteEffect::setParamPerFrame() {
                    HRESULT hr = _pID3DXEffect->SetMatrix(_h_matView, &P_CAM->_vMatrixView );
                    checkDxException(hr, D3D_OK, "setParamPerFrame SetMatrix(_h_matView) sB");
                }
                
           2 -> GgafDx9PointSpriteEffect::~GgafDx9PointSpriteEffect() {
                }
                


Top 10 Lines:

     Line      Count

       42          2
        7          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/effect/GgafDx9BoardSetEffect.cpp:
                #include "stdafx.h"
                
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
           2 -> GgafDx9BoardSetEffect::GgafDx9BoardSetEffect(char* prm_effect_name) : GgafDx9Effect(prm_effect_name) {
                    //VF[_[O[o
                    HRESULT hr;
                //    static float view_width = (float)(GGAFDX9_PROPERTY(VIEW_SCREEN_WIDTH));
                //    static float view_height = (float)(GGAFDX9_PROPERTY(VIEW_SCREEN_HEIGHT));
                
                    static float view_width = (float)(GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH));
                    static float view_height = (float)(GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT));
                
                    hr = _pID3DXEffect->SetFloat("g_view_width", view_width);
                    checkDxException(hr, D3D_OK, "GgafDx9BoardEffect::GgafDx9BoardEffect SetFloat(g_view_width) sB");
                    hr = _pID3DXEffect->SetFloat("g_view_height", view_height);
                    checkDxException(hr, D3D_OK, "GgafDx9BoardEffect::GgafDx9BoardEffect SetFloat(g_view_height) sB");
                
                    //nh
                    _ahAlpha[0] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha001" );
                    _ahAlpha[1] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha002" );
                    _ahAlpha[2] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha003" );
                    _ahAlpha[3] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha004" );
                    _ahAlpha[4] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha005" );
                    _ahAlpha[5] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha006" );
                    _ahAlpha[6] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha007" );
                    _ahAlpha[7] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha008" );
                    _ahAlpha[8] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha009" );
                    _ahAlpha[9] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha010" );
                    _ahAlpha[10] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha011" );
                    _ahAlpha[11] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha012" );
                    _ahAlpha[12] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha013" );
                    _ahAlpha[13] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha014" );
                    _ahAlpha[14] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha015" );
                    _ahAlpha[15] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha016" );
                    _ahAlpha[16] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha017" );
                    _ahAlpha[17] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha018" );
                    _ahAlpha[18] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha019" );
                    _ahAlpha[19] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha020" );
                    _ahAlpha[20] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha021" );
                    _ahAlpha[21] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha022" );
                    _ahAlpha[22] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha023" );
                    _ahAlpha[23] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha024" );
                    _ahAlpha[24] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha025" );
                    _ahAlpha[25] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha026" );
                    _ahAlpha[26] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha027" );
                    _ahAlpha[27] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha028" );
                
                    _ahOffsetU[0] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU001" );
                    _ahOffsetU[1] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU002" );
                    _ahOffsetU[2] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU003" );
                    _ahOffsetU[3] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU004" );
                    _ahOffsetU[4] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU005" );
                    _ahOffsetU[5] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU006" );
                    _ahOffsetU[6] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU007" );
                    _ahOffsetU[7] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU008" );
                    _ahOffsetU[8] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU009" );
                    _ahOffsetU[9] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU010" );
                    _ahOffsetU[10] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU011" );
                    _ahOffsetU[11] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU012" );
                    _ahOffsetU[12] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU013" );
                    _ahOffsetU[13] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU014" );
                    _ahOffsetU[14] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU015" );
                    _ahOffsetU[15] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU016" );
                    _ahOffsetU[16] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU017" );
                    _ahOffsetU[17] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU018" );
                    _ahOffsetU[18] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU019" );
                    _ahOffsetU[19] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU020" );
                    _ahOffsetU[20] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU021" );
                    _ahOffsetU[21] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU022" );
                    _ahOffsetU[22] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU023" );
                    _ahOffsetU[23] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU024" );
                    _ahOffsetU[24] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU025" );
                    _ahOffsetU[25] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU026" );
                    _ahOffsetU[26] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU027" );
                    _ahOffsetU[27] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU028" );
                
                    _ahOffsetV[0] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV001" );
                    _ahOffsetV[1] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV002" );
                    _ahOffsetV[2] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV003" );
                    _ahOffsetV[3] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV004" );
                    _ahOffsetV[4] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV005" );
                    _ahOffsetV[5] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV006" );
                    _ahOffsetV[6] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV007" );
                    _ahOffsetV[7] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV008" );
                    _ahOffsetV[8] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV009" );
                    _ahOffsetV[9] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV010" );
                    _ahOffsetV[10] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV011" );
                    _ahOffsetV[11] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV012" );
                    _ahOffsetV[12] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV013" );
                    _ahOffsetV[13] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV014" );
                    _ahOffsetV[14] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV015" );
                    _ahOffsetV[15] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV016" );
                    _ahOffsetV[16] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV017" );
                    _ahOffsetV[17] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV018" );
                    _ahOffsetV[18] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV019" );
                    _ahOffsetV[19] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV020" );
                    _ahOffsetV[20] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV021" );
                    _ahOffsetV[21] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV022" );
                    _ahOffsetV[22] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV023" );
                    _ahOffsetV[23] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV024" );
                    _ahOffsetV[24] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV025" );
                    _ahOffsetV[25] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV026" );
                    _ahOffsetV[26] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV027" );
                    _ahOffsetV[27] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV028" );
                
                    _ahTransformedX[0] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX001" );
                    _ahTransformedX[1] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX002" );
                    _ahTransformedX[2] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX003" );
                    _ahTransformedX[3] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX004" );
                    _ahTransformedX[4] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX005" );
                    _ahTransformedX[5] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX006" );
                    _ahTransformedX[6] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX007" );
                    _ahTransformedX[7] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX008" );
                    _ahTransformedX[8] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX009" );
                    _ahTransformedX[9] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX010" );
                    _ahTransformedX[10] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX011" );
                    _ahTransformedX[11] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX012" );
                    _ahTransformedX[12] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX013" );
                    _ahTransformedX[13] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX014" );
                    _ahTransformedX[14] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX015" );
                    _ahTransformedX[15] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX016" );
                    _ahTransformedX[16] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX017" );
                    _ahTransformedX[17] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX018" );
                    _ahTransformedX[18] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX019" );
                    _ahTransformedX[19] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX020" );
                    _ahTransformedX[20] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX021" );
                    _ahTransformedX[21] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX022" );
                    _ahTransformedX[22] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX023" );
                    _ahTransformedX[23] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX024" );
                    _ahTransformedX[24] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX025" );
                    _ahTransformedX[25] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX026" );
                    _ahTransformedX[26] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX027" );
                    _ahTransformedX[27] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX028" );
                
                    _ahTransformedY[0] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY001" );
                    _ahTransformedY[1] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY002" );
                    _ahTransformedY[2] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY003" );
                    _ahTransformedY[3] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY004" );
                    _ahTransformedY[4] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY005" );
                    _ahTransformedY[5] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY006" );
                    _ahTransformedY[6] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY007" );
                    _ahTransformedY[7] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY008" );
                    _ahTransformedY[8] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY009" );
                    _ahTransformedY[9] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY010" );
                    _ahTransformedY[10] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY011" );
                    _ahTransformedY[11] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY012" );
                    _ahTransformedY[12] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY013" );
                    _ahTransformedY[13] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY014" );
                    _ahTransformedY[14] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY015" );
                    _ahTransformedY[15] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY016" );
                    _ahTransformedY[16] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY017" );
                    _ahTransformedY[17] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY018" );
                    _ahTransformedY[18] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY019" );
                    _ahTransformedY[19] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY020" );
                    _ahTransformedY[20] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY021" );
                    _ahTransformedY[21] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY022" );
                    _ahTransformedY[22] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY023" );
                    _ahTransformedY[23] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY024" );
                    _ahTransformedY[24] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY025" );
                    _ahTransformedY[25] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY026" );
                    _ahTransformedY[26] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY027" );
                    _ahTransformedY[27] = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY028" );
                
                    _ahDepthZ[0] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ001" );
                    _ahDepthZ[1] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ002" );
                    _ahDepthZ[2] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ003" );
                    _ahDepthZ[3] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ004" );
                    _ahDepthZ[4] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ005" );
                    _ahDepthZ[5] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ006" );
                    _ahDepthZ[6] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ007" );
                    _ahDepthZ[7] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ008" );
                    _ahDepthZ[8] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ009" );
                    _ahDepthZ[9] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ010" );
                    _ahDepthZ[10] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ011" );
                    _ahDepthZ[11] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ012" );
                    _ahDepthZ[12] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ013" );
                    _ahDepthZ[13] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ014" );
                    _ahDepthZ[14] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ015" );
                    _ahDepthZ[15] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ016" );
                    _ahDepthZ[16] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ017" );
                    _ahDepthZ[17] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ018" );
                    _ahDepthZ[18] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ019" );
                    _ahDepthZ[19] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ020" );
                    _ahDepthZ[20] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ021" );
                    _ahDepthZ[21] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ022" );
                    _ahDepthZ[22] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ023" );
                    _ahDepthZ[23] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ024" );
                    _ahDepthZ[24] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ025" );
                    _ahDepthZ[25] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ026" );
                    _ahDepthZ[26] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ027" );
                    _ahDepthZ[27] = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ028" );
                
                    _h_tex_blink_power = _pID3DXEffect->GetParameterByName( NULL, "g_tex_blink_power" );
                    _h_tex_blink_threshold = _pID3DXEffect->GetParameterByName( NULL, "g_tex_blink_threshold" );
                }
                
           4 -> GgafDx9BoardSetEffect::~GgafDx9BoardSetEffect() {
                }
                


Top 10 Lines:

     Line      Count

      200          4
        7          2

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        6   Total number of line executions
     2.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/effect/GgafDx9BoardEffect.cpp:
                #include "stdafx.h"
                
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
           1 -> GgafDx9BoardEffect::GgafDx9BoardEffect(char* prm_effect_name) : GgafDx9Effect(prm_effect_name) {
                    //VF[_[O[o
                    HRESULT hr;
                    static float view_width = (float)(GGAFDX9_PROPERTY(VIEW_SCREEN_WIDTH));
                    static float view_height = (float)(GGAFDX9_PROPERTY(VIEW_SCREEN_HEIGHT));
                
                    hr = _pID3DXEffect->SetFloat("g_view_width", view_width);
                    checkDxException(hr, D3D_OK, "GgafDx9BoardEffect::GgafDx9BoardEffect SetFloat(g_view_width) sB");
                    hr = _pID3DXEffect->SetFloat("g_view_height", view_height);
                    checkDxException(hr, D3D_OK, "GgafDx9BoardEffect::GgafDx9BoardEffect SetFloat(g_view_height) sB");
                
                    //nh
                    _hAlpha = _pID3DXEffect->GetParameterByName( NULL, "g_alpha" );
                    _hOffsetU = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU" );
                    _hOffsetV = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV" );
                    _hTransformedX = _pID3DXEffect->GetParameterByName( NULL, "g_transformedX" );
                    _hTransformedY = _pID3DXEffect->GetParameterByName( NULL, "g_transformedY" );
                    _hDepthZ = _pID3DXEffect->GetParameterByName( NULL, "g_depthZ" );
                    _hSx = _pID3DXEffect->GetParameterByName( NULL, "g_sx" );
                    _hSy = _pID3DXEffect->GetParameterByName( NULL, "g_sy" );
                    _h_tex_blink_power = _pID3DXEffect->GetParameterByName( NULL, "g_tex_blink_power" );
                    _h_tex_blink_threshold = _pID3DXEffect->GetParameterByName( NULL, "g_tex_blink_threshold" );
                }
                
                
           2 -> GgafDx9BoardEffect::~GgafDx9BoardEffect() {
                }
                


Top 10 Lines:

     Line      Count

       32          2
        7          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/effect/GgafDx9SpriteSetEffect.cpp:
                #include "stdafx.h"
                
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
           1 -> GgafDx9SpriteSetEffect::GgafDx9SpriteSetEffect(char* prm_effect_name) : GgafDx9Effect(prm_effect_name) {
                    //VF[_[O[o
                    HRESULT hr;
                //    //VIEWs
                //    hr = _pID3DXEffect->SetMatrix( "g_matView", &GgafDx9God::_vMatrixView );
                //    checkDxException(hr, D3D_OK, "GgafDx9SpriteSetEffect::GgafDx9SpriteSetEffect SetMatrix(g_matView) sB");
                    //es
                    hr = _pID3DXEffect->SetMatrix("g_matProj", &P_CAM->_vMatrixProj );
                    checkDxException(hr, D3D_OK, "GgafDx9SpriteSetEffect::GgafDx9SpriteSetEffect SetMatrix() sB");
                
                    hr = _pID3DXEffect->SetFloat("g_zf", P_CAM->_zf);
                    checkDxException(hr, D3D_OK, "GgafDx9SpriteEffect::GgafDx9SpriteEffect SetFloat(g_zf) sB");
                
                
                    //VF[_[nh
                    _h_matView  = _pID3DXEffect->GetParameterByName( NULL, "g_matView" );
                    _ah_matWorld[0] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld001" );
                    _ah_matWorld[1] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld002" );
                    _ah_matWorld[2] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld003" );
                    _ah_matWorld[3] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld004" );
                    _ah_matWorld[4] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld005" );
                    _ah_matWorld[5] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld006" );
                    _ah_matWorld[6] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld007" );
                    _ah_matWorld[7] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld008" );
                    _ah_matWorld[8] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld009" );
                    _ah_matWorld[9] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld010" );
                    _ah_matWorld[10] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld011" );
                    _ah_matWorld[11] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld012" );
                    _ah_matWorld[12] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld013" );
                    _ah_matWorld[13] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld014" );
                    _ah_matWorld[14] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld015" );
                    _ah_matWorld[15] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld016" );
                    _ah_matWorld[16] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld017" );
                    _ah_matWorld[17] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld018" );
                //    _ah_matWorld[18] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld019" );
                //    _ah_matWorld[19] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld020" );
                //    _ah_matWorld[20] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld021" );
                //    _ah_matWorld[21] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld022" );
                //    _ah_matWorld[22] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld023" );
                //    _ah_matWorld[23] = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld024" );
                
                    _ahOffsetU[0] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU001" );
                    _ahOffsetU[1] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU002" );
                    _ahOffsetU[2] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU003" );
                    _ahOffsetU[3] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU004" );
                    _ahOffsetU[4] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU005" );
                    _ahOffsetU[5] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU006" );
                    _ahOffsetU[6] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU007" );
                    _ahOffsetU[7] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU008" );
                    _ahOffsetU[8] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU009" );
                    _ahOffsetU[9] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU010" );
                    _ahOffsetU[10] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU011" );
                    _ahOffsetU[11] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU012" );
                    _ahOffsetU[12] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU013" );
                    _ahOffsetU[13] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU014" );
                    _ahOffsetU[14] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU015" );
                    _ahOffsetU[15] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU016" );
                    _ahOffsetU[16] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU017" );
                    _ahOffsetU[17] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU018" );
                //    _ahOffsetU[18] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU019" );
                //    _ahOffsetU[19] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU020" );
                //    _ahOffsetU[20] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU021" );
                //    _ahOffsetU[21] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU022" );
                //    _ahOffsetU[22] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU023" );
                //    _ahOffsetU[23] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU024" );
                
                    _ahOffsetV[0] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV001" );
                    _ahOffsetV[1] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV002" );
                    _ahOffsetV[2] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV003" );
                    _ahOffsetV[3] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV004" );
                    _ahOffsetV[4] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV005" );
                    _ahOffsetV[5] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV006" );
                    _ahOffsetV[6] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV007" );
                    _ahOffsetV[7] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV008" );
                    _ahOffsetV[8] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV009" );
                    _ahOffsetV[9] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV010" );
                    _ahOffsetV[10] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV011" );
                    _ahOffsetV[11] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV012" );
                    _ahOffsetV[12] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV013" );
                    _ahOffsetV[13] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV014" );
                    _ahOffsetV[14] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV015" );
                    _ahOffsetV[15] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV016" );
                    _ahOffsetV[16] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV017" );
                    _ahOffsetV[17] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV018" );
                //    _ahOffsetV[18] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV019" );
                //    _ahOffsetV[19] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV020" );
                //    _ahOffsetV[20] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV021" );
                //    _ahOffsetV[21] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV022" );
                //    _ahOffsetV[22] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV023" );
                //    _ahOffsetV[23] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV024" );
                
                    _ahAlpha[0] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha001" );
                    _ahAlpha[1] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha002" );
                    _ahAlpha[2] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha003" );
                    _ahAlpha[3] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha004" );
                    _ahAlpha[4] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha005" );
                    _ahAlpha[5] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha006" );
                    _ahAlpha[6] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha007" );
                    _ahAlpha[7] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha008" );
                    _ahAlpha[8] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha009" );
                    _ahAlpha[9] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha010" );
                    _ahAlpha[10] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha011" );
                    _ahAlpha[11] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha012" );
                    _ahAlpha[12] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha013" );
                    _ahAlpha[13] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha014" );
                    _ahAlpha[14] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha015" );
                    _ahAlpha[15] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha016" );
                    _ahAlpha[16] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha017" );
                    _ahAlpha[17] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha018" );
                //    _ahAlpha[18] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha019" );
                //    _ahAlpha[19] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha020" );
                //    _ahAlpha[20] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha021" );
                //    _ahAlpha[21] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha022" );
                //    _ahAlpha[22] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha023" );
                //    _ahAlpha[23] = _pID3DXEffect->GetParameterByName( NULL, "g_alpha024" );
                
                    _h_tex_blink_power = _pID3DXEffect->GetParameterByName( NULL, "g_tex_blink_power" );
                    _h_tex_blink_threshold = _pID3DXEffect->GetParameterByName( NULL, "g_tex_blink_threshold" );
                }
                
                void GgafDx9SpriteSetEffect::setParamPerFrame() {
                    HRESULT hr = _pID3DXEffect->SetMatrix(_h_matView, &P_CAM->_vMatrixView );
                    checkDxException(hr, D3D_OK, "setParamPerFrame SetMatrix(_h_matView) sB");
                }
                
           2 -> GgafDx9SpriteSetEffect::~GgafDx9SpriteSetEffect() {
                }
                


Top 10 Lines:

     Line      Count

      132          2
        7          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/effect/GgafDx9SpriteEffect.cpp:
                #include "stdafx.h"
                
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
           1 -> GgafDx9SpriteEffect::GgafDx9SpriteEffect(char* prm_effect_name) : GgafDx9Effect(prm_effect_name) {
                    //VF[_[O[o
                    HRESULT hr;
                //    //VIEWs
                //    hr = _pID3DXEffect->SetMatrix( "g_matView", &GgafDx9God::_vMatrixView );
                //    checkDxException(hr, D3D_OK, "GgafDx9SpriteEffect::GgafDx9SpriteEffect SetMatrix(g_matView) sB");
                    //es
                    hr = _pID3DXEffect->SetMatrix("g_matProj", &P_CAM->_vMatrixProj );
                    checkDxException(hr, D3D_OK, "GgafDx9SpriteEffect::GgafDx9SpriteEffect SetMatrix() sB");
                
                    hr = _pID3DXEffect->SetFloat("g_zf", P_CAM->_zf);
                    checkDxException(hr, D3D_OK, "GgafDx9SpriteEffect::GgafDx9SpriteEffect SetFloat(g_zf) sB");
                
                
                    //VF[_[nh
                    _h_matView  = _pID3DXEffect->GetParameterByName( NULL, "g_matView" );
                    _h_matWorld = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld" );
                    _hAlpha    = _pID3DXEffect->GetParameterByName( NULL, "g_hAlpha" );
                    _hOffsetU  = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU" );
                    _hOffsetV  = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV" );
                    _h_tex_blink_power = _pID3DXEffect->GetParameterByName( NULL, "g_tex_blink_power" );
                    _h_tex_blink_threshold = _pID3DXEffect->GetParameterByName( NULL, "g_tex_blink_threshold" );
                }
                
                void GgafDx9SpriteEffect::setParamPerFrame() {
                    HRESULT hr = _pID3DXEffect->SetMatrix(_h_matView, &P_CAM->_vMatrixView );
                    checkDxException(hr, D3D_OK, "setParamPerFrame SetMatrix(_h_matView) sB");
                }
                
           2 -> GgafDx9SpriteEffect::~GgafDx9SpriteEffect() {
                }
                


Top 10 Lines:

     Line      Count

       36          2
        7          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/effect/GgafDx9MeshSetEffect.cpp:
                #include "stdafx.h"
                
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
           3 -> GgafDx9MeshSetEffect::GgafDx9MeshSetEffect(char* prm_effect_name) : GgafDx9Effect(prm_effect_name) {
                
                    //VF[_[O[o
                    HRESULT hr;
                
                    //es
                    hr = _pID3DXEffect->SetMatrix("g_matProj", &P_CAM->_vMatrixProj );
                    checkDxException(hr, D3D_OK, "GgafDx9MeshActor::GgafDx9MeshSetEffect SetMatrix() sB");
                    //Cg
                    hr = _pID3DXEffect->SetValue("g_vecLightDirection", &(GgafDx9God::_d3dlight9_default.Direction), sizeof(D3DVECTOR) );
                    checkDxException(hr, D3D_OK, "GgafDx9MeshSetEffect::GgafDx9MeshSetEffect SetValue(g_vecLightDirection) sB");
                    //Diffuse
                    hr = _pID3DXEffect->SetValue("g_colLightDiffuse", &(GgafDx9God::_d3dlight9_default.Diffuse), sizeof(D3DCOLORVALUE));
                    checkDxException(hr, D3D_OK, "GgafDx9MeshSetEffect::GgafDx9MeshSetEffect SetValue(g_colLightDiffuse) sB");
                    //Ambient
                    hr = _pID3DXEffect->SetValue("g_colLightAmbient", &(GgafDx9God::_d3dlight9_default.Ambient), sizeof(D3DCOLORVALUE));
                    checkDxException(hr, D3D_OK, "GgafDx9MeshSetEffect::GgafDx9MeshSetEffect SetValue(g_colLightAmbient) sB");
                
                    hr = _pID3DXEffect->SetFloat("g_zf", P_CAM->_zf);
                    checkDxException(hr, D3D_OK, "GgafDx9MeshSetEffect::GgafDx9SpriteEffect SetFloat(g_zf) sB");
                
                    //VF[_[nh
                    _h_matView = _pID3DXEffect->GetParameterByName( NULL, "g_matView" );
                    _ah_matWorld[0]  = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld001" );
                    _ah_matWorld[1]  = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld002" );
                    _ah_matWorld[2]  = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld003" );
                    _ah_matWorld[3]  = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld004" );
                    _ah_matWorld[4]  = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld005" );
                    _ah_matWorld[5]  = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld006" );
                    _ah_matWorld[6]  = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld007" );
                    _ah_matWorld[7]  = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld008" );
                    _ah_matWorld[8]  = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld009" );
                    _ah_matWorld[9]  = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld010" );
                    _ah_matWorld[10]  = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld011" );
                    _ah_matWorld[11]  = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld012" );
                    _ah_matWorld[12]  = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld013" );
                    _ah_matWorld[13]  = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld014" );
                    _ah_matWorld[14]  = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld015" );
                    _ah_matWorld[15]  = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld016" );
                    _ah_matWorld[16]  = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld017" );
                    _ah_matWorld[17]  = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld018" );
                    _ah_matWorld[18]  = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld019" );
                //    _ah_matWorld[19]  = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld020" );
                
                
                
                    _ah_materialDiffuse[0] = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse001" );
                    _ah_materialDiffuse[1] = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse002" );
                    _ah_materialDiffuse[2] = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse003" );
                    _ah_materialDiffuse[3] = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse004" );
                    _ah_materialDiffuse[4] = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse005" );
                    _ah_materialDiffuse[5] = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse006" );
                    _ah_materialDiffuse[6] = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse007" );
                    _ah_materialDiffuse[7] = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse008" );
                    _ah_materialDiffuse[8] = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse009" );
                    _ah_materialDiffuse[9] = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse010" );
                    _ah_materialDiffuse[10] = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse011" );
                    _ah_materialDiffuse[11] = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse012" );
                    _ah_materialDiffuse[12] = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse013" );
                    _ah_materialDiffuse[13] = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse014" );
                    _ah_materialDiffuse[14] = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse015" );
                    _ah_materialDiffuse[15] = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse016" );
                    _ah_materialDiffuse[16] = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse017" );
                    _ah_materialDiffuse[17] = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse018" );
                    _ah_materialDiffuse[18] = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse019" );
                //    _ah_materialDiffuse[19] = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse020" );
                
                
                    _ahOffsetU[0] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU001" );
                    _ahOffsetU[1] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU002" );
                    _ahOffsetU[2] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU003" );
                    _ahOffsetU[3] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU004" );
                    _ahOffsetU[4] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU005" );
                    _ahOffsetU[5] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU006" );
                    _ahOffsetU[6] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU007" );
                    _ahOffsetU[7] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU008" );
                    _ahOffsetU[8] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU009" );
                    _ahOffsetU[9] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU010" );
                    _ahOffsetU[10] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU011" );
                    _ahOffsetU[11] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU012" );
                    _ahOffsetU[12] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU013" );
                    _ahOffsetU[13] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU014" );
                    _ahOffsetU[14] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU015" );
                    _ahOffsetU[15] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU016" );
                    _ahOffsetU[16] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU017" );
                    _ahOffsetU[17] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU018" );
                    _ahOffsetU[18] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU019" );
                //    _ahOffsetU[19] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetU020" );
                
                
                    _ahOffsetV[0] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV001" );
                    _ahOffsetV[1] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV002" );
                    _ahOffsetV[2] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV003" );
                    _ahOffsetV[3] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV004" );
                    _ahOffsetV[4] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV005" );
                    _ahOffsetV[5] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV006" );
                    _ahOffsetV[6] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV007" );
                    _ahOffsetV[7] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV008" );
                    _ahOffsetV[8] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV009" );
                    _ahOffsetV[9] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV010" );
                    _ahOffsetV[10] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV011" );
                    _ahOffsetV[11] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV012" );
                    _ahOffsetV[12] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV013" );
                    _ahOffsetV[13] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV014" );
                    _ahOffsetV[14] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV015" );
                    _ahOffsetV[15] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV016" );
                    _ahOffsetV[16] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV017" );
                    _ahOffsetV[17] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV018" );
                    _ahOffsetV[18] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV019" );
                //    _ahOffsetV[19] = _pID3DXEffect->GetParameterByName( NULL, "g_offsetV020" );
                
                
                    _h_tex_blink_power = _pID3DXEffect->GetParameterByName( NULL, "g_tex_blink_power" );
                    _h_tex_blink_threshold = _pID3DXEffect->GetParameterByName( NULL, "g_tex_blink_threshold" );
                }
                
                void GgafDx9MeshSetEffect::setParamPerFrame() {
                    HRESULT hr = _pID3DXEffect->SetMatrix(_h_matView, &P_CAM->_vMatrixView );
                    checkDxException(hr, D3D_OK, "setParamPerFrame SetMatrix(_h_matView) sB");
                }
                
           6 -> GgafDx9MeshSetEffect::~GgafDx9MeshSetEffect() {
                }
                


Top 10 Lines:

     Line      Count

      128          6
        7          3

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        9   Total number of line executions
     3.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/effect/GgafDx9MeshEffect.cpp:
                #include "stdafx.h"
                
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
           2 -> GgafDx9MeshEffect::GgafDx9MeshEffect(char* prm_effect_name) : GgafDx9Effect(prm_effect_name) {
                
                    //VF[_[O[o
                    HRESULT hr;
                    //es
                    hr = _pID3DXEffect->SetMatrix("g_matProj", &P_CAM->_vMatrixProj );
                    checkDxException(hr, D3D_OK, "GgafDx9MeshActor::GgafDx9MeshEffect SetMatrix() sB");
                    //Cg
                    hr = _pID3DXEffect->SetValue("g_vecLightDirection", &(GgafDx9God::_d3dlight9_default.Direction), sizeof(D3DVECTOR) );
                    checkDxException(hr, D3D_OK, "GgafDx9MeshEffect::GgafDx9MeshEffect SetValue(g_vecLightDirection) sB");
                    //Diffuse
                    hr = _pID3DXEffect->SetValue("g_colLightDiffuse", &(GgafDx9God::_d3dlight9_default.Diffuse), sizeof(D3DCOLORVALUE));
                    checkDxException(hr, D3D_OK, "GgafDx9MeshEffect::GgafDx9MeshEffect SetValue(g_colLightDiffuse) sB");
                    //Ambient
                    hr = _pID3DXEffect->SetValue("g_colLightAmbient", &(GgafDx9God::_d3dlight9_default.Ambient), sizeof(D3DCOLORVALUE));
                    checkDxException(hr, D3D_OK, "GgafDx9MeshEffect::GgafDx9MeshEffect SetValue(g_colLightAmbient) sB");
                
                    hr = _pID3DXEffect->SetFloat("g_zf", P_CAM->_zf);
                    checkDxException(hr, D3D_OK, "GgafDx9MeshEffect::GgafDx9SpriteEffect SetFloat(g_zf) sB");
                    //VF[_[nh
                    _h_matView = _pID3DXEffect->GetParameterByName( NULL, "g_matView" );
                    _h_matWorld = _pID3DXEffect->GetParameterByName( NULL, "g_matWorld" );
                    _h_colMaterialDiffuse = _pID3DXEffect->GetParameterByName( NULL, "g_colMaterialDiffuse" );
                    _h_tex_blink_power = _pID3DXEffect->GetParameterByName( NULL, "g_tex_blink_power" );
                    _h_tex_blink_threshold = _pID3DXEffect->GetParameterByName( NULL, "g_tex_blink_threshold" );
                    _h_offset_u = _pID3DXEffect->GetParameterByName( NULL, "g_offset_u" );
                    _h_offset_v = _pID3DXEffect->GetParameterByName( NULL, "g_offset_v" );
                
                }
                
                void GgafDx9MeshEffect::setParamPerFrame() {
                    HRESULT hr = _pID3DXEffect->SetMatrix(_h_matView, &P_CAM->_vMatrixView );
                    checkDxException(hr, D3D_OK, "setParamPerFrame SetMatrix(_h_matView) sB");
                }
                
           4 -> GgafDx9MeshEffect::~GgafDx9MeshEffect() {
                }
                


Top 10 Lines:

     Line      Count

       42          4
        7          2

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        6   Total number of line executions
     2.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/GgafDx9CameraViewPoint.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
           1 -> GgafDx9CameraViewPoint::GgafDx9CameraViewPoint() : GgafDx9GeometricActor("ViewPoint", NULL) {
                    _class_name = "GgafDx9CameraViewPoint";
                }
                
                void GgafDx9CameraViewPoint::initialize() {
                    _pKuroko->setMvVelo(0);
                }
                
                void GgafDx9CameraViewPoint::processBehavior() {
                //    _pKuroko->behave();
                }
                
                
           2 -> GgafDx9CameraViewPoint::~GgafDx9CameraViewPoint() {
                }


Top 10 Lines:

     Line      Count

       19          2
        6          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/sound/GgafDx9Se.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                
          92 -> GgafDx9Se::GgafDx9Se(char* prm_wave_name) : GgafObject() {
                    if (GgafDx9Sound::_pIDirectSound8 == NULL) {
                        throwGgafCriticalException("GgafDx9Se::GgafDx9Se("<<prm_wave_name<<") DirectSound AB");
                    }
                
                    _wave_name = NEW char[128];
                    strcpy(_wave_name, prm_wave_name);
                    string wave_filename = GGAFDX9_PROPERTY(DIR_WAVE) + string(_wave_name) + ".wav";
                
                    HRESULT hr;
                    // Wavet@CJ
                    CWaveDecorder WaveFile;
                    if (!WaveFile.Open((LPSTR)wave_filename.c_str())) {
                        throwGgafCriticalException("GgafDx9Se::GgafDx9Se("<<prm_wave_name<<") t@C "<<wave_filename<<" JB");
                        //return false;
                    }
                
                    // ZJ_obt@
                    DSBUFFERDESC dsbdesc;
                    ZeroMemory(&dsbdesc, sizeof(DSBUFFERDESC));
                    dsbdesc.dwSize = sizeof(DSBUFFERDESC);
                    //dsbdesc.dwFlags = DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY | DSBCAPS_GLOBALFOCUS | DSBCAPS_LOCSOFTWARE;//| DSBCAPS_GETCURRENTPOSITION2;// | DSBCAPS_LOCSOFTWARE;
                    //TODO:DSBCAPS_LOCSOFTWARE or DSBCAPS_LOCDEFERH
                    //TODO:GgafDx9Bgm vH
                    dsbdesc.dwFlags = DSBCAPS_LOCSOFTWARE | DSBCAPS_CTRLPAN | DSBCAPS_CTRLFREQUENCY | DSBCAPS_CTRLVOLUME | DSBCAPS_GETCURRENTPOSITION2 | DSBCAPS_GLOBALFOCUS;
                    dsbdesc.dwBufferBytes = WaveFile.GetWaveSize();
                    dsbdesc.lpwfxFormat = WaveFile.GetWaveFormat();
                
                    // obt@
                    hr = GgafDx9Sound::_pIDirectSound8->CreateSoundBuffer(&dsbdesc, &_pIDirectSoundBuffer, NULL);
                    checkDxException(hr, D3D_OK, "GgafDx9Se::GgafDx9Se("<<prm_wave_name<<") CreateSoundBuffersBTEhJ[hLH");
                
                    if (!writeBuffer(WaveFile)) {
                        _TRACE_("GgafDx9Se::GgafDx9Se("<<prm_wave_name<<") xGgafDx9Se::writeBuffer()sB");
                    }
                    hr = _pIDirectSoundBuffer->GetFrequency(&_dwDefaultFrequency);
                    checkDxException(hr, D3D_OK, "GgafDx9Se::GgafDx9Se("<<prm_wave_name<<") GetFrequency sBTEhJ[hLH");
                
                	_TRACE_("GgafDx9Se::GgafDx9Se() _wave_name="<<_wave_name<<" this="<<this<<" _id="<<_id);
                }
                
                
                
                int GgafDx9Se::writeBuffer(CWaveDecorder& WaveFile) {
                    // ZJ_Eobt@Wavef[^
                    LPVOID lpvPtr1; // ubN|C^
                    DWORD dwBytes1; // ubNTCY
                    LPVOID lpvPtr2; // QubN|C^
                    DWORD dwBytes2; // QubNTCY
                
                    HRESULT hr;
                
                    hr = _pIDirectSoundBuffer->Lock(0, WaveFile.GetWaveSize(), &lpvPtr1, &dwBytes1, &lpvPtr2, &dwBytes2, 0);
                
                    // DSERR_BUFFERLOSTCRestore\bhgobt@
                    if (DSERR_BUFFERLOST == hr) {
                        _TRACE_("GgafDx9Se::writeBuffer() DSERR_BUFFERLOST Bobt@");
                        _pIDirectSoundBuffer->Restore();
                        hr = _pIDirectSoundBuffer->Lock(0, WaveFile.GetWaveSize(), &lpvPtr1, &dwBytes1, &lpvPtr2, &dwBytes2, 0);
                    }
                
                    if (hr != D3D_OK) {
                        return false;
                    }
                    // bN
                
                    // Cobt@
                    // obt@f[^Rs[
                    long lSize = WaveFile.GetWave(static_cast<LPBYTE> (lpvPtr1), dwBytes1);
                    if (lSize > 0 && dwBytes2 != 0) {
                        lSize = WaveFile.GetWave(static_cast<LPBYTE> (lpvPtr2), dwBytes2);
                    }
                
                    // IUnlockD
                    _pIDirectSoundBuffer->Unlock(lpvPtr1, dwBytes1, lpvPtr2, dwBytes2);
                
                    if (lSize < 0) {
                        return false;
                    }
                
                    return true;
                }
                
                void GgafDx9Se::play(int prm_iVolume, float prm_fPan, float prm_fRate_Frequency) {
                    if (_pIDirectSoundBuffer == NULL) {
                        _TRACE_("_pIDirectSoundBuffer==NULL;!");
                    }
                    DWORD dwStatus;
                    if (FAILED(_pIDirectSoundBuffer->GetStatus(&dwStatus))) {
                        _TRACE_("GgafDx9Se::play() GetStatus() s");
                    }
                    if (dwStatus == (DWORD)DSERR_BUFFERLOST) {
                        if (FAILED(_pIDirectSoundBuffer->Restore())) {
                            _TRACE_("GgafDx9Se::play() Restore() s");
                        }
                        if (!restore()) {
                            _TRACE_("GgafDx9Se::play() restore() s");
                        }
                    }
                    setVolume(prm_iVolume);
                    setPan(prm_fPan);
                    setFrequencyRate(prm_fRate_Frequency);
                    HRESULT hr;
                    hr = _pIDirectSoundBuffer->SetCurrentPosition(0); //obt@
                    checkDxException(hr, DS_OK, "GgafDx9Se::play() SetCurrentPosition(0) sB");
                    hr = _pIDirectSoundBuffer->Play(0, 0, 0x00000000);
                    checkDxException(hr, DS_OK, "GgafDx9Se::play() Play(0, 0, 0x00000000) sB");
                }
                
                void GgafDx9Se::setVolume(int prm_iVolume) {
                    int db = GgafDx9Sound::aDbVolume[(LONG)(prm_iVolume * GgafDx9Sound::_master_volume_rate * GgafDx9Sound::_se_volume_rate)];
                    HRESULT hr = _pIDirectSoundBuffer->SetVolume(db);
                    checkDxException(hr, DS_OK, "GgafDx9Se::setVolume() SetVolume("<<prm_iVolume<<") sB");
                }
                
                void GgafDx9Se::setPan(float prm_fPan) {
                    HRESULT hr = _pIDirectSoundBuffer->SetPan(prm_fPan*DSBPAN_RIGHT);
                    checkDxException(hr, DS_OK, "GgafDx9Se::setPan() SetPan("<<prm_fPan<<") sB");
                }
                
                void GgafDx9Se::setFrequencyRate(float prm_fRate_Frequency) {
                    HRESULT hr = _pIDirectSoundBuffer->SetFrequency((DWORD)(_dwDefaultFrequency*prm_fRate_Frequency)); //g
                    checkDxException(hr, DS_OK, "GgafDx9Se::setFrequencyRate() SetFrequency((DWORD)"<<(_dwDefaultFrequency*prm_fRate_Frequency)<<") sB");
                }
                
                int GgafDx9Se::restore(void) {
                    string wave_filename = GGAFDX9_PROPERTY(DIR_WAVE) + _wave_name + ".wav";
                    // Wavet@CJ
                    CWaveDecorder WaveFile;
                    if (!WaveFile.Open((LPSTR)wave_filename.c_str())) {
                        return false;
                    }
                
                    if (!writeBuffer(WaveFile)) {
                        return false;
                    }
                    return true;
                }
                
                
                
                
                bool GgafDx9Se::isPlaying() {
                    DWORD dwStatus = 0;
                    _pIDirectSoundBuffer->GetStatus( &dwStatus );
                    if( (dwStatus & DSBSTATUS_PLAYING) != 0 ) {
                        return true;
                    } else {
                        return false;
                    }
                }
                
                
         184 -> GgafDx9Se::~GgafDx9Se() {
                    _TRACE_("GgafDx9Se::~GgafDx9Se() _wave_name="<<_wave_name<<" this="<<this<<" _id="<<_id);
                    DELETEARR_IMPOSSIBLE_NULL(_wave_name);
                    RELEASE_IMPOSSIBLE_NULL(_pIDirectSoundBuffer);
                }


Top 10 Lines:

     Line      Count

      160        184
        7         92

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      276   Total number of line executions
    92.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9Core/include/jp/ggaf/dx9core/util/GgafDx9SphereRadiusVectors.h:
                #ifndef GGAFDX9SPHERERADIUSVECTORS_H_
                #define GGAFDX9SPHERERADIUSVECTORS_H_
                namespace GgafDx9Core {
                
                
                
                
                
                /**
                 * PAPxNgWNXB .
                 * xNgZ]pY]pAtZ]pY]pxNg\vB<BR>
                 * APAx0 y0 z0 xNgBi1/8j<BR>
                 * yz<BR>
                 * xNgev(X,Y,Z)P(unsigned __int16)A1  10000 B<BR>
                 * pxPis_angjA1x  10 Bp 900 Banglel(1x1000)<BR>
                 */
                class GgafDx9SphereRadiusVectors : public GgafCore::GgafObject {
                public:
                
                    /**
                     * \[g\xNgNX.
                     * SR_VECTOR(xNg)lAr\oNXB<BR>
                     * lAyvf  zvf  xvf B<BR>
                     */
           1 ->     class COMPARE_ABLE_SR_VECTOR : public GgafCore::GgafObject {
                    public:
                
                        /**
                         * COMPARE_ABLE_SR_VECTORpxNg\.
                         * evfPA1000000{B<BR>
                         * <BR>
                         * PxNg(0.658301, 0.1132, 0.744) <BR>
                         * SR_VECTORA(658301, 113200, 744000) <BR>
                         */
                        struct SR_VECTOR {
                            UINT32 x;
                            UINT32 z;
                            UINT32 y;
                        };
                
                
                        UINT64 num_yzx;
                        SR_VECTOR vec;
           1 ->         COMPARE_ABLE_SR_VECTOR() : GgafObject() {
                        }
                        /**
                         * PxNgB<BR>
                         * @param prm_x PxNgXvfi1  1000000)
                         * @param prm_y PxNgYvfi1  1000000)
                         * @param prm_z PxNgZvfi1  1000000)
                         */
                        void set(UINT32 prm_x, UINT32 prm_y, UINT32 prm_z) {
                            vec.x = prm_x;
                            vec.y = prm_y;
                            vec.z = prm_z;
                            num_yzx = (prm_y * 1000000LL * 1000000LL ) +
                            (prm_z * 1000000LL ) +
                            (prm_x );
                
                            //_TRACE_(prm_x<<","<<prm_y<<","<<prm_z<<"  num_yzx="<<(num_yzx));
                            //1048575LL = &b11111111111111111111 (20bit)
                        }
                    };
                
                
                
                
                
                    /** I 1/8\[g\xNgz(vf900*900) */
                    //COMPARE_ABLE_SR_VECTOR _sr[];
                    COMPARE_ABLE_SR_VECTOR _sr[(S_ANG90 + 1) * (S_ANG90 + 1)];
                    GgafDx9SphereRadiusVectors();
                
                    /**
                     * X,Y,ZxNgAZ]Y]B
                     * AAX,Y,Z S
                     * @param prm_x PxNgXvfi1  1000000) > 0
                     * @param prm_y PxNgYvfi1  1000000) > 0
                     * @param prm_z PxNgZvfi1  1000000) > 0
                     * @param out_angFaceZ Z]li ]l0AxNg(1,0,0)BxNg(0,0,1)vBjiPs_angj
                     * @param out_angFaceY_rev vY]li]l0AxNg(1,0,0)BxNg(0,1,0)vjiPs_angj
                     * @param s vZixjBmB
                     */
                    void getFaceAngClosely(UINT32 prm_x,
                                           UINT32 prm_y,
                                           UINT32 prm_z,
                                           s_ang& out_angFaceZ,
                                           s_ang& out_angFaceY_rev,
                                           int s = 25);
                
                    /**
                     * Z]Y]lAPxNg .
                     * AAxNgevf(X,Y,Z)ltB<BR>
                     * lUINT32AintZC<BR>
                     * @param prm_angFaceY_rev Z]li ]l0AxNg(1,0,0)BxNg(0,0,1)vBjiPs_angj
                     * @param prm_angFaceZ vY]li]l0AxNg(1,0,0)BxNg(0,1,0)vjiPs_angj
                     * @param out_x PxNgXvfi1  1000000) > 0
                     * @param out_y PxNgYvfi1  1000000) > 0
                     * @param out_z PxNgZvfi1  1000000) > 0
                     */
                    void getVectorClosely(s_ang prm_angFaceY_rev,
                                          s_ang prm_angFaceZ,
                                          UINT32& out_x,
                                          UINT32& out_y,
                                          UINT32& out_z
                                          );
                
                
                    virtual ~GgafDx9SphereRadiusVectors();
                };
                
                
                
                
                }
                #endif /*GGAFDX9SPHERERADIUSVECTORS_H_*/
                


Top 10 Lines:

     Line      Count

       25          1
       44          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/GgafDx9BaseActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
        4696 -> GgafDx9BaseActor::GgafDx9BaseActor(const char* prm_name) : GgafMainActor(prm_name) {
                    _obj_class |= Obj_GgafDx9BaseActor;
                    _class_name = "GgafDx9BaseActor";
                }
                
        4697 -> GgafDx9BaseActor::~GgafDx9BaseActor() {
                }


Top 10 Lines:

     Line      Count

       11       4697
        6       4696

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

     9393   Total number of line executions
  3131.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/sound/GgafDx9Bgm.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace Dix;
                
                //GgafDx9Bgm::GgafDx9Bgm(char* prm_ogg_name) : GgafObject() {
                //    _TRACE_("GgafDx9Bgm::GgafDx9Bgm "<<prm_ogg_name);
                //    if (GgafDx9Sound::_pIDirectSound8 == NULL) {
                //        throwGgafCriticalException("GgafDx9Bgm::GgafDx9Bgm("<<prm_ogg_name<<") DirectSound AB");
                //    }
                //    _file_name = string(prm_ogg_name);
                //    string ogg_filename = GGAFDX9_PROPERTY(DIR_OGG) + _file_name + ".ogg";
                //    pOggResource = NEW OggVorbisFile( ogg_filename.c_str() );
                //    pOggDecoder =  NEW OggDecoder( pOggResource );
                //    pPcmPlayer = NEW PCMPlayer(GgafDx9Sound::_pIDirectSound8 , pOggDecoder);
                //}
                
           4 -> GgafDx9Bgm::GgafDx9Bgm(char* prm_bgm_key) : GgafObject() {
                    if (GgafDx9Sound::_pIDirectSound8 == NULL) {
                        throwGgafCriticalException("GgafDx9Bgm::GgafDx9Bgm("<<prm_bgm_key<<") DirectSound AB");
                    }
                    string bgm_key = string(prm_bgm_key);
                    _ogg_file_name = (*GgafProperties::_pMapProperties)[bgm_key+"_OGG"];
                    _bpm = atoi((*GgafProperties::_pMapProperties)[bgm_key+"_BPM"].c_str());
                    _title = (*GgafProperties::_pMapProperties)[bgm_key+"_TITLE"];
                    _TRACE_("GgafDx9Bgm::GgafDx9Bgm KEY="<<prm_bgm_key<<" _file_name="<<_ogg_file_name<<" _bpm="<<_bpm<<" _title="<<_title);
                    string full_ogg_file_name = GGAFDX9_PROPERTY(DIR_OGG) + string(_ogg_file_name);
                    pOggResource = NEW OggVorbisFile( full_ogg_file_name.c_str() );
                    pOggDecoder =  NEW OggDecoder( pOggResource );
                    pPcmPlayer = NEW PCMPlayer(GgafDx9Sound::_pIDirectSound8 , pOggDecoder);
                }
                
                void GgafDx9Bgm::play(int prm_volume, float prm_pan, bool prm_isLoop) {
                    setVolume(prm_volume);
                    setPan(prm_pan);
                    pPcmPlayer->play(prm_isLoop);
                }
                
                void GgafDx9Bgm::pause() {
                    pPcmPlayer->pause();
                }
                
                void GgafDx9Bgm::stop() {
                    pPcmPlayer->stop();
                }
                
                void GgafDx9Bgm::setVolume(int prm_volume) {
                    //{[fVx
                    int db = GgafDx9Sound::aDbVolume[(LONG)(prm_volume * GgafDx9Sound::_master_volume_rate * GgafDx9Sound::_bgm_volume_rate)];
                    pPcmPlayer->setVolume(db);
                }
                
                void GgafDx9Bgm::setPan(float prm_pan) {
                
                    pPcmPlayer->setPan(prm_pan*DSBPAN_RIGHT);
                }
                
                void GgafDx9Bgm::clear() {
                    pPcmPlayer->clear();
                }
                
                bool GgafDx9Bgm::isActiveActor() {
                    if (pPcmPlayer->getState() == PCMPlayer::STATE_PLAY) {
                        return true;
                    } else {
                        return false;
                    }
                }
                
           8 -> GgafDx9Bgm::~GgafDx9Bgm() {
                    _TRACE_("GgafDx9Bgm::~GgafDx9Bgm() begin");
                    _TRACE_("pPcmPlayer->setVolume(DSBVOLUME_MIN);");
                    pPcmPlayer->setVolume(DSBVOLUME_MIN);
                    _TRACE_("pPcmPlayer->terminateThread();");
                    pPcmPlayer->terminateThread();
                    _TRACE_("DELETE_IMPOSSIBLE_NULL(pPcmPlayer);");
                    DELETE_IMPOSSIBLE_NULL(pPcmPlayer);
                    _TRACE_("DELETE_IMPOSSIBLE_NULL(pOggDecoder);");
                    DELETE_IMPOSSIBLE_NULL(pOggDecoder);
                    _TRACE_("DELETE_IMPOSSIBLE_NULL(pOggResource);");
                    DELETE_IMPOSSIBLE_NULL(pOggResource);
                    _TRACE_("GgafDx9Bgm::~GgafDx9Bgm() end");
                
                }


Top 10 Lines:

     Line      Count

       71          8
       19          4

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       12   Total number of line executions
     4.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/manager/GgafDx9SeManager.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
           1 -> GgafDx9SeManager::GgafDx9SeManager(const char* prm_manager_name) :
                    GgafResourceManager<GgafDx9Se> (prm_manager_name) {
                }
                
                GgafDx9Se* GgafDx9SeManager::processCreateResource(char* prm_idstr, void* prm_p) {
                    // prm_idstr = "1/laser" Af}l[W[L["1/laser"o^
                    // wavet@C"laser.wav"B
                    // Awave`lAlA
                    // mB
                
                    GgafDx9Se* pResource = NULL;
                    char idstr[129];
                    strcpy(idstr, prm_idstr);
                    char* pT = strtok(idstr, "/" );
                    pT = strtok(NULL, "/");
                    if (pT == NULL) {
                        pResource = NEW GgafDx9Se(prm_idstr);
                    } else {
                        pResource = NEW GgafDx9Se(pT);
                    }
                
                    return pResource;
                }
                
                GgafResourceConnection<GgafDx9Se>* GgafDx9SeManager::processCreateConnection(char* prm_idstr, GgafDx9Se* prm_pResource) {
                    TRACE3(" GgafDx9SeManager::processCreateConnection "<<prm_idstr<<" JnB");
                    GgafDx9SeConnection* pConnection = NEW GgafDx9SeConnection(prm_idstr, prm_pResource);
                    TRACE3(" GgafDx9SeManager::processCreateConnection "<<prm_idstr<<" IB");
                    return pConnection;
                }


Top 10 Lines:

     Line      Count

        6          1

Execution Summary:

        2   Executable lines in this file
        1   Lines executed
    50.00   Percent of the file executed

        1   Total number of line executions
     0.50   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9Core/include/jp/ggaf/dx9core/manager/GgafDx9SeManager.h:
                #ifndef GGAFDX9SEMANAGER_H_
                #define GGAFDX9SEMANAGER_H_
                namespace GgafDx9Core {
                
                /**
                 * GgafDx9Se NX .
                 *  GgafDx9Se IuWFNgo^AgB
                 * @version 1.00
                 * @since 2008/09/08
                 * @author Masatoshi Tsuge
                 */
                class GgafDx9SeManager : public GgafCore::GgafResourceManager<GgafDx9Se> {
                
                public:
                
                    /**
                     * RXgN^
                     * @param prm_manager_name }l[W(eK{)
                     */
                    GgafDx9SeManager(const char* prm_manager_name);
                
                    GgafDx9Se* processCreateResource(char* prm_idstr, void* prm_p);
                
                    GgafCore::GgafResourceConnection<GgafDx9Se>* processCreateConnection(char* prm_idstr, GgafDx9Se* prm_pResource);
                
           2 ->     virtual ~GgafDx9SeManager() {
                    }
                };
                
                }
                #endif /*GGAFDX9SEMANAGER_H_*/


Top 10 Lines:

     Line      Count

       26          2

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     2.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/manager/GgafDx9BgmManager.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
           1 -> GgafDx9BgmManager::GgafDx9BgmManager(const char* prm_manager_name) :
                    GgafResourceManager<GgafDx9Bgm> (prm_manager_name) {
                }
                
                GgafDx9Bgm* GgafDx9BgmManager::processCreateResource(char* prm_idstr, void* prm_p) {
                    GgafDx9Bgm* pResourceBgm = NEW GgafDx9Bgm(prm_idstr);
                    return pResourceBgm;
                }
                
                GgafResourceConnection<GgafDx9Bgm>* GgafDx9BgmManager::processCreateConnection(char* prm_idstr, GgafDx9Bgm* prm_pResource) {
                    TRACE3(" GgafDx9BgmManager::processCreateConnection "<<prm_idstr<<" JnB");
                    GgafDx9BgmConnection* pConnection = NEW GgafDx9BgmConnection(prm_idstr, prm_pResource);
                    TRACE3(" GgafDx9BgmManager::processCreateConnection "<<prm_idstr<<" IB");
                    return pConnection;
                }


Top 10 Lines:

     Line      Count

        6          1

Execution Summary:

        2   Executable lines in this file
        1   Lines executed
    50.00   Percent of the file executed

        1   Total number of line executions
     0.50   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9Core/include/jp/ggaf/dx9core/manager/GgafDx9BgmManager.h:
                #ifndef GGAFDX9BGMMANAGER_H_
                #define GGAFDX9BGMMANAGER_H_
                namespace GgafDx9Core {
                
                /**
                 * GgafDx9Bgm NX .
                 *  GgafDx9Bgm IuWFNgo^AgB
                 * @version 1.00
                 * @since 2008/09/08
                 * @author Masatoshi Tsuge
                 */
                class GgafDx9BgmManager : public GgafCore::GgafResourceManager<GgafDx9Bgm> {
                
                public:
                
                    /**
                     * RXgN^
                     * @param prm_manager_name }l[W(eK{)
                     */
                    GgafDx9BgmManager(const char* prm_manager_name);
                
                    GgafDx9Bgm* processCreateResource(char* prm_idstr, void* prm_p);
                
                    GgafCore::GgafResourceConnection<GgafDx9Bgm>* processCreateConnection(char* prm_idstr, GgafDx9Bgm* prm_pResource);
                
           2 ->     virtual ~GgafDx9BgmManager() {
                    }
                };
                
                }
                #endif /*GGAFDX9BGMMANAGER_H_*/


Top 10 Lines:

     Line      Count

       26          2

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     2.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/scene/supporter/GgafDx9AlphaCurtain.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
          16 -> GgafDx9AlphaCurtain::GgafDx9AlphaCurtain(GgafDx9Scene* prm_pDxScene) : GgafCurtain(prm_pDxScene) {
                    _pDxScene = prm_pDxScene;
                    _alpha = 1.0;
                }
                
          32 -> GgafDx9AlphaCurtain::~GgafDx9AlphaCurtain() {
                }


Top 10 Lines:

     Line      Count

       11         32
        6         16

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       48   Total number of line executions
    16.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9Core/include/jp/ggaf/dx9core/util/XFile/framework/../framework/../framework/Frm_3dMath.h:
                /////////////////////////////////////////////////////////
                // Frm_3DMath.h
                // Declares vector, matrix, rectangles and defines special
                // array elements
                /////////////////////////////////////////////////////////
                
                #ifndef FRM_MATH_H
                #define FRM_MATH_H
                
                //#include <mem.h>
                #include <math.h>
                
                #define MINFLOAT 1.17549435E-38F
                
                namespace Frm {
                
                //Vector description/////////////////////////
                template<typename T>
                class vector {
                public:
                    T x, y, z;
       87842 ->     vector(void) :
                        x(0), y(0), z(0) {
                    }
       31328 ->     vector(T px, T py, T pz) :
                        x(px), y(py), z(pz) {
                    }
       15664 ->     vector(const vector<T> &pv) :
                        x(pv.x), y(pv.y), z(pv.z) {
                    }
                    vector(const T* &pv) {
                        x = pv[0];
                        y = pv[1];
                        z = pv[2];
                    }
                
                    vector<T>& operator=(const vector<T> &pv) {
                        x = pv.x;
                        y = pv.y;
                        z = pv.z;
                        return *this;
                    }
                    inline void Set(T px, T py, T pz) {
                        x = px;
                        y = py;
                        z = pz;
                    }
                    bool operator>(const vector<T> &pv) {
                        return (x + y) > (pv.x + pv.y);
                    }
                
                    T operator[](int index) const {
                        if (index == 1)
                            return y;
                        if (index == 2)
                            return z;
                        return x;
                    }
                    T& operator[](int index) {
                        if (index == 1)
                            return y;
                        if (index == 2)
                            return z;
                        return x;
                    }
                
                    vector<T> operator+(vector<T> pv) const {
                        return vector<T> ((T) (x + pv.x), (T) (y + pv.y), (T) (z + pv.z));
                    }
                    vector<T> operator-(vector<T>& pv) const {
                        return vector<T> ((T) (x - pv.x), (T) (y - pv.y), (T) (z - pv.z));
                    }
                    vector<T> operator*(T pT) const {
                        return vector<T> ((T) (pT * x), (T) (pT * y), (T) (pT * z));
                    }
                    void Normalize(void) {
                        vector<T> pv((T) (x * x), (T) (y * y), (T) (z * z));
                        T fLength = (T) (1.0f / (float) (pv.x + pv.y + pv.z));
                        if (fLength < 1e-08)
                            return;
                        x = (T) (pv.x * fLength);
                        y = (T) (pv.y * fLength);
                        z = (T) (pv.z * fLength);
                    }
                    T Dot(vector<T> pV) const {
                        return (T) (x * pV.x + y * pV.y + z * pV.z);
                    }
                    vector<T> Cross(vector<T> pV) const {
                        return vector<T> ((T) (y * pV.z - z * pV.y), (T) (z * pV.x - x * pV.z),
                                (T) (x * pV.y - y * pV.x));
                    }
                    vector<T> UnitCross(vector<T> pV) const {
                        vector<T> pR((T) (y * pV.z - z * pV.y), (T) (z * pV.x - x * pV.z),
                                (T) (x * pV.y - y * pV.x));
                        pR.Normalize();
                        return pR;
                    }
                    //addtsuge
                    T Abs() {
                        return (T) sqrt(x * x + y * y + z * z);
                    }
                };
                
                typedef vector<float> Vector;
                
                template<typename T, int size>
                struct Array {
                    T data[size];
       53503 ->     Array(void) {
                        memset(data, 0, size * sizeof(T));
                    }
        2256 ->     Array(const Array<T, size> &pA) {
                        memcpy(data, pA.data, size * sizeof(T));
                    }
                    Array(const T* pT) {
                        memcpy(data, pT, size * sizeof(T));
                    }
                
                    Array<T, size>& operator=(Array<T, size> pA) {
                        memcpy(data, pA.data, size * sizeof(T));
                        return *this;
                    }
                    Array<T, size>& operator+=(Array<T, size> pA);
                    Array<T, size> operator*(const T pScalar);
                    Array<T, size> operator+(Array<T, size> pA);
                    Array<T, size> operator-(Array<T, size> pA);
                    T operator[](int index) const {
                        return data[index];
                    }
                    T& operator[](int index) {
                        return data[index];
                    }
                };
                
                //typedef Array<unsigned short, 3> Face;
                typedef Array<unsigned short, 4> Face; //modify tsuge
                
                typedef Array<float, 3> Vertex;
                typedef Array<float, 2> TCoord;
                typedef Array<float, 4> Color4;
                typedef Array<float, 3> Color3;
                
                template<typename T>
                Array<T, 4> Set4(T px, T py, T pz, T pw) {
                    T data[4];
                    data[0] = px;
                    data[1] = py;
                    data[2] = pz;
                    data[3] = pw;
                    return Array<T, 4> (data);
                }
                
                template<typename T>
                Array<T, 3> Set3(T px, T py, T pz) {
                    T data[3];
                    data[0] = px;
                    data[1] = py;
                    data[2] = pz;
                    return Array<T, 3> (data);
                }
                
                template<typename T>
                Array<T, 2> Set2(T pu, T pv) {
                    T data[2];
                    data[0] = pu;
                    data[1] = pv;
                    return Array<T, 2> (data);
                }
                
                template<typename T>
                class matrix {
                public:
                    T data[16];
          38 ->     matrix(void) {
                        memset(data, 0, 16 * sizeof(T));
                    }
                    matrix(const matrix<T> &pm) {
                        memcpy(data, pm.data, 16 * sizeof(T));
                    }
                    matrix(const T* pT) {
                        memcpy(data, pT, 16 * sizeof(T));
                    }
                    void Zero(void) {
                        memset(data, 0, 16 * sizeof(T));
                    }
                    void Identity(void) {
                        memset(data, 0, 16 * sizeof(T));
                        data[0] = (T) 1;
                        data[5] = (T) 1;
                        data[10] = (T) 1;
                        data[15] = (T) 1;
                    }
                    //add tsugecchi 2009/08/31
                    bool isIdentity() {
                        T val0 =  (T)0;
                        T val1 =  (T)1;
                        if( data[0] == val1 &&
                            data[1] == val0 &&
                            data[2] == val0 &&
                            data[3] == val0 &&
                            data[4] == val0 &&
                            data[5] == val1 &&
                            data[6] == val0 &&
                            data[7] == val0 &&
                            data[8] == val0 &&
                            data[9] == val0 &&
                            data[10] == val1 &&
                            data[11] == val0 &&
                            data[12] == val0 &&
                            data[13] == val0 &&
                            data[14] == val0 &&
                            data[15] == val1 )
                        {
                            return true;
                        } else {
                            return false;
                        }
                    }
                
                    matrix<T>& operator=(const matrix<T> &pm) {
                        memcpy(data, pm.data, 16 * sizeof(T));
                        return *this;
                    }
                    matrix<T> operator+(matrix<T> pm);
                    matrix<T> operator-(matrix<T> pm);
                    matrix<T> operator*(matrix<T> pm);
                    matrix<T>& operator*=(matrix<T> &pm);
                    matrix<T> operator*(T pT);
                    vector<T> operator*(const vector<T>& pV);
                    Array<T, 3> operator*(const Array<T, 3>& pV);
                
                    T operator[](int index) const {
                        return data[index];
                    }
                    T& operator[](int index) {
                        return data[index];
                    }
                
                    T _fastcall Index(int pRow, int pCol) const {
                        return data[(pRow << 2) + pCol];
                    }
                    T operator()(int pRow, int pCol) const {
                        return data[(pRow << 2) + pCol];
                    }
                    T& operator()(int pRow, int pCol) {
                        return data[(pRow << 2) + pCol];
                    }
                    vector<T> GetRow(int index) {
                        index <<= 2;
                        return vector<T> (data[index++], data[index++], data[index]);
                    }
                    vector<T> GetColumn(int index) {
                        return vector<T> (data[index], data[index + 4], data[index + 8]);
                    }
                    void ScalingMatrix(const vector<T> &pvT);
                    void TranslationMatrix(const Array<T, 3> &pAT);
                    void QuaternionMatrix(T &x, T &y, T &z, T &w);
                
                private:
                    int k, l, row, col;
                };
                
                typedef matrix<float> Matrix;
                //typedef matrix<float> Matrix4F;
                
                template<typename T>
                class quaternion {
                public:
                    T data[4];
       ##### ->     quaternion(void) {
                        memset(data, 0, 4 * sizeof(T));
                    }
                    quaternion(const quaternion<T> &pq) {
                        memcpy(data, pq.data, 4 * sizeof(T));
                    }
                    quaternion(const T* pT) {
                        memcpy(data, pT, 4 * sizeof(T));
                    }
                    void Zero(void) {
                        memset(data, 0, 4 * sizeof(T));
                    }
                    T operator[](int index) const {
                        return data[index];
                    }
                    T& operator[](int index) {
                        return data[index];
                    }
                    quaternion<T>& operator=(const quaternion<T> &pq) {
                        memcpy(data, pq.data, 4 * sizeof(T));
                        return *this;
                    }
                    quaternion<T> operator+(quaternion<T> pq);
                    quaternion<T> operator*(quaternion<T> pq);
                    quaternion<T> operator*(T pT);
                    T Dot(quaternion<T> &pq);
                    quaternion<T> Slerp(T pT, quaternion<T> &pq);
                private:
                    float qACos(float pValue);
                };
                
                typedef quaternion<float> Quaternion;
                
                //Rectangle description///////////////////////
                template<typename T>
                class trect {
                public:
                    T xs, ys, xe, ye;
                    trect(void) :
                        xs(0), ys(0), xe(0), ye(0) {
                    }
                    trect(const trect<T> &prect) {
                        xs = prect.xs;
                        ys = prect.ys;
                        xe = prect.xe;
                        ye = prect.ye;
                    }
                    trect<T>& operator=(const trect<T> &prect) {
                        xs = prect.xs;
                        ys = prect.ys;
                        xe = prect.xe;
                        ye = prect.ye;
                        return *this;
                    }
                    trect<T>& operator+=(const vector<T> &pV) {
                        xs += pV.x;
                        ys += pV.y;
                        xe += pV.x;
                        ye += pV.y;
                        return *this;
                    }
                    /**/
                    /*      trect<T>& operator+=(vector<T> &pV)
                     {xs += pV[VX]; ys += pV[VY]; xe += pV[VX]; ye += pV[VY]; return *this;};
                    */
                    trect(const T pxs, const T pys, const T pxe, const T pye) {
                        xs = pxs;
                        ys = pys;
                        xe = pxe;
                        ye = pye;
                    }
                    inline void Set(const T pxs, const T pys, const T pxe, const T pye) {
                        xs = pxs;
                        ys = pys;
                        xe = pxe;
                        ye = pye;
                    }
                    bool _fastcall InRect(const T &px, const T &py) {
                        if (px < xs)
                            return false;
                        if (px > xe)
                            return false;
                        if (py < ys)
                            return false;
                        if (py > ye)
                            return false;
                        return true;
                    }
                    bool _fastcall InRect(const vector<T> &pv) {
                        if (pv.x < xs)
                            return false;
                        if (pv.x > xe)
                            return false;
                        if (pv.y < ys)
                            return false;
                        if (pv.y > ye)
                            return false;
                        return true;
                    }
                    /**/
                    /*   	bool _fastcall InRect( vector<T> &pv)
                     { if (pv[VX] < xs) return false;
                     if (pv[VX] > xe) return false;
                     if (pv[VY] < ys) return false;
                     if (pv[VY] > ye) return false;
                     return true;};
                    */
                    bool _fastcall InRect(const trect<T> &prect) {
                        if ((prect.xe <= xe) && (prect.ye <= ye) && (prect.xs >= xs)
                                && (prect.ys >= ys))
                            return true;
                        return false;
                    }
                    bool _fastcall Intersect(const trect<T> &prect) {
                        if (prect.xe < xs)
                            return false;
                        if (prect.xs > xe)
                            return false;
                        if (prect.ye < ys)
                            return false;
                        if (prect.ys > ye)
                            return false;
                        return true;
                    }
                    bool _fastcall Union(const trect<T> &prect) {
                        if (!Intersect(prect))
                            return false;
                        if (xs < prect.xs)
                            xs = prect.xs;
                        if (ys < prect.ys)
                            ys = prect.ys;
                        if (xe > prect.xe)
                            xe = prect.xe;
                        if (ye > prect.ye)
                            ye = prect.ye;
                        return true;
                    }
                };
                
                //// Implementation details ////////////////////
                
                template<typename T, int size>
                Array<T, size>& Array<T, size>::operator+=(Array<T, size> pA) {
                    for (int i = 0; i < size; i++)
                        data[i] += pA.data[i];
                    return *this;
                }
                
                template<typename T, int size>
                Array<T, size> Array<T, size>::operator*(const T pScalar) {
                    T rdata[size];
                    memcpy(rdata, data, size * sizeof(T));
                    for (int i = 0; i < size; i++)
                        rdata[i] *= pScalar;
                    return Array<T, size> (rdata);
                }
                
                template<typename T, int size>
                Array<T, size> Array<T, size>::operator+(Array<T, size> pA) {
                    T rdata[size];
                    for (int i = 0; i < size; i++)
                        rdata[i] = data[i] + pA.data[i];
                    return Array<T, size> (rdata);
                }
                
                template<typename T, int size>
                Array<T, size> Array<T, size>::operator-(Array<T, size> pA) {
                    T rdata[size];
                    for (int i = 0; i < size; i++)
                        rdata[i] = data[i] - pA.data[i];
                    return Array<T, size> (rdata);
                }
                
                template<typename T>
                matrix<T> matrix<T>::operator+(matrix<T> pm) {
                    T Rdata[16];
                    for (k = 0; k < 16; k++)
                        Rdata[k] = data[k] + pm.data[k];
                    return matrix<T> (Rdata);
                }
                
                template<typename T>
                matrix<T> matrix<T>::operator-(matrix<T> pm) {
                    T Rdata[16];
                    for (k = 0; k < 16; k++)
                        Rdata[k] = data[k] - pm.data[k];
                    return matrix<T> (Rdata);
                }
                
                template<typename T>
                matrix<T> matrix<T>::operator*(matrix<T> pm) {
                    T Rdata[16];
                    for (row = 0; row < 16; row += 4)
                        for (col = 0; col < 4; col++) {
                            l = 0;
                            Rdata[row + col] = 0;
                            for (k = 0; k < 4; k++, l += 4)
                                Rdata[row + col] += data[row + k] * pm.data[l + col];
                        }
                    return matrix<T> (Rdata);
                }
                
                template<typename T>
                matrix<T>& matrix<T>::operator*=(matrix<T> &pm) {
                    T Rdata[16];
                    for (row = 0; row < 16; row += 4)
                        for (col = 0; col < 4; col++) {
                            l = 0;
                            Rdata[row + col] = 0;
                            for (k = 0; k < 4; k++, l += 4)
                                Rdata[row + col] += data[row + k] * pm.data[l + col];
                        }
                    memcpy(data, Rdata, 16* sizeof (T));
                    return *this;
                }
                
                template<typename T>
                matrix<T> matrix<T>::operator*(T pT)
                {
                    T Rdata[16];
                    memcpy(Rdata, data, 16 * sizeof(T));
                    for(k = 0; k < 16; k++)
                    Rdata[k] *= pT;
                    return matrix<T>(Rdata);
                }
                
                template<typename T>
                vector<T> matrix<T>::operator*(const vector<T>& pV)
                {
                    T vdata[4], pvdata[4];
                    pvdata[0] = pV.x;
                    pvdata[1] = pV.y;
                    pvdata[2] = pV.z;
                    pvdata[3] = 0;
                    for (col = 0; col < 4; col++)
                    {
                        vdata[row] = 0;
                        k=0;
                        for (row = 0; row < 4; row++, k+=4)
                        vdata[col] += data[k + col]*pvdata[row];
                    }
                    return vector<T>(vdata);
                } /**/
                
                template<typename T>
                Array<T, 3> matrix<T>::operator*(const Array<T, 3>& pV)
                {
                    T vdata[4], pvdata[4];
                
                    memcpy(pvdata, pV.data, 3*sizeof(T));
                    pvdata[3] = 1.0f;
                
                    for (col = 0; col < 4; col++)
                    {
                        k = 0;
                        vdata[col] = 0;
                        for (row = 0; row < 4; row++, k+=4)
                        vdata[col] += data[k + col]*pvdata[row];
                    }
                
                    return Array<T, 3>(vdata);
                }
                
                template<typename T>
                void matrix<T>::ScalingMatrix(const vector<T> &pvT)
                {
                    Identity();
                    data[0] = pvT.x;
                    data[5] = pvT.y;
                    data[10] = pvT.z;
                }
                
                template<typename T>
                void matrix<T>::TranslationMatrix(const Array<T,3> &pAT)
                {
                    Identity();
                    data[12] = pAT[0];
                    data[13] = pAT[1];
                    data[14] = pAT[2];
                }
                
                template<typename T>
                void matrix<T>::QuaternionMatrix(T &x, T &y, T &z, T &w)
                {
                    T xx = x*x; T yy = y*y; T zz = z*z;
                    T xy = x*y; T xz = x*z; T yz = y*z;
                    T wx = w*x; T wy = w*y; T wz = w*z;
                
                    data[0] = 1 - 2 * ( yy + zz );
                    data[1] = 2 * ( xy - wz );
                    data[2] = 2 * ( xz + wy );
                
                    data[4] = 2 * ( xy + wz );
                    data[5] = 1 - 2 * ( xx + zz );
                    data[6] = 2 * ( yz - wx );
                
                    data[8] = 2 * ( xz - wy );
                    data[9] = 2 * ( yz + wx );
                    data[10] = 1 - 2 * ( xx + yy );
                
                    data[3] = data[7] = data[11] = 0.0f;
                    data[12] = data[13] = data[14] = 0.0f;
                    data[15] = 1.0f;
                }
                
                /*************************************************
                 NEW- NEW- NEW- NEW- NEW- NEW- NEW- NEW- NEW- NEW*/
                
                template<typename T>
                float quaternion<T>::qACos(float pValue)
                {
                    if ( -1.0f < pValue )
                    {
                        if ( pValue < 1.0f )
                        return (float)acos(pValue);
                        else
                        return 0.0f;
                    }
                    else
                    return M_PI;
                }
                
                template<typename T>
                quaternion<T> quaternion<T>::operator+(quaternion<T> pq)
                {
                    T rdata[4];
                    rdata[0] = pq.data[0] + data[0];
                    rdata[1] = pq.data[1] + data[1];
                    rdata[2] = pq.data[2] + data[2];
                    rdata[3] = pq.data[3] + data[3];
                    return quaternion<T>(rdata);
                }
                
                template<typename T>
                quaternion<T> quaternion<T>::operator*(T pT)
                {
                    T rdata[4];
                    rdata[0] = pT * data[0];
                    rdata[1] = pT * data[1];
                    rdata[2] = pT * data[2];
                    rdata[3] = pT * data[3];
                    return quaternion<T>(rdata);
                }
                
                template<typename T>
                T quaternion<T>::Dot(quaternion<T> &pq)
                {
                    return ((data[0] * pq.data[0]) + (data[1] * pq.data[1]) + (data[2] *pq.data[2]) + (data[3] * pq.data[3]));
                }
                
                template<typename T>
                quaternion<T> quaternion<T>::Slerp(T pT, quaternion<T> &pq) {
                    //We calculate the angle spread between both quaternions
                    T AngleCos = pq.Dot(*this);
                    T Angle = qACos(AngleCos); //see the function ACos above
                
                    if (Angle < MINFLOAT)
                        return quaternion<T>(*this);
                    //We calculate the interpolated angle and deduce the resulting quaternion
                    T InvAngleSin = (T)(1.0f / sin(Angle));
                
                    T Coeff0 = sin((1-pT) * Angle) * InvAngleSin;
                    T Coeff1 = sin(pT * Angle) * InvAngleSin;
                    return quaternion<T>((*this * Coeff0)+(pq * Coeff1));
                }
                
                /*************************************************/
                
                };
                #endif


Top 10 Lines:

     Line      Count

       22      87842
      109      53503
       25      31328
       28      15664
      112       2256
      174         38

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

   190631   Total number of line executions
 27233.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9Core/include/jp/ggaf/dx9core/util/XFile/ToolBox/../framework/frm_IO.h:
                /////////////////////////////////////////////////////////
                // FRM_IO.h
                // provides a load/save base class to be derived
                //
                /////////////////////////////////////////////////////////
                
                #ifndef FRM_IO_H
                #define FRM_IO_H
                
                #include "../framework/frm_types.h"
                
                namespace Frm {
                template<class T>
                class IO {
                public:
          13 ->     IO(void) :
                        _Type(IO_NOTYPE) {
                    }
                    virtual bool Load(std::string pFilename, T &pT)=0;
                    virtual bool Save(std::string pFilename, T &pT)=0;/**/
                    virtual bool Load(std::string pFilename, std::vector<T> &pVT)=0;
                    virtual bool Save(std::string pFilename, std::vector<T> &pVT)=0;/**/
                    void LoadInBuffer(std::string pFilename) {
                        int length;
                        ifstream fin(pFilename.c_str());
                        fin.seekg(0, ios::end);
                        length = fin.tellg();
                        fin.seekg(0, ios::beg);
                
                        Buffer = NEW char[length];
                        // read data as a block:
                        fin.read(Buffer, length);
                
                        fin.close();
                    }
                
                    uchar _Type;
                protected:
                    char* Buffer;
                    float TextToNum(char* pText) {
                        float test = 0, num = 10;
                        bool sign;
                
                        int textsize = strlen(pText);
                        unsigned char i = 0;
                
                        sign = false;
                        while ((sign == false) && (i < textsize)) {
                            switch (pText[i]) {
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7':
                            case '8':
                            case '9':
                            case '-':
                            case '.':
                                sign = true;
                                break;
                            default:
                                i++;
                                break;
                            }
                        }
                
                        if (i >= textsize)
                            return 0.0f;
                
                        if (pText[i] == '-') {
                            sign = true;
                            i++;
                        } else
                            sign = false;
                
                        while ((pText[i] >= '0') && (pText[i] <= '9')) {
                            test *= num;
                            test += (pText[i++] - '0');
                        }
                        num = 0.1f;
                        if ((i < textsize) && (pText[i++] == '.'))
                            while ((pText[i] >= '0') && (pText[i] <= '9')) {
                                test += (pText[i++] - '0') * num;
                                num *= 0.1f;
                            }
                        if (sign)
                            test = -test;
                        return test;
                    }
                    void Remove(char pDelimiter, char* pText) {
                        char result[255];
                        uint32 i, j = 0;
                        for (i = 0; i < strlen(pText); i++)
                            if (pText[i] != pDelimiter)
                                result[j++] = pText[i];
                        result[j++] = '\0';
                        memcpy(pText, result, j);
                    }
                
                };
                
                }
                #endif


Top 10 Lines:

     Line      Count

       16         13

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       13   Total number of line executions
    13.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/manager/GgafDx9ModelManager.cpp:
                
                // {vO Paul Coppens AXt@CTv
                // ACifobOjNXgpB
                //  PaulB
                //
                // yz
                // Frm ONX
                //
                // yLoading and displaying .X files without DirectX z
                // http://www.gamedev.net/reference/programming/features/xfilepc/
                //
                //                                         2009/03/06 Masatoshi Tsuge
                
                #include "stdafx.h"
                
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                
                int GgafDx9ModelManager::_id_max = 0;
                GgafDx9Model* GgafDx9ModelManager::_pModelLastDraw = NULL;
           1 -> GgafDx9ModelManager::GgafDx9ModelManager(const char* prm_manager_name) :
                    GgafResourceManager<GgafDx9Model> (prm_manager_name) {
                
                    //eNX`}lW[
                    _pTextureManager = NEW GgafDx9TextureManager("GgafDx9TextureManager");
                    //|S`t@C
                    HRESULT hr;
                    DirectXFileCreate( &_pIDirectXFile_sprx );
                    char* paChar_SpriteModelineTemplate = GgafUtil::getFileText(GGAFDX9_PROPERTY(DIR_SPRITE_MODEL) + "ggaf_spritemodel_define.x");
                    if (paChar_SpriteModelineTemplate == NULL) {
                        throwGgafCriticalException("[GgafDx9ModelManager::GgafDx9ModelManager] XvCgev[g\""<<GGAFDX9_PROPERTY(DIR_SPRITE_MODEL)<<"ggaf_spritemodel_define.x\" JB");
                    }
                    hr = _pIDirectXFile_sprx->RegisterTemplates(paChar_SpriteModelineTemplate, (DWORD)(strlen(paChar_SpriteModelineTemplate)));
                    if(hr != DXFILE_OK) {
                        throwGgafCriticalException("[GgafDx9ModelManager::GgafDx9ModelManager] RegisterTemplatessB\""<<GGAFDX9_PROPERTY(DIR_SPRITE_MODEL)<<"ggaf_spritemodel_define.x\"mFB");
                    }
                    DELETE_IMPOSSIBLE_NULL(paChar_SpriteModelineTemplate);
                
                    //|S`t@C
                    DirectXFileCreate( &_pIDirectXFile_psprx );
                    char* paChar_PointSpriteModelineTemplate = GgafUtil::getFileText(GGAFDX9_PROPERTY(DIR_SPRITE_MODEL) + "ggaf_pointspritemodel_define.x");
                    if (paChar_PointSpriteModelineTemplate == NULL) {
                        throwGgafCriticalException("[GgafDx9ModelManager::GgafDx9ModelManager] |CgXvCgev[g\""<<GGAFDX9_PROPERTY(DIR_SPRITE_MODEL)<<"ggaf_pointspritemodel_define.x\" JB");
                    }
                    hr = _pIDirectXFile_psprx->RegisterTemplates(paChar_PointSpriteModelineTemplate, (DWORD)(strlen(paChar_PointSpriteModelineTemplate)));
                    if(hr != DXFILE_OK) {
                        throwGgafCriticalException("[GgafDx9ModelManager::GgafDx9ModelManager] RegisterTemplatessB\""<<GGAFDX9_PROPERTY(DIR_SPRITE_MODEL)<<"ggaf_pointspritemodel_define.x\"mFB");
                    }
                    DELETE_IMPOSSIBLE_NULL(paChar_PointSpriteModelineTemplate);
                
                }
                
                GgafDx9Model* GgafDx9ModelManager::processCreateResource(char* prm_idstr, void* prm_p) {
                    //U
                    char model_type = *prm_idstr; //
                    char* model_name = prm_idstr + 2; //R~
                    GgafDx9Model* pResourceModel;
                    switch (model_type) {
                        case 'D':
                            //D3DXMeshModel
                            pResourceModel = createD3DXMeshModel(model_name, D3DXMESH_SYSTEMMEM);
                            break;
                        case 'd':
                            //DynaD3DXMeshModel
                            pResourceModel = createD3DXMeshModel(model_name, D3DXMESH_DYNAMIC);
                            break;
                        case 'A':
                            //D3DXAniMeshModel
                            pResourceModel = createD3DXAniMeshModel(model_name);
                            break;
                        case 'X':
                            //MeshModel
                            pResourceModel = createMeshModel(model_name);
                            break;
                        case 'x':
                            //MeshSetModel
                            pResourceModel = createMeshSetModel(model_name);
                            break;
                        case 'G':
                            //CubeMapMeshModel
                            pResourceModel = createCubeMapMeshModel(model_name);
                            break;
                        case 'g':
                            //CubeMapMeshSetModel
                            pResourceModel = createCubeMapMeshSetModel(model_name);
                            break;
                        case 'M':
                            //MorphMeshModel "M/4/xxxxx" AvC}bV1A[t^[QbgbV4
                            pResourceModel = createMorphMeshModel(model_name);
                            break;
                        case 'H':
                            //CubeMapMorphMeshModel "H/4/xxxxx" AvC}bV1A[t^[QbgbV4
                            pResourceModel = createCubeMapMorphMeshModel(model_name);
                            break;
                        case 'S':
                            //SpriteModel
                            pResourceModel = createSpriteModel(model_name);
                            break;
                        case 's':
                            //SpriteSetModel
                            pResourceModel = createSpriteSetModel(model_name);
                            break;
                        case 'B':
                            //BoardModel
                            pResourceModel = createBoardModel(model_name);
                            break;
                        case 'b':
                            //BoardSetModel
                            pResourceModel = createBoardSetModel(model_name);
                            break;
                        case 'C':
                            //cubeModel
                            pResourceModel = createD3DXMeshModel("cube", D3DXMESH_SYSTEMMEM);
                            break;
                        case 'P':
                            //PointSpriteModel
                            pResourceModel = createPointSpriteModel(model_name);
                            break;
                        default:
                            TRACE3("GgafDx9ModelManager::processCreateResource("<<prm_idstr<<") ");
                            throwGgafCriticalException("GgafDx9ModelManager::processCreateResource("<<prm_idstr<<") fm");
                            pResourceModel = NULL;
                            break;
                    }
                    return pResourceModel;
                }
                
                GgafDx9D3DXMeshModel* GgafDx9ModelManager::createD3DXMeshModel(char* prm_model_name, DWORD prm_dwOptions) {
                    GgafDx9D3DXMeshModel* pD3DXMeshModel_New = NEW GgafDx9D3DXMeshModel(prm_model_name, prm_dwOptions);
                    restoreD3DXMeshModel(pD3DXMeshModel_New);
                    return pD3DXMeshModel_New;
                }
                
                GgafDx9D3DXAniMeshModel* GgafDx9ModelManager::createD3DXAniMeshModel(char* prm_model_name) {
                    GgafDx9D3DXAniMeshModel* pD3DXAniMeshModel_New = NEW GgafDx9D3DXAniMeshModel(prm_model_name);
                    restoreD3DXAniMeshModel(pD3DXAniMeshModel_New);
                    return pD3DXAniMeshModel_New;
                }
                
                GgafDx9SpriteModel* GgafDx9ModelManager::createSpriteModel(char* prm_model_name) {
                    GgafDx9SpriteModel* pSpriteModel_New = NEW GgafDx9SpriteModel(prm_model_name);
                    restoreSpriteModel(pSpriteModel_New);
                    return pSpriteModel_New;
                }
                
                GgafDx9SpriteSetModel* GgafDx9ModelManager::createSpriteSetModel(char* prm_model_name) {
                    GgafDx9SpriteSetModel* pSpriteSetModel_New = NEW GgafDx9SpriteSetModel(prm_model_name);
                    restoreSpriteSetModel(pSpriteSetModel_New);
                    return pSpriteSetModel_New;
                }
                
                GgafDx9BoardModel* GgafDx9ModelManager::createBoardModel(char* prm_model_name) {
                    GgafDx9BoardModel* pBoardModel_New = NEW GgafDx9BoardModel(prm_model_name);
                    restoreBoardModel(pBoardModel_New);
                    return pBoardModel_New;
                }
                
                GgafDx9BoardSetModel* GgafDx9ModelManager::createBoardSetModel(char* prm_model_name) {
                    GgafDx9BoardSetModel* pBoardSetModel_New = NEW GgafDx9BoardSetModel(prm_model_name);
                    restoreBoardSetModel(pBoardSetModel_New);
                    return pBoardSetModel_New;
                }
                
                GgafDx9MeshModel* GgafDx9ModelManager::createMeshModel(char* prm_model_name) {
                    GgafDx9MeshModel* pMeshModel_New = NEW GgafDx9MeshModel(prm_model_name);
                    restoreMeshModel(pMeshModel_New);
                    return pMeshModel_New;
                }
                
                GgafDx9MeshSetModel* GgafDx9ModelManager::createMeshSetModel(char* prm_model_name) {
                    GgafDx9MeshSetModel* pMeshSetModel_New = NEW GgafDx9MeshSetModel(prm_model_name);
                    restoreMeshSetModel(pMeshSetModel_New);
                    return pMeshSetModel_New;
                }
                
                GgafDx9CubeMapMeshModel* GgafDx9ModelManager::createCubeMapMeshModel(char* prm_model_name) {
                    GgafDx9CubeMapMeshModel* pMeshCubeMapModel_New = NEW GgafDx9CubeMapMeshModel(prm_model_name);
                    restoreMeshModel((GgafDx9MeshModel*)pMeshCubeMapModel_New);
                    return pMeshCubeMapModel_New;
                }
                
                GgafDx9CubeMapMeshSetModel* GgafDx9ModelManager::createCubeMapMeshSetModel(char* prm_model_name) {
                    GgafDx9CubeMapMeshSetModel* pMeshCubeMapSetModel_New = NEW GgafDx9CubeMapMeshSetModel(prm_model_name);
                    restoreMeshSetModel((GgafDx9MeshSetModel*)pMeshCubeMapSetModel_New);
                    return pMeshCubeMapSetModel_New;
                }
                
                
                GgafDx9MorphMeshModel* GgafDx9ModelManager::createMorphMeshModel(char* prm_model_name) {
                    // "M/4/xxxxx" AvC}bV1A[t^[QbgbV4
                    // prm_model_name  "4/xxxxx" B
                    // [t^[QbgfAfAflcB
                    GgafDx9MorphMeshModel* pMorphMeshModel_New = NEW GgafDx9MorphMeshModel(prm_model_name);
                    restoreMorphMeshModel(pMorphMeshModel_New);
                    return pMorphMeshModel_New;
                }
                
                GgafDx9CubeMapMorphMeshModel* GgafDx9ModelManager::createCubeMapMorphMeshModel(char* prm_model_name) {
                    // "M/4/xxxxx" AvC}bV1A[t^[QbgbV4
                    // prm_model_name  "4/xxxxx" B
                    // [t^[QbgfAfAflcB
                    GgafDx9CubeMapMorphMeshModel* pCubeMapMorphMeshModel_New = NEW GgafDx9CubeMapMorphMeshModel(prm_model_name);
                    restoreMorphMeshModel((GgafDx9MorphMeshModel*)pCubeMapMorphMeshModel_New);
                    return pCubeMapMorphMeshModel_New;
                }
                
                
                GgafDx9PointSpriteModel* GgafDx9ModelManager::createPointSpriteModel(char* prm_model_name) {
                    GgafDx9PointSpriteModel* pPointSpriteModel_New = NEW GgafDx9PointSpriteModel(prm_model_name);
                    restorePointSpriteModel(pPointSpriteModel_New);
                    return pPointSpriteModel_New;
                }
                
                void GgafDx9ModelManager::restoreMeshModel(GgafDx9MeshModel* prm_pMeshModel) {
                    TRACE3("GgafDx9ModelManager::restoreMeshModel(" << prm_pMeshModel->_model_name << ")");
                    //yGgafDx9MeshModel\zijTvz
                    //Pj_obt@A_CfbNXobt@  new
                    //QjXt@CAA_obt@A_CfbNXobt@ B
                    //RjQjsA GgafDx9MeshModel oB
                    //@@@@E_obt@
                    //@@@@E_CfbNXobt@
                    //@@@@E}eAz(vf}eA)
                    //@@@@EeNX`z(vf}eA)
                    //@@@@EDrawIndexedPrimitivepz(vf}eAXg)
                
                
                    string xfile_name = GGAFDX9_PROPERTY(DIR_MESH_MODEL) + string(prm_pMeshModel->_model_name) + ".x"; //f{".x"Xt@C
                    HRESULT hr;
                
                    //_obt@f[^
                    ToolBox::IO_Model_X iox;
                
                    Frm::Model3D* model_pModel3D = NULL;
                    Frm::Mesh*    model_pMeshesFront = NULL;
                
                    GgafDx9MeshModel::INDEXPARAM* model_paIndexParam = NULL;
                    GgafDx9MeshModel::VERTEX*     model_paVtxBuffer_org = NULL;
                    WORD*                         model_paIdxBuffer_org = NULL;
                    D3DMATERIAL9*                 model_paD3DMaterial9 = NULL;
                    GgafDx9TextureConnection**    model_papTextureCon = NULL;
                    int nVertices = 0;
                    int nFaces = 0;
                    int nFaceNormals = 0;
                
                    if (prm_pMeshModel->_pModel3D == NULL) {
                        model_pModel3D = NEW Frm::Model3D();
                
                        bool r = iox.Load(xfile_name, model_pModel3D);
                        if (r == false) {
                            throwGgafCriticalException("[GgafDx9ModelManager::restoreMeshModel] Xt@CsB="<<xfile_name);
                        }
                        //bVOAm
                        int nMesh = (int)model_pModel3D->_Meshes.size();
                        uint16* paNumVertices = NEW uint16[nMesh];
                        int index_Mesh = 0;
                        for (list<Frm::Mesh*>::iterator iteMeshes = model_pModel3D->_Meshes.begin();
                                iteMeshes != model_pModel3D->_Meshes.end(); iteMeshes++) {
                            paNumVertices[index_Mesh] = ((*iteMeshes)->_nVertices);
                            index_Mesh++;
                        }
                
                        model_pModel3D->ConcatenateMeshes(); //bVq
                
                        model_pMeshesFront = model_pModel3D->_Meshes.front();
                        nVertices = model_pMeshesFront->_nVertices; //bVA_
                        nFaces = model_pMeshesFront->_nFaces;       //bVA
                        nFaceNormals = model_pMeshesFront->_nFaceNormals; //bVA@
                        model_paVtxBuffer_org = NEW GgafDx9MeshModel::VERTEX[nVertices];
                        prm_pMeshModel->_size_vertices = sizeof(GgafDx9MeshModel::VERTEX) * nVertices;
                        prm_pMeshModel->_size_vertex_unit = sizeof(GgafDx9MeshModel::VERTEX);
                        int nTextureCoords = model_pMeshesFront->_nTextureCoords;
                        if (nVertices < nTextureCoords) {
                            TRACE3("nTextureCoords="<<nTextureCoords<<"/nVertices="<<nVertices);
                            TRACE3("UVWA_obt@zB_B="<<xfile_name);
                        }
                
                        //_obt@JnI
                        //@O
                        FLOAT model_fBoundingSphereRadius;
                        for (int i = 0; i < nVertices; i++) {
                            model_paVtxBuffer_org[i].x = model_pMeshesFront->_Vertices[i].data[0];
                            model_paVtxBuffer_org[i].y = model_pMeshesFront->_Vertices[i].data[1];
                            model_paVtxBuffer_org[i].z = model_pMeshesFront->_Vertices[i].data[2];
                            model_paVtxBuffer_org[i].nx = 0.0f;
                            model_paVtxBuffer_org[i].ny = 0.0f;
                            model_paVtxBuffer_org[i].nz = 0.0f;
                            model_paVtxBuffer_org[i].color = D3DCOLOR_ARGB(255,255,255,255); //_J[g
                            if (i < nTextureCoords) {
                                model_paVtxBuffer_org[i].tu = model_pMeshesFront->_TextureCoords[i].data[0];  //oUVW
                                model_paVtxBuffer_org[i].tv = model_pMeshesFront->_TextureCoords[i].data[1];
                            } else {
                                model_paVtxBuffer_org[i].tu = 0.0f;
                                model_paVtxBuffer_org[i].tv = 0.0f;
                            }
                
                            //
                            model_fBoundingSphereRadius = (FLOAT)(GgafDx9Util::sqrt_fast(model_paVtxBuffer_org[i].x * model_paVtxBuffer_org[i].x +
                                                                 model_paVtxBuffer_org[i].y * model_paVtxBuffer_org[i].y +
                                                                 model_paVtxBuffer_org[i].z * model_paVtxBuffer_org[i].z));
                            if (prm_pMeshModel->_fBoundingSphereRadius < model_fBoundingSphereRadius) {
                                prm_pMeshModel->_fBoundingSphereRadius = model_fBoundingSphereRadius;
                            }
                        }
                
                
                
                        //@B
                        //L_@I
                        //y2009/03/04]ACfBAz
                        //L_AWAPZ@B
                        //AL_@exijA@_pB
                        //@ex  @_p ^ _Sfacepv
                        //BKB
                
                        float* paRad = NEW float[nFaces*3];
                        float* paRadSum_Vtx = NEW float[nVertices];
                        for (int i = 0; i < nVertices; i++) {
                            paRadSum_Vtx[i] = 0;
                        }
                        std::fill_n(paRadSum_Vtx, nVertices, 0);
                        static unsigned short indexVertices_per_Face[3];
                        static unsigned short indexNormals_per_Face[3];
                        for (int i = 0; i < nFaces; i++) {
                            for (int j = 0; j < 3; j++) {
                                //_CfbNXR(A,B,C)
                                indexVertices_per_Face[j] = model_pMeshesFront->_Faces[i].data[j];
                                //@CfbNXR
                                if (nFaceNormals > i) {
                                    indexNormals_per_Face[j] = model_pMeshesFront->_FaceNormals[i].data[j];
                                } else {
                                    //@
                                    indexNormals_per_Face[j] = (unsigned short)0;
                                }
                            }
                
                            //_CfbNX A p(CAB)Az
                            paRad[i*3+0] = getRadv1_v0v1v2(
                                             model_pMeshesFront->_Vertices[indexVertices_per_Face[2]],
                                             model_pMeshesFront->_Vertices[indexVertices_per_Face[0]],
                                             model_pMeshesFront->_Vertices[indexVertices_per_Face[1]]
                                           );
                            //A _CfbNXRApZ
                            paRadSum_Vtx[indexVertices_per_Face[0]] += paRad[i*3+0];
                
                            //_CfbNX B p(ABC)Az
                            paRad[i*3+1] = getRadv1_v0v1v2(
                                             model_pMeshesFront->_Vertices[indexVertices_per_Face[0]],
                                             model_pMeshesFront->_Vertices[indexVertices_per_Face[1]],
                                             model_pMeshesFront->_Vertices[indexVertices_per_Face[2]]
                                           );
                            //B _CfbNXRApZ
                            paRadSum_Vtx[indexVertices_per_Face[1]] += paRad[i*3+1];
                
                            //_CfbNX C p(ACB)Az
                            paRad[i*3+2] = (float)(2*PI - (paRad[i*3+0] + paRad[i*3+1]));
                            //C _CfbNXRApZ
                            paRadSum_Vtx[indexVertices_per_Face[2]] += paRad[i*3+2];
                        }
                
                        static float rate; //@o_pB@xNg|B@xNgeB
                        for (int i = 0; i < nFaces; i++) {
                            for (int j = 0; j < 3; j++) {
                                indexVertices_per_Face[j] = model_pMeshesFront->_Faces[i].data[j];       //_CfbNXR
                                if (nFaceNormals > i) {
                                    indexNormals_per_Face[j] = model_pMeshesFront->_FaceNormals[i].data[j];
                                } else {
                                    //@
                                    indexNormals_per_Face[j] = (unsigned short)0;
                                }
                
                            }
                            if (nFaceNormals > i) {
                                rate = (paRad[i*3+0] / paRadSum_Vtx[indexVertices_per_Face[0]]);
                                model_paVtxBuffer_org[indexVertices_per_Face[0]].nx += (model_pMeshesFront->_Normals[indexNormals_per_Face[0]].x * rate);
                                model_paVtxBuffer_org[indexVertices_per_Face[0]].ny += (model_pMeshesFront->_Normals[indexNormals_per_Face[0]].y * rate);
                                model_paVtxBuffer_org[indexVertices_per_Face[0]].nz += (model_pMeshesFront->_Normals[indexNormals_per_Face[0]].z * rate);
                                rate = (paRad[i*3+1] / paRadSum_Vtx[indexVertices_per_Face[1]]);
                                model_paVtxBuffer_org[indexVertices_per_Face[1]].nx += (model_pMeshesFront->_Normals[indexNormals_per_Face[1]].x * rate);
                                model_paVtxBuffer_org[indexVertices_per_Face[1]].ny += (model_pMeshesFront->_Normals[indexNormals_per_Face[1]].y * rate);
                                model_paVtxBuffer_org[indexVertices_per_Face[1]].nz += (model_pMeshesFront->_Normals[indexNormals_per_Face[1]].z * rate);
                                rate = (paRad[i*3+2] / paRadSum_Vtx[indexVertices_per_Face[2]]);
                                model_paVtxBuffer_org[indexVertices_per_Face[2]].nx += (model_pMeshesFront->_Normals[indexNormals_per_Face[2]].x * rate);
                                model_paVtxBuffer_org[indexVertices_per_Face[2]].ny += (model_pMeshesFront->_Normals[indexNormals_per_Face[2]].y * rate);
                                model_paVtxBuffer_org[indexVertices_per_Face[2]].nz += (model_pMeshesFront->_Normals[indexNormals_per_Face[2]].z * rate);
                            } else {
                                //@A@vZB
                
                                //_CfbNXR
                                int indexVertices1 = model_pMeshesFront->_Faces[i].data[0];
                                int indexVertices2 = model_pMeshesFront->_Faces[i].data[1];
                                int indexVertices3 = model_pMeshesFront->_Faces[i].data[2];
                                //_R
                                D3DXVECTOR3 v1 = D3DXVECTOR3(
                                    model_pMeshesFront->_Vertices[indexVertices1].data[0],
                                    model_pMeshesFront->_Vertices[indexVertices1].data[1],
                                    model_pMeshesFront->_Vertices[indexVertices1].data[2]
                                );
                                D3DXVECTOR3 v2 = D3DXVECTOR3(
                                    model_pMeshesFront->_Vertices[indexVertices2].data[0],
                                    model_pMeshesFront->_Vertices[indexVertices2].data[1],
                                    model_pMeshesFront->_Vertices[indexVertices2].data[2]
                                );
                                D3DXVECTOR3 v3 = D3DXVECTOR3(
                                    model_pMeshesFront->_Vertices[indexVertices3].data[0],
                                    model_pMeshesFront->_Vertices[indexVertices3].data[1],
                                    model_pMeshesFront->_Vertices[indexVertices3].data[2]
                                );
                
                                D3DXPLANE Plane;
                                // 3 _
                                D3DXPlaneFromPoints(&Plane, &v1, &v2, &v3);
                                //K(@)Zo
                                D3DXPlaneNormalize(&Plane, &Plane);
                
                                rate = (paRad[i*3+0] / paRadSum_Vtx[indexVertices_per_Face[0]]);
                                model_paVtxBuffer_org[indexVertices_per_Face[0]].nx += (Plane.a * rate);
                                model_paVtxBuffer_org[indexVertices_per_Face[0]].ny += (Plane.b * rate);
                                model_paVtxBuffer_org[indexVertices_per_Face[0]].nz += (Plane.c * rate);
                                rate = (paRad[i*3+1] / paRadSum_Vtx[indexVertices_per_Face[1]]);
                                model_paVtxBuffer_org[indexVertices_per_Face[1]].nx += (Plane.a * rate);
                                model_paVtxBuffer_org[indexVertices_per_Face[1]].ny += (Plane.b * rate);
                                model_paVtxBuffer_org[indexVertices_per_Face[1]].nz += (Plane.c * rate);
                                rate = (paRad[i*3+2] / paRadSum_Vtx[indexVertices_per_Face[2]]);
                                model_paVtxBuffer_org[indexVertices_per_Face[2]].nx += (Plane.a * rate);
                                model_paVtxBuffer_org[indexVertices_per_Face[2]].ny += (Plane.b * rate);
                                model_paVtxBuffer_org[indexVertices_per_Face[2]].nz += (Plane.c * rate);
                            }
                        }
                
                
                        int n = 0;
                        int nVertices_begin = 0;
                        int nVertices_end = 0;
                        for (std::list<Frm::Bone*>::iterator iteBone = model_pModel3D->_toplevel_Skelettons.begin() ;
                                iteBone != model_pModel3D->_toplevel_Skelettons.end(); iteBone++) {
                
                            _TRACE_("(*iteBone)->_Name="<<((*iteBone)->_Name));
                
                            //Xt@CFrameTransformMatrix(0t[Aj[V)l
                            if ((*iteBone)) {
                                Frm::Matrix* pMatPos = &((*iteBone)->_MatrixPos);
                                if (pMatPos == 0 || pMatPos== NULL || pMatPos->isIdentity()) {
                                    //FrameTransformMatrix Ps
                                    _TRACE_("FrameTransformMatrix is Identity");
                                } else {
                                    _TRACE_("Execute FrameTransform!");
                                    static D3DXMATRIX FrameTransformMatrix;
                                    FrameTransformMatrix._11 = pMatPos->data[0];
                                    FrameTransformMatrix._12 = pMatPos->data[1];
                                    FrameTransformMatrix._13 = pMatPos->data[2];
                                    FrameTransformMatrix._14 = pMatPos->data[3];
                                    FrameTransformMatrix._21 = pMatPos->data[4];
                                    FrameTransformMatrix._22 = pMatPos->data[5];
                                    FrameTransformMatrix._23 = pMatPos->data[6];
                                    FrameTransformMatrix._24 = pMatPos->data[7];
                                    FrameTransformMatrix._31 = pMatPos->data[8];
                                    FrameTransformMatrix._32 = pMatPos->data[9];
                                    FrameTransformMatrix._33 = pMatPos->data[10];
                                    FrameTransformMatrix._34 = pMatPos->data[11];
                                    FrameTransformMatrix._41 = pMatPos->data[12];
                                    FrameTransformMatrix._42 = pMatPos->data[13];
                                    FrameTransformMatrix._43 = pMatPos->data[14];
                                    FrameTransformMatrix._44 = pMatPos->data[15];
                
                                    if (n == 0) {
                                        nVertices_begin = 0;
                                        nVertices_end = paNumVertices[n];
                                    } else {
                                        nVertices_begin += paNumVertices[n-1];
                                        nVertices_end += paNumVertices[n];
                                    }
                
                                    static D3DXVECTOR3 vecVertex;
                                    static D3DXVECTOR3 vecNormal;
                                    for (int i = nVertices_begin; i < nVertices_end; i++) {
                                        vecVertex.x = model_paVtxBuffer_org[i].x;
                                        vecVertex.y = model_paVtxBuffer_org[i].y;
                                        vecVertex.z = model_paVtxBuffer_org[i].z;
                                        D3DXVec3TransformCoord(&vecVertex, &vecVertex, &FrameTransformMatrix);
                                        vecNormal.x = model_paVtxBuffer_org[i].nx;
                                        vecNormal.y = model_paVtxBuffer_org[i].ny;
                                        vecNormal.z = model_paVtxBuffer_org[i].nz;
                                        D3DXVec3TransformNormal(&vecNormal, &vecNormal, &FrameTransformMatrix);
                
                                        model_paVtxBuffer_org[i].x = vecVertex.x;
                                        model_paVtxBuffer_org[i].y = vecVertex.y;
                                        model_paVtxBuffer_org[i].z = vecVertex.z;
                                        model_paVtxBuffer_org[i].nx = vecNormal.x;
                                        model_paVtxBuffer_org[i].ny = vecNormal.y;
                                        model_paVtxBuffer_org[i].nz = vecNormal.z;
                                    }
                                }
                            }
                            n++;
                        }
                        DELETE_IMPOSSIBLE_NULL(paNumVertices);
                
                        //@K
                        static D3DXVECTOR3 vec;
                        for (int i = 0; i < nVertices; i++) {
                            vec.x = model_paVtxBuffer_org[i].nx;
                            vec.y = model_paVtxBuffer_org[i].ny;
                            vec.z = model_paVtxBuffer_org[i].nz;
                            if (vec.x == 0 && vec.y == 0 && vec.z == 0) {
                                model_paVtxBuffer_org[i].nx = 0;
                                model_paVtxBuffer_org[i].ny = 0;
                                model_paVtxBuffer_org[i].nz = 0;
                            } else {
                                D3DXVec3Normalize( &vec, &vec);
                                model_paVtxBuffer_org[i].nx = vec.x;
                                model_paVtxBuffer_org[i].ny = vec.y;
                                model_paVtxBuffer_org[i].nz = vec.z;
                            }
                        }
                //        TRACE3("@K----------------------------");
                //        for (int i = 0; i < nVertices; i++) {
                //            TRACE3("["<<i<<"]=" << model_paVtxBuffer_org[i].x << "\t, " << model_paVtxBuffer_org[i].y << "\t, " << model_paVtxBuffer_org[i].z << "\t, " << model_paVtxBuffer_org[i].nx << "\t, " << model_paVtxBuffer_org[i].ny << "\t, " << model_paVtxBuffer_org[i].nz << "\t, " << model_paVtxBuffer_org[i].tu << "\t, " << model_paVtxBuffer_org[i].tv);
                //        }
                //        TRACE3("--------------------------------------");
                
                        //CfbNXobt@o^
                        model_paIdxBuffer_org = NEW WORD[nFaces*3];
                        for (int i = 0; i < nFaces; i++) {
                            model_paIdxBuffer_org[i*3 + 0] = model_pMeshesFront->_Faces[i].data[0];
                            model_paIdxBuffer_org[i*3 + 1] = model_pMeshesFront->_Faces[i].data[1];
                            model_paIdxBuffer_org[i*3 + 2] = model_pMeshesFront->_Faces[i].data[2];
                        }
                
                        //}eAXg
                //        UINT aMaterialsGrp = UINT[nFaces];
                //        for (int i = 0; i < nFaces; i++) {
                //            aMaterialsGrp[i] =  model_pMeshesFront->_FaceMaterials[i];
                //        }
                
                        //`iDrawIndexedPrimitivejp[^Xg
                        GgafDx9MeshModel::INDEXPARAM* paParam = NEW GgafDx9MeshModel::INDEXPARAM[nFaces]; //}eAoonFacesKv
                
                        int prev_materialno = -1;
                        int materialno = 0;
                        int paramno = 0;
                        int faceNoCnt_break = 0;
                        int prev_faceNoCnt_break = -1;
                        UINT max_num_vertices = 0;
                        UINT min_num_vertices = UINT_MAX;
                
                        int faceNoCnt;
                        for (faceNoCnt = 0; faceNoCnt < nFaces; faceNoCnt++) {
                            materialno = model_pMeshesFront->_FaceMaterials[faceNoCnt];
                            if (prev_materialno != materialno) {
                                //TRACE3("BREAK! paramno="<<paramno);
                                prev_faceNoCnt_break = faceNoCnt_break;
                                faceNoCnt_break = faceNoCnt;
                
                                paParam[paramno].MaterialNo = materialno;
                                paParam[paramno].BaseVertexIndex = 0;
                                paParam[paramno].MinIndex = UINT_MAX; //uCNAKuCNl
                                paParam[paramno].NumVertices = UINT_MAX; //uCN
                                paParam[paramno].StartIndex = faceNoCnt*3;
                                paParam[paramno].PrimitiveCount = UINT_MAX; //uCN
                
                                if (faceNoCnt > 0) {
                                    paParam[paramno-1].MinIndex = min_num_vertices;
                                    paParam[paramno-1].NumVertices = (UINT)(max_num_vertices - min_num_vertices + 1);
                                    paParam[paramno-1].PrimitiveCount = (UINT)(faceNoCnt_break - prev_faceNoCnt_break);
                                    //Zbg
                                    max_num_vertices = 0;
                                    min_num_vertices = UINT_MAX;
                                }
                                paramno++;
                            }
                
                            if (max_num_vertices <  model_paIdxBuffer_org[faceNoCnt*3 + 0]) {
                                max_num_vertices = model_paIdxBuffer_org[faceNoCnt*3 + 0];
                            }
                            if (max_num_vertices <  model_paIdxBuffer_org[faceNoCnt*3 + 1]) {
                                max_num_vertices = model_paIdxBuffer_org[faceNoCnt*3 + 1];
                            }
                            if (max_num_vertices <  model_paIdxBuffer_org[faceNoCnt*3 + 2]) {
                                max_num_vertices = model_paIdxBuffer_org[faceNoCnt*3 + 2];
                            }
                            if (min_num_vertices >  model_paIdxBuffer_org[faceNoCnt*3 + 0]) {
                                min_num_vertices = model_paIdxBuffer_org[faceNoCnt*3 + 0];
                            }
                            if (min_num_vertices >  model_paIdxBuffer_org[faceNoCnt*3 + 1]) {
                                min_num_vertices = model_paIdxBuffer_org[faceNoCnt*3 + 1];
                            }
                            if (min_num_vertices >  model_paIdxBuffer_org[faceNoCnt*3 + 2]) {
                                min_num_vertices = model_paIdxBuffer_org[faceNoCnt*3 + 2];
                            }
                            prev_materialno = materialno;
                        }
                        if (nFaces > 0) {
                            paParam[paramno-1].MinIndex = min_num_vertices;
                            paParam[paramno-1].NumVertices = (UINT)(max_num_vertices - min_num_vertices + 1);
                            paParam[paramno-1].PrimitiveCount = (UINT)(faceNoCnt - faceNoCnt_break);
                        }
                
                        model_paIndexParam = NEW GgafDx9MeshModel::INDEXPARAM[paramno];
                        for (int i = 0; i < paramno; i++) {
                            model_paIndexParam[i].MaterialNo = paParam[i].MaterialNo;
                            model_paIndexParam[i].BaseVertexIndex = paParam[i].BaseVertexIndex;
                            model_paIndexParam[i].MinIndex = paParam[i].MinIndex;
                            model_paIndexParam[i].NumVertices = paParam[i].NumVertices;
                            model_paIndexParam[i].StartIndex = paParam[i].StartIndex;
                            model_paIndexParam[i].PrimitiveCount = paParam[i].PrimitiveCount;
                        }
                        prm_pMeshModel->_nMaterialListGrp = paramno;
                        delete[] paRad;
                        delete[] paRadSum_Vtx;
                        delete[] paParam;
                    }
                
                    if (prm_pMeshModel->_pIDirect3DVertexBuffer9 == NULL) {
                
                        //_obt@
                        hr = GgafDx9God::_pID3DDevice9->CreateVertexBuffer(
                                prm_pMeshModel->_size_vertices,
                                D3DUSAGE_WRITEONLY,
                                GgafDx9MeshModel::FVF,
                                D3DPOOL_DEFAULT, //D3DPOOL_DEFAULT
                                &(prm_pMeshModel->_pIDirect3DVertexBuffer9),
                                NULL);
                        checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreMeshModel] _pID3DDevice9->CreateVertexBuffer s model="<<(prm_pMeshModel->_model_name));
                
                        //obt@_f[^
                        void *pVertexBuffer;
                        hr = prm_pMeshModel->_pIDirect3DVertexBuffer9->Lock(0, prm_pMeshModel->_size_vertices, (void**)&pVertexBuffer, 0);
                        checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreMeshModel] _obt@bNs model="<<prm_pMeshModel->_model_name);
                        memcpy(pVertexBuffer, model_paVtxBuffer_org, prm_pMeshModel->_size_vertices); //pVertexBuffer  paVertex
                        prm_pMeshModel->_pIDirect3DVertexBuffer9->Unlock();
                    }
                
                
                    //CfbNXobt@f[^
                    if (prm_pMeshModel->_pIDirect3DIndexBuffer9 == NULL) {
                        int nFaces = model_pMeshesFront->_nFaces;
                
                        hr = GgafDx9God::_pID3DDevice9->CreateIndexBuffer(
                                               sizeof(WORD) * nFaces * 3,
                                                D3DUSAGE_WRITEONLY,
                                                D3DFMT_INDEX16,
                                                D3DPOOL_DEFAULT,
                                                &(prm_pMeshModel->_pIDirect3DIndexBuffer9),
                                                NULL);
                        checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreMeshModel] _pID3DDevice9->CreateIndexBuffer s model="<<(prm_pMeshModel->_model_name));
                        void* pIndexBuffer;
                        prm_pMeshModel->_pIDirect3DIndexBuffer9->Lock(0,0,(void**)&pIndexBuffer,0);
                        memcpy(pIndexBuffer , model_paIdxBuffer_org , sizeof(WORD) * nFaces * 3);
                        prm_pMeshModel->_pIDirect3DIndexBuffer9->Unlock();
                    }
                
                    //}eAJEg
                    int model_nMaterials = 0;
                    for (list<Frm::Material*>::iterator material = model_pMeshesFront->_Materials.begin(); material != model_pMeshesFront->_Materials.end(); material++) {
                        model_nMaterials++;
                    }
                
                    model_paD3DMaterial9 = NEW D3DMATERIAL9[model_nMaterials];
                    model_papTextureCon = NEW GgafDx9TextureConnection*[model_nMaterials];
                
                    char* texture_filename;
                    int n = 0;
                    for (list<Frm::Material*>::iterator material = model_pMeshesFront->_Materials.begin(); material != model_pMeshesFront->_Materials.end(); material++) {
                        model_paD3DMaterial9[n].Diffuse.r = (*material)->_FaceColor.data[0];
                        model_paD3DMaterial9[n].Diffuse.g = (*material)->_FaceColor.data[1];
                        model_paD3DMaterial9[n].Diffuse.b = (*material)->_FaceColor.data[2];
                        model_paD3DMaterial9[n].Diffuse.a = (*material)->_FaceColor.data[3];
                
                        model_paD3DMaterial9[n].Ambient.r = (*material)->_FaceColor.data[0];
                        model_paD3DMaterial9[n].Ambient.g = (*material)->_FaceColor.data[1];
                        model_paD3DMaterial9[n].Ambient.b = (*material)->_FaceColor.data[2];
                        model_paD3DMaterial9[n].Ambient.a = (*material)->_FaceColor.data[3];
                
                        model_paD3DMaterial9[n].Specular.r = (*material)->_SpecularColor.data[0];
                        model_paD3DMaterial9[n].Specular.g = (*material)->_SpecularColor.data[1];
                        model_paD3DMaterial9[n].Specular.b = (*material)->_SpecularColor.data[2];
                        model_paD3DMaterial9[n].Specular.a = 1.000000f;
                        model_paD3DMaterial9[n].Power =  (*material)->_power;
                
                        model_paD3DMaterial9[n].Emissive.r = (*material)->_EmissiveColor.data[0];
                        model_paD3DMaterial9[n].Emissive.g = (*material)->_EmissiveColor.data[1];
                        model_paD3DMaterial9[n].Emissive.b = (*material)->_EmissiveColor.data[2];
                        model_paD3DMaterial9[n].Emissive.a = 1.000000f;
                
                        texture_filename = (char*)((*material)->_TextureName.c_str());
                        if (texture_filename != NULL && lstrlen(texture_filename) > 0 ) {
                            model_papTextureCon[n] = (GgafDx9TextureConnection*)_pTextureManager->getConnection(texture_filename);
                        } else {
                            //eNX`^eNX`u
                            model_papTextureCon[n] = (GgafDx9TextureConnection*)_pTextureManager->getConnection("white.png");
                        }
                        n++;
                    }
                
                    //f
                    prm_pMeshModel->_pModel3D = model_pModel3D;
                    prm_pMeshModel->_pMeshesFront = model_pMeshesFront;
                
                    prm_pMeshModel->_paIdxBuffer_org = model_paIdxBuffer_org;
                    prm_pMeshModel->_paVtxBuffer_org = model_paVtxBuffer_org;
                    prm_pMeshModel->_paIndexParam = model_paIndexParam;
                    prm_pMeshModel->_paD3DMaterial9_default = model_paD3DMaterial9;
                    prm_pMeshModel->_papTextureCon = model_papTextureCon;
                    prm_pMeshModel->_dwNumMaterials = model_nMaterials;
                
                //    {
                //        //fobO
                //        _TRACE_("#_obt@ nVertices="<<nVertices);
                //        float x,y,z,nx,ny,nz,tu,tv;
                //        for (int i = 0; i < nVertices; i++) {
                //            x = model_paVtxBuffer_org[i].x;
                //            y = model_paVtxBuffer_org[i].y;
                //            z = model_paVtxBuffer_org[i].z;
                //            nx = model_paVtxBuffer_org[i].nx;
                //            ny = model_paVtxBuffer_org[i].ny;
                //            nz = model_paVtxBuffer_org[i].nz;
                //            tu = model_paVtxBuffer_org[i].tu;
                //            tv = model_paVtxBuffer_org[i].tv;
                //
                //            _TRACE_("_["<<i<<"] "<<x<<";"<<y<<";"<<z<<";,\t"<<nx<<";"<<ny<<";"<<nz<<";,\t"<<tu<<";"<<tv<<";,");
                //        }
                //
                //
                //        _TRACE_("#CfbNXobt@ nFaces="<<nFaces);
                //        WORD vtx1,vtx2,vtx3;
                //        for (int face = 0; face < nFaces; face++) {
                //            vtx1 = model_paIdxBuffer_org[face*3 + 0];
                //            vtx2 = model_paIdxBuffer_org[face*3 + 1];
                //            vtx3 = model_paIdxBuffer_org[face*3 + 2];
                //            _TRACE_("["<<face<<"] 3;"<<vtx1<<","<<vtx2<<","<<vtx3<<";,");
                //        }
                //
                //        _TRACE_("}eA  model_nMaterials="<<model_nMaterials);
                //        float a,r,g,b;
                //        for (int i = 0; i < model_nMaterials; i++) {
                //            a = model_paD3DMaterial9[i].Diffuse.a;
                //            r = model_paD3DMaterial9[i].Diffuse.r;
                //            g = model_paD3DMaterial9[i].Diffuse.g;
                //            b = model_paD3DMaterial9[i].Diffuse.b;
                //            _TRACE_("nMaterial["<<i<<"] Diffuse(rgba)=("<<r<<","<<g<<","<<b<<","<<a<<")");
                //            a = model_paD3DMaterial9[i].Ambient.a;
                //            r = model_paD3DMaterial9[i].Ambient.r;
                //            g = model_paD3DMaterial9[i].Ambient.g;
                //            b = model_paD3DMaterial9[i].Ambient.b;
                //            _TRACE_("nMaterial["<<i<<"] Ambient(rgba)=("<<r<<","<<g<<","<<b<<","<<a<<")");
                //        }
                //
                //        _TRACE_("#}eAXg _nMaterialListGrp="<< prm_pMeshModel->_nMaterialListGrp);
                //        for (UINT i = 0; i < prm_pMeshModel->_nMaterialListGrp; i++) {
                //            int material_no = prm_pMeshModel->_paIndexParam[i].MaterialNo;
                //            _TRACE_("MaterialGrp["<<i<<"] "<<material_no<<",");
                //        }
                //
                //        _TRACE_("#IndexParam  _nMaterialListGrp="<< prm_pMeshModel->_nMaterialListGrp);
                //        UINT MaterialNo;
                //        INT BaseVertexIndex;
                //        UINT MinIndex;
                //        UINT NumVertices;
                //        UINT StartIndex;
                //        UINT PrimitiveCount;
                //        for (UINT i = 0; i < prm_pMeshModel->_nMaterialListGrp; i++) {
                //            MaterialNo = model_paIndexParam[i].MaterialNo;
                //            BaseVertexIndex = model_paIndexParam[i].BaseVertexIndex;
                //            MinIndex = model_paIndexParam[i].MinIndex;
                //            NumVertices = model_paIndexParam[i].NumVertices;
                //            StartIndex = model_paIndexParam[i].StartIndex;
                //            PrimitiveCount = model_paIndexParam[i].PrimitiveCount;
                //            _TRACE_("MaterialGrp["<<i<<"] MaterialNo="<<MaterialNo);
                //            _TRACE_("MaterialGrp["<<i<<"] BaseVertexIndex="<<BaseVertexIndex);
                //            _TRACE_("MaterialGrp["<<i<<"] MinIndex="<<MinIndex);
                //            _TRACE_("MaterialGrp["<<i<<"] NumVertices="<<MaterialNo);
                //            _TRACE_("MaterialGrp["<<i<<"] StartIndex="<<StartIndex);
                //            _TRACE_("MaterialGrp["<<i<<"] PrimitiveCount="<<PrimitiveCount);
                //        }
                //    }
                
                }
                
                void GgafDx9ModelManager::restoreMorphMeshModel(GgafDx9MorphMeshModel* prm_pMorphMeshModel) {
                    TRACE3("GgafDx9ModelManager::restoreMorphMeshModel(" << prm_pMorphMeshModel->_model_name << ")");
                    //yGgafDx9MorphMeshModel\zijTvz
                    //{IrestoreMeshModelizj
                    //PjvC}{[t^[QbgN A_obt@A_CfbNXobt@ 
                    //QjXt@CAA_obt@A_CfbNXobt@ B
                    //RjQjsA GgafDx9MeshModel oB
                    //@@@@EvC}bV_obt@
                    //@@@@E[t^[QbgN _obt@
                    //@@@@E_CfbNXobt@ivC}bVj
                    //@@@@E}eAz(vf}eABvC}bV)
                    //@@@@EeNX`z(vf}eABvC}bV)
                    //@@@@EDrawIndexedPrimitivepz(vf}eAXgBvC}bV)
                    int morph_target_num = prm_pMorphMeshModel->_morph_target_num;
                
                    string* paXfileName = NEW string[morph_target_num+1];
                
                    for(int i = 0; i < morph_target_num+1; i++) {
                        char* xfilename_base = prm_pMorphMeshModel->_model_name + 2; //Q~  "2/ceres"  "ceres"
                        paXfileName[i] = GGAFDX9_PROPERTY(DIR_MESH_MODEL) + string(xfilename_base) + "_" + (char)('0'+i) + ".x"; //"ceres_0.x"
                    }
                    HRESULT hr;
                    //_obt@f[^
                    ToolBox::IO_Model_X* paIOX = NULL;
                    Frm::Model3D**                         model_papModel3D = NULL;
                    Frm::Mesh**                            model_papMeshesFront = NULL;
                
                    GgafDx9MorphMeshModel::INDEXPARAM*     model_paIndexParam = NULL;
                    GgafDx9MorphMeshModel::VERTEX_PRIMARY* model_paVtxBuffer_org_primary = NULL;
                    GgafDx9MorphMeshModel::VERTEX_MORPH**  model_papaVtxBuffer_org_morph = NULL;
                    WORD*                                  model_paIdxBuffer_org = NULL;
                    D3DMATERIAL9*                          model_paD3DMaterial9 = NULL;
                
                    GgafDx9TextureConnection** model_papTextureCon = NULL;
                
                    if (prm_pMorphMeshModel->_papModel3D == NULL) {
                        paIOX = NEW ToolBox::IO_Model_X[morph_target_num+1];
                        model_papModel3D = NEW Frm::Model3D*[morph_target_num+1];
                        model_papMeshesFront = NEW Frm::Mesh*[morph_target_num+1];
                        model_papaVtxBuffer_org_morph = NEW GgafDx9MorphMeshModel::VERTEX_MORPH*[morph_target_num];
                        int nVertices = 0;
                        int nTextureCoords = 0;
                        int nFaces = 0;
                        int nFaceNormals = 0;
                        FLOAT model_fBoundingSphereRadius;
                        for (int pattern = 0; pattern < morph_target_num+1; pattern++) {
                            model_papModel3D[pattern] = NEW Frm::Model3D();
                            bool r = paIOX[pattern].Load(paXfileName[pattern], model_papModel3D[pattern]);
                            if (r == false) {
                                throwGgafCriticalException("[GgafDx9ModelManager::restoreMorphMeshModel] Xt@CsB="<<paXfileName[pattern]);
                            }
                            //bVOAm
                            int nMesh = (int)model_papModel3D[pattern]->_Meshes.size();
                            uint16* paNumVertices = NEW uint16[nMesh];
                            int index_Mesh = 0;
                            for (list<Frm::Mesh*>::iterator iteMeshes = model_papModel3D[pattern]->_Meshes.begin();
                                    iteMeshes != model_papModel3D[pattern]->_Meshes.end(); iteMeshes++) {
                                paNumVertices[index_Mesh] = ((*iteMeshes)->_nVertices);
                                index_Mesh++;
                            }
                            model_papModel3D[pattern]->ConcatenateMeshes(); //bVq
                            model_papMeshesFront[pattern] = model_papModel3D[pattern]->_Meshes.front();
                //            _TRACE_("---");
                            nVertices = model_papMeshesFront[pattern]->_nVertices;
                //            _TRACE_("pattern="<<pattern<<"/nVertices="<<nVertices);
                            nTextureCoords = model_papMeshesFront[pattern]->_nTextureCoords;
                //            _TRACE_("pattern="<<pattern<<"/nTextureCoords="<<nTextureCoords);
                            nFaces = model_papMeshesFront[pattern]->_nFaces;
                //            _TRACE_("pattern="<<pattern<<"/nFaces="<<nFaces);
                            nFaceNormals = model_papMeshesFront[pattern]->_nFaceNormals;
                //            _TRACE_("pattern="<<pattern<<"/nFaceNormals="<<nFaceNormals);
                
                            if (nVertices*(morph_target_num+1) > 65535) {
                                throwGgafCriticalException("[GgafDx9ModelManager::restoreMorphMeshModel] _ 65535B\nModelF"<<prm_pMorphMeshModel->getName()<<"  nVertices:"<<nVertices<<"  Zbg:"<<(morph_target_num+1));
                            }
                //            if (nFaces * 3 * (morph_target_num+1) > 65535) {
                //                throwGgafCriticalException("[GgafDx9ModelManager::restoreMorphMeshModel] _CfbNX 65535B\nModelF"<<prm_pMorphMeshModel->getName()<<"  nFaces:"<<nFaces<<"(*3)  Zbg:"<<(morph_target_num+1));
                //            }
                
                            if (pattern == 0) {
                                //vC}bV
                                model_paVtxBuffer_org_primary = NEW GgafDx9MorphMeshModel::VERTEX_PRIMARY[nVertices];
                                prm_pMorphMeshModel->_size_vertices_primary = sizeof(GgafDx9MorphMeshModel::VERTEX_PRIMARY) * nVertices;
                                prm_pMorphMeshModel->_size_vertex_unit_primary = sizeof(GgafDx9MorphMeshModel::VERTEX_PRIMARY);
                                //@O
                                for (int i = 0; i < nVertices; i++) {
                                    model_paVtxBuffer_org_primary[i].x = model_papMeshesFront[pattern]->_Vertices[i].data[0];
                                    model_paVtxBuffer_org_primary[i].y = model_papMeshesFront[pattern]->_Vertices[i].data[1];
                                    model_paVtxBuffer_org_primary[i].z = model_papMeshesFront[pattern]->_Vertices[i].data[2];
                                    model_paVtxBuffer_org_primary[i].nx = 0.0f;
                                    model_paVtxBuffer_org_primary[i].ny = 0.0f;
                                    model_paVtxBuffer_org_primary[i].nz = 0.0f;
                                    model_paVtxBuffer_org_primary[i].color = D3DCOLOR_ARGB(255,255,255,255);
                                    if (i < nTextureCoords) {
                                        model_paVtxBuffer_org_primary[i].tu = model_papMeshesFront[pattern]->_TextureCoords[i].data[0];  //oUVW
                                        model_paVtxBuffer_org_primary[i].tv = model_papMeshesFront[pattern]->_TextureCoords[i].data[1];
                                    } else {
                                        model_paVtxBuffer_org_primary[i].tu = 0.0f;
                                        model_paVtxBuffer_org_primary[i].tv = 0.0f;
                                    }
                
                                    //
                                    model_fBoundingSphereRadius = (FLOAT)(GgafDx9Util::sqrt_fast(model_paVtxBuffer_org_primary[i].x * model_paVtxBuffer_org_primary[i].x +
                                                                         model_paVtxBuffer_org_primary[i].y * model_paVtxBuffer_org_primary[i].y +
                                                                         model_paVtxBuffer_org_primary[i].z * model_paVtxBuffer_org_primary[i].z));
                                    if (prm_pMorphMeshModel->_fBoundingSphereRadius < model_fBoundingSphereRadius) {
                                        prm_pMorphMeshModel->_fBoundingSphereRadius = model_fBoundingSphereRadius;
                                    }
                                }
                            } else {
                                //[t^[QbgbV
                                model_papaVtxBuffer_org_morph[pattern-1] = NEW GgafDx9MorphMeshModel::VERTEX_MORPH[nVertices];
                                prm_pMorphMeshModel->_size_vertices_morph = sizeof(GgafDx9MorphMeshModel::VERTEX_MORPH) * nVertices;
                                prm_pMorphMeshModel->_size_vertex_unit_morph = sizeof(GgafDx9MorphMeshModel::VERTEX_MORPH);
                                //@O
                                for (int i = 0; i < nVertices; i++) {
                                    model_papaVtxBuffer_org_morph[pattern-1][i].x = model_papMeshesFront[pattern]->_Vertices[i].data[0];
                                    model_papaVtxBuffer_org_morph[pattern-1][i].y = model_papMeshesFront[pattern]->_Vertices[i].data[1];
                                    model_papaVtxBuffer_org_morph[pattern-1][i].z = model_papMeshesFront[pattern]->_Vertices[i].data[2];
                                    model_papaVtxBuffer_org_morph[pattern-1][i].nx = 0.0f;
                                    model_papaVtxBuffer_org_morph[pattern-1][i].ny = 0.0f;
                                    model_papaVtxBuffer_org_morph[pattern-1][i].nz = 0.0f;
                                }
                            }
                
                            int nTextureCoords = model_papMeshesFront[pattern]->_nTextureCoords;
                            if (nVertices < nTextureCoords) {
                                TRACE3("nTextureCoords="<<nTextureCoords<<"/nVertices="<<nVertices);
                                TRACE3("UVWA_obt@zB_B="<<paXfileName[pattern]);
                            }
                
                            //@B
                            //restoreMeshModell
                            float* paRad = NEW float[nFaces*3];
                            float* paRadSum_Vtx = NEW float[nVertices];
                            for (int i = 0; i < nVertices; i++) {
                                paRadSum_Vtx[i] = 0;
                            }
                            std::fill_n(paRadSum_Vtx, nVertices, 0);
                            static unsigned short indexVertices_per_Face[3];
                            static unsigned short indexNormals_per_Face[3];
                            for (int i = 0; i < nFaces; i++) {
                                for (int j = 0; j < 3; j++) {
                                    //_CfbNXR(A,B,C)
                                    indexVertices_per_Face[j] = model_papMeshesFront[pattern]->_Faces[i].data[j];
                                    //@CfbNXR
                                    if (nFaceNormals > i) {
                                        indexNormals_per_Face[j] = model_papMeshesFront[pattern]->_FaceNormals[i].data[j];
                                    } else {
                                        //@
                                        indexNormals_per_Face[j] = (unsigned short)0;
                                    }
                                }
                
                                //_CfbNX A p(CAB)Az
                                paRad[i*3+0] = getRadv1_v0v1v2(
                                                 model_papMeshesFront[pattern]->_Vertices[indexVertices_per_Face[2]],
                                                 model_papMeshesFront[pattern]->_Vertices[indexVertices_per_Face[0]],
                                                 model_papMeshesFront[pattern]->_Vertices[indexVertices_per_Face[1]]
                                               );
                                //A _CfbNXRApZ
                                paRadSum_Vtx[indexVertices_per_Face[0]] += paRad[i*3+0];
                
                                //_CfbNX B p(ABC)Az
                                paRad[i*3+1] = getRadv1_v0v1v2(
                                                 model_papMeshesFront[pattern]->_Vertices[indexVertices_per_Face[0]],
                                                 model_papMeshesFront[pattern]->_Vertices[indexVertices_per_Face[1]],
                                                 model_papMeshesFront[pattern]->_Vertices[indexVertices_per_Face[2]]
                                               );
                                //B _CfbNXRApZ
                                paRadSum_Vtx[indexVertices_per_Face[1]] += paRad[i*3+1];
                
                                //_CfbNX C p(ACB)Az
                                paRad[i*3+2] = (float)(2*PI - (paRad[i*3+0] + paRad[i*3+1]));
                                //C _CfbNXRApZ
                                paRadSum_Vtx[indexVertices_per_Face[2]] += paRad[i*3+2];
                            }
                
                            float rate; //@o_pB@xNg|B@xNgeB
                            for (int i = 0; i < nFaces; i++) {
                                for (int j = 0; j < 3; j++) {
                                    indexVertices_per_Face[j] = model_papMeshesFront[pattern]->_Faces[i].data[j];       //_CfbNXR
                                    if (nFaceNormals > i) {
                                        indexNormals_per_Face[j] = model_papMeshesFront[pattern]->_FaceNormals[i].data[j];  //@CfbNXR
                                    } else {
                                        //@
                                        indexNormals_per_Face[j] = (unsigned short)0;
                                    }
                                }
                                if (nFaceNormals > i) {
                                    rate = (paRad[i*3+0] / paRadSum_Vtx[indexVertices_per_Face[0]]);
                                    if (pattern == 0) { //vC}bV
                                        model_paVtxBuffer_org_primary[indexVertices_per_Face[0]].nx += (model_papMeshesFront[pattern]->_Normals[indexNormals_per_Face[0]].x * rate);
                                        model_paVtxBuffer_org_primary[indexVertices_per_Face[0]].ny += (model_papMeshesFront[pattern]->_Normals[indexNormals_per_Face[0]].y * rate);
                                        model_paVtxBuffer_org_primary[indexVertices_per_Face[0]].nz += (model_papMeshesFront[pattern]->_Normals[indexNormals_per_Face[0]].z * rate);
                                    } else {            //[t^[QbgbV
                                        model_papaVtxBuffer_org_morph[pattern-1][indexVertices_per_Face[0]].nx += (model_papMeshesFront[pattern]->_Normals[indexNormals_per_Face[0]].x * rate);
                                        model_papaVtxBuffer_org_morph[pattern-1][indexVertices_per_Face[0]].ny += (model_papMeshesFront[pattern]->_Normals[indexNormals_per_Face[0]].y * rate);
                                        model_papaVtxBuffer_org_morph[pattern-1][indexVertices_per_Face[0]].nz += (model_papMeshesFront[pattern]->_Normals[indexNormals_per_Face[0]].z * rate);
                                    }
                                    rate = (paRad[i*3+1] / paRadSum_Vtx[indexVertices_per_Face[1]]);
                                    if (pattern == 0) { //vC}bV
                                        model_paVtxBuffer_org_primary[indexVertices_per_Face[1]].nx += (model_papMeshesFront[pattern]->_Normals[indexNormals_per_Face[1]].x * rate);
                                        model_paVtxBuffer_org_primary[indexVertices_per_Face[1]].ny += (model_papMeshesFront[pattern]->_Normals[indexNormals_per_Face[1]].y * rate);
                                        model_paVtxBuffer_org_primary[indexVertices_per_Face[1]].nz += (model_papMeshesFront[pattern]->_Normals[indexNormals_per_Face[1]].z * rate);
                                    } else {            //[t^[QbgbV
                                        model_papaVtxBuffer_org_morph[pattern-1][indexVertices_per_Face[1]].nx += (model_papMeshesFront[pattern]->_Normals[indexNormals_per_Face[1]].x * rate);
                                        model_papaVtxBuffer_org_morph[pattern-1][indexVertices_per_Face[1]].ny += (model_papMeshesFront[pattern]->_Normals[indexNormals_per_Face[1]].y * rate);
                                        model_papaVtxBuffer_org_morph[pattern-1][indexVertices_per_Face[1]].nz += (model_papMeshesFront[pattern]->_Normals[indexNormals_per_Face[1]].z * rate);
                                    }
                                    rate = (paRad[i*3+2] / paRadSum_Vtx[indexVertices_per_Face[2]]);
                                    if (pattern == 0) { //vC}bV
                                        model_paVtxBuffer_org_primary[indexVertices_per_Face[2]].nx += (model_papMeshesFront[pattern]->_Normals[indexNormals_per_Face[2]].x * rate);
                                        model_paVtxBuffer_org_primary[indexVertices_per_Face[2]].ny += (model_papMeshesFront[pattern]->_Normals[indexNormals_per_Face[2]].y * rate);
                                        model_paVtxBuffer_org_primary[indexVertices_per_Face[2]].nz += (model_papMeshesFront[pattern]->_Normals[indexNormals_per_Face[2]].z * rate);
                                    } else {            //[t^[QbgbV
                                        model_papaVtxBuffer_org_morph[pattern-1][indexVertices_per_Face[2]].nx += (model_papMeshesFront[pattern]->_Normals[indexNormals_per_Face[2]].x * rate);
                                        model_papaVtxBuffer_org_morph[pattern-1][indexVertices_per_Face[2]].ny += (model_papMeshesFront[pattern]->_Normals[indexNormals_per_Face[2]].y * rate);
                                        model_papaVtxBuffer_org_morph[pattern-1][indexVertices_per_Face[2]].nz += (model_papMeshesFront[pattern]->_Normals[indexNormals_per_Face[2]].z * rate);
                                    }
                                } else {
                                    //@
                                    int indexVertices1 = model_papMeshesFront[pattern]->_Faces[i].data[0];
                                    int indexVertices2 = model_papMeshesFront[pattern]->_Faces[i].data[1];
                                    int indexVertices3 = model_papMeshesFront[pattern]->_Faces[i].data[2];
                                    D3DXVECTOR3 v1 = D3DXVECTOR3(
                                        model_papMeshesFront[pattern]->_Vertices[indexVertices1].data[0],
                                        model_papMeshesFront[pattern]->_Vertices[indexVertices1].data[1],
                                        model_papMeshesFront[pattern]->_Vertices[indexVertices1].data[2]
                                    );
                                    D3DXVECTOR3 v2 = D3DXVECTOR3(
                                        model_papMeshesFront[pattern]->_Vertices[indexVertices2].data[0],
                                        model_papMeshesFront[pattern]->_Vertices[indexVertices2].data[1],
                                        model_papMeshesFront[pattern]->_Vertices[indexVertices2].data[2]
                                    );
                                    D3DXVECTOR3 v3 = D3DXVECTOR3(
                                        model_papMeshesFront[pattern]->_Vertices[indexVertices3].data[0],
                                        model_papMeshesFront[pattern]->_Vertices[indexVertices3].data[1],
                                        model_papMeshesFront[pattern]->_Vertices[indexVertices3].data[2]
                                    );
                
                                    D3DXPLANE Plane;
                                    // 3 _
                                    D3DXPlaneFromPoints(&Plane, &v1, &v2, &v3);
                                    //K(@)Zo
                                    D3DXPlaneNormalize(&Plane, &Plane);
                
                                    if (pattern == 0) { //vC}bV
                                        rate = (paRad[i*3+0] / paRadSum_Vtx[indexVertices_per_Face[0]]);
                                        model_paVtxBuffer_org_primary[indexVertices_per_Face[0]].nx += (Plane.a * rate);
                                        model_paVtxBuffer_org_primary[indexVertices_per_Face[0]].ny += (Plane.b * rate);
                                        model_paVtxBuffer_org_primary[indexVertices_per_Face[0]].nz += (Plane.c * rate);
                                        rate = (paRad[i*3+1] / paRadSum_Vtx[indexVertices_per_Face[1]]);
                                        model_paVtxBuffer_org_primary[indexVertices_per_Face[1]].nx += (Plane.a * rate);
                                        model_paVtxBuffer_org_primary[indexVertices_per_Face[1]].ny += (Plane.b * rate);
                                        model_paVtxBuffer_org_primary[indexVertices_per_Face[1]].nz += (Plane.c * rate);
                                        rate = (paRad[i*3+2] / paRadSum_Vtx[indexVertices_per_Face[2]]);
                                        model_paVtxBuffer_org_primary[indexVertices_per_Face[2]].nx += (Plane.a * rate);
                                        model_paVtxBuffer_org_primary[indexVertices_per_Face[2]].ny += (Plane.b * rate);
                                        model_paVtxBuffer_org_primary[indexVertices_per_Face[2]].nz += (Plane.c * rate);
                                    } else {
                                        rate = (paRad[i*3+0] / paRadSum_Vtx[indexVertices_per_Face[0]]);
                                        model_papaVtxBuffer_org_morph[pattern-1][indexVertices_per_Face[0]].nx += (Plane.a * rate);
                                        model_papaVtxBuffer_org_morph[pattern-1][indexVertices_per_Face[0]].ny += (Plane.b * rate);
                                        model_papaVtxBuffer_org_morph[pattern-1][indexVertices_per_Face[0]].nz += (Plane.c * rate);
                                        rate = (paRad[i*3+1] / paRadSum_Vtx[indexVertices_per_Face[1]]);
                                        model_papaVtxBuffer_org_morph[pattern-1][indexVertices_per_Face[1]].nx += (Plane.a * rate);
                                        model_papaVtxBuffer_org_morph[pattern-1][indexVertices_per_Face[1]].ny += (Plane.b * rate);
                                        model_papaVtxBuffer_org_morph[pattern-1][indexVertices_per_Face[1]].nz += (Plane.c * rate);
                                        rate = (paRad[i*3+2] / paRadSum_Vtx[indexVertices_per_Face[2]]);
                                        model_papaVtxBuffer_org_morph[pattern-1][indexVertices_per_Face[2]].nx += (Plane.a * rate);
                                        model_papaVtxBuffer_org_morph[pattern-1][indexVertices_per_Face[2]].ny += (Plane.b * rate);
                                        model_papaVtxBuffer_org_morph[pattern-1][indexVertices_per_Face[2]].nz += (Plane.c * rate);
                                    }
                                }
                            }
                            //Xt@CFrameTransformMatrix(0t[Aj[V)l
                            int n = 0;
                            int nVertices_begin = 0;
                            int nVertices_end = 0;
                            D3DXMATRIX FrameTransformMatrix;
                
                            for (std::list<Frm::Bone*>::iterator iteBone = model_papModel3D[pattern]->_toplevel_Skelettons.begin() ;
                                    iteBone != model_papModel3D[pattern]->_toplevel_Skelettons.end(); iteBone++) {
                                _TRACE_("(*iteBone)->_Name="<<((*iteBone)->_Name));
                
                                if ((*iteBone)) {
                                    Frm::Matrix* pMatPos = &((*iteBone)->_MatrixPos);
                                    if (pMatPos == 0 || pMatPos== NULL || pMatPos->isIdentity()) {
                                        //FrameTransformMatrix Ps
                                        _TRACE_("pattern=["<<pattern<<"] FrameTransformMatrix is Identity");
                                    } else {
                                        _TRACE_("pattern=["<<pattern<<"] Execute FrameTransform!");
                                        FrameTransformMatrix._11 = pMatPos->data[0];
                                        FrameTransformMatrix._12 = pMatPos->data[1];
                                        FrameTransformMatrix._13 = pMatPos->data[2];
                                        FrameTransformMatrix._14 = pMatPos->data[3];
                                        FrameTransformMatrix._21 = pMatPos->data[4];
                                        FrameTransformMatrix._22 = pMatPos->data[5];
                                        FrameTransformMatrix._23 = pMatPos->data[6];
                                        FrameTransformMatrix._24 = pMatPos->data[7];
                                        FrameTransformMatrix._31 = pMatPos->data[8];
                                        FrameTransformMatrix._32 = pMatPos->data[9];
                                        FrameTransformMatrix._33 = pMatPos->data[10];
                                        FrameTransformMatrix._34 = pMatPos->data[11];
                                        FrameTransformMatrix._41 = pMatPos->data[12];
                                        FrameTransformMatrix._42 = pMatPos->data[13];
                                        FrameTransformMatrix._43 = pMatPos->data[14];
                                        FrameTransformMatrix._44 = pMatPos->data[15];
                
                                        if (n == 0) {
                                            nVertices_begin = 0;
                                            nVertices_end = paNumVertices[n];
                                        } else {
                                            nVertices_begin += paNumVertices[n-1];
                                            nVertices_end += paNumVertices[n];
                                        }
                
                                        D3DXVECTOR3 vecVertex;
                                        D3DXVECTOR3 vecNormal;
                                        if (pattern == 0) {
                                            for (int i = nVertices_begin; i < nVertices_end; i++) {
                                                vecVertex.x = model_paVtxBuffer_org_primary[i].x;
                                                vecVertex.y = model_paVtxBuffer_org_primary[i].y;
                                                vecVertex.z = model_paVtxBuffer_org_primary[i].z;
                                                D3DXVec3TransformCoord(&vecVertex, &vecVertex, &FrameTransformMatrix);
                                                vecNormal.x = model_paVtxBuffer_org_primary[i].nx;
                                                vecNormal.y = model_paVtxBuffer_org_primary[i].ny;
                                                vecNormal.z = model_paVtxBuffer_org_primary[i].nz;
                                                D3DXVec3TransformNormal(&vecNormal, &vecNormal, &FrameTransformMatrix);
                
                                                model_paVtxBuffer_org_primary[i].x = vecVertex.x;
                                                model_paVtxBuffer_org_primary[i].y = vecVertex.y;
                                                model_paVtxBuffer_org_primary[i].z = vecVertex.z;
                                                model_paVtxBuffer_org_primary[i].nx = vecNormal.x;
                                                model_paVtxBuffer_org_primary[i].ny = vecNormal.y;
                                                model_paVtxBuffer_org_primary[i].nz = vecNormal.z;
                                            }
                                        } else {
                                            for (int i = nVertices_begin; i < nVertices_end; i++) {
                                                vecVertex.x = model_papaVtxBuffer_org_morph[pattern-1][i].x;
                                                vecVertex.y = model_papaVtxBuffer_org_morph[pattern-1][i].y;
                                                vecVertex.z = model_papaVtxBuffer_org_morph[pattern-1][i].z;
                                                D3DXVec3TransformCoord(&vecVertex, &vecVertex, &FrameTransformMatrix);
                                                vecNormal.x = model_papaVtxBuffer_org_morph[pattern-1][i].nx;
                                                vecNormal.y = model_papaVtxBuffer_org_morph[pattern-1][i].ny;
                                                vecNormal.z = model_papaVtxBuffer_org_morph[pattern-1][i].nz;
                                                D3DXVec3TransformNormal(&vecNormal, &vecNormal, &FrameTransformMatrix);
                
                                                model_papaVtxBuffer_org_morph[pattern-1][i].x = vecVertex.x;
                                                model_papaVtxBuffer_org_morph[pattern-1][i].y = vecVertex.y;
                                                model_papaVtxBuffer_org_morph[pattern-1][i].z = vecVertex.z;
                                                model_papaVtxBuffer_org_morph[pattern-1][i].nx = vecNormal.x;
                                                model_papaVtxBuffer_org_morph[pattern-1][i].ny = vecNormal.y;
                                                model_papaVtxBuffer_org_morph[pattern-1][i].nz = vecNormal.z;
                                            }
                                        }
                                    }
                                }
                                n++;
                            }
                            DELETE_IMPOSSIBLE_NULL(paNumVertices);
                
                            //@K
                            D3DXVECTOR3 vec;
                            for (int i = 0; i < nVertices; i++) {
                                if (pattern == 0) { //vC}bV
                                    vec.x = model_paVtxBuffer_org_primary[i].nx;
                                    vec.y = model_paVtxBuffer_org_primary[i].ny;
                                    vec.z = model_paVtxBuffer_org_primary[i].nz;
                                    if (vec.x == 0 && vec.y == 0 && vec.z == 0) {
                                        model_paVtxBuffer_org_primary[i].nx = 0;
                                        model_paVtxBuffer_org_primary[i].ny = 0;
                                        model_paVtxBuffer_org_primary[i].nz = 0;
                                    } else {
                                        D3DXVec3Normalize( &vec, &vec);
                                        model_paVtxBuffer_org_primary[i].nx = vec.x;
                                        model_paVtxBuffer_org_primary[i].ny = vec.y;
                                        model_paVtxBuffer_org_primary[i].nz = vec.z;
                                    }
                                } else {           //[t^[QbgbV
                                    vec.x = model_papaVtxBuffer_org_morph[pattern-1][i].nx;
                                    vec.y = model_papaVtxBuffer_org_morph[pattern-1][i].ny;
                                    vec.z = model_papaVtxBuffer_org_morph[pattern-1][i].nz;
                                    if (vec.x == 0 && vec.y == 0 && vec.z == 0) {
                                        model_papaVtxBuffer_org_morph[pattern-1][i].nx = 0;
                                        model_papaVtxBuffer_org_morph[pattern-1][i].ny = 0;
                                        model_papaVtxBuffer_org_morph[pattern-1][i].nz = 0;
                                    } else {
                                        D3DXVec3Normalize( &vec, &vec);
                                        model_papaVtxBuffer_org_morph[pattern-1][i].nx = vec.x;
                                        model_papaVtxBuffer_org_morph[pattern-1][i].ny = vec.y;
                                        model_papaVtxBuffer_org_morph[pattern-1][i].nz = vec.z;
                                    }
                                }
                            }
                            delete[] paRad;
                            delete[] paRadSum_Vtx;
                        } //for (int pattern = 0; pattern < 2; pattern++)
                
                
                        //CfbNXobt@
                        model_paIdxBuffer_org = NEW WORD[nFaces*3];
                        for (int i = 0; i < nFaces; i++) {
                            model_paIdxBuffer_org[i*3 + 0] = model_papMeshesFront[0]->_Faces[i].data[0];
                            model_paIdxBuffer_org[i*3 + 1] = model_papMeshesFront[0]->_Faces[i].data[1];
                            model_paIdxBuffer_org[i*3 + 2] = model_papMeshesFront[0]->_Faces[i].data[2];
                        }
                
                        //}eAXg
                //        UINT aMaterialsGrp = UINT[nFaces];
                //        for (int i = 0; i < nFaces; i++) {
                //            aMaterialsGrp[i] =  model_pMeshesFront->_FaceMaterials[i];
                //        }
                
                        //`iDrawIndexedPrimitivejp[^Xg
                        GgafDx9MeshModel::INDEXPARAM* paParam = NEW GgafDx9MeshModel::INDEXPARAM[nFaces];
                
                        int prev_materialno = -1;
                        int materialno = 0;
                        int paramno = 0;
                        int faceNoCnt_break = 0;
                        int prev_faceNoCnt_break = -1;
                        UINT max_num_vertices = 0;
                        UINT min_num_vertices = UINT_MAX;
                
                        int faceNoCnt;
                        for (faceNoCnt = 0; faceNoCnt < nFaces; faceNoCnt++) {
                            materialno = model_papMeshesFront[0]->_FaceMaterials[faceNoCnt];
                            if (prev_materialno != materialno) {
                                //TRACE3("BREAK! paramno="<<paramno);
                                prev_faceNoCnt_break = faceNoCnt_break;
                                faceNoCnt_break = faceNoCnt;
                
                                paParam[paramno].MaterialNo = materialno;
                                paParam[paramno].BaseVertexIndex = 0;
                                paParam[paramno].MinIndex = UINT_MAX; //uCNAl
                                paParam[paramno].NumVertices = UINT_MAX; //uCN
                                paParam[paramno].StartIndex = faceNoCnt*3;
                                paParam[paramno].PrimitiveCount = UINT_MAX; //uCN
                
                                if (faceNoCnt > 0) {
                                    paParam[paramno-1].MinIndex = min_num_vertices;
                                    paParam[paramno-1].NumVertices = (UINT)(max_num_vertices - min_num_vertices + 1);
                                    paParam[paramno-1].PrimitiveCount = (UINT)(faceNoCnt_break - prev_faceNoCnt_break);
                                    //Zbg
                                    max_num_vertices = 0;
                                    min_num_vertices = UINT_MAX;
                                }
                                paramno++;
                            }
                
                            if (max_num_vertices <  model_paIdxBuffer_org[faceNoCnt*3 + 0]) {
                                max_num_vertices = model_paIdxBuffer_org[faceNoCnt*3 + 0];
                            }
                            if (max_num_vertices <  model_paIdxBuffer_org[faceNoCnt*3 + 1]) {
                                max_num_vertices = model_paIdxBuffer_org[faceNoCnt*3 + 1];
                            }
                            if (max_num_vertices <  model_paIdxBuffer_org[faceNoCnt*3 + 2]) {
                                max_num_vertices = model_paIdxBuffer_org[faceNoCnt*3 + 2];
                            }
                            if (min_num_vertices >  model_paIdxBuffer_org[faceNoCnt*3 + 0]) {
                                min_num_vertices = model_paIdxBuffer_org[faceNoCnt*3 + 0];
                            }
                            if (min_num_vertices >  model_paIdxBuffer_org[faceNoCnt*3 + 1]) {
                                min_num_vertices = model_paIdxBuffer_org[faceNoCnt*3 + 1];
                            }
                            if (min_num_vertices >  model_paIdxBuffer_org[faceNoCnt*3 + 2]) {
                                min_num_vertices = model_paIdxBuffer_org[faceNoCnt*3 + 2];
                            }
                            prev_materialno = materialno;
                        }
                        if (nFaces > 0) {
                            paParam[paramno-1].MinIndex = min_num_vertices;
                            paParam[paramno-1].NumVertices = (UINT)(max_num_vertices - min_num_vertices + 1);
                            paParam[paramno-1].PrimitiveCount = (UINT)(faceNoCnt - faceNoCnt_break);
                        }
                
                        model_paIndexParam = NEW GgafDx9MorphMeshModel::INDEXPARAM[paramno];
                        for (int i = 0; i < paramno; i++) {
                            model_paIndexParam[i].MaterialNo = paParam[i].MaterialNo;
                            model_paIndexParam[i].BaseVertexIndex = paParam[i].BaseVertexIndex;
                            model_paIndexParam[i].MinIndex = paParam[i].MinIndex;
                            model_paIndexParam[i].NumVertices = paParam[i].NumVertices;
                            model_paIndexParam[i].StartIndex = paParam[i].StartIndex;
                            model_paIndexParam[i].PrimitiveCount = paParam[i].PrimitiveCount;
                        }
                        prm_pMorphMeshModel->_nMaterialListGrp = paramno;
                
                        delete[] paParam;
                    }
                
                    if (prm_pMorphMeshModel->_pIDirect3DVertexDeclaration9 == NULL) {
                
                        int elemnum = (4+(2*morph_target_num))+1; //D3DVERTEXELEMENT9 \zvf
                        D3DVERTEXELEMENT9* paDecl = NEW D3DVERTEXELEMENT9[elemnum];
                                                                         // 4 = vC}bV
                                                                         // (2*morph_target_num) = [t^[QbgbV
                                                                         // 1 = D3DDECL_END()
                        //vC}bV_tH[}bg
                        //FVFgACreateVertexDeclaration
                        //TODO:_tH[}bg\zAfB
                        //vC}_tH[}bg
                        //float x, y, z; // _W
                        paDecl[0].Stream = 0;
                        paDecl[0].Offset = 0;
                        paDecl[0].Type = D3DDECLTYPE_FLOAT3;
                        paDecl[0].Method = D3DDECLMETHOD_DEFAULT;
                        paDecl[0].Usage = D3DDECLUSAGE_POSITION;
                        paDecl[0].UsageIndex = 0;
                        //float nx, ny, nz; // @
                        paDecl[1].Stream = 0;
                        paDecl[1].Offset = sizeof(float)*3;
                        paDecl[1].Type = D3DDECLTYPE_FLOAT3;
                        paDecl[1].Method = D3DDECLMETHOD_DEFAULT;
                        paDecl[1].Usage = D3DDECLUSAGE_NORMAL;
                        paDecl[1].UsageIndex = 0;
                        //DWORD color; // _J[
                        paDecl[2].Stream = 0;
                        paDecl[2].Offset = sizeof(float)*6;
                        paDecl[2].Type = D3DDECLTYPE_D3DCOLOR;
                        paDecl[2].Method = D3DDECLMETHOD_DEFAULT;
                        paDecl[2].Usage = D3DDECLUSAGE_COLOR;
                        paDecl[2].UsageIndex = 0;
                        //float tu, tv; // eNX`W
                        paDecl[3].Stream = 0;
                        paDecl[3].Offset = sizeof(float)*6+sizeof(DWORD);
                        paDecl[3].Type = D3DDECLTYPE_FLOAT2;
                        paDecl[3].Method = D3DDECLMETHOD_DEFAULT;
                        paDecl[3].Usage = D3DDECLUSAGE_TEXCOORD;
                        paDecl[3].UsageIndex = 0;
                        //[t^[QbgbV_tH[}bg
                        for (int i = 4, s = 1; i < elemnum-1; i+=2, s++) {
                            //float x, y, z; // _W
                            paDecl[i].Stream = s;
                            paDecl[i].Offset = 0;
                            paDecl[i].Type = D3DDECLTYPE_FLOAT3;
                            paDecl[i].Method = D3DDECLMETHOD_DEFAULT;
                            paDecl[i].Usage = D3DDECLUSAGE_POSITION;
                            paDecl[i].UsageIndex = s;
                            //float nx, ny, nz; // @
                            paDecl[i+1].Stream = s;
                            paDecl[i+1].Offset = sizeof(float)*3;
                            paDecl[i+1].Type = D3DDECLTYPE_FLOAT3;
                            paDecl[i+1].Method = D3DDECLMETHOD_DEFAULT;
                            paDecl[i+1].Usage = D3DDECLUSAGE_NORMAL;
                            paDecl[i+1].UsageIndex = s;
                        }
                        //D3DDECL_END()
                        paDecl[elemnum-1].Stream = 0xFF;
                        paDecl[elemnum-1].Offset = 0;
                        paDecl[elemnum-1].Type = D3DDECLTYPE_UNUSED;
                        paDecl[elemnum-1].Method = 0;
                        paDecl[elemnum-1].Usage = 0;
                        paDecl[elemnum-1].UsageIndex = 0;
                
                        hr = GgafDx9God::_pID3DDevice9->CreateVertexDeclaration( paDecl, &(prm_pMorphMeshModel->_pIDirect3DVertexDeclaration9) );
                        checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreMorphMeshModel] GgafDx9God::_pID3DDevice9->CreateVertexDeclaration s model="<<(prm_pMorphMeshModel->_model_name));
                        //Xg[        hr = m_pDecl->GetDeclaration( m_pElement, &m_numElements);
                
                        DELETEARR_IMPOSSIBLE_NULL(paDecl);
                    }
                
                    //_obt@
                    if (prm_pMorphMeshModel->_pIDirect3DVertexBuffer9_primary == NULL) {
                        prm_pMorphMeshModel->_paIDirect3DVertexBuffer9_morph = NEW LPDIRECT3DVERTEXBUFFER9[morph_target_num];
                        for (int pattern = 0; pattern < morph_target_num+1; pattern++) {
                
                            if (pattern == 0) {
                                //vC}_obt@
                                hr = GgafDx9God::_pID3DDevice9->CreateVertexBuffer(
                                        prm_pMorphMeshModel->_size_vertices_primary,
                                        D3DUSAGE_WRITEONLY,
                                        0, //GgafDx9MorphMeshModel::FVF,
                                        D3DPOOL_DEFAULT, //D3DPOOL_DEFAULT
                                        &(prm_pMorphMeshModel->_pIDirect3DVertexBuffer9_primary),
                                        NULL);
                                checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreMorphMeshModel] _pID3DDevice9->CreateVertexBuffer sivC}j model="<<(prm_pMorphMeshModel->_model_name));
                                void *pVertexBuffer;
                                hr = prm_pMorphMeshModel->_pIDirect3DVertexBuffer9_primary->Lock(0, prm_pMorphMeshModel->_size_vertices_primary, (void**)&pVertexBuffer, 0);
                                checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreMorphMeshModel] _obt@bNsivC}j model="<<prm_pMorphMeshModel->_model_name);
                                memcpy(pVertexBuffer, model_paVtxBuffer_org_primary, prm_pMorphMeshModel->_size_vertices_primary); //pVertexBuffer  paVertex
                                prm_pMorphMeshModel->_pIDirect3DVertexBuffer9_primary->Unlock();
                            } else {
                                //[t^[Qbg_obt@
                                hr = GgafDx9God::_pID3DDevice9->CreateVertexBuffer(
                                        prm_pMorphMeshModel->_size_vertices_morph,
                                        D3DUSAGE_WRITEONLY,
                                        0, //GgafDx9MorphMeshModel::FVF,
                                        D3DPOOL_DEFAULT, //D3DPOOL_DEFAULT
                                        &(prm_pMorphMeshModel->_paIDirect3DVertexBuffer9_morph[pattern-1]),
                                        NULL);
                                checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreMorphMeshModel] _pID3DDevice9->CreateVertexBuffer si[t:"<<pattern-1<<"j model="<<(prm_pMorphMeshModel->_model_name));
                                void *pVertexBuffer;
                                hr = prm_pMorphMeshModel->_paIDirect3DVertexBuffer9_morph[pattern-1]->Lock(0, prm_pMorphMeshModel->_size_vertices_morph, (void**)&pVertexBuffer, 0);
                                checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreMorphMeshModel] _obt@bNsi[t:"<<pattern-1<<"j model="<<prm_pMorphMeshModel->_model_name);
                                memcpy(pVertexBuffer, model_papaVtxBuffer_org_morph[pattern-1], prm_pMorphMeshModel->_size_vertices_morph); //pVertexBuffer  paVertex
                                prm_pMorphMeshModel->_paIDirect3DVertexBuffer9_morph[pattern-1]->Unlock();
                            }
                        }
                    }
                
                
                    //CfbNXobt@f[^ivC}A[t^[Qbgj
                    if (prm_pMorphMeshModel->_pIDirect3DIndexBuffer9 == NULL) {
                        int nFaces = model_papMeshesFront[0]->_nFaces;
                
                        hr = GgafDx9God::_pID3DDevice9->CreateIndexBuffer(
                                               sizeof(WORD) * nFaces * 3,
                                                D3DUSAGE_WRITEONLY,
                                                D3DFMT_INDEX16,
                                                D3DPOOL_DEFAULT,
                                                &(prm_pMorphMeshModel->_pIDirect3DIndexBuffer9),
                                                NULL);
                        checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreMorphMeshModel] _pID3DDevice9->CreateIndexBuffer s model="<<(prm_pMorphMeshModel->_model_name));
                        void* pIndexBuffer;
                        prm_pMorphMeshModel->_pIDirect3DIndexBuffer9->Lock(0,0,(void**)&pIndexBuffer,0);
                        memcpy(pIndexBuffer , model_paIdxBuffer_org , sizeof(WORD) * nFaces * 3);
                        prm_pMorphMeshModel->_pIDirect3DIndexBuffer9->Unlock();
                    }
                
                    //}eA
                    //}eAvC}bV}eAA
                    //vC}yS[t^[Qbg}eAB
                    //model_papMeshesFront[0]gAcgB
                    //TODO:I[t^[Qbg}eA\BB
                    int model_nMaterials = 0;
                    for (list<Frm::Material*>::iterator material =  model_papMeshesFront[0]->_Materials.begin();
                            material !=  model_papMeshesFront[0]->_Materials.end(); material++) {
                        model_nMaterials++;
                    }
                
                    model_paD3DMaterial9 = NEW D3DMATERIAL9[model_nMaterials];
                    model_papTextureCon = NEW GgafDx9TextureConnection*[model_nMaterials];
                
                    char* texture_filename;
                    int n = 0;
                    for (list<Frm::Material*>::iterator material = model_papMeshesFront[0]->_Materials.begin(); material != model_papMeshesFront[0]->_Materials.end(); material++) {
                        model_paD3DMaterial9[n].Diffuse.r = (*material)->_FaceColor.data[0];
                        model_paD3DMaterial9[n].Diffuse.g = (*material)->_FaceColor.data[1];
                        model_paD3DMaterial9[n].Diffuse.b = (*material)->_FaceColor.data[2];
                        model_paD3DMaterial9[n].Diffuse.a = (*material)->_FaceColor.data[3];
                
                        model_paD3DMaterial9[n].Ambient.r = (*material)->_FaceColor.data[0];
                        model_paD3DMaterial9[n].Ambient.g = (*material)->_FaceColor.data[1];
                        model_paD3DMaterial9[n].Ambient.b = (*material)->_FaceColor.data[2];
                        model_paD3DMaterial9[n].Ambient.a = (*material)->_FaceColor.data[3];
                
                        model_paD3DMaterial9[n].Specular.r = (*material)->_SpecularColor.data[0];
                        model_paD3DMaterial9[n].Specular.g = (*material)->_SpecularColor.data[1];
                        model_paD3DMaterial9[n].Specular.b = (*material)->_SpecularColor.data[2];
                        model_paD3DMaterial9[n].Specular.a = 1.000000f;
                        model_paD3DMaterial9[n].Power =  (*material)->_power;
                
                        model_paD3DMaterial9[n].Emissive.r = (*material)->_EmissiveColor.data[0];
                        model_paD3DMaterial9[n].Emissive.g = (*material)->_EmissiveColor.data[1];
                        model_paD3DMaterial9[n].Emissive.b = (*material)->_EmissiveColor.data[2];
                        model_paD3DMaterial9[n].Emissive.a = 1.000000f;
                
                        texture_filename = (char*)((*material)->_TextureName.c_str());
                        if (texture_filename != NULL && lstrlen(texture_filename) > 0 ) {
                            model_papTextureCon[n] = (GgafDx9TextureConnection*)_pTextureManager->getConnection(texture_filename);
                        } else {
                            //eNX`^eNX`u
                            model_papTextureCon[n] = (GgafDx9TextureConnection*)_pTextureManager->getConnection("white.png");
                        }
                        n++;
                    }
                
                    if (model_nMaterials != n) {
                        TRACE3("GgafDx9ModelManager::restoreMorphMeshModel(" << prm_pMorphMeshModel->_model_name << ") }eABmodel_nMaterials="<<model_nMaterials<<"/n="<<n);
                    }
                
                    DELETEARR_IMPOSSIBLE_NULL(paIOX);
                    DELETEARR_IMPOSSIBLE_NULL(paXfileName);
                
                    //f
                    prm_pMorphMeshModel->_papModel3D = model_papModel3D;
                    prm_pMorphMeshModel->_papMeshesFront = model_papMeshesFront;
                    prm_pMorphMeshModel->_paIdxBuffer_org = model_paIdxBuffer_org;
                    prm_pMorphMeshModel->_paVtxBuffer_org_primary = model_paVtxBuffer_org_primary;
                    prm_pMorphMeshModel->_papaVtxBuffer_org_morph = model_papaVtxBuffer_org_morph;
                    prm_pMorphMeshModel->_paIndexParam = model_paIndexParam;
                    prm_pMorphMeshModel->_paD3DMaterial9_default = model_paD3DMaterial9;
                    prm_pMorphMeshModel->_papTextureCon = model_papTextureCon;
                    prm_pMorphMeshModel->_dwNumMaterials = model_nMaterials;
                }
                
                void GgafDx9ModelManager::restoreD3DXMeshModel(GgafDx9D3DXMeshModel* prm_pD3DXMeshModel) {
                    TRACE3("GgafDx9ModelManager::restoreD3DXMeshModel(" << prm_pD3DXMeshModel->_model_name << ")");
                    //yrestoreD3DXMeshModel\zijTvz
                    //1)D3DXLoadMeshFromXgpXt@C
                    //2)GgafDx9D3DXMeshModeloZbg
                    //TODO:GgafDx9D3DXMeshModelKvB
                
                    //Xt@C[hKveGgafDx9D3DXMeshModeloCX^X
                    LPD3DXMESH pID3DXMesh; //bV(ID3DXMeshC^[tFCX|C^j
                    D3DMATERIAL9* model_paD3DMaterial9; //}eA(D3DXMATERIAL\zvfw|C^j
                    GgafDx9TextureConnection** model_papTextureCon; //eNX`z(IDirect3DTexture9C^[tFCX|C^IuWFNgj
                    DWORD dwNumMaterials;
                    string xfile_name = GGAFDX9_PROPERTY(DIR_MESH_MODEL) + string(prm_pD3DXMeshModel->_model_name) + ".x"; //f{".x"Xt@C
                
                    LPD3DXBUFFER pID3DXBuffer; //pobt@i}eApj
                    HRESULT hr;
                    //Xt@Ct@C[h
                    hr = D3DXLoadMeshFromX(
                           xfile_name.c_str(),         //[in]  LPCTSTR pFilename
                           prm_pD3DXMeshModel->_dwOptions, //[in]  DWORD Options  D3DXMESH_SYSTEMMEM D3DXMESH_VB_DYNAMIC
                           GgafDx9God::_pID3DDevice9,  //[in]  LPDIRECT3DDEVICE9 pDevice
                           NULL,                       //[out] LPD3DXBUFFER* ppAdjacency
                           &pID3DXBuffer,              //[out] LPD3DXBUFFER* ppMaterials
                           NULL,                       //[out] LPD3DXBUFFER* ppEffectInstances
                           &dwNumMaterials,            //[out] DWORD* pNumMaterials
                           &pID3DXMesh                 //[out] LPD3DXMESH* pMesh
                         );
                    checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreD3DXMeshModel] D3DXLoadMeshFromX[hsB="<<xfile_name);
                
                    //K
                    DWORD *pAdjacency = NEW DWORD [ pID3DXMesh->GetNumFaces() * 3 ];
                    hr = pID3DXMesh->GenerateAdjacency( 1e-6f, pAdjacency );
                    checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreD3DXMeshModel] GenerateAdjacencyB="<<xfile_name);
                    hr = pID3DXMesh->OptimizeInplace( D3DXMESHOPT_ATTRSORT, pAdjacency, NULL, NULL, NULL );
                    checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreD3DXMeshModel] D3DXMESHOPT_ATTRSORTB="<<xfile_name);
                    hr = pID3DXMesh->OptimizeInplace( D3DXMESHOPT_VERTEXCACHE, pAdjacency, NULL, NULL, NULL );
                    checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreD3DXMeshModel] D3DXMESHOPT_VERTEXCACHEB="<<xfile_name);
                    DELETEARR_IMPOSSIBLE_NULL(pAdjacency);
                
                    //}eAo
                    D3DXMATERIAL* paD3DMaterial9_tmp = (D3DXMATERIAL*)(pID3DXBuffer->GetBufferPointer());
                    //2008/02/02 ]
                    // 
                    // GetBufferPointer() D3DXMATERIAL\zoMatD3D (D3DMATERIAL9\) ~B
                    //\Rs[`A`B
                    model_paD3DMaterial9 = NEW D3DMATERIAL9[dwNumMaterials];
                    for( DWORD i = 0; i < dwNumMaterials; i++){
                        model_paD3DMaterial9[i] = paD3DMaterial9_tmp[i].MatD3D;
                    }
                
                    //}eADiffuseAmbientRs[
                    //RFAmbientCggpBRAmbientl}eA
                    //GNX|[gxt@C}eAAmbientlic[HjB
                    //Diffuse=AmbientnYlB
                    //ftHgADiffuselAmbientlAB
                    //2009/3/13
                    //pCvCgB}eADiffuseVF[_[p[^pB
                    //TODO:}eAAmbientQBH
                    for( DWORD i = 0; i < dwNumMaterials; i++) {
                        model_paD3DMaterial9[i].Ambient = model_paD3DMaterial9[i].Diffuse;
                    }
                
                    //eNX`o
                    model_papTextureCon = NEW GgafDx9TextureConnection*[dwNumMaterials];
                    char* texture_filename;
                    for( DWORD i = 0; i < dwNumMaterials; i++) {
                        texture_filename = paD3DMaterial9_tmp[i].pTextureFilename;
                        if (texture_filename != NULL && lstrlen(texture_filename) > 0 ) {
                            model_papTextureCon[i] = (GgafDx9TextureConnection*)_pTextureManager->getConnection(texture_filename);
                        } else {
                            //eNX`
                            model_papTextureCon[i] = (GgafDx9TextureConnection*)_pTextureManager->getConnection("white.png");
                        }
                    }
                    RELEASE_IMPOSSIBLE_NULL(pID3DXBuffer);//eNX`t@Cobt@
                
                    //Xt@C@AFVF@A@vZB
                    if(pID3DXMesh->GetFVF() != (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)) {
                        LPD3DXMESH pID3DXMesh_tmp = NULL;
                        hr = pID3DXMesh->CloneMeshFVF(
                                           pID3DXMesh->GetOptions(),             // [in]  DWORD Options,
                                           D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1, // [in]  DWORD FVF,
                                           GgafDx9God::_pID3DDevice9,            // [in]  LPDIRECT3DDEVICE9 pDevice,
                                           &pID3DXMesh_tmp                       // [out] LPD3DXMESH *ppCloneMesh
                                         );
                        checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreD3DXMeshModel]  pID3DXMesh->CloneMeshFVF()sB="<<xfile_name);
                        D3DXComputeNormals(pID3DXMesh_tmp, NULL); //@vZiFace\@AEEEj
                        RELEASE_IMPOSSIBLE_NULL(pID3DXMesh);
                        pID3DXMesh = pID3DXMesh_tmp;
                    }
                
                    //bVA}eAAeNX`QA}eAfIuWFNg
                    prm_pD3DXMeshModel->_pID3DXMesh = pID3DXMesh;
                    prm_pD3DXMeshModel->_paD3DMaterial9_default = model_paD3DMaterial9;
                    prm_pD3DXMeshModel->_papTextureCon = model_papTextureCon;
                    prm_pD3DXMeshModel->_dwNumMaterials = dwNumMaterials;
                    prm_pD3DXMeshModel->_fBoundingSphereRadius = 10.0f; //TODO:Ea100px
                
                }
                
                void GgafDx9ModelManager::restoreD3DXAniMeshModel(GgafDx9D3DXAniMeshModel* prm_pD3DXAniMeshModel) {
                    TRACE3("GgafDx9ModelManager::restoreD3DXAniMeshModel(" << prm_pD3DXAniMeshModel->_model_name << ")");
                    //TODO:IIIIIIII
                
                
                
                
                    //yrestoreD3DXAniMeshModel\zijTvz
                    //1)D3DXLoadMeshFromXgpXt@C
                    //2)GgafDx9D3DXAniMeshModeloZbg
                    //TODO:GgafDx9D3DXAniMeshModelKvB
                    //Xt@C[hKveGgafDx9D3DXAniMeshModeloCX^X
                    LPD3DXMESH pID3DXAniMesh; //bV(ID3DXAniMeshC^[tFCX|C^j
                    D3DMATERIAL9* model_paD3DMaterial9 = NULL; //}eA(D3DXMATERIAL\zvfw|C^j
                    GgafDx9TextureConnection** model_papTextureCon = NULL; //eNX`z(IDirect3DTexture9C^[tFCX|C^IuWFNgj
                    DWORD dwNumMaterials;
                    string xfile_name = GGAFDX9_PROPERTY(DIR_MESH_MODEL) + string(prm_pD3DXAniMeshModel->_model_name) + ".x"; //f{".x"Xt@C
                
                
                    //AnimTicksPerSecondlo
                    ifstream ifs(xfile_name.c_str());
                    if (ifs.fail()) {
                        throwGgafCriticalException(" GgafDx9ModelManager::restoreD3DXAniMeshModel ["<<xfile_name<<"] J");
                    }
                    string buf;
                    bool isdone = false;
                    int anim_ticks_per_second = 4800;
                    string data;
                    while(isdone == false && !ifs.eof()) {
                        ifs >> data;
                        if (data == "AnimTicksPerSecond" || data == "AnimTicksPerSecond{") {
                            while(isdone == false) {
                                ifs >> data;
                                if (data == "{") {
                                    continue;
                                } else if (data == "}") {
                                    isdone = true;
                                    break;
                                } else {
                                    anim_ticks_per_second = atoi(data.c_str()); //"60;"  60
                                    isdone = true;
                                    break;
                                }
                            }
                        }
                    }
                    ifs.close();
                
                    LPD3DXBUFFER pID3DXBuffer; //pobt@i}eApj
                    HRESULT hr;
                    //Xt@Ct@C[h
                    GgafDx9AllocHierarchyWorldFrame* pAH = NEW GgafDx9AllocHierarchyWorldFrame(); // CAllocHierarchyBasehNX
                    D3DXFRAME_WORLD* pFR; // [hstt[\
                    ID3DXAnimationController* pAC; // Aj[VRg[
                    hr = D3DXLoadMeshHierarchyFromX(
                            xfile_name.c_str(),
                            D3DXMESH_MANAGED,
                            GgafDx9God::_pID3DDevice9,
                            pAH,
                            NULL,
                            (D3DXFRAME**)(&pFR),
                            &pAC
                         );
                    checkDxException(hr, D3D_OK, "GgafDx9ModelManager::restoreD3DXAniMeshModel "<<xfile_name<<" sB="<<xfile_name);
                    if (pFR == NULL) {
                        throwGgafCriticalException("GgafDx9ModelManager::restoreD3DXAniMeshModel "<<xfile_name<<" t[I");
                    }
                    //}eAz
                    list<D3DXFRAME_WORLD*> listFrame;
                    getDrawFrameList(&listFrame, pFR); //}eAmAt[AXg
                    list<D3DXFRAME_WORLD*>::iterator it = listFrame.begin();
                    int model_nMaterials = 0;
                    //t[XgA}eA
                    for (int i = 0; it != listFrame.end(); i++, it++) {
                        if ((*it)->pMeshContainer == NULL) {
                            continue;
                        } else {
                            model_nMaterials += (int)((*it)->pMeshContainer->NumMaterials);
                        }
                    }
                    //z
                    model_paD3DMaterial9 = NEW D3DMATERIAL9[model_nMaterials];
                    model_papTextureCon  = NEW GgafDx9TextureConnection*[model_nMaterials];
                    //fp}eAAeNX`Ax
                    it = listFrame.begin();
                    int n = 0;
                    char* texture_filename;
                    for (int i = 0; it != listFrame.end(); i++, it++) {
                        if ((*it)->pMeshContainer == NULL) {
                            continue;
                        } else {
                            for (int j = 0; j < (int)((*it)->pMeshContainer->NumMaterials); j++) {
                //                (*it)->pMeshContainer->pMaterials[j].MatD3D.Diffuse
                                model_paD3DMaterial9[n] = (*it)->pMeshContainer->pMaterials[j].MatD3D; //}eARs[
                
                                texture_filename = (*it)->pMeshContainer->pMaterials[j].pTextureFilename;
                                if (texture_filename != NULL && lstrlen(texture_filename) > 0 ) {
                                    model_papTextureCon[n] = (GgafDx9TextureConnection*)_pTextureManager->getConnection(texture_filename);
                                } else {
                                    //eNX`^eNX`u
                                    model_papTextureCon[n] = (GgafDx9TextureConnection*)_pTextureManager->getConnection("white.png");
                                }
                                n ++;
                            }
                        }
                    }
                    //E
                    D3DXVECTOR3 vecCenter;
                    FLOAT model_fBoundingSphereRadius;
                    D3DXFrameCalculateBoundingSphere(pFR, &vecCenter, &model_fBoundingSphereRadius);
                    //bVA}eAAeNX`QA}eAfIuWFNg
                
                
                
                
                
                
                
                    prm_pD3DXAniMeshModel->_pAH = pAH;
                    prm_pD3DXAniMeshModel->_pFR = pFR;
                    prm_pD3DXAniMeshModel->_pAcBase = pAC;
                    prm_pD3DXAniMeshModel->_fBoundingSphereRadius = model_fBoundingSphereRadius;
                    _TRACE_("Ea="<<model_fBoundingSphereRadius);
                //    prm_pD3DXAniMeshModel->_advance_time_per_frame0 =  advanceTimePerFrame0; //gbN0P[v
                //    _TRACE_("Aj[VZbg0_advance_time_per_frame");
                
                //    prm_pD3DXAniMeshModel->_pID3DXAniMesh = pID3DXAniMesh;
                    prm_pD3DXAniMeshModel->_paD3DMaterial9_default = model_paD3DMaterial9;
                    prm_pD3DXAniMeshModel->_papTextureCon = model_papTextureCon;
                    prm_pD3DXAniMeshModel->_dwNumMaterials = model_nMaterials;
                    prm_pD3DXAniMeshModel->_anim_ticks_per_second = anim_ticks_per_second;
                }
                
                void GgafDx9ModelManager::getDrawFrameList(list<D3DXFRAME_WORLD*>* pList, D3DXFRAME_WORLD* pFrame) {
                    if (pFrame->pMeshContainer) {
                        //bVReiL
                        pList->push_back(pFrame); //Xg
                    }
                    if (pFrame->pFrameFirstChild) {
                        // qt[L
                        getDrawFrameList(pList, (D3DXFRAME_WORLD*)pFrame->pFrameFirstChild);
                    }
                    if (pFrame->pFrameSibling) {
                        //Zt[L
                        getDrawFrameList(pList, (D3DXFRAME_WORLD*)pFrame->pFrameSibling);
                    }
                }
                
                void GgafDx9ModelManager::restoreSpriteModel(GgafDx9SpriteModel* prm_pSpriteModel) {
                    TRACE3("GgafDx9ModelManager::restoreSpriteModel(" << prm_pSpriteModel->_model_name << ")");
                
                    prm_pSpriteModel->_papTextureCon = NULL;
                    prm_pSpriteModel->_paRectUV = NULL;
                
                
                    HRESULT hr;
                    string xfile_name = GGAFDX9_PROPERTY(DIR_SPRITE_MODEL) + string(prm_pSpriteModel->_model_name) + ".sprx";
                
                    //XvCgev[go^(s)
                    IDirectXFileEnumObject* pIDirectXFileEnumObject;
                    IDirectXFileData* pIDirectXFileData;
                    hr = _pIDirectXFile_sprx->CreateEnumObject((void*)xfile_name.c_str(), DXFILELOAD_FROMFILE, &pIDirectXFileEnumObject);
                    checkDxException(hr, DXFILE_OK, "[GgafDx9ModelManager::restoreSpriteModel] "<<xfile_name<<"CreateEnumObjectsB");
                
                    //TODO:GUIDBSB
                    //const GUID PersonID_GUID ={ 0xB2B63407,0x6AA9,0x4618, 0x95, 0x63, 0x63, 0x1E, 0xDC, 0x20, 0x4C, 0xDE};
                
                    char** ppaChar_TextureFile;
                    float* pFloat_Size_SpriteModelWidth;
                    float* pFloat_Size_SpriteModelHeight;
                    int* pInt_RowNum_TextureSplit;
                    int* pInt_ColNum_TextureSplit;
                
                    // 1Zbg
                    hr = pIDirectXFileEnumObject->GetNextDataObject(&pIDirectXFileData);
                    if(hr != DXFILE_OK) {
                        throwGgafCriticalException("[GgafDx9ModelManager::restoreSpriteModel] "<<xfile_name<<" sB");
                    }
                    const GUID *pGuid;
                    pIDirectXFileData->GetType( &pGuid );
                    //if( *pGuid == PersonID_GUID ) {
                    if(true) {
                        DWORD Size;
                        // PersonIDev[gf[^
                        pIDirectXFileData->GetData("TextureFile"     , &Size, (void**)&ppaChar_TextureFile);
                        pIDirectXFileData->GetData("Width"           , &Size, (void**)&pFloat_Size_SpriteModelWidth);
                        pIDirectXFileData->GetData("Height"          , &Size, (void**)&pFloat_Size_SpriteModelHeight);
                        pIDirectXFileData->GetData("TextureSplitRows", &Size, (void**)&pInt_RowNum_TextureSplit);
                        pIDirectXFileData->GetData("TextureSplitCols", &Size, (void**)&pInt_ColNum_TextureSplit);
                        prm_pSpriteModel->_fSize_SpriteModelWidthPx = *pFloat_Size_SpriteModelWidth;
                        prm_pSpriteModel->_fSize_SpriteModelHeightPx = *pFloat_Size_SpriteModelHeight;
                        prm_pSpriteModel->_row_texture_split = *pInt_RowNum_TextureSplit;
                        prm_pSpriteModel->_col_texture_split = *pInt_ColNum_TextureSplit;
                    } else {
                        throwGgafCriticalException("[GgafDx9ModelManager::restoreSpriteModel] "<<xfile_name<<" GUIDvB");
                    }
                    RELEASE_IMPOSSIBLE_NULL(pIDirectXFileData);
                    //eNX`f
                    //string texture_filename = GGAFDX9_PROPERTY(DIR_TEXTURE_MODEL) + string(*ppaChar_TextureFile);
                    GgafDx9TextureConnection* model_pTextureCon = (GgafDx9TextureConnection*)_pTextureManager->getConnection(*ppaChar_TextureFile);
                    //eNX`QB
                    prm_pSpriteModel->_papTextureCon = NEW GgafDx9TextureConnection*[1];
                    prm_pSpriteModel->_papTextureCon[0] = model_pTextureCon;
                
                    GgafDx9SpriteModel::VERTEX* paVertex = NEW GgafDx9SpriteModel::VERTEX[4];
                    prm_pSpriteModel->_size_vertices = sizeof(GgafDx9SpriteModel::VERTEX)*4;
                    prm_pSpriteModel->_size_vertex_unit = sizeof(GgafDx9SpriteModel::VERTEX);
                
                    //_zf
                    //UVPiAjp^[OjftHgB
                    //VF[_[`Ajp^[UVWdlB
                    //x,y  2 AfS[JW_S
                
                    //
                    paVertex[0].x = *pFloat_Size_SpriteModelWidth / -2 / PX_UNIT;
                    paVertex[0].y = *pFloat_Size_SpriteModelHeight / 2 / PX_UNIT;
                    paVertex[0].z = 0.0f;
                    paVertex[0].nx = 0.0f;
                    paVertex[0].ny = 0.0f;
                    paVertex[0].nz = -1.0f;
                    paVertex[0].color = D3DCOLOR_ARGB(255,255,255,255);
                    paVertex[0].tu = 0.0f;
                    paVertex[0].tv = 0.0f;
                    //E
                    paVertex[1].x = *pFloat_Size_SpriteModelWidth / 2 / PX_UNIT;
                    paVertex[1].y = *pFloat_Size_SpriteModelHeight / 2 / PX_UNIT;
                    paVertex[1].z = 0.0f;
                    paVertex[1].nx = 0.0f;
                    paVertex[1].ny = 0.0f;
                    paVertex[1].nz = -1.0f;
                    paVertex[1].color = D3DCOLOR_ARGB(255,255,255,255);
                    paVertex[1].tu = 1.0f/(float)(*pInt_ColNum_TextureSplit);// - (pxU/2);
                    paVertex[1].tv = 0.0f;
                    //
                    paVertex[2].x = *pFloat_Size_SpriteModelWidth / -2 / PX_UNIT;
                    paVertex[2].y = *pFloat_Size_SpriteModelHeight / -2 / PX_UNIT;
                    paVertex[2].z = 0.0f;
                    paVertex[2].nx = 0.0f;
                    paVertex[2].ny = 0.0f;
                    paVertex[2].nz = -1.0f;
                    paVertex[2].color = D3DCOLOR_ARGB(255,255,255,255);
                    paVertex[2].tu = 0.0f;
                    paVertex[2].tv = 1.0f/(float)(*pInt_RowNum_TextureSplit);// - (pxV/2);
                    //E
                    paVertex[3].x = *pFloat_Size_SpriteModelWidth / 2 / PX_UNIT;
                    paVertex[3].y = *pFloat_Size_SpriteModelHeight / -2 / PX_UNIT;
                    paVertex[3].z = 0.0f;
                    paVertex[3].nx = 0.0f;
                    paVertex[3].ny = 0.0f;
                    paVertex[3].nz = -1.0f;
                    paVertex[3].color = D3DCOLOR_ARGB(255,255,255,255);
                    paVertex[3].tu = 1.0f/(float)(*pInt_ColNum_TextureSplit);// - (pxU/2);
                    paVertex[3].tv = 1.0f/(float)(*pInt_RowNum_TextureSplit);// - (pxV/2);
                
                
                    //
                    FLOAT model_fBoundingSphereRadius = (FLOAT)(GgafDx9Util::sqrt_fast(paVertex[0].x * paVertex[0].x +
                                                               paVertex[0].y * paVertex[0].y +
                                                               paVertex[0].z * paVertex[0].z));
                    prm_pSpriteModel->_fBoundingSphereRadius = model_fBoundingSphereRadius;
                
                
                    //obt@
                    if (prm_pSpriteModel->_pIDirect3DVertexBuffer9 == NULL) {
                
                        hr = GgafDx9God::_pID3DDevice9->CreateVertexBuffer(
                                prm_pSpriteModel->_size_vertices,
                                D3DUSAGE_WRITEONLY,
                                GgafDx9SpriteModel::FVF,
                                D3DPOOL_DEFAULT, //D3DPOOL_DEFAULT
                                &(prm_pSpriteModel->_pIDirect3DVertexBuffer9),
                                NULL);
                        checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreSpriteModel] _pID3DDevice9->CreateVertexBuffer s model="<<(prm_pSpriteModel->_model_name));
                    }
                    //_obt@
                    //_rfIJ[h_obt@[h
                    void *pVertexBuffer;
                    hr = prm_pSpriteModel->_pIDirect3DVertexBuffer9->Lock(0, prm_pSpriteModel->_size_vertices, (void**)&pVertexBuffer, 0);
                    checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreSpriteModel] _obt@bNs model="<<prm_pSpriteModel->_model_name);
                
                    memcpy(pVertexBuffer, paVertex, prm_pSpriteModel->_size_vertices); //pVertexBuffer  paVertex
                    prm_pSpriteModel->_pIDirect3DVertexBuffer9->Unlock();
                
                    //Sp^[UVzf
                    //2009/3/13
                    //VF[_[UVA`UV(model_paRectUV[n]._aUV[0])OgpB
                    //TODO:B
                
                    int pattnum = (*pInt_ColNum_TextureSplit) * (*pInt_RowNum_TextureSplit);
                    GgafDx9RectUV* model_paRectUV = NEW GgafDx9RectUV[pattnum];
                    for (int row = 0; row < *pInt_RowNum_TextureSplit; row++) {
                        for (int col = 0; col < *pInt_ColNum_TextureSplit; col++) {
                            int pattno_uvflip = row*(*pInt_ColNum_TextureSplit)+col;
                            model_paRectUV[pattno_uvflip]._aUV[0].tu = (float)(1.0f/(*pInt_ColNum_TextureSplit)*col);
                            model_paRectUV[pattno_uvflip]._aUV[0].tv = (float)(1.0f/(*pInt_RowNum_TextureSplit)*row);
                
                            model_paRectUV[pattno_uvflip]._aUV[1].tu = (float)((1.0f/(*pInt_ColNum_TextureSplit)*(col+1)));
                            model_paRectUV[pattno_uvflip]._aUV[1].tv = (float)(1.0f/(*pInt_RowNum_TextureSplit)*row);
                
                            model_paRectUV[pattno_uvflip]._aUV[2].tu = (float)(1.0f/(*pInt_ColNum_TextureSplit)*col);
                            model_paRectUV[pattno_uvflip]._aUV[2].tv = (float)((1.0f/(*pInt_RowNum_TextureSplit)*(row+1)));
                
                            model_paRectUV[pattno_uvflip]._aUV[3].tu = (float)((1.0f/(*pInt_ColNum_TextureSplit)*(col+1)));
                            model_paRectUV[pattno_uvflip]._aUV[3].tv = (float)((1.0f/(*pInt_RowNum_TextureSplit)*(row+1)));
                        }
                    }
                    prm_pSpriteModel->_paRectUV = model_paRectUV;
                    prm_pSpriteModel->_pattno_uvflip_Max=pattnum-1;
                    prm_pSpriteModel->_dwNumMaterials = 1;
                    D3DMATERIAL9* model_paD3DMaterial9;
                    model_paD3DMaterial9 = NEW D3DMATERIAL9[prm_pSpriteModel->_dwNumMaterials];
                    for( DWORD i = 0; i < prm_pSpriteModel->_dwNumMaterials; i++){
                        //model_paD3DMaterial9[i] = paD3DMaterial9_tmp[i].MatD3D;
                        model_paD3DMaterial9[i].Diffuse.r = 1.0f;
                        model_paD3DMaterial9[i].Diffuse.g = 1.0f;
                        model_paD3DMaterial9[i].Diffuse.b = 1.0f;
                        model_paD3DMaterial9[i].Diffuse.a = 1.0f;
                        model_paD3DMaterial9[i].Ambient.r = 1.0f;
                        model_paD3DMaterial9[i].Ambient.g = 1.0f;
                        model_paD3DMaterial9[i].Ambient.b = 1.0f;
                        model_paD3DMaterial9[i].Ambient.a = 1.0f;
                    }
                    prm_pSpriteModel->_paD3DMaterial9_default = model_paD3DMaterial9;
                    //n
                    DELETEARR_IMPOSSIBLE_NULL(paVertex);
                    RELEASE_SAFETY(pIDirectXFileData);
                    RELEASE_IMPOSSIBLE_NULL(pIDirectXFileEnumObject);
                }
                
                void GgafDx9ModelManager::restoreSpriteSetModel(GgafDx9SpriteSetModel* prm_pSpriteSetModel) {
                    TRACE3("GgafDx9ModelManager::restoreSpriteSetModel(" << prm_pSpriteSetModel->_model_name << ")");
                
                    if (4*prm_pSpriteSetModel->_set_num > 65535) {
                        throwGgafCriticalException("X[GgafDx9ModelManager::restoreSpriteSetModel] _ 65535B\nModelF"<<prm_pSpriteSetModel->getName()<<"  nVertices:4  Zbg:"<<(prm_pSpriteSetModel->_set_num));
                    }
                
                    if ( 2 * 3 * prm_pSpriteSetModel->_set_num > 65535) {
                        throwGgafCriticalException("[GgafDx9ModelManager::restoreSpriteSetModel] _CfbNX 65535B\nModelF"<<prm_pSpriteSetModel->getName()<<"  nFaces:2(*3)  Zbg:"<<(prm_pSpriteSetModel->_set_num));
                    }
                
                    prm_pSpriteSetModel->_papTextureCon = NULL;
                    prm_pSpriteSetModel->_paRectUV = NULL;
                
                
                    HRESULT hr;
                    //XvCgev[go^(s)
                    IDirectXFileEnumObject* pIDirectXFileEnumObject;
                    IDirectXFileData* pIDirectXFileData;
                    string xfile_name; //XvCg`t@CiXt@C`j
                    //"12/Bomb" or "8/Bomb" or "Bomb"  "Bomb" tpX
                    if (*(prm_pSpriteSetModel->_model_name + 1) == '/') {
                        xfile_name = GGAFDX9_PROPERTY(DIR_SPRITE_MODEL) + string(prm_pSpriteSetModel->_model_name + 2) + ".sprx";
                    } else if (*(prm_pSpriteSetModel->_model_name + 2) == '/') {
                        xfile_name = GGAFDX9_PROPERTY(DIR_SPRITE_MODEL) + string(prm_pSpriteSetModel->_model_name + 3) + ".sprx";
                    } else {
                        xfile_name = GGAFDX9_PROPERTY(DIR_SPRITE_MODEL) + string(prm_pSpriteSetModel->_model_name) + ".sprx";
                    }
                    hr = _pIDirectXFile_sprx->CreateEnumObject((void*)xfile_name.c_str(), DXFILELOAD_FROMFILE, &pIDirectXFileEnumObject);
                    checkDxException(hr, DXFILE_OK, "[GgafDx9ModelManager::restoreSpriteSetModel] "<<xfile_name<<"CreateEnumObjectsB");
                
                    //TODO:GUIDBSB
                    //const GUID PersonID_GUID ={ 0xB2B63407,0x6AA9,0x4618, 0x95, 0x63, 0x63, 0x1E, 0xDC, 0x20, 0x4C, 0xDE};
                
                    char** ppaChar_TextureFile;
                    float* pFloat_Size_SpriteSetModelWidth;
                    float* pFloat_Size_SpriteSetModelHeight;
                    int* pInt_RowNum_TextureSplit;
                    int* pInt_ColNum_TextureSplit;
                
                    // 1Zbg
                    hr = pIDirectXFileEnumObject->GetNextDataObject(&pIDirectXFileData);
                    if(hr != DXFILE_OK) {
                        throwGgafCriticalException("[GgafDx9ModelManager::restoreSpriteSetModel] "<<xfile_name<<" sB");
                    }
                    const GUID *pGuid;
                    pIDirectXFileData->GetType( &pGuid );
                    //if( *pGuid == PersonID_GUID ) {
                    if(true) {
                        DWORD Size;
                        // PersonIDev[gf[^
                        pIDirectXFileData->GetData("TextureFile"     , &Size, (void**)&ppaChar_TextureFile);
                        pIDirectXFileData->GetData("Width"           , &Size, (void**)&pFloat_Size_SpriteSetModelWidth);
                        pIDirectXFileData->GetData("Height"          , &Size, (void**)&pFloat_Size_SpriteSetModelHeight);
                        pIDirectXFileData->GetData("TextureSplitRows", &Size, (void**)&pInt_RowNum_TextureSplit);
                        pIDirectXFileData->GetData("TextureSplitCols", &Size, (void**)&pInt_ColNum_TextureSplit);
                        prm_pSpriteSetModel->_fSize_SpriteSetModelWidthPx = *pFloat_Size_SpriteSetModelWidth;
                        prm_pSpriteSetModel->_fSize_SpriteSetModelHeightPx = *pFloat_Size_SpriteSetModelHeight;
                        prm_pSpriteSetModel->_row_texture_split = *pInt_RowNum_TextureSplit;
                        prm_pSpriteSetModel->_col_texture_split = *pInt_ColNum_TextureSplit;
                    } else {
                        throwGgafCriticalException("[GgafDx9ModelManager::restoreSpriteSetModel] "<<xfile_name<<" GUIDvB");
                    }
                    RELEASE_IMPOSSIBLE_NULL(pIDirectXFileData);
                    //eNX`f
                    GgafDx9TextureConnection* model_pTextureCon = (GgafDx9TextureConnection*)_pTextureManager->getConnection(*ppaChar_TextureFile);
                    //eNX`QB
                    prm_pSpriteSetModel->_papTextureCon = NEW GgafDx9TextureConnection*[1];
                    prm_pSpriteSetModel->_papTextureCon[0] = model_pTextureCon;
                    //obt@
                    if (prm_pSpriteSetModel->_pIDirect3DVertexBuffer9 == NULL) {
                        prm_pSpriteSetModel->_size_vertices = sizeof(GgafDx9SpriteSetModel::VERTEX)*4;
                        prm_pSpriteSetModel->_size_vertex_unit = sizeof(GgafDx9SpriteSetModel::VERTEX);
                
                        GgafDx9SpriteSetModel::VERTEX* paVertex = NEW GgafDx9SpriteSetModel::VERTEX[4 * prm_pSpriteSetModel->_set_num];
                        //_zf
                        //UVPiAjp^[OjftHgB
                        //VF[_[`Ajp^[UVWdlB
                        //x,y  2 AfS[JW_S
                        for (int i = 0; i < prm_pSpriteSetModel->_set_num; i++) {
                
                            paVertex[i*4 + 0].x = *pFloat_Size_SpriteSetModelWidth / -2 / PX_UNIT;
                            paVertex[i*4 + 0].y = *pFloat_Size_SpriteSetModelHeight / 2 / PX_UNIT;
                            paVertex[i*4 + 0].z = 0.0f;
                            paVertex[i*4 + 0].nx = 0.0f;
                            paVertex[i*4 + 0].ny = 0.0f;
                            paVertex[i*4 + 0].nz = -1.0f;
                            paVertex[i*4 + 0].tu = 0.0f;
                            paVertex[i*4 + 0].tv = 0.0f;
                            paVertex[i*4 + 0].index = (float)i;
                            //E
                            paVertex[i*4 + 1].x = *pFloat_Size_SpriteSetModelWidth / 2 / PX_UNIT;
                            paVertex[i*4 + 1].y = *pFloat_Size_SpriteSetModelHeight / 2 / PX_UNIT;
                            paVertex[i*4 + 1].z = 0.0f;
                            paVertex[i*4 + 1].nx = 0.0f;
                            paVertex[i*4 + 1].ny = 0.0f;
                            paVertex[i*4 + 1].nz = -1.0f;
                            paVertex[i*4 + 1].tu = 1.0f/(float)(*pInt_ColNum_TextureSplit);// - (pxU/2);
                            paVertex[i*4 + 1].tv = 0.0f;
                            paVertex[i*4 + 1].index = (float)i;
                            //
                            paVertex[i*4 + 2].x = *pFloat_Size_SpriteSetModelWidth / -2 / PX_UNIT;
                            paVertex[i*4 + 2].y = *pFloat_Size_SpriteSetModelHeight / -2 / PX_UNIT;
                            paVertex[i*4 + 2].z = 0.0f;
                            paVertex[i*4 + 2].nx = 0.0f;
                            paVertex[i*4 + 2].ny = 0.0f;
                            paVertex[i*4 + 2].nz = -1.0f;
                            paVertex[i*4 + 2].tu = 0.0f;
                            paVertex[i*4 + 2].tv = 1.0f/(float)(*pInt_RowNum_TextureSplit);// - (pxV/2);
                            paVertex[i*4 + 2].index = (float)i;
                            //E
                            paVertex[i*4 + 3].x = *pFloat_Size_SpriteSetModelWidth / 2 / PX_UNIT;
                            paVertex[i*4 + 3].y = *pFloat_Size_SpriteSetModelHeight / -2 / PX_UNIT;
                            paVertex[i*4 + 3].z = 0.0f;
                            paVertex[i*4 + 3].nx = 0.0f;
                            paVertex[i*4 + 3].ny = 0.0f;
                            paVertex[i*4 + 3].nz = -1.0f;
                            paVertex[i*4 + 3].tu = 1.0f/(float)(*pInt_ColNum_TextureSplit);// - (pxU/2);
                            paVertex[i*4 + 3].tv = 1.0f/(float)(*pInt_RowNum_TextureSplit);// - (pxV/2);
                            paVertex[i*4 + 3].index = (float)i;
                
                //            _TRACE_("paVertex["<<(i*4 + 0)<<"].x ="<<paVertex[i*4 + 0].x );
                //            _TRACE_("paVertex["<<(i*4 + 0)<<"].y ="<<paVertex[i*4 + 0].y );
                //            _TRACE_("paVertex["<<(i*4 + 0)<<"].z ="<<paVertex[i*4 + 0].z );
                //            _TRACE_("paVertex["<<(i*4 + 0)<<"].index ="<<paVertex[i*4 + 0].index );
                //            _TRACE_("paVertex["<<(i*4 + 1)<<"].x ="<<paVertex[i*4 + 1].x );
                //            _TRACE_("paVertex["<<(i*4 + 1)<<"].y ="<<paVertex[i*4 + 1].y );
                //            _TRACE_("paVertex["<<(i*4 + 1)<<"].z ="<<paVertex[i*4 + 1].z );
                //            _TRACE_("paVertex["<<(i*4 + 1)<<"].index ="<<paVertex[i*4 + 1].index );
                //            _TRACE_("paVertex["<<(i*4 + 2)<<"].x ="<<paVertex[i*4 + 2].x );
                //            _TRACE_("paVertex["<<(i*4 + 2)<<"].y ="<<paVertex[i*4 + 2].y );
                //            _TRACE_("paVertex["<<(i*4 + 2)<<"].z ="<<paVertex[i*4 + 2].z );
                //            _TRACE_("paVertex["<<(i*4 + 2)<<"].index ="<<paVertex[i*4 + 2].index );
                //            _TRACE_("paVertex["<<(i*4 + 3)<<"].x ="<<paVertex[i*4 + 3].x );
                //            _TRACE_("paVertex["<<(i*4 + 3)<<"].y ="<<paVertex[i*4 + 3].y );
                //            _TRACE_("paVertex["<<(i*4 + 3)<<"].z ="<<paVertex[i*4 + 3].z );
                //            _TRACE_("paVertex["<<(i*4 + 3)<<"].index ="<<paVertex[i*4 + 3].index );
                
                        }
                
                        //
                        FLOAT model_fBoundingSphereRadius = (FLOAT)(GgafDx9Util::sqrt_fast(paVertex[0].x * paVertex[0].x +
                                                                   paVertex[0].y * paVertex[0].y +
                                                                   paVertex[0].z * paVertex[0].z));
                        prm_pSpriteSetModel->_fBoundingSphereRadius = model_fBoundingSphereRadius;
                
                
                        hr = GgafDx9God::_pID3DDevice9->CreateVertexBuffer(
                                prm_pSpriteSetModel->_size_vertices * prm_pSpriteSetModel->_set_num,
                                D3DUSAGE_WRITEONLY,
                                GgafDx9SpriteSetModel::FVF,
                                D3DPOOL_DEFAULT, //D3DPOOL_DEFAULT
                                &(prm_pSpriteSetModel->_pIDirect3DVertexBuffer9),
                                NULL);
                        checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreSpriteSetModel] _p1ID3DDevice9->CreateVertexBuffer s model="<<(prm_pSpriteSetModel->_model_name));
                        //_obt@
                        //_rfIJ[h_obt@[h
                        void *pVertexBuffer;
                        hr = prm_pSpriteSetModel->_pIDirect3DVertexBuffer9->Lock(
                                                       0,
                                                       prm_pSpriteSetModel->_size_vertices * prm_pSpriteSetModel->_set_num,
                                                       (void**)&pVertexBuffer,
                                                       0
                                                   );
                        checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreSpriteSetModel] _obt@bNs model="<<prm_pSpriteSetModel->_model_name);
                
                        memcpy(
                            pVertexBuffer,
                            paVertex,
                            prm_pSpriteSetModel->_size_vertices* prm_pSpriteSetModel->_set_num
                        ); //pVertexBuffer  paVertex
                        prm_pSpriteSetModel->_pIDirect3DVertexBuffer9->Unlock();
                        DELETEARR_IMPOSSIBLE_NULL(paVertex);
                    }
                
                    //CfbNXobt@
                    if (prm_pSpriteSetModel->_pIDirect3DIndexBuffer9 == NULL) {
                        int nVertices = 4;
                        int nFaces = 2;
                        WORD* unit_paIdxBuffer = NEW WORD[(nFaces*3)];
                        unit_paIdxBuffer[0] = 0;
                        unit_paIdxBuffer[1] = 1;
                        unit_paIdxBuffer[2] = 2;
                
                        unit_paIdxBuffer[3] = 1;
                        unit_paIdxBuffer[4] = 3;
                        unit_paIdxBuffer[5] = 2;
                
                        //_TRACE_("prm_pSpriteSetModel->_set_num="<<prm_pSpriteSetModel->_set_num);
                        WORD* paIdxBufferSet = NEW WORD[(nFaces*3) * prm_pSpriteSetModel->_set_num];
                        for (int i = 0; i < prm_pSpriteSetModel->_set_num; i++) {
                            for (int j = 0; j < nFaces; j++) {
                                paIdxBufferSet[((i*nFaces*3)+(j*3)) + 0] = unit_paIdxBuffer[j*3 + 0] + (nVertices*i);
                                paIdxBufferSet[((i*nFaces*3)+(j*3)) + 1] = unit_paIdxBuffer[j*3 + 1] + (nVertices*i);
                                paIdxBufferSet[((i*nFaces*3)+(j*3)) + 2] = unit_paIdxBuffer[j*3 + 2] + (nVertices*i);
                //                _TRACE_("paIdxBufferSet["<<(((i*nFaces*3)+(j*3)) + 0)<<"] = unit_paIdxBuffer["<<(j*3 + 0)<<"] + (nVertices*"<<i<<")="<<(unit_paIdxBuffer[j*3 + 0] + (nVertices*i)));
                //                _TRACE_("paIdxBufferSet["<<(((i*nFaces*3)+(j*3)) + 1)<<"] = unit_paIdxBuffer["<<(j*3 + 1)<<"] + (nVertices*"<<i<<")="<<(unit_paIdxBuffer[j*3 + 1] + (nVertices*i)));
                //                _TRACE_("paIdxBufferSet["<<(((i*nFaces*3)+(j*3)) + 2)<<"] = unit_paIdxBuffer["<<(j*3 + 2)<<"] + (nVertices*"<<i<<")="<<(unit_paIdxBuffer[j*3 + 2] + (nVertices*i)));
                            }
                        }
                
                        hr = GgafDx9God::_pID3DDevice9->CreateIndexBuffer(
                                               sizeof(WORD) * nFaces * 3 * prm_pSpriteSetModel->_set_num,
                                                D3DUSAGE_WRITEONLY,
                                                D3DFMT_INDEX16,
                                                D3DPOOL_DEFAULT,
                                                &(prm_pSpriteSetModel->_pIDirect3DIndexBuffer9),
                                                NULL);
                        checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreSpriteSetModel] _pID3DDevice9->CreateIndexBuffer s model="<<(prm_pSpriteSetModel->_model_name));
                
                        void* pIndexBuffer;
                        prm_pSpriteSetModel->_pIDirect3DIndexBuffer9->Lock(0,0,(void**)&pIndexBuffer,0);
                        memcpy(
                          pIndexBuffer ,
                          paIdxBufferSet,
                          sizeof(WORD) * nFaces * 3 * prm_pSpriteSetModel->_set_num
                        );
                        prm_pSpriteSetModel->_pIDirect3DIndexBuffer9->Unlock();
                        DELETEARR_IMPOSSIBLE_NULL(unit_paIdxBuffer);
                        DELETEARR_IMPOSSIBLE_NULL(paIdxBufferSet);
                
                        //`p[^[
                        GgafDx9SpriteSetModel::INDEXPARAM* paIndexParam = NEW GgafDx9SpriteSetModel::INDEXPARAM[prm_pSpriteSetModel->_set_num];
                        for (int i = 0; i < prm_pSpriteSetModel->_set_num; i++) {
                            paIndexParam[i].MaterialNo = 0;
                            paIndexParam[i].BaseVertexIndex = 0;
                            paIndexParam[i].MinIndex = 0;
                            paIndexParam[i].NumVertices = nVertices*(i+1);
                            paIndexParam[i].StartIndex = 0;
                            paIndexParam[i].PrimitiveCount = nFaces*(i+1);
                        }
                        prm_pSpriteSetModel->_paIndexParam = paIndexParam;
                    }
                
                    //Sp^[UVzf
                    //2009/3/13
                    //VF[_[UVA`UV(model_paRectUV[n]._aUV[0])OgpB
                    //TODO:B
                    int pattnum = (*pInt_ColNum_TextureSplit) * (*pInt_RowNum_TextureSplit);
                    GgafDx9RectUV* model_paRectUV = NEW GgafDx9RectUV[pattnum];
                    for (int row = 0; row < *pInt_RowNum_TextureSplit; row++) {
                        for (int col = 0; col < *pInt_ColNum_TextureSplit; col++) {
                            int pattno_uvflip = row*(*pInt_ColNum_TextureSplit)+col;
                            model_paRectUV[pattno_uvflip]._aUV[0].tu = (float)(1.0f/(*pInt_ColNum_TextureSplit)*col);
                            model_paRectUV[pattno_uvflip]._aUV[0].tv = (float)(1.0f/(*pInt_RowNum_TextureSplit)*row);
                
                            model_paRectUV[pattno_uvflip]._aUV[1].tu = (float)((1.0f/(*pInt_ColNum_TextureSplit)*(col+1)));
                            model_paRectUV[pattno_uvflip]._aUV[1].tv = (float)(1.0f/(*pInt_RowNum_TextureSplit)*row);
                
                            model_paRectUV[pattno_uvflip]._aUV[2].tu = (float)(1.0f/(*pInt_ColNum_TextureSplit)*col);
                            model_paRectUV[pattno_uvflip]._aUV[2].tv = (float)((1.0f/(*pInt_RowNum_TextureSplit)*(row+1)));
                
                            model_paRectUV[pattno_uvflip]._aUV[3].tu = (float)((1.0f/(*pInt_ColNum_TextureSplit)*(col+1)));
                            model_paRectUV[pattno_uvflip]._aUV[3].tv = (float)((1.0f/(*pInt_RowNum_TextureSplit)*(row+1)));
                        }
                    }
                    prm_pSpriteSetModel->_paRectUV = model_paRectUV;
                    prm_pSpriteSetModel->_pattno_uvflip_Max=pattnum-1;
                    prm_pSpriteSetModel->_dwNumMaterials = 1;
                    D3DMATERIAL9* model_paD3DMaterial9 = NEW D3DMATERIAL9[prm_pSpriteSetModel->_dwNumMaterials];
                    for( DWORD i = 0; i < prm_pSpriteSetModel->_dwNumMaterials; i++){
                        //model_paD3DMaterial9[i] = paD3DMaterial9_tmp[i].MatD3D;
                        model_paD3DMaterial9[i].Diffuse.r = 1.0f;
                        model_paD3DMaterial9[i].Diffuse.g = 1.0f;
                        model_paD3DMaterial9[i].Diffuse.b = 1.0f;
                        model_paD3DMaterial9[i].Diffuse.a = 1.0f;
                        model_paD3DMaterial9[i].Ambient.r = 1.0f;
                        model_paD3DMaterial9[i].Ambient.g = 1.0f;
                        model_paD3DMaterial9[i].Ambient.b = 1.0f;
                        model_paD3DMaterial9[i].Ambient.a = 1.0f;
                    }
                    prm_pSpriteSetModel->_paD3DMaterial9_default = model_paD3DMaterial9;
                    //n
                    RELEASE_SAFETY(pIDirectXFileData);
                    RELEASE_IMPOSSIBLE_NULL(pIDirectXFileEnumObject);
                }
                
                void GgafDx9ModelManager::restoreBoardModel(GgafDx9BoardModel* prm_pBoardModel) {
                    TRACE3("GgafDx9ModelManager::restoreBoardModel(" << prm_pBoardModel->_model_name << ")");
                
                    prm_pBoardModel->_papTextureCon = NULL;
                    prm_pBoardModel->_paRectUV = NULL;
                
                    HRESULT hr;
                    string xfile_name = GGAFDX9_PROPERTY(DIR_SPRITE_MODEL) + string(prm_pBoardModel->_model_name) + ".sprx";
                
                    //XvCgev[go^(s)
                    IDirectXFileEnumObject* pIDirectXFileEnumObject;
                    IDirectXFileData* pIDirectXFileData;
                    hr = _pIDirectXFile_sprx->CreateEnumObject((void*)xfile_name.c_str(), DXFILELOAD_FROMFILE, &pIDirectXFileEnumObject);
                    checkDxException(hr, DXFILE_OK, "[GgafDx9ModelManager::restoreBoardModel] "<<xfile_name<<"CreateEnumObjectsB");
                
                    //TODO:GUIDBSB
                    //const GUID PersonID_GUID ={ 0xB2B63407,0x6AA9,0x4618, 0x95, 0x63, 0x63, 0x1E, 0xDC, 0x20, 0x4C, 0xDE};
                
                    char** ppaChar_TextureFile;
                    float* pFloat_Size_BoardModelWidth;
                    float* pFloat_Size_BoardModelHeight;
                    int* pInt_RowNum_TextureSplit;
                    int* pInt_ColNum_TextureSplit;
                
                    // 1Zbg
                    hr = pIDirectXFileEnumObject->GetNextDataObject(&pIDirectXFileData);
                    if(hr != DXFILE_OK) {
                        throwGgafCriticalException("[GgafDx9ModelManager::restoreBoardModel] "<<xfile_name<<" sB");
                    }
                    const GUID *pGuid;
                    pIDirectXFileData->GetType( &pGuid );
                    //if( *pGuid == PersonID_GUID ) {
                    if(true) {
                        DWORD Size;
                        pIDirectXFileData->GetData("TextureFile"     , &Size, (void**)&ppaChar_TextureFile);
                        pIDirectXFileData->GetData("Width"           , &Size, (void**)&pFloat_Size_BoardModelWidth);
                        pIDirectXFileData->GetData("Height"          , &Size, (void**)&pFloat_Size_BoardModelHeight);
                        pIDirectXFileData->GetData("TextureSplitRows", &Size, (void**)&pInt_RowNum_TextureSplit);
                        pIDirectXFileData->GetData("TextureSplitCols", &Size, (void**)&pInt_ColNum_TextureSplit);
                
                        prm_pBoardModel->_fSize_BoardModelWidthPx = *pFloat_Size_BoardModelWidth;
                        prm_pBoardModel->_fSize_BoardModelHeightPx = *pFloat_Size_BoardModelHeight;
                        prm_pBoardModel->_row_texture_split = *pInt_RowNum_TextureSplit;
                        prm_pBoardModel->_col_texture_split = *pInt_ColNum_TextureSplit;
                    } else {
                        throwGgafCriticalException("[GgafDx9ModelManager::restoreBoardModel] "<<xfile_name<<" GUIDvB");
                    }
                
                    //eNX`f
                    GgafDx9TextureConnection* model_pTextureCon = (GgafDx9TextureConnection*)_pTextureManager->getConnection(*ppaChar_TextureFile);
                    //eNX`QB
                    prm_pBoardModel->_papTextureCon = NEW GgafDx9TextureConnection*[1];
                    prm_pBoardModel->_papTextureCon[0] = model_pTextureCon;
                
                    GgafDx9BoardModel::VERTEX* paVertex = NEW GgafDx9BoardModel::VERTEX[4];
                    prm_pBoardModel->_size_vertices = sizeof(GgafDx9BoardModel::VERTEX)*4;
                    prm_pBoardModel->_size_vertex_unit = sizeof(GgafDx9BoardModel::VERTEX);
                
                    //1pxuv
                    float texWidth  = (float)(model_pTextureCon->refer()->_pD3DXIMAGE_INFO->Width); //eNX`(px)
                    float texHeight = (float)(model_pTextureCon->refer()->_pD3DXIMAGE_INFO->Height); //eNX`(px)
                     float pxU = 1.0f / texWidth; //eNX`(px)
                     float pxV = 1.0f / texHeight; //eNX`(px)
                
                    //
                    paVertex[0].x = 0.0f;
                    paVertex[0].y = 0.0f;
                    paVertex[0].z = 0.0f;
                    paVertex[0].tu = (pxU/100);
                    paVertex[0].tv = (pxV/100);
                    //E
                    paVertex[1].x = *pFloat_Size_BoardModelWidth;
                    paVertex[1].y = 0.0f;
                    paVertex[1].z = 0.0f;
                    paVertex[1].tu = 1.0f/(float)(*pInt_ColNum_TextureSplit) - (pxU/100); //
                    paVertex[1].tv = (pxV/100);
                    //
                    paVertex[2].x = 0.0f;
                    paVertex[2].y = *pFloat_Size_BoardModelHeight;
                    paVertex[2].z = 0.0f;
                    paVertex[2].tu = (pxU/100);
                    paVertex[2].tv = 1.0f/(float)(*pInt_RowNum_TextureSplit) - (pxV/100); //
                    //E
                    paVertex[3].x = *pFloat_Size_BoardModelWidth;
                    paVertex[3].y = *pFloat_Size_BoardModelHeight;
                    paVertex[3].z = 0.0f;
                    paVertex[3].tu = 1.0f/(float)(*pInt_ColNum_TextureSplit) - (pxU/100);
                    paVertex[3].tv = 1.0f/(float)(*pInt_RowNum_TextureSplit) - (pxV/100);
                
                    //obt@
                    if (prm_pBoardModel->_pIDirect3DVertexBuffer9 == NULL) {
                
                        hr = GgafDx9God::_pID3DDevice9->CreateVertexBuffer(
                                prm_pBoardModel->_size_vertices,
                                D3DUSAGE_WRITEONLY,
                                GgafDx9BoardModel::FVF,
                                D3DPOOL_DEFAULT, //D3DPOOL_DEFAULT
                                &(prm_pBoardModel->_pIDirect3DVertexBuffer9),
                                NULL);
                        checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreBoardModel] _pID3DDevice9->CreateVertexBuffer s model="<<(prm_pBoardModel->_model_name));
                    }
                    //_obt@
                    //_rfIJ[h_obt@[h
                    void *pVertexBuffer;
                    hr = prm_pBoardModel->_pIDirect3DVertexBuffer9->Lock(0, prm_pBoardModel->_size_vertices, (void**)&pVertexBuffer, 0);
                    checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreBoardModel] _obt@bNs model="<<prm_pBoardModel->_model_name);
                
                    memcpy(pVertexBuffer, paVertex, prm_pBoardModel->_size_vertices); //pVertexBuffer  paVertex
                    prm_pBoardModel->_pIDirect3DVertexBuffer9->Unlock();
                
                    //Sp^[UVzf
                    //2009/3/13
                    //VF[_[UVA`UV(model_paRectUV[n]._aUV[0])OgpB
                    //TODO:]B
                    int pattnum = (*pInt_ColNum_TextureSplit) * (*pInt_RowNum_TextureSplit);
                    GgafDx9RectUV* model_paRectUV = NEW GgafDx9RectUV[pattnum];
                    for (int row = 0; row < *pInt_RowNum_TextureSplit; row++) {
                        for (int col = 0; col < *pInt_ColNum_TextureSplit; col++) {
                            int pattno_uvflip = row*(*pInt_ColNum_TextureSplit)+col;
                            model_paRectUV[pattno_uvflip]._aUV[0].tu = (float)(1.0f*col/(*pInt_ColNum_TextureSplit));
                            model_paRectUV[pattno_uvflip]._aUV[0].tv = (float)(1.0f*row/(*pInt_RowNum_TextureSplit));
                
                            model_paRectUV[pattno_uvflip]._aUV[1].tu = (float)(1.0f*(col+1)/(*pInt_ColNum_TextureSplit));
                            model_paRectUV[pattno_uvflip]._aUV[1].tv = (float)(1.0f*row/(*pInt_RowNum_TextureSplit));
                
                            model_paRectUV[pattno_uvflip]._aUV[2].tu = (float)(1.0f*col/(*pInt_ColNum_TextureSplit));
                            model_paRectUV[pattno_uvflip]._aUV[2].tv = (float)(1.0f*(row+1)/(*pInt_RowNum_TextureSplit));
                
                            model_paRectUV[pattno_uvflip]._aUV[3].tu = (float)(1.0f*(col+1)/(*pInt_ColNum_TextureSplit));
                            model_paRectUV[pattno_uvflip]._aUV[3].tv = (float)(1.0f*(row+1)/(*pInt_RowNum_TextureSplit));
                        }
                    }
                    prm_pBoardModel->_paRectUV = model_paRectUV;
                    prm_pBoardModel->_pattno_max = pattnum-1;
                    prm_pBoardModel->_dwNumMaterials = 1;
                    D3DMATERIAL9* model_paD3DMaterial9;
                    model_paD3DMaterial9 = NEW D3DMATERIAL9[prm_pBoardModel->_dwNumMaterials];
                    for( DWORD i = 0; i < prm_pBoardModel->_dwNumMaterials; i++){
                        //model_paD3DMaterial9[i] = paD3DMaterial9_tmp[i].MatD3D;
                        model_paD3DMaterial9[i].Diffuse.r = 1.0f;
                        model_paD3DMaterial9[i].Diffuse.g = 1.0f;
                        model_paD3DMaterial9[i].Diffuse.b = 1.0f;
                        model_paD3DMaterial9[i].Diffuse.a = 1.0f;
                        model_paD3DMaterial9[i].Ambient.r = 1.0f;
                        model_paD3DMaterial9[i].Ambient.g = 1.0f;
                        model_paD3DMaterial9[i].Ambient.b = 1.0f;
                        model_paD3DMaterial9[i].Ambient.a = 1.0f;
                    }
                    prm_pBoardModel->_paD3DMaterial9_default = model_paD3DMaterial9;
                
                    //n
                    DELETEARR_IMPOSSIBLE_NULL(paVertex);
                    RELEASE_SAFETY(pIDirectXFileData);
                    RELEASE_IMPOSSIBLE_NULL(pIDirectXFileEnumObject);
                }
                
                void GgafDx9ModelManager::restoreBoardSetModel(GgafDx9BoardSetModel* prm_pBoardSetModel) {
                    TRACE3("GgafDx9ModelManager::restoreBoardSetModel(" << prm_pBoardSetModel->_model_name << ")");
                
                    if (4*prm_pBoardSetModel->_set_num > 65535) {
                        throwGgafCriticalException("[GgafDx9ModelManager::restoreBoardSetModel] _ 65535B\nModelF"<<prm_pBoardSetModel->getName()<<"  nVertices:4  Zbg:"<<(prm_pBoardSetModel->_set_num));
                    }
                //    if ( 2 * 3 * prm_pBoardSetModel->_set_num > 65535) {
                //        throwGgafCriticalException("[GgafDx9ModelManager::restoreBoardSetModel] _CfbNX 65535B\nModelF"<<prm_pBoardSetModel->getName()<<"  nFaces:2(*3)  Zbg:"<<(prm_pBoardSetModel->_set_num));
                //    }
                
                    prm_pBoardSetModel->_papTextureCon = NULL;
                    prm_pBoardSetModel->_paRectUV = NULL;
                
                    HRESULT hr;
                    string xfile_name; //XvCg`t@CiXt@C`j
                    //"12/Moji" or "8/Moji" or "Moji"  "Moji" tpXB
                    //TODO:l3("123/Moji")B
                    if (*(prm_pBoardSetModel->_model_name + 1) == '/') {
                        xfile_name = GGAFDX9_PROPERTY(DIR_SPRITE_MODEL) + string(prm_pBoardSetModel->_model_name + 2) + ".sprx";
                    } else if (*(prm_pBoardSetModel->_model_name + 2) == '/') {
                        xfile_name = GGAFDX9_PROPERTY(DIR_SPRITE_MODEL) + string(prm_pBoardSetModel->_model_name + 3) + ".sprx";
                    } else {
                        xfile_name = GGAFDX9_PROPERTY(DIR_SPRITE_MODEL) + string(prm_pBoardSetModel->_model_name) + ".sprx";
                    }
                    //XvCgev[go^(s)
                
                    IDirectXFileEnumObject* pIDirectXFileEnumObject;
                    IDirectXFileData* pIDirectXFileData;
                    hr = _pIDirectXFile_sprx->CreateEnumObject((void*)xfile_name.c_str(), DXFILELOAD_FROMFILE, &pIDirectXFileEnumObject);
                    checkDxException(hr, DXFILE_OK, "[GgafDx9ModelManager::restoreBoardSetModel] "<<xfile_name<<"CreateEnumObjectsB");
                
                    //TODO:GUIDBSB
                    //const GUID PersonID_GUID ={ 0xB2B63407,0x6AA9,0x4618, 0x95, 0x63, 0x63, 0x1E, 0xDC, 0x20, 0x4C, 0xDE};
                
                    char** ppaChar_TextureFile;
                    float* pFloat_Size_BoardSetModelWidth;
                    float* pFloat_Size_BoardSetModelHeight;
                    int* pInt_RowNum_TextureSplit;
                    int* pInt_ColNum_TextureSplit;
                
                    // 1Zbg
                    hr = pIDirectXFileEnumObject->GetNextDataObject(&pIDirectXFileData);
                    if(hr != DXFILE_OK) {
                        throwGgafCriticalException("[GgafDx9ModelManager::restoreBoardSetModel] "<<xfile_name<<" sB");
                    }
                    const GUID *pGuid;
                    pIDirectXFileData->GetType( &pGuid );
                    //if( *pGuid == PersonID_GUID ) {
                    if(true) {
                        DWORD Size;
                        pIDirectXFileData->GetData("TextureFile"     , &Size, (void**)&ppaChar_TextureFile);
                        pIDirectXFileData->GetData("Width"           , &Size, (void**)&pFloat_Size_BoardSetModelWidth);
                        pIDirectXFileData->GetData("Height"          , &Size, (void**)&pFloat_Size_BoardSetModelHeight);
                        pIDirectXFileData->GetData("TextureSplitRows", &Size, (void**)&pInt_RowNum_TextureSplit);
                        pIDirectXFileData->GetData("TextureSplitCols", &Size, (void**)&pInt_ColNum_TextureSplit);
                
                        prm_pBoardSetModel->_fSize_BoardSetModelWidthPx = *pFloat_Size_BoardSetModelWidth;
                        prm_pBoardSetModel->_fSize_BoardSetModelHeightPx = *pFloat_Size_BoardSetModelHeight;
                        prm_pBoardSetModel->_row_texture_split = *pInt_RowNum_TextureSplit;
                        prm_pBoardSetModel->_col_texture_split = *pInt_ColNum_TextureSplit;
                    } else {
                        throwGgafCriticalException("[GgafDx9ModelManager::restoreBoardSetModel] "<<xfile_name<<" GUIDvB");
                    }
                
                    //eNX`f
                    GgafDx9TextureConnection* model_pTextureCon = (GgafDx9TextureConnection*)_pTextureManager->getConnection(*ppaChar_TextureFile);
                    //eNX`QB
                    prm_pBoardSetModel->_papTextureCon = NEW GgafDx9TextureConnection*[1];
                    prm_pBoardSetModel->_papTextureCon[0] = model_pTextureCon;
                
                    if (prm_pBoardSetModel->_pIDirect3DVertexBuffer9 == NULL) {
                
                        prm_pBoardSetModel->_size_vertices = sizeof(GgafDx9BoardSetModel::VERTEX)*4;
                        prm_pBoardSetModel->_size_vertex_unit = sizeof(GgafDx9BoardSetModel::VERTEX);
                        GgafDx9BoardSetModel::VERTEX* paVertex = NEW GgafDx9BoardSetModel::VERTEX[4 * prm_pBoardSetModel->_set_num];
                
                        //1pxuv
                        float texWidth  = (float)(model_pTextureCon->refer()->_pD3DXIMAGE_INFO->Width); //eNX`(px)
                        float texHeight = (float)(model_pTextureCon->refer()->_pD3DXIMAGE_INFO->Height); //eNX`(px)
                        float pxU = 1.0f / texWidth; //eNX`(px)
                        float pxV = 1.0f / texHeight; //eNX`(px)
                
                        for (int i = 0; i < prm_pBoardSetModel->_set_num; i++) {
                            //
                            paVertex[i*4 + 0].x = 0.0f;
                            paVertex[i*4 + 0].y = 0.0f;
                            paVertex[i*4 + 0].z = 0.0f;
                            paVertex[i*4 + 0].tu = (pxU/100);
                            paVertex[i*4 + 0].tv = (pxV/100);
                            paVertex[i*4 + 0].index = (float)i;
                            //E
                            paVertex[i*4 + 1].x = *pFloat_Size_BoardSetModelWidth;
                            paVertex[i*4 + 1].y = 0.0f;
                            paVertex[i*4 + 1].z = 0.0f;
                            paVertex[i*4 + 1].tu = 1.0f/(float)(*pInt_ColNum_TextureSplit) - (pxU/100);
                            paVertex[i*4 + 1].tv = (pxV/100);
                            paVertex[i*4 + 1].index = (float)i;
                            //
                            paVertex[i*4 + 2].x = 0.0f;
                            paVertex[i*4 + 2].y = *pFloat_Size_BoardSetModelHeight;
                            paVertex[i*4 + 2].z = 0.0f;
                            paVertex[i*4 + 2].tu = (pxU/100);
                            paVertex[i*4 + 2].tv = 1.0f/(float)(*pInt_RowNum_TextureSplit) - (pxV/100);
                            paVertex[i*4 + 2].index = (float)i;
                            //E
                            paVertex[i*4 + 3].x = *pFloat_Size_BoardSetModelWidth;
                            paVertex[i*4 + 3].y = *pFloat_Size_BoardSetModelHeight;
                            paVertex[i*4 + 3].z = 0.0f;
                            paVertex[i*4 + 3].tu = 1.0f/(float)(*pInt_ColNum_TextureSplit) - (pxU/100);
                            paVertex[i*4 + 3].tv = 1.0f/(float)(*pInt_RowNum_TextureSplit) - (pxV/100);
                            paVertex[i*4 + 3].index = (float)i;
                         }
                
                        //obt@
                
                        hr = GgafDx9God::_pID3DDevice9->CreateVertexBuffer(
                                prm_pBoardSetModel->_size_vertices * prm_pBoardSetModel->_set_num,
                                D3DUSAGE_WRITEONLY,
                                GgafDx9BoardSetModel::FVF,
                                D3DPOOL_DEFAULT, //D3DPOOL_DEFAULT
                                &(prm_pBoardSetModel->_pIDirect3DVertexBuffer9),
                                NULL);
                        checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreBoardSetModel] _pID3DDevice9->CreateVertexBuffer s model="<<(prm_pBoardSetModel->_model_name));
                        //_obt@
                        //_rfIJ[h_obt@[h
                        void *pVertexBuffer;
                        hr = prm_pBoardSetModel->_pIDirect3DVertexBuffer9->Lock(
                                                                             0,
                                                                             prm_pBoardSetModel->_size_vertices * prm_pBoardSetModel->_set_num,
                                                                             (void**)&pVertexBuffer,
                                                                             0
                                                                           );
                        checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreBoardSetModel] _obt@bNs model="<<prm_pBoardSetModel->_model_name);
                
                        memcpy(
                          pVertexBuffer,
                          paVertex,
                          prm_pBoardSetModel->_size_vertices * prm_pBoardSetModel->_set_num
                        ); //pVertexBuffer  paVertex
                        prm_pBoardSetModel->_pIDirect3DVertexBuffer9->Unlock();
                
                        DELETEARR_IMPOSSIBLE_NULL(paVertex);
                    }
                
                
                    //CfbNXobt@
                    if (prm_pBoardSetModel->_pIDirect3DIndexBuffer9 == NULL) {
                        int nVertices = 4;
                        int nFaces = 2;
                        WORD* unit_paIdxBuffer = NEW WORD[(nFaces*3)];
                        unit_paIdxBuffer[0] = 0;
                        unit_paIdxBuffer[1] = 1;
                        unit_paIdxBuffer[2] = 2;
                
                        unit_paIdxBuffer[3] = 1;
                        unit_paIdxBuffer[4] = 3;
                        unit_paIdxBuffer[5] = 2;
                
                        WORD* paIdxBufferSet = NEW WORD[(nFaces*3) * prm_pBoardSetModel->_set_num];
                        for (int i = 0; i < prm_pBoardSetModel->_set_num; i++) {
                            for (int j = 0; j < nFaces; j++) {
                                paIdxBufferSet[((i*nFaces*3)+(j*3)) + 0] = unit_paIdxBuffer[j*3 + 0] + (nVertices*i);
                                paIdxBufferSet[((i*nFaces*3)+(j*3)) + 1] = unit_paIdxBuffer[j*3 + 1] + (nVertices*i);
                                paIdxBufferSet[((i*nFaces*3)+(j*3)) + 2] = unit_paIdxBuffer[j*3 + 2] + (nVertices*i);
                            }
                        }
                
                        hr = GgafDx9God::_pID3DDevice9->CreateIndexBuffer(
                                                sizeof(WORD) * nFaces * 3 * prm_pBoardSetModel->_set_num,
                                                D3DUSAGE_WRITEONLY,
                                                D3DFMT_INDEX16,
                                                D3DPOOL_DEFAULT,
                                                &(prm_pBoardSetModel->_pIDirect3DIndexBuffer9),
                                                NULL);
                        checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreBoardSetModel] _pID3DDevice9->CreateIndexBuffer s model="<<(prm_pBoardSetModel->_model_name));
                
                        void* pIndexBuffer;
                        prm_pBoardSetModel->_pIDirect3DIndexBuffer9->Lock(0,0,(void**)&pIndexBuffer,0);
                        memcpy(
                          pIndexBuffer ,
                          paIdxBufferSet,
                          sizeof(WORD) * nFaces * 3 * prm_pBoardSetModel->_set_num
                        );
                        prm_pBoardSetModel->_pIDirect3DIndexBuffer9->Unlock();
                        DELETEARR_IMPOSSIBLE_NULL(unit_paIdxBuffer);
                        DELETEARR_IMPOSSIBLE_NULL(paIdxBufferSet);
                
                        //`p[^[
                        GgafDx9BoardSetModel::INDEXPARAM* paIndexParam = NEW GgafDx9BoardSetModel::INDEXPARAM[prm_pBoardSetModel->_set_num];
                        for (int i = 0; i < prm_pBoardSetModel->_set_num; i++) {
                            paIndexParam[i].MaterialNo = 0;
                            paIndexParam[i].BaseVertexIndex = 0;
                            paIndexParam[i].MinIndex = 0;
                            paIndexParam[i].NumVertices = nVertices*(i+1);
                            paIndexParam[i].StartIndex = 0;
                            paIndexParam[i].PrimitiveCount = nFaces*(i+1);
                        }
                        prm_pBoardSetModel->_paIndexParam = paIndexParam;
                    }
                
                
                    //Sp^[UVzf
                    //2009/3/13
                    //VF[_[UVA`UV(model_paRectUV[n]._aUV[0])OgpB
                    //TODO:]B
                    int pattnum = (*pInt_ColNum_TextureSplit) * (*pInt_RowNum_TextureSplit);
                    GgafDx9RectUV* model_paRectUV = NEW GgafDx9RectUV[pattnum];
                    for (int row = 0; row < *pInt_RowNum_TextureSplit; row++) {
                        for (int col = 0; col < *pInt_ColNum_TextureSplit; col++) {
                            int pattno_uvflip = row*(*pInt_ColNum_TextureSplit)+col;
                            model_paRectUV[pattno_uvflip]._aUV[0].tu = (float)(1.0f*col/(*pInt_ColNum_TextureSplit));
                            model_paRectUV[pattno_uvflip]._aUV[0].tv = (float)(1.0f*row/(*pInt_RowNum_TextureSplit));
                
                            model_paRectUV[pattno_uvflip]._aUV[1].tu = (float)(1.0f*(col+1)/(*pInt_ColNum_TextureSplit));
                            model_paRectUV[pattno_uvflip]._aUV[1].tv = (float)(1.0f*row/(*pInt_RowNum_TextureSplit));
                
                            model_paRectUV[pattno_uvflip]._aUV[2].tu = (float)(1.0f*col/(*pInt_ColNum_TextureSplit));
                            model_paRectUV[pattno_uvflip]._aUV[2].tv = (float)(1.0f*(row+1)/(*pInt_RowNum_TextureSplit));
                
                            model_paRectUV[pattno_uvflip]._aUV[3].tu = (float)(1.0f*(col+1)/(*pInt_ColNum_TextureSplit));
                            model_paRectUV[pattno_uvflip]._aUV[3].tv = (float)(1.0f*(row+1)/(*pInt_RowNum_TextureSplit));
                        }
                    }
                    prm_pBoardSetModel->_paRectUV = model_paRectUV;
                    prm_pBoardSetModel->_pattno_max = pattnum-1;
                    prm_pBoardSetModel->_dwNumMaterials = 1;
                    D3DMATERIAL9* model_paD3DMaterial9 = NEW D3DMATERIAL9[prm_pBoardSetModel->_dwNumMaterials];
                    for( DWORD i = 0; i < prm_pBoardSetModel->_dwNumMaterials; i++){
                        //model_paD3DMaterial9[i] = paD3DMaterial9_tmp[i].MatD3D;
                        model_paD3DMaterial9[i].Diffuse.r = 1.0f;
                        model_paD3DMaterial9[i].Diffuse.g = 1.0f;
                        model_paD3DMaterial9[i].Diffuse.b = 1.0f;
                        model_paD3DMaterial9[i].Diffuse.a = 1.0f;
                        model_paD3DMaterial9[i].Ambient.r = 1.0f;
                        model_paD3DMaterial9[i].Ambient.g = 1.0f;
                        model_paD3DMaterial9[i].Ambient.b = 1.0f;
                        model_paD3DMaterial9[i].Ambient.a = 1.0f;
                    }
                    prm_pBoardSetModel->_paD3DMaterial9_default = model_paD3DMaterial9;
                
                    //n
                
                    RELEASE_SAFETY(pIDirectXFileData);
                    RELEASE_IMPOSSIBLE_NULL(pIDirectXFileEnumObject);
                }
                
                void GgafDx9ModelManager::restoreMeshSetModel(GgafDx9MeshSetModel* prm_pMeshSetModel) {
                    TRACE3("GgafDx9ModelManager::restoreMeshSetModel(" << prm_pMeshSetModel->_model_name << ")");
                    string xfile_name; //Xt@C
                    //"12/Ceres" or "8/Celes" or "Celes"  "Celes" tpX
                    //TODO:lR
                    if (*(prm_pMeshSetModel->_model_name + 1) == '/') {
                        xfile_name = GGAFDX9_PROPERTY(DIR_MESH_MODEL) + string(prm_pMeshSetModel->_model_name + 2) + ".x";
                    } else if (*(prm_pMeshSetModel->_model_name + 2) == '/') {
                        xfile_name = GGAFDX9_PROPERTY(DIR_MESH_MODEL) + string(prm_pMeshSetModel->_model_name + 3) + ".x";
                    } else {
                        xfile_name = GGAFDX9_PROPERTY(DIR_MESH_MODEL) + string(prm_pMeshSetModel->_model_name) + ".x"; //f{".x"Xt@C
                    }
                
                
                    HRESULT hr;
                    //_obt@f[^
                    ToolBox::IO_Model_X iox;
                
                    Frm::Model3D* model_pModel3D = NULL;
                    Frm::Mesh* model_pMeshesFront = NULL;
                
                    GgafDx9MeshSetModel::INDEXPARAM** model_papaIndexParam = NULL;
                    GgafDx9MeshSetModel::VERTEX* unit_paVtxBuffer_org = NULL;
                    GgafDx9MeshSetModel::VERTEX* model_paVtxBuffer_org = NULL;
                    WORD* unit_paIdxBuffer_org = NULL;
                    WORD* model_paIdxBuffer_org = NULL;
                    D3DMATERIAL9* model_paD3DMaterial9 = NULL;
                    GgafDx9TextureConnection** model_papTextureCon = NULL;
                
                    int nVertices = 0;
                    int nTextureCoords = 0;
                    int nFaces = 0;
                    int nFaceNormals = 0;
                
                    if (prm_pMeshSetModel->_pModel3D == NULL) {
                        model_pModel3D = NEW Frm::Model3D();
                
                        bool r = iox.Load(xfile_name, model_pModel3D);
                        if (r == false) {
                            throwGgafCriticalException("[GgafDx9ModelManager::restoreMeshSetModel] Xt@CsB="<<xfile_name);
                        }
                
                        //bVOAm
                        int nMesh = (int)model_pModel3D->_Meshes.size();
                        uint16* paNumVertices = NEW uint16[nMesh];
                        int index_Mesh = 0;
                        for (list<Frm::Mesh*>::iterator iteMeshes = model_pModel3D->_Meshes.begin();
                                iteMeshes != model_pModel3D->_Meshes.end(); iteMeshes++) {
                            paNumVertices[index_Mesh] = ((*iteMeshes)->_nVertices);
                            index_Mesh++;
                        }
                        model_pModel3D->ConcatenateMeshes(); //bVq
                
                        model_pMeshesFront = model_pModel3D->_Meshes.front();
                        nVertices = model_pMeshesFront->_nVertices;
                        nTextureCoords = model_pMeshesFront->_nTextureCoords;
                        nFaces = model_pMeshesFront->_nFaces;
                        nFaceNormals = model_pMeshesFront->_nFaceNormals;
                        unit_paVtxBuffer_org = NEW GgafDx9MeshSetModel::VERTEX[nVertices];
                
                        if (nVertices*prm_pMeshSetModel->_set_num > 65535) {
                            throwGgafCriticalException("[GgafDx9ModelManager::restoreMeshSetModel] _ 65535B\nModelF"<<prm_pMeshSetModel->getName()<<"  nVertices:"<<nVertices<<"  Zbg:"<<(prm_pMeshSetModel->_set_num));
                        }
                
                //        if ( nFaces * 3 * prm_pMeshSetModel->_set_num > 65535) {
                //            throwGgafCriticalException("[GgafDx9ModelManager::restoreMeshSetModel] _CfbNX 65535B\nModelF"<<prm_pMeshSetModel->getName()<<"  nFaces:"<<nFaces<<"(*3)  Zbg:"<<(prm_pMeshSetModel->_set_num));
                //        }
                
                        prm_pMeshSetModel->_nVertices = nVertices;
                        prm_pMeshSetModel->_nFaces = nFaces;
                        prm_pMeshSetModel->_size_vertices = sizeof(GgafDx9MeshSetModel::VERTEX) * nVertices;
                        prm_pMeshSetModel->_size_vertex_unit = sizeof(GgafDx9MeshSetModel::VERTEX);
                
                        //@O
                        FLOAT model_fBoundingSphereRadius;
                        for (int i = 0; i < nVertices; i++) {
                            unit_paVtxBuffer_org[i].x = model_pMeshesFront->_Vertices[i].data[0];
                            unit_paVtxBuffer_org[i].y = model_pMeshesFront->_Vertices[i].data[1];
                            unit_paVtxBuffer_org[i].z = model_pMeshesFront->_Vertices[i].data[2];
                            unit_paVtxBuffer_org[i].nx = 0.0f;
                            unit_paVtxBuffer_org[i].ny = 0.0f;
                            unit_paVtxBuffer_org[i].nz = 0.0f;
                            unit_paVtxBuffer_org[i].color = D3DCOLOR_ARGB(255,255,255,255); //_J[g
                            if (i < nTextureCoords) {
                                unit_paVtxBuffer_org[i].tu = model_pMeshesFront->_TextureCoords[i].data[0];  //oUVW
                                unit_paVtxBuffer_org[i].tv = model_pMeshesFront->_TextureCoords[i].data[1];
                            } else {
                                unit_paVtxBuffer_org[i].tu = 0;
                                unit_paVtxBuffer_org[i].tv = 0;
                            }
                            unit_paVtxBuffer_org[i].index = 0; //_ij
                
                            //
                            model_fBoundingSphereRadius = (FLOAT)(GgafDx9Util::sqrt_fast(unit_paVtxBuffer_org[i].x * unit_paVtxBuffer_org[i].x +
                                                                 unit_paVtxBuffer_org[i].y * unit_paVtxBuffer_org[i].y +
                                                                 unit_paVtxBuffer_org[i].z * unit_paVtxBuffer_org[i].z));
                            if (prm_pMeshSetModel->_fBoundingSphereRadius < model_fBoundingSphereRadius) {
                                prm_pMeshSetModel->_fBoundingSphereRadius = model_fBoundingSphereRadius;
                            }
                        }
                
                        int nTextureCoords = model_pMeshesFront->_nTextureCoords;
                        if (nVertices < nTextureCoords) {
                            TRACE3("nTextureCoords="<<nTextureCoords<<"/nVertices="<<nVertices);
                            TRACE3("UVWA_obt@zB_B="<<xfile_name);
                        }
                
                        //@B
                        //@ restoreMeshModel BvQB
                        float* paRad = NEW float[nFaces*3];
                        float* paRadSum_Vtx = NEW float[nVertices];
                        for (int i = 0; i < nVertices; i++) {
                            paRadSum_Vtx[i] = 0;
                        }
                        std::fill_n(paRadSum_Vtx, nVertices, 0);
                        unsigned short indexVertices_per_Face[3];
                        unsigned short indexNormals_per_Face[3];
                        for (int i = 0; i < nFaces; i++) {
                            for (int j = 0; j < 3; j++) {
                                //_CfbNXR(A,B,C)
                                indexVertices_per_Face[j] = model_pMeshesFront->_Faces[i].data[j];
                                //@CfbNXR
                                if (nFaceNormals > i) {
                                    indexNormals_per_Face[j] = model_pMeshesFront->_FaceNormals[i].data[j];
                                } else {
                                    //@
                                    indexNormals_per_Face[j] = (unsigned short)0;
                                }
                            }
                
                            //_CfbNX A p(CAB)Az
                            paRad[i*3+0] = getRadv1_v0v1v2(
                                             model_pMeshesFront->_Vertices[indexVertices_per_Face[2]],
                                             model_pMeshesFront->_Vertices[indexVertices_per_Face[0]],
                                             model_pMeshesFront->_Vertices[indexVertices_per_Face[1]]
                                           );
                            //A _CfbNXRApZ
                            paRadSum_Vtx[indexVertices_per_Face[0]] += paRad[i*3+0];
                
                            //_CfbNX B p(ABC)Az
                            paRad[i*3+1] = getRadv1_v0v1v2(
                                             model_pMeshesFront->_Vertices[indexVertices_per_Face[0]],
                                             model_pMeshesFront->_Vertices[indexVertices_per_Face[1]],
                                             model_pMeshesFront->_Vertices[indexVertices_per_Face[2]]
                                           );
                            //B _CfbNXRApZ
                            paRadSum_Vtx[indexVertices_per_Face[1]] += paRad[i*3+1];
                
                            //_CfbNX C p(ACB)Az
                            paRad[i*3+2] = (float)(2*PI - (paRad[i*3+0] + paRad[i*3+1]));
                            //C _CfbNXRApZ
                            paRadSum_Vtx[indexVertices_per_Face[2]] += paRad[i*3+2];
                        }
                
                        float rate; //@o_pB@xNg|B@xNgeB
                        for (int i = 0; i < nFaces; i++) {
                            for (int j = 0; j < 3; j++) {
                                indexVertices_per_Face[j] = model_pMeshesFront->_Faces[i].data[j];       //_CfbNXR
                                if (nFaceNormals > i) {
                                    indexNormals_per_Face[j] = model_pMeshesFront->_FaceNormals[i].data[j];  //@CfbNXR
                                } else {
                                    //@
                                    indexNormals_per_Face[j] = (unsigned short)0;
                
                                }
                            }
                            if (nFaceNormals > i) {
                                rate = (paRad[i*3+0] / paRadSum_Vtx[indexVertices_per_Face[0]]);
                                unit_paVtxBuffer_org[indexVertices_per_Face[0]].nx += (model_pMeshesFront->_Normals[indexNormals_per_Face[0]].x * rate);
                                unit_paVtxBuffer_org[indexVertices_per_Face[0]].ny += (model_pMeshesFront->_Normals[indexNormals_per_Face[0]].y * rate);
                                unit_paVtxBuffer_org[indexVertices_per_Face[0]].nz += (model_pMeshesFront->_Normals[indexNormals_per_Face[0]].z * rate);
                                rate = (paRad[i*3+1] / paRadSum_Vtx[indexVertices_per_Face[1]]);
                                unit_paVtxBuffer_org[indexVertices_per_Face[1]].nx += (model_pMeshesFront->_Normals[indexNormals_per_Face[1]].x * rate);
                                unit_paVtxBuffer_org[indexVertices_per_Face[1]].ny += (model_pMeshesFront->_Normals[indexNormals_per_Face[1]].y * rate);
                                unit_paVtxBuffer_org[indexVertices_per_Face[1]].nz += (model_pMeshesFront->_Normals[indexNormals_per_Face[1]].z * rate);
                                rate = (paRad[i*3+2] / paRadSum_Vtx[indexVertices_per_Face[2]]);
                                unit_paVtxBuffer_org[indexVertices_per_Face[2]].nx += (model_pMeshesFront->_Normals[indexNormals_per_Face[2]].x * rate);
                                unit_paVtxBuffer_org[indexVertices_per_Face[2]].ny += (model_pMeshesFront->_Normals[indexNormals_per_Face[2]].y * rate);
                                unit_paVtxBuffer_org[indexVertices_per_Face[2]].nz += (model_pMeshesFront->_Normals[indexNormals_per_Face[2]].z * rate);
                            } else {
                
                
                                //@A@vZB
                
                                //_CfbNXR
                                int indexVertices1 = model_pMeshesFront->_Faces[i].data[0];
                                int indexVertices2 = model_pMeshesFront->_Faces[i].data[1];
                                int indexVertices3 = model_pMeshesFront->_Faces[i].data[2];
                                //_R
                                D3DXVECTOR3 v1 = D3DXVECTOR3(
                                    model_pMeshesFront->_Vertices[indexVertices1].data[0],
                                    model_pMeshesFront->_Vertices[indexVertices1].data[1],
                                    model_pMeshesFront->_Vertices[indexVertices1].data[2]
                                );
                                D3DXVECTOR3 v2 = D3DXVECTOR3(
                                    model_pMeshesFront->_Vertices[indexVertices2].data[0],
                                    model_pMeshesFront->_Vertices[indexVertices2].data[1],
                                    model_pMeshesFront->_Vertices[indexVertices2].data[2]
                                );
                                D3DXVECTOR3 v3 = D3DXVECTOR3(
                                    model_pMeshesFront->_Vertices[indexVertices3].data[0],
                                    model_pMeshesFront->_Vertices[indexVertices3].data[1],
                                    model_pMeshesFront->_Vertices[indexVertices3].data[2]
                                );
                
                                D3DXPLANE Plane;
                                // 3 _
                                D3DXPlaneFromPoints(&Plane, &v1, &v2, &v3);
                                //K(@)Zo
                                D3DXPlaneNormalize(&Plane, &Plane);
                
                                rate = (paRad[i*3+0] / paRadSum_Vtx[indexVertices_per_Face[0]]);
                                unit_paVtxBuffer_org[indexVertices_per_Face[0]].nx += (Plane.a * rate);
                                unit_paVtxBuffer_org[indexVertices_per_Face[0]].ny += (Plane.b * rate);
                                unit_paVtxBuffer_org[indexVertices_per_Face[0]].nz += (Plane.c * rate);
                                rate = (paRad[i*3+1] / paRadSum_Vtx[indexVertices_per_Face[1]]);
                                unit_paVtxBuffer_org[indexVertices_per_Face[1]].nx += (Plane.a * rate);
                                unit_paVtxBuffer_org[indexVertices_per_Face[1]].ny += (Plane.b * rate);
                                unit_paVtxBuffer_org[indexVertices_per_Face[1]].nz += (Plane.c * rate);
                                rate = (paRad[i*3+2] / paRadSum_Vtx[indexVertices_per_Face[2]]);
                                unit_paVtxBuffer_org[indexVertices_per_Face[2]].nx += (Plane.a * rate);
                                unit_paVtxBuffer_org[indexVertices_per_Face[2]].ny += (Plane.b * rate);
                                unit_paVtxBuffer_org[indexVertices_per_Face[2]].nz += (Plane.c * rate);
                
                            }
                        }
                        int n = 0;
                        int nVertices_begin = 0;
                        int nVertices_end = 0;
                        for (std::list<Frm::Bone*>::iterator iteBone = model_pModel3D->_toplevel_Skelettons.begin() ;
                                iteBone != model_pModel3D->_toplevel_Skelettons.end(); iteBone++) {
                
                            _TRACE_("(*iteBone)->_Name="<<((*iteBone)->_Name));
                            //Xt@CFrameTransformMatrix(0t[Aj[V)l
                            if ((*iteBone)) {
                                Frm::Matrix* pMatPos = &((*iteBone)->_MatrixPos);
                                if (pMatPos == 0 || pMatPos== NULL || pMatPos->isIdentity()) {
                                    //FrameTransformMatrix Ps
                                    _TRACE_("FrameTransformMatrix is Identity");
                                } else {
                                    _TRACE_("Execute FrameTransform!");
                                    D3DXMATRIX FrameTransformMatrix;
                                    FrameTransformMatrix._11 = pMatPos->data[0];
                                    FrameTransformMatrix._12 = pMatPos->data[1];
                                    FrameTransformMatrix._13 = pMatPos->data[2];
                                    FrameTransformMatrix._14 = pMatPos->data[3];
                                    FrameTransformMatrix._21 = pMatPos->data[4];
                                    FrameTransformMatrix._22 = pMatPos->data[5];
                                    FrameTransformMatrix._23 = pMatPos->data[6];
                                    FrameTransformMatrix._24 = pMatPos->data[7];
                                    FrameTransformMatrix._31 = pMatPos->data[8];
                                    FrameTransformMatrix._32 = pMatPos->data[9];
                                    FrameTransformMatrix._33 = pMatPos->data[10];
                                    FrameTransformMatrix._34 = pMatPos->data[11];
                                    FrameTransformMatrix._41 = pMatPos->data[12];
                                    FrameTransformMatrix._42 = pMatPos->data[13];
                                    FrameTransformMatrix._43 = pMatPos->data[14];
                                    FrameTransformMatrix._44 = pMatPos->data[15];
                
                                    if (n == 0) {
                                        nVertices_begin = 0;
                                        nVertices_end = paNumVertices[n];
                                    } else {
                                        nVertices_begin += paNumVertices[n-1];
                                        nVertices_end += paNumVertices[n];
                                    }
                
                                    D3DXVECTOR3 vecVertex;
                                    D3DXVECTOR3 vecNormal;
                                    for (int i = nVertices_begin; i < nVertices_end; i++) {
                                        vecVertex.x = unit_paVtxBuffer_org[i].x;
                                        vecVertex.y = unit_paVtxBuffer_org[i].y;
                                        vecVertex.z = unit_paVtxBuffer_org[i].z;
                                        D3DXVec3TransformCoord(&vecVertex, &vecVertex, &FrameTransformMatrix);
                                        vecNormal.x = unit_paVtxBuffer_org[i].nx;
                                        vecNormal.y = unit_paVtxBuffer_org[i].ny;
                                        vecNormal.z = unit_paVtxBuffer_org[i].nz;
                                        D3DXVec3TransformNormal(&vecNormal, &vecNormal, &FrameTransformMatrix);
                
                                        unit_paVtxBuffer_org[i].x = vecVertex.x;
                                        unit_paVtxBuffer_org[i].y = vecVertex.y;
                                        unit_paVtxBuffer_org[i].z = vecVertex.z;
                                        unit_paVtxBuffer_org[i].nx = vecNormal.x;
                                        unit_paVtxBuffer_org[i].ny = vecNormal.y;
                                        unit_paVtxBuffer_org[i].nz = vecNormal.z;
                                    }
                                }
                            }
                            n++;
                        }
                        DELETE_IMPOSSIBLE_NULL(paNumVertices);
                
                        //@K
                        D3DXVECTOR3 vec;
                        for (int i = 0; i < nVertices; i++) {
                            vec.x = unit_paVtxBuffer_org[i].nx;
                            vec.y = unit_paVtxBuffer_org[i].ny;
                            vec.z = unit_paVtxBuffer_org[i].nz;
                            if (vec.x == 0 && vec.y == 0 && vec.z == 0) {
                                unit_paVtxBuffer_org[i].nx = 0;
                                unit_paVtxBuffer_org[i].ny = 0;
                                unit_paVtxBuffer_org[i].nz = 0;
                            } else {
                                D3DXVec3Normalize( &vec, &vec);
                                unit_paVtxBuffer_org[i].nx = vec.x;
                                unit_paVtxBuffer_org[i].ny = vec.y;
                                unit_paVtxBuffer_org[i].nz = vec.z;
                            }
                        }
                //        TRACE3("@K----------------------------");
                //        for (int i = 0; i < nVertices; i++) {
                //            TRACE3("["<<i<<"]=" << unit_paVtxBuffer_org[i].x << "\t, " << unit_paVtxBuffer_org[i].y << "\t, " << unit_paVtxBuffer_org[i].z << "\t, " << unit_paVtxBuffer_org[i].nx << "\t, " << unit_paVtxBuffer_org[i].ny << "\t, " << unit_paVtxBuffer_org[i].nz << "\t, " << unit_paVtxBuffer_org[i].tu << "\t, " << unit_paVtxBuffer_org[i].tv);
                //        }
                //        TRACE3("--------------------------------------");
                
                
                        //CfbNXobt@o^
                        unit_paIdxBuffer_org = NEW WORD[nFaces*3];
                        for (int i = 0; i < nFaces; i++) {
                            unit_paIdxBuffer_org[i*3 + 0] = model_pMeshesFront->_Faces[i].data[0];
                            unit_paIdxBuffer_org[i*3 + 1] = model_pMeshesFront->_Faces[i].data[1];
                            unit_paIdxBuffer_org[i*3 + 2] = model_pMeshesFront->_Faces[i].data[2];
                        }
                
                        //_obt@ZbgJRs[
                        model_paVtxBuffer_org = NEW GgafDx9MeshSetModel::VERTEX[nVertices * prm_pMeshSetModel->_set_num];
                        for (int i = 0; i < prm_pMeshSetModel->_set_num; i++) {
                            for (int j = 0; j < nVertices; j++) {
                                model_paVtxBuffer_org[(i*nVertices) + j] = unit_paVtxBuffer_org[j];
                                model_paVtxBuffer_org[(i*nVertices) + j].index = (float)i; //+= (nVertices*i);
                            }
                        }
                        DELETEARR_IMPOSSIBLE_NULL(unit_paVtxBuffer_org);
                
                        //CfbNXobt@ZbgJRs[
                        model_paIdxBuffer_org = NEW WORD[(nFaces*3) * prm_pMeshSetModel->_set_num];
                        for (int i = 0; i < prm_pMeshSetModel->_set_num; i++) {
                            for (int j = 0; j < nFaces; j++) {
                                model_paIdxBuffer_org[((i*nFaces*3)+(j*3)) + 0] = unit_paIdxBuffer_org[j*3 + 0] + (nVertices*i);
                                model_paIdxBuffer_org[((i*nFaces*3)+(j*3)) + 1] = unit_paIdxBuffer_org[j*3 + 1] + (nVertices*i);
                                model_paIdxBuffer_org[((i*nFaces*3)+(j*3)) + 2] = unit_paIdxBuffer_org[j*3 + 2] + (nVertices*i);
                            }
                        }
                        DELETEARR_IMPOSSIBLE_NULL(unit_paIdxBuffer_org);
                
                        //}eAXgZbgJRs[
                        uint16* paFaceMaterials = NEW uint16[nFaces * prm_pMeshSetModel->_set_num];
                        for (int i = 0; i < prm_pMeshSetModel->_set_num; i++) {
                            for (int j = 0; j < nFaces; j++) {
                                paFaceMaterials[(i*nFaces) + j] = model_pMeshesFront->_FaceMaterials[j];
                            }
                        }
                
                        //p[^ZbgJRs[
                        model_papaIndexParam = NEW GgafDx9MeshSetModel::INDEXPARAM*[prm_pMeshSetModel->_set_num];
                        prm_pMeshSetModel->_pa_nMaterialListGrp = NEW UINT[prm_pMeshSetModel->_set_num];
                        for (int set_index = 0; set_index < prm_pMeshSetModel->_set_num; set_index++) {
                            GgafDx9MeshSetModel::INDEXPARAM* paParam = NEW GgafDx9MeshSetModel::INDEXPARAM[nFaces * (set_index+1)];
                            int prev_materialno = -1;
                            int materialno = 0;
                            int paramno = 0;
                            int faceNoCnt_break = 0;
                            int prev_faceNoCnt_break = -1;
                            UINT max_num_vertices = 0;
                            UINT min_num_vertices = UINT_MAX;
                
                            int faceNoCnt;
                            for (faceNoCnt = 0; faceNoCnt < nFaces * (set_index+1); faceNoCnt++) {
                                materialno = paFaceMaterials[faceNoCnt];
                                if (prev_materialno != materialno) {
                                    //TRACE3("BREAK! paramno="<<paramno);
                                    prev_faceNoCnt_break = faceNoCnt_break;
                                    faceNoCnt_break = faceNoCnt;
                
                                    paParam[paramno].MaterialNo = materialno;
                                    paParam[paramno].BaseVertexIndex = 0;
                                    paParam[paramno].MinIndex = UINT_MAX; //uCNAKuCNl
                                    paParam[paramno].NumVertices = UINT_MAX; //uCN
                                    paParam[paramno].StartIndex = faceNoCnt*3;
                                    paParam[paramno].PrimitiveCount = UINT_MAX; //uCN
                
                                    if (faceNoCnt > 0) {
                                        paParam[paramno-1].MinIndex = min_num_vertices;
                                        paParam[paramno-1].NumVertices = (UINT)(max_num_vertices - min_num_vertices + 1);
                                        paParam[paramno-1].PrimitiveCount = (UINT)(faceNoCnt_break - prev_faceNoCnt_break);
                                        //Zbg
                                        max_num_vertices = 0;
                                        min_num_vertices = UINT_MAX;
                                    }
                                    paramno++;
                                }
                
                                if (max_num_vertices <  model_paIdxBuffer_org[faceNoCnt*3 + 0]) {
                                    max_num_vertices = model_paIdxBuffer_org[faceNoCnt*3 + 0];
                                }
                                if (max_num_vertices <  model_paIdxBuffer_org[faceNoCnt*3 + 1]) {
                                    max_num_vertices = model_paIdxBuffer_org[faceNoCnt*3 + 1];
                                }
                                if (max_num_vertices <  model_paIdxBuffer_org[faceNoCnt*3 + 2]) {
                                    max_num_vertices = model_paIdxBuffer_org[faceNoCnt*3 + 2];
                                }
                                if (min_num_vertices >  model_paIdxBuffer_org[faceNoCnt*3 + 0]) {
                                    min_num_vertices = model_paIdxBuffer_org[faceNoCnt*3 + 0];
                                }
                                if (min_num_vertices >  model_paIdxBuffer_org[faceNoCnt*3 + 1]) {
                                    min_num_vertices = model_paIdxBuffer_org[faceNoCnt*3 + 1];
                                }
                                if (min_num_vertices >  model_paIdxBuffer_org[faceNoCnt*3 + 2]) {
                                    min_num_vertices = model_paIdxBuffer_org[faceNoCnt*3 + 2];
                                }
                                prev_materialno = materialno;
                            }
                            if (nFaces > 0) {
                                paParam[paramno-1].MinIndex = min_num_vertices;
                                paParam[paramno-1].NumVertices = (UINT)(max_num_vertices - min_num_vertices + 1);
                                paParam[paramno-1].PrimitiveCount = (UINT)(faceNoCnt - faceNoCnt_break);
                            }
                
                            model_papaIndexParam[set_index] = NEW GgafDx9MeshSetModel::INDEXPARAM[paramno];
                            for (int i = 0; i < paramno; i++) {
                //                _TRACE_("model_papaIndexParam["<<set_index<<"]["<<i<<"].MaterialNo = paParam["<<i<<"].MaterialNo = "<<paParam[i].MaterialNo);
                //                _TRACE_("model_papaIndexParam["<<set_index<<"]["<<i<<"].BaseVertexIndex = paParam["<<i<<"].BaseVertexIndex = "<<paParam[i].BaseVertexIndex);
                //                _TRACE_("model_papaIndexParam["<<set_index<<"]["<<i<<"].MinIndex = paParam["<<i<<"].MinIndex = "<<paParam[i].MinIndex);
                //                _TRACE_("model_papaIndexParam["<<set_index<<"]["<<i<<"].NumVertices = paParam["<<i<<"].NumVertices = "<<paParam[i].NumVertices);
                //                _TRACE_("model_papaIndexParam["<<set_index<<"]["<<i<<"].StartIndex = paParam["<<i<<"].StartIndex = "<<paParam[i].StartIndex);
                //                _TRACE_("model_papaIndexParam["<<set_index<<"]["<<i<<"].PrimitiveCount = paParam["<<i<<"].PrimitiveCount = "<<paParam[i].PrimitiveCount);
                                model_papaIndexParam[set_index][i].MaterialNo = paParam[i].MaterialNo;
                                model_papaIndexParam[set_index][i].BaseVertexIndex = paParam[i].BaseVertexIndex;
                                model_papaIndexParam[set_index][i].MinIndex = paParam[i].MinIndex;
                                model_papaIndexParam[set_index][i].NumVertices = paParam[i].NumVertices;
                                model_papaIndexParam[set_index][i].StartIndex = paParam[i].StartIndex;
                                model_papaIndexParam[set_index][i].PrimitiveCount = paParam[i].PrimitiveCount;
                            }
                
                            prm_pMeshSetModel->_pa_nMaterialListGrp[set_index] = paramno;
                
                            //_TRACE_("prm_pMeshSetModel->_pa_nMaterialListGrp["<<set_index<<"]="<<prm_pMeshSetModel->_pa_nMaterialListGrp[set_index]);
                            delete[] paParam;
                        }
                
                        DELETEARR_IMPOSSIBLE_NULL(paFaceMaterials);
                        delete[] paRad;
                        delete[] paRadSum_Vtx;
                    }
                
                    if (prm_pMeshSetModel->_pIDirect3DVertexBuffer9 == NULL) {
                        //_obt@
                        hr = GgafDx9God::_pID3DDevice9->CreateVertexBuffer(
                                prm_pMeshSetModel->_size_vertices * prm_pMeshSetModel->_set_num,
                                D3DUSAGE_WRITEONLY,
                                GgafDx9MeshSetModel::FVF,
                                D3DPOOL_DEFAULT, //D3DPOOL_DEFAULT
                                &(prm_pMeshSetModel->_pIDirect3DVertexBuffer9),
                                NULL);
                        checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreMeshSetModel] _pID3DDevice9->CreateVertexBuffer s model="<<(prm_pMeshSetModel->_model_name));
                
                //        char str[256];
                //        sprintf (str, "VertexBuffer %s = %p \n",prm_pMeshSetModel->_model_name, prm_pMeshSetModel->_pIDirect3DVertexBuffer9);
                //        MessageBox(GgafDx9God::_hWnd, str, TEXT(""), MB_OK );
                
                        //obt@_f[^
                        void *pVertexBuffer;
                        hr = prm_pMeshSetModel->_pIDirect3DVertexBuffer9->Lock(
                                                      0,
                                                      prm_pMeshSetModel->_size_vertices * prm_pMeshSetModel->_set_num,
                                                      (void**)&pVertexBuffer,
                                                      0
                                                    );
                        checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreMeshSetModel] _obt@bNs model="<<prm_pMeshSetModel->_model_name);
                
                        memcpy(
                          pVertexBuffer,
                          model_paVtxBuffer_org,
                          prm_pMeshSetModel->_size_vertices * prm_pMeshSetModel->_set_num
                        ); //pVertexBuffer  paVertex
                        prm_pMeshSetModel->_pIDirect3DVertexBuffer9->Unlock();
                    }
                
                
                    //CfbNXobt@f[^
                    if (prm_pMeshSetModel->_pIDirect3DIndexBuffer9 == NULL) {
                
                        int nFaces = model_pMeshesFront->_nFaces;
                
                        hr = GgafDx9God::_pID3DDevice9->CreateIndexBuffer(
                                               sizeof(WORD) * nFaces * 3 * prm_pMeshSetModel->_set_num,
                                                D3DUSAGE_WRITEONLY,
                                                D3DFMT_INDEX16,
                                                D3DPOOL_DEFAULT,
                                                &(prm_pMeshSetModel->_pIDirect3DIndexBuffer9),
                                                NULL);
                        checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restoreMeshSetModel] _pID3DDevice9->CreateIndexBuffer s model="<<(prm_pMeshSetModel->_model_name));
                
                        void* pIndexBuffer;
                        prm_pMeshSetModel->_pIDirect3DIndexBuffer9->Lock(0,0,(void**)&pIndexBuffer,0);
                        memcpy(
                          pIndexBuffer ,
                          model_paIdxBuffer_org,
                          sizeof(WORD) * nFaces * 3 * prm_pMeshSetModel->_set_num
                        );
                        prm_pMeshSetModel->_pIDirect3DIndexBuffer9->Unlock();
                    }
                
                    //}eAJEg
                    int model_nMaterials = 0;
                    for (list<Frm::Material*>::iterator material = model_pMeshesFront->_Materials.begin(); material != model_pMeshesFront->_Materials.end(); material++) {
                        model_nMaterials++;
                    }
                
                    //}eA
                    model_paD3DMaterial9 = NEW D3DMATERIAL9[model_nMaterials];
                    model_papTextureCon = NEW GgafDx9TextureConnection*[model_nMaterials];
                
                    char* texture_filename;
                    int n = 0;
                    for (list<Frm::Material*>::iterator material = model_pMeshesFront->_Materials.begin(); material != model_pMeshesFront->_Materials.end(); material++) {
                        model_paD3DMaterial9[n].Diffuse.r = (*material)->_FaceColor.data[0];
                        model_paD3DMaterial9[n].Diffuse.g = (*material)->_FaceColor.data[1];
                        model_paD3DMaterial9[n].Diffuse.b = (*material)->_FaceColor.data[2];
                        model_paD3DMaterial9[n].Diffuse.a = (*material)->_FaceColor.data[3];
                
                        model_paD3DMaterial9[n].Ambient.r = (*material)->_FaceColor.data[0];
                        model_paD3DMaterial9[n].Ambient.g = (*material)->_FaceColor.data[1];
                        model_paD3DMaterial9[n].Ambient.b = (*material)->_FaceColor.data[2];
                        model_paD3DMaterial9[n].Ambient.a = (*material)->_FaceColor.data[3];
                
                        model_paD3DMaterial9[n].Specular.r = (*material)->_SpecularColor.data[0];
                        model_paD3DMaterial9[n].Specular.g = (*material)->_SpecularColor.data[1];
                        model_paD3DMaterial9[n].Specular.b = (*material)->_SpecularColor.data[2];
                        model_paD3DMaterial9[n].Specular.a = 1.000000f;
                        model_paD3DMaterial9[n].Power =  (*material)->_power;
                
                        model_paD3DMaterial9[n].Emissive.r = (*material)->_EmissiveColor.data[0];
                        model_paD3DMaterial9[n].Emissive.g = (*material)->_EmissiveColor.data[1];
                        model_paD3DMaterial9[n].Emissive.b = (*material)->_EmissiveColor.data[2];
                        model_paD3DMaterial9[n].Emissive.a = 1.000000f;
                
                        texture_filename = (char*)((*material)->_TextureName.c_str());
                        if (texture_filename != NULL && lstrlen(texture_filename) > 0 ) {
                            model_papTextureCon[n] = (GgafDx9TextureConnection*)_pTextureManager->getConnection(texture_filename);
                        } else {
                            //eNX`^eNX`u
                            model_papTextureCon[n] = (GgafDx9TextureConnection*)_pTextureManager->getConnection("white.png");
                        }
                        n++;
                    }
                
                    if (model_nMaterials != n) {
                        TRACE3("GgafDx9ModelManager::restoreMeshSetModel(" << prm_pMeshSetModel->_model_name << ") }eABmodel_nMaterials="<<model_nMaterials<<"/n="<<n);
                    }
                
                    //f
                    prm_pMeshSetModel->_pModel3D = model_pModel3D;
                    prm_pMeshSetModel->_pMeshesFront = model_pMeshesFront;
                
                    prm_pMeshSetModel->_paIdxBuffer_org = model_paIdxBuffer_org;
                    prm_pMeshSetModel->_paVtxBuffer_org = model_paVtxBuffer_org;
                    prm_pMeshSetModel->_papaIndexParam = model_papaIndexParam;
                    prm_pMeshSetModel->_paD3DMaterial9_default = model_paD3DMaterial9;
                    prm_pMeshSetModel->_papTextureCon = model_papTextureCon;
                    prm_pMeshSetModel->_dwNumMaterials = model_nMaterials;
                }
                
                void GgafDx9ModelManager::restorePointSpriteModel(GgafDx9PointSpriteModel* prm_pPointSpriteModel) {
                
                    TRACE3("GgafDx9ModelManager::restorePointSpriteModel(" << prm_pPointSpriteModel->_model_name << ")");
                
                    prm_pPointSpriteModel->_papTextureCon = NULL;
                    HRESULT hr;
                    string xfile_name = GGAFDX9_PROPERTY(DIR_SPRITE_MODEL) + string(prm_pPointSpriteModel->_model_name) + ".psprx";
                
                    //XvCgev[go^(s)
                    IDirectXFileEnumObject* pIDirectXFileEnumObject;
                    IDirectXFileData* pIDirectXFileData;
                    hr = _pIDirectXFile_psprx->CreateEnumObject((void*)xfile_name.c_str(), DXFILELOAD_FROMFILE, &pIDirectXFileEnumObject);
                    checkDxException(hr, DXFILE_OK, "[GgafDx9ModelManager::restorePointSpriteModel] "<<xfile_name<<"CreateEnumObjectsB");
                
                    //TODO:GUIDBSB
                    //const GUID PersonID_GUID ={ 0xB2B63407,0x6AA9,0x4618, 0x95, 0x63, 0x63, 0x1E, 0xDC, 0x20, 0x4C, 0xDE};
                
                    char** ppaChar_TextureFile;
                    float* pFloat_SquareSize;
                    int* pInt_TextureSplitRowCol;
                    int* pInt_VerticesNum;
                    D3DVECTOR* paD3DVECTOR_Vertices;
                    D3DCOLORVALUE* paD3DVECTOR_VertexColors;
                    int* paInt_InitUvPtnNo;
                    float* paFLOAT_InitScale;
                
                    // 1Zbg
                    hr = pIDirectXFileEnumObject->GetNextDataObject(&pIDirectXFileData);
                    if(hr != DXFILE_OK) {
                        throwGgafCriticalException("[GgafDx9ModelManager::restorePointSpriteModel] "<<xfile_name<<" sB");
                    }
                    const GUID *pGuid;
                    pIDirectXFileData->GetType( &pGuid );
                    //if( *pGuid == PersonID_GUID ) {
                    if(true) {
                        DWORD Size;
                        // PersonIDev[gf[^
                        pIDirectXFileData->GetData("SquareSize"     , &Size, (void**)&pFloat_SquareSize);
                        pIDirectXFileData->GetData("TextureFile"    , &Size, (void**)&ppaChar_TextureFile);
                        pIDirectXFileData->GetData("TextureSplitRowCol", &Size, (void**)&pInt_TextureSplitRowCol);
                        pIDirectXFileData->GetData("VerticesNum"    , &Size, (void**)&pInt_VerticesNum);
                        pIDirectXFileData->GetData("Vertices"       , &Size, (void**)&paD3DVECTOR_Vertices);
                        pIDirectXFileData->GetData("VertexColors"   , &Size, (void**)&paD3DVECTOR_VertexColors);
                        pIDirectXFileData->GetData("InitUvPtnNo"    , &Size, (void**)&paInt_InitUvPtnNo);
                        pIDirectXFileData->GetData("InitScale"      , &Size, (void**)&paFLOAT_InitScale);
                
                    } else {
                        throwGgafCriticalException("[GgafDx9ModelManager::restorePointSpriteModel] "<<xfile_name<<" GUIDvB");
                    }
                    RELEASE_IMPOSSIBLE_NULL(pIDirectXFileData);
                    //
                    float model_fSquareSize = *pFloat_SquareSize;
                    int model_texture_split_rowcol = *pInt_TextureSplitRowCol;
                    int model_vertices_num = *pInt_VerticesNum;
                    TRACE3("GgafDx9ModelManager::restorePointSpriteModel model_vertices_num="<<model_vertices_num);
                    UINT model_size_vertices = sizeof(GgafDx9PointSpriteModel::VERTEX)*model_vertices_num;
                    UINT model_size_vertex_unit = sizeof(GgafDx9PointSpriteModel::VERTEX);
                
                    //eNX`f
                    GgafDx9TextureConnection** model_papTextureCon = NULL;
                    model_papTextureCon = NEW GgafDx9TextureConnection*[1];
                    model_papTextureCon[0] = (GgafDx9TextureConnection*)_pTextureManager->getConnection(*ppaChar_TextureFile);
                
                    float texWidth  = (float)(model_papTextureCon[0]->refer()->_pD3DXIMAGE_INFO->Width); //eNX`(px)
                    float texHeight = (float)(model_papTextureCon[0]->refer()->_pD3DXIMAGE_INFO->Height); //eNX`(px)
                    FLOAT model_fBoundingSphereRadius = 0;
                
                    //_obt@
                    GgafDx9PointSpriteModel::VERTEX* model_paVtxBuffer_org = NEW GgafDx9PointSpriteModel::VERTEX[model_vertices_num];
                
                
                //    GgafDx9UvFlipper uvflipper(NULL);
                //    uvflipper.setTextureUvRotation(model_texture_split_rowcol,
                //                                   1.0f / model_texture_split_rowcol,
                //                                   1.0f / model_texture_split_rowcol );
                //    uvflipper.forcePtnNoRange(0, model_texture_split_rowcol * model_texture_split_rowcol-1);
                //    float u = 0;
                //    float v = 0;
                    float dis;
                    for (int i = 0; i < model_vertices_num; i++) {
                //        uvflipper.setPtnNo(paInt_InitUvPtnNo[i]);
                //        uvflipper.getUV(u, v);
                        model_paVtxBuffer_org[i].x = paD3DVECTOR_Vertices[i].x;
                        model_paVtxBuffer_org[i].y = paD3DVECTOR_Vertices[i].y;
                        model_paVtxBuffer_org[i].z = paD3DVECTOR_Vertices[i].z;
                        model_paVtxBuffer_org[i].psize = (model_fSquareSize*model_texture_split_rowcol / texWidth) * paFLOAT_InitScale[i]; //PSIZEsNZTCY{B
                                                                                                                //VF[_[gksNZvZ
                        model_paVtxBuffer_org[i].color = D3DCOLOR_COLORVALUE(paD3DVECTOR_VertexColors[i].r,
                                                                             paD3DVECTOR_VertexColors[i].g,
                                                                             paD3DVECTOR_VertexColors[i].b,
                                                                             paD3DVECTOR_VertexColors[i].a );
                //        model_paVtxBuffer_org[i].tu = u;
                //        model_paVtxBuffer_org[i].tv = v;
                        model_paVtxBuffer_org[i].tu = (float)(paInt_InitUvPtnNo[i]);
                        model_paVtxBuffer_org[i].tv = 0;
                
                        dis = (FLOAT)(GgafDx9Util::sqrt_fast(model_paVtxBuffer_org[i].x * model_paVtxBuffer_org[i].x +
                                                             model_paVtxBuffer_org[i].y * model_paVtxBuffer_org[i].y +
                                                             model_paVtxBuffer_org[i].z * model_paVtxBuffer_org[i].z  )
                                       + (((model_fSquareSize/PX_UNIT) * 1.41421356 ) / 2.0)
                                     );
                
                         if (model_fBoundingSphereRadius < dis) {
                             model_fBoundingSphereRadius = dis;
                         }
                    }
                
                //    for (int i = 0; i < model_vertices_num; i++) {
                //        _TRACE_("rmodel_paVtxBuffer_org["<<i<<"].x = "<<(model_paVtxBuffer_org[i].x));
                //        _TRACE_("rmodel_paVtxBuffer_org["<<i<<"].y = "<<(model_paVtxBuffer_org[i].y));
                //        _TRACE_("rmodel_paVtxBuffer_org["<<i<<"].z = "<<(model_paVtxBuffer_org[i].z));
                //    }
                    D3DMATERIAL9*   model_paD3DMaterial9 = NULL;
                
                
                    if (prm_pPointSpriteModel->_pIDirect3DVertexBuffer9 == NULL) {
                
                        //_obt@
                        hr = GgafDx9God::_pID3DDevice9->CreateVertexBuffer(
                                model_size_vertices,
                                D3DUSAGE_WRITEONLY,
                                GgafDx9PointSpriteModel::FVF,
                                D3DPOOL_DEFAULT, //D3DPOOL_DEFAULT D3DPOOL_MANAGED
                                &(prm_pPointSpriteModel->_pIDirect3DVertexBuffer9),
                                NULL);
                        checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restorePointSpriteModel] _pID3DDevice9->CreateVertexBuffer s model="<<(prm_pPointSpriteModel->_model_name));
                
                        //obt@_f[^
                        void *pVertexBuffer;
                        hr = prm_pPointSpriteModel->_pIDirect3DVertexBuffer9->Lock(0, model_size_vertices, (void**)&pVertexBuffer, 0);
                        checkDxException(hr, D3D_OK, "[GgafDx9ModelManager::restorePointSpriteModel] _obt@bNs model="<<prm_pPointSpriteModel->_model_name);
                        memcpy(pVertexBuffer, model_paVtxBuffer_org, model_size_vertices); //pVertexBuffer  paVertex
                        prm_pPointSpriteModel->_pIDirect3DVertexBuffer9->Unlock();
                    }
                
                    model_paD3DMaterial9 = NEW D3DMATERIAL9[1];
                    model_paD3DMaterial9[0].Diffuse.r = 1.0f;
                    model_paD3DMaterial9[0].Diffuse.g = 1.0f;
                    model_paD3DMaterial9[0].Diffuse.b = 1.0f;
                    model_paD3DMaterial9[0].Diffuse.a = 1.0f;
                
                    //f
                    prm_pPointSpriteModel->_paD3DMaterial9_default = model_paD3DMaterial9;
                    prm_pPointSpriteModel->_papTextureCon = model_papTextureCon;
                    prm_pPointSpriteModel->_dwNumMaterials = 1;
                    prm_pPointSpriteModel->_fSquareSize = model_fSquareSize;
                    prm_pPointSpriteModel->_fTexSize = texWidth;
                    prm_pPointSpriteModel->_texture_split_rowcol = model_texture_split_rowcol;
                    prm_pPointSpriteModel->_vertices_num = model_vertices_num;
                    prm_pPointSpriteModel->_size_vertices = model_size_vertices;
                    prm_pPointSpriteModel->_size_vertex_unit = model_size_vertex_unit;
                    prm_pPointSpriteModel->_paVtxBuffer_org = model_paVtxBuffer_org;
                    prm_pPointSpriteModel->_fBoundingSphereRadius = model_fBoundingSphereRadius;
                    RELEASE_SAFETY(pIDirectXFileData);
                    RELEASE_IMPOSSIBLE_NULL(pIDirectXFileEnumObject);
                }
                
                
                GgafResourceConnection<GgafDx9Model>* GgafDx9ModelManager::processCreateConnection(char* prm_idstr, GgafDx9Model* prm_pResource) {
                    TRACE3(" GgafDx9ModelManager::processCreateConnection "<<prm_idstr<<" JnB");
                    GgafDx9ModelConnection* p = NEW GgafDx9ModelConnection(prm_idstr, prm_pResource);
                    TRACE3(" GgafDx9ModelManager::processCreateConnection "<<prm_idstr<<" IB");
                    return p;
                }
                
           2 -> GgafDx9ModelManager::~GgafDx9ModelManager() {
                    TRACE3("GgafDx9ModelManager::~GgafDx9ModelManager() start-->");
                    RELEASE_IMPOSSIBLE_NULL(_pIDirectXFile_sprx);
                    RELEASE_IMPOSSIBLE_NULL(_pIDirectXFile_psprx);
                    DELETE_IMPOSSIBLE_NULL(_pTextureManager);
                    TRACE3("GgafDx9ModelManager::releaseAll() A");
                    releaseAll();
                }
                
                void GgafDx9ModelManager::restoreAll() {
                    TRACE3("GgafDx9ModelManager::restoreAll() start-->");
                    GgafResourceConnection<GgafDx9Model>* pCurrent = _pFirstConnection;
                    TRACE3("restoreAll pCurrent="<<pCurrent);
                    while (pCurrent) {
                        pCurrent->refer()->restore();
                        pCurrent = pCurrent->getNext();
                    }
                    TRACE3("GgafDx9ModelManager::restoreAll() end<--");
                }
                
                void GgafDx9ModelManager::onDeviceLostAll() {
                    TRACE3("GgafDx9ModelManager::onDeviceLostAll() start-->");
                    GgafResourceConnection<GgafDx9Model>* pCurrent = _pFirstConnection;
                    TRACE3("onDeviceLostAll pCurrent="<<pCurrent);
                    while (pCurrent) {
                        pCurrent->refer()->onDeviceLost();
                        pCurrent = pCurrent->getNext();
                    }
                    TRACE3("GgafDx9ModelManager::onDeviceLostAll() end<--");
                }
                
                void GgafDx9ModelManager::releaseAll() {
                    TRACE3("GgafDx9ModelManager::releaseAll() start-->");
                    GgafResourceConnection<GgafDx9Model>* pCurrent = _pFirstConnection;
                    while (pCurrent) {
                        pCurrent->refer()->release();
                        pCurrent = pCurrent->getNext();
                    }
                    TRACE3("GgafDx9ModelManager::releaseAll() end<--");
                }
                
                float GgafDx9ModelManager::getRadv1_v0v1v2(Frm::Vertex& v0, Frm::Vertex& v1, Frm::Vertex& v2) {
                    Frm::Vector V0;
                    Frm::Vector V1;
                    Frm::Vector V2;
                    V0.x = v0.data[0]; V0.y = v0.data[1]; V0.z = v0.data[2];
                    V1.x = v1.data[0]; V1.y = v1.data[1]; V1.z = v1.data[2];
                    V2.x = v2.data[0]; V2.y = v2.data[1]; V2.z = v2.data[2];
                    Frm::Vector V;
                    V = V2 - V1;
                    Frm::Vector W;
                    W = V0 - V1;
                    //xNg V W p
                    //    V=(vx,vy,vz)=(bx-ax,by-ay,bz-az)
                    //    W=(wx,wy,wz)=(cx-ax,cy-ay,cz-az)
                    //    VAWxNgp
                    //    cos=(VAWxNgjiVjiWj
                    //        =(vx*wx+vy*wy+vz*wz)
                    //         [g(vx^2+vy^2+vz^2)[g(wx^2+wy^2+wz^2)
                    float DOT, LV, LW, cosV1;
                    //TRACE3("V=("<<V.x<<"."<<V.y<<","<<V.z<<")");
                    //TRACE3("W=("<<W.x<<"."<<W.y<<","<<W.z<<")");
                    DOT = V.Dot(W);
                    LV = V.Abs();
                    LW = W.Abs();
                    cosV1 = DOT / LV / LW;
                    if (cosV1 == 0) {
                        return (float)PI/2;
                    } else {
                        return cosV1;
                    }
                
                }
                
                
                
                
                //uoiO`j 2009/07/05v
                //VF[_[nAD3DXLoadMeshFromX _obt@CYB
                //D3DXLoadMeshFromX Xt@Cv_i_CfbNXjB
                //Op`|SBOXA_8A_CfbNX12(*3)i12jA@xNg6A@CfbNX12(*3)AA
                //Xt@CeLXgGfB^ D3DXLoadMeshFromX _24B
                //AXt@C@Rf[^ADIRECTX@e_A
                //_8{PnY@\\zBu\zvudlvuB
                //e(se) D3DXLoadMeshFromX  ID3DXMesh \zAAeAGbWNbL
                //@_DA_i@jA_AsB
                //AVF[_[[tAIuWFNgDrawIndexedPrimitive\A
                //_Bu__obt@BvlsB
                //_A@_ACfOB
                //D3DXLoadMeshFromX _KLBAmobt@ASYuSvB
                //D3DXLoadMeshFromX \[XR[hARJB
                //AB D3DXLoadMeshFromX gHB_sB
                //VF[_[gXt@CAAB@H
                //vAu_vu@vu}eAvuUVvuKvvAB
                //Xt@CAtH[}bgEEEXt@CHIAB
                // D3DXLoadMeshFromX ugv_tAAXt@C}X^[B
                //AXt@CfB
                //A^ZRCAA3DSMAXGNX|[gXt@CuIvfAV[eBOLBlJnB
                // Paul TvR[hBhttp://www.gamedev.net/reference/programming/features/xfilepc/
                //uLoading and displaying .X files without DirectXvIBhsVgsbNBpB
                //TvA\l_BO}VABiGCCVCj
                //l_OAKBABSRB
                //gvgCAhG[IJVNiCBiEEEAIBTODOijj
                //AlBHAYB


Top 10 Lines:

     Line      Count

     3305          2
       23          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9Core/include/jp/ggaf/dx9core/util/XFile/ToolBox/IOModel_X.h:
                /////////////////////////////////////////////////////////
                // IOModel_X.h
                // load/save X file descriptions
                //
                /////////////////////////////////////////////////////////
                
                #ifndef IOMODEL_X
                #define IOMODEL_X
                
                //#define DEBUG
                
                
                #include "../Toolbox/MyTrace.h"
                
                #include "../framework/frm_IO.h"
                //#include <GL\freeglut.h>
                #include "../framework/Frm_Mesh.h"
                #include "../ToolBox/XFileStructs.h"
                
                namespace ToolBox {
                
          13 -> class IO_Model_X: Frm::IO<Frm::Model3D*> {
                public:
          13 ->     IO_Model_X(void) :
                        _LoadSkeletton(0) { //tsuge add
                        _Type = IO_3DX;
                        token_next = 0; //add tsuge
                    }
                    bool Load(std::string pFilename, Frm::Model3D* &pT);
                    bool Save(std::string pFilename, Frm::Model3D* &pT);
                    bool Load(std::string pFilename, std::vector<Frm::Model3D*> &pVT) {
                        return false;
                    }
                    bool Save(std::string pFilename, std::vector<Frm::Model3D*> &pVT) {
                        return false;
                    }
                
                private:
                    ifstream fin;
                    Frm::Bone* _LoadSkeletton;
                    Frm::Mesh* _LoadMesh;
                    Frm::AnimationSet* _LoadAnimationSet;
                    Frm::Model3D* _Object;
                    std::string active_load_filename;
                    //Utilities
                    int16 ProcessBlock(void);
                    int16 BlockID(std::string &pText);
                    void AvoidTemplate(void);
                    void Find(uchar pChar);
                    //Unique X struct ID in case no name are found
                    //Uses the Windows function GetTickCount
                    char* SetUID(char pType);
                    //structure used by the previous function to quickly
                    //convert a 32 bit number to a non-significant text.
                    union {
                        uint32 Integer[2]; //mod tsuge
                        //char Text[5];
                        char Text[8+2]; //mod tsuge
                    } _X_UID;
                
                    /** Xt@Cg[N\ */
                    uchar token_next; //add tsuge
                
                    //X File struct processing
                    uint32 _MaxKey; //Max animation key for a loaded animation set
                    void ProcessFrameTransformMatrix(Frm::Bone* &pB);
                    void ProcessBone(Frm::Bone* pBone);
                    void ProcessMesh(void);
                    void ProcessMeshTextureCoords(void);
                    void ProcessMeshMaterials(void);
                    void ProcessMeshNormals(void);
                    void ProcessMaterial(void);
                    void ProcessSkinWeights(void);
                    void ProcessAnimationSets(void);
                    void ProcessAnimations(Frm::AnimationSet* &pAS);
                    void ProcessAnimationKeys(Frm::Animation* &pA);
                    void MapMeshToBones(Frm::Bone* &pBone);
                
                };
                
                }
                #endif


Top 10 Lines:

     Line      Count

       22         13
       24         13

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

       26   Total number of line executions
    13.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9Core/include/jp/ggaf/dx9core/util/XFile/framework/frm_mesh.h:
                /////////////////////////////////////////////////////////
                // Frm_Mesh.h
                //
                //
                /////////////////////////////////////////////////////////
                
                #ifndef FRM_MESH_H
                #define FRM_MESH_H
                
                #include "../framework/frm_types.h"
                #include "../framework/frm_3Dmath.h"
                //#include "framework\frm_Quaternion.h"
                #include "../framework/frm_Material.h"
                
                //#define DEBUG
                #include "../Toolbox/Mytrace.h"
                
                #include <list>
                #include <vector>
                
                namespace Frm {
                
                class Mesh;
                
                class Bone {
                public:
          19 ->     Bone(void) :
                        _nVertices(0), _Vertices(0), _Weights(0) {
                        _MatrixPos.Identity();
                        _SkinOffset.Identity();
                        _MeshName = ""; //add tsuge
                        _Name = "";     //add tsuge
                    }
                    ~Bone(void);
                    Bone* IsName(std::string &BoneName);
                    void UpdateIndices(uint16 pIndex);
                
                    Matrix _MatrixPos, _SkinOffset;
                    uint32 _nVertices;
                    uint16* _Vertices;
                    float* _Weights;
                    std::string _MeshName;
                    std::string _Name;
                    std::list<Bone*> _Bones;
                };
                
                struct Subset {
                    uint16 Size;
                    Face* Faces;
                };
                
                class Mesh {
                public:
          21 ->     Mesh(void) :
                        _nVertices(0), _FirstVertex(0), _Vertices(0),
                        _nTextureCoords(0), _FirstTextureCoord(0), _TextureCoords(0),
                        _nFaces(0),  _FirstFace(0), _Faces(0),
                        _nNormals(0), _FirstNormal(0), _Normals(0),
                        _nFaceNormals(0), _FaceNormals(0),
                        _nMaterials(0), _FirstMaterial(0), _FaceMaterials(0) {
                    }
                    ~Mesh(void);
                    Mesh* IsName(std::string &MeshName) {
                        if (strcmp(_Name.c_str(), MeshName.c_str()) == 0)
                            return this;
                        return 0;
                    }
                    void UpdateIndices(void);
                    void CreateSubsets(void);
                    //Vertices
                    uint16 _nVertices, _FirstVertex;
                    Vertex* _Vertices;
                    //Texture Coords for each vertex
                    uint16 _nTextureCoords, _FirstTextureCoord;
                    TCoord* _TextureCoords;
                    //Faces
                    uint32 _nFaces, _FirstFace;
                    Face* _Faces;
                    //Subset of a mesh: there is one subset for each material used
                    std::list<Subset*> _Subsets;
                    //Normals
                    uint16 _nNormals, _FirstNormal;
                    vector<float>* _Normals;
                    uint16 _nFaceNormals;
                    Face* _FaceNormals;   //add tsuge
                    //Material index for each face
                    uint16 _nMaterials, _FirstMaterial;
                    uint16* _FaceMaterials;
                    //list of Materials for that Mesh
                    std::list<Material*> _Materials;
                    std::string _Name;
                };
                
                typedef struct {
                    uint32 Time;
                    Frm::Quaternion Rotation;
                } RotateKey;
                
                typedef struct {
                    uint32 Time;
                    Frm::Vertex Translation;
                } PositionKey;
                
                typedef struct {
                    uint32 Time;
                    Frm::Vector Scale;
                } ScaleKey;
                
                typedef struct {
                    uint32 Time;
                    Frm::Matrix Matrix;
                } MatrixKey;
                
       ##### -> class Animation {
                public:
                    ~Animation(void);
                    Animation* Get(void) {
                        return this;
                    }
                    Animation* IsName(std::string &pText) {
                        if (strcmp(_BoneName.c_str(), pText.c_str()) == 0)
                            return this;
                        return 0;
                    }
                
                    std::string _BoneName;
                    std::vector<ScaleKey*> _Scalings;
                    std::vector<RotateKey*> _Rotations;
                    std::vector<PositionKey*> _Translations;
                    std::vector<MatrixKey*> _Matrices;
                };
                
       ##### -> class AnimationSet {
                public:
                    ~AnimationSet(void);
                    AnimationSet* IsName(std::string &pText) {
                        if (strcmp(_Name.c_str(), pText.c_str()) == 0)
                            return this;
                        return 0;
                    }
                    Animation* FindAnimation(std::string &pText);
                    std::string _Name;
                    std::list<Animation*> _Animations;
                    uint32 _MaxKey; //Maximum time key for the full animation set
                };
                
                class Model3D {
                public:
          13 ->     Model3D(void) :
                        _Skeletton(0) {
                    }
                    ~Model3D(void);
                    Mesh* IsMeshName(std::string &pText);
                    void ConcatenateMeshes(void);
                    AnimationSet* FindAnimationSet(std::string &pText);
                    Bone* _Skeletton;
                    std::list<Mesh*> _Meshes;
                    std::list<AnimationSet*> _AnimationSets;
                
                    //add tsuge begin
                    std::list<Frm::Bone*> _toplevel_Skelettons;
                    //add tsuge end
                
                private:
                    void UpdateBoneIndices(Bone* &pBone);
                };
                
                }
                
                #endif


Top 10 Lines:

     Line      Count

       54         21
       27         19
      149         13

Execution Summary:

        9   Executable lines in this file
        5   Lines executed
    55.56   Percent of the file executed

       53   Total number of line executions
     5.89   Average executions per line


*** File c:/cygwin/mingw/bin/../lib/gcc/mingw32/4.5.2/include/c++/bits/stl_list.h:
                // List implementation -*- C++ -*-
                
                // Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
                // Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file stl_list.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                #ifndef _STL_LIST_H
                #define _STL_LIST_H 1
                
                #include <bits/concept_check.h>
                #include <initializer_list>
                
                _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)
                
                  // Supporting structures are split into common and templated types; the
                  // latter publicly inherits from the former in an effort to reduce code
                  // duplication.  This results in some "needless" static_cast'ing later on,
                  // but it's all safe downcasting.
                
                  /// Common part of a node in the %list. 
                  struct _List_node_base
                  {
                    _List_node_base* _M_next;
                    _List_node_base* _M_prev;
                
                    static void
                    swap(_List_node_base& __x, _List_node_base& __y) throw ();
                
                    void
                    _M_transfer(_List_node_base * const __first,
                		_List_node_base * const __last) throw ();
                
                    void
                    _M_reverse() throw ();
                
                    void
                    _M_hook(_List_node_base * const __position) throw ();
                
                    void
                    _M_unhook() throw ();
                  };
                
                  /// An actual node in the %list.
                  template<typename _Tp>
                    struct _List_node : public _List_node_base
          75 ->     {
                      ///< User's data.
                      _Tp _M_data;
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      template<typename... _Args>
          75 ->         _List_node(_Args&&... __args)
                	: _List_node_base(), _M_data(std::forward<_Args>(__args)...) { }
                #endif
                    };
                
                  /**
                   *  @brief A list::iterator.
                   *
                   *  All the functions are op overloads.
                  */
                  template<typename _Tp>
                    struct _List_iterator
                    {
                      typedef _List_iterator<_Tp>                _Self;
                      typedef _List_node<_Tp>                    _Node;
                
                      typedef ptrdiff_t                          difference_type;
                      typedef std::bidirectional_iterator_tag    iterator_category;
                      typedef _Tp                                value_type;
                      typedef _Tp*                               pointer;
                      typedef _Tp&                               reference;
                
                      _List_iterator()
                      : _M_node() { }
                
                      explicit
         456 ->       _List_iterator(_List_node_base* __x)
                      : _M_node(__x) { }
                
                      // Must downcast from List_node_base to _List_node to get to _M_data.
                      reference
                      operator*() const
                      { return static_cast<_Node*>(_M_node)->_M_data; }
                
                      pointer
                      operator->() const
                      { return &static_cast<_Node*>(_M_node)->_M_data; }
                
                      _Self&
                      operator++()
                      {
                	_M_node = _M_node->_M_next;
                	return *this;
                      }
                
                      _Self
                      operator++(int)
                      {
                	_Self __tmp = *this;
                	_M_node = _M_node->_M_next;
                	return __tmp;
                      }
                
                      _Self&
                      operator--()
                      {
                	_M_node = _M_node->_M_prev;
                	return *this;
                      }
                
                      _Self
                      operator--(int)
                      {
                	_Self __tmp = *this;
                	_M_node = _M_node->_M_prev;
                	return __tmp;
                      }
                
                      bool
                      operator==(const _Self& __x) const
                      { return _M_node == __x._M_node; }
                
                      bool
                      operator!=(const _Self& __x) const
                      { return _M_node != __x._M_node; }
                
                      // The only member points to the %list element.
                      _List_node_base* _M_node;
                    };
                
                  /**
                   *  @brief A list::const_iterator.
                   *
                   *  All the functions are op overloads.
                  */
                  template<typename _Tp>
                    struct _List_const_iterator
                    {
                      typedef _List_const_iterator<_Tp>          _Self;
                      typedef const _List_node<_Tp>              _Node;
                      typedef _List_iterator<_Tp>                iterator;
                
                      typedef ptrdiff_t                          difference_type;
                      typedef std::bidirectional_iterator_tag    iterator_category;
                      typedef _Tp                                value_type;
                      typedef const _Tp*                         pointer;
                      typedef const _Tp&                         reference;
                
                      _List_const_iterator()
                      : _M_node() { }
                
                      explicit
          72 ->       _List_const_iterator(const _List_node_base* __x)
                      : _M_node(__x) { }
                
                      _List_const_iterator(const iterator& __x)
                      : _M_node(__x._M_node) { }
                
                      // Must downcast from List_node_base to _List_node to get to
                      // _M_data.
                      reference
                      operator*() const
                      { return static_cast<_Node*>(_M_node)->_M_data; }
                
                      pointer
                      operator->() const
                      { return &static_cast<_Node*>(_M_node)->_M_data; }
                
                      _Self&
                      operator++()
                      {
                	_M_node = _M_node->_M_next;
                	return *this;
                      }
                
                      _Self
                      operator++(int)
                      {
                	_Self __tmp = *this;
                	_M_node = _M_node->_M_next;
                	return __tmp;
                      }
                
                      _Self&
                      operator--()
                      {
                	_M_node = _M_node->_M_prev;
                	return *this;
                      }
                
                      _Self
                      operator--(int)
                      {
                	_Self __tmp = *this;
                	_M_node = _M_node->_M_prev;
                	return __tmp;
                      }
                
                      bool
                      operator==(const _Self& __x) const
                      { return _M_node == __x._M_node; }
                
                      bool
                      operator!=(const _Self& __x) const
                      { return _M_node != __x._M_node; }
                
                      // The only member points to the %list element.
                      const _List_node_base* _M_node;
                    };
                
                  template<typename _Val>
                    inline bool
                    operator==(const _List_iterator<_Val>& __x,
                	       const _List_const_iterator<_Val>& __y)
                    { return __x._M_node == __y._M_node; }
                
                  template<typename _Val>
                    inline bool
                    operator!=(const _List_iterator<_Val>& __x,
                               const _List_const_iterator<_Val>& __y)
                    { return __x._M_node != __y._M_node; }
                
                
                  /// See bits/stl_deque.h's _Deque_base for an explanation.
                  template<typename _Tp, typename _Alloc>
                    class _List_base
                    {
                    protected:
                      // NOTA BENE
                      // The stored instance is not actually of "allocator_type"'s
                      // type.  Instead we rebind the type to
                      // Allocator<List_node<Tp>>, which according to [20.1.5]/4
                      // should probably be the same.  List_node<Tp> is not the same
                      // size as Tp (it's two pointers larger), and specializations on
                      // Tp may go unused because List_node<Tp> is being bound
                      // instead.
                      //
                      // We put this to the test in the constructors and in
                      // get_allocator, where we use conversions between
                      // allocator_type and _Node_alloc_type. The conversion is
                      // required by table 32 in [20.1.5].
                      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other
                        _Node_alloc_type;
                
                      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;
                
                      struct _List_impl 
                      : public _Node_alloc_type
         100 ->       {
                	_List_node_base _M_node;
                
         100 -> 	_List_impl()
                	: _Node_alloc_type(), _M_node()
                	{ }
                
                	_List_impl(const _Node_alloc_type& __a)
                	: _Node_alloc_type(__a), _M_node()
                	{ }
                      };
                
                      _List_impl _M_impl;
                
                      _List_node<_Tp>*
                      _M_get_node()
                      { return _M_impl._Node_alloc_type::allocate(1); }
                      
                      void
                      _M_put_node(_List_node<_Tp>* __p)
                      { _M_impl._Node_alloc_type::deallocate(__p, 1); }
                      
                  public:
                      typedef _Alloc allocator_type;
                
                      _Node_alloc_type&
                      _M_get_Node_allocator()
                      { return *static_cast<_Node_alloc_type*>(&this->_M_impl); }
                
                      const _Node_alloc_type&
                      _M_get_Node_allocator() const
                      { return *static_cast<const _Node_alloc_type*>(&this->_M_impl); }
                
                      _Tp_alloc_type
                      _M_get_Tp_allocator() const
                      { return _Tp_alloc_type(_M_get_Node_allocator()); }
                
                      allocator_type
                      get_allocator() const
                      { return allocator_type(_M_get_Node_allocator()); }
                
         100 ->       _List_base()
                      : _M_impl()
                      { _M_init(); }
                
                      _List_base(const allocator_type& __a)
                      : _M_impl(__a)
                      { _M_init(); }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      _List_base(_List_base&& __x)
                      : _M_impl(__x._M_get_Node_allocator())
                      {
                	_M_init();
                	_List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node);	
                      }
                #endif
                
                      // This is what actually destroys the list.
         100 ->       ~_List_base()
                      { _M_clear(); }
                
                      void
                      _M_clear();
                
                      void
                      _M_init()
                      {
                        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
                        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
                      }
                    };
                
                  /**
                   *  @brief A standard container with linear time access to elements,
                   *  and fixed time insertion/deletion at any point in the sequence.
                   *
                   *  @ingroup sequences
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>, including the
                   *  <a href="tables.html#68">optional sequence requirements</a> with the
                   *  %exception of @c at and @c operator[].
                   *
                   *  This is a @e doubly @e linked %list.  Traversal up and down the
                   *  %list requires linear time, but adding and removing elements (or
                   *  @e nodes) is done in constant time, regardless of where the
                   *  change takes place.  Unlike std::vector and std::deque,
                   *  random-access iterators are not provided, so subscripting ( @c
                   *  [] ) access is not allowed.  For algorithms which only need
                   *  sequential access, this lack makes no difference.
                   *
                   *  Also unlike the other standard containers, std::list provides
                   *  specialized algorithms %unique to linked lists, such as
                   *  splicing, sorting, and in-place reversal.
                   *
                   *  A couple points on memory allocation for list<Tp>:
                   *
                   *  First, we never actually allocate a Tp, we allocate
                   *  List_node<Tp>'s and trust [20.1.5]/4 to DTRT.  This is to ensure
                   *  that after elements from %list<X,Alloc1> are spliced into
                   *  %list<X,Alloc2>, destroying the memory of the second %list is a
                   *  valid operation, i.e., Alloc1 giveth and Alloc2 taketh away.
                   *
                   *  Second, a %list conceptually represented as
                   *  @code
                   *    A <---> B <---> C <---> D
                   *  @endcode
                   *  is actually circular; a link exists between A and D.  The %list
                   *  class holds (as its only data member) a private list::iterator
                   *  pointing to @e D, not to @e A!  To get to the head of the %list,
                   *  we start at the tail and move forward by one.  When this member
                   *  iterator's next/previous pointers refer to itself, the %list is
                   *  %empty. 
                  */
                  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
                    class list : protected _List_base<_Tp, _Alloc>
         100 ->     {
                      // concept requirements
                      typedef typename _Alloc::value_type                _Alloc_value_type;
                      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
                      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
                
                      typedef _List_base<_Tp, _Alloc>                    _Base;
                      typedef typename _Base::_Tp_alloc_type		 _Tp_alloc_type;
                
                    public:
                      typedef _Tp                                        value_type;
                      typedef typename _Tp_alloc_type::pointer           pointer;
                      typedef typename _Tp_alloc_type::const_pointer     const_pointer;
                      typedef typename _Tp_alloc_type::reference         reference;
                      typedef typename _Tp_alloc_type::const_reference   const_reference;
                      typedef _List_iterator<_Tp>                        iterator;
                      typedef _List_const_iterator<_Tp>                  const_iterator;
                      typedef std::reverse_iterator<const_iterator>      const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>            reverse_iterator;
                      typedef size_t                                     size_type;
                      typedef ptrdiff_t                                  difference_type;
                      typedef _Alloc                                     allocator_type;
                
                    protected:
                      // Note that pointers-to-_Node's can be ctor-converted to
                      // iterator types.
                      typedef _List_node<_Tp>				 _Node;
                
                      using _Base::_M_impl;
                      using _Base::_M_put_node;
                      using _Base::_M_get_node;
                      using _Base::_M_get_Tp_allocator;
                      using _Base::_M_get_Node_allocator;
                
                      /**
                       *  @param  x  An instance of user data.
                       *
                       *  Allocates space for a new node and constructs a copy of @a x in it.
                       */
                #ifndef __GXX_EXPERIMENTAL_CXX0X__
                      _Node*
                      _M_create_node(const value_type& __x)
                      {
                	_Node* __p = this->_M_get_node();
                	__try
                	  {
                	    _M_get_Tp_allocator().construct(&__p->_M_data, __x);
                	  }
                	__catch(...)
                	  {
                	    _M_put_node(__p);
                	    __throw_exception_again;
                	  }
                	return __p;
                      }
                #else
                      template<typename... _Args>
                        _Node*
                        _M_create_node(_Args&&... __args)
                	{
                	  _Node* __p = this->_M_get_node();
                	  __try
                	    {
                	      _M_get_Node_allocator().construct(__p,
                						std::forward<_Args>(__args)...);
                	    }
                	  __catch(...)
                	    {
                	      _M_put_node(__p);
                	      __throw_exception_again;
                	    }
                	  return __p;
                	}
                #endif
                
                    public:
                      // [23.2.2.1] construct/copy/destroy
                      // (assign() and get_allocator() are also listed in this section)
                      /**
                       *  @brief  Default constructor creates no elements.
                       */
         100 ->       list()
                      : _Base() { }
                
                      /**
                       *  @brief  Creates a %list with no elements.
                       *  @param  a  An allocator object.
                       */
                      explicit
                      list(const allocator_type& __a)
                      : _Base(__a) { }
                
                      /**
                       *  @brief  Creates a %list with copies of an exemplar element.
                       *  @param  n  The number of elements to initially create.
                       *  @param  value  An element to copy.
                       *  @param  a  An allocator object.
                       *
                       *  This constructor fills the %list with @a n copies of @a value.
                       */
                      explicit
                      list(size_type __n, const value_type& __value = value_type(),
                	   const allocator_type& __a = allocator_type())
                      : _Base(__a)
                      { _M_fill_initialize(__n, __value); }
                
                      /**
                       *  @brief  %List copy constructor.
                       *  @param  x  A %list of identical element and allocator types.
                       *
                       *  The newly-created %list uses a copy of the allocation object used
                       *  by @a x.
                       */
                      list(const list& __x)
                      : _Base(__x._M_get_Node_allocator())
                      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      /**
                       *  @brief  %List move constructor.
                       *  @param  x  A %list of identical element and allocator types.
                       *
                       *  The newly-created %list contains the exact contents of @a x.
                       *  The contents of @a x are a valid, but unspecified %list.
                       */
                      list(list&& __x)
                      : _Base(std::forward<_Base>(__x)) { }
                
                      /**
                       *  @brief  Builds a %list from an initializer_list
                       *  @param  l  An initializer_list of value_type.
                       *  @param  a  An allocator object.
                       *
                       *  Create a %list consisting of copies of the elements in the
                       *  initializer_list @a l.  This is linear in l.size().
                       */
                      list(initializer_list<value_type> __l,
                           const allocator_type& __a = allocator_type())
                      : _Base(__a)
                      { _M_initialize_dispatch(__l.begin(), __l.end(), __false_type()); }
                #endif
                
                      /**
                       *  @brief  Builds a %list from a range.
                       *  @param  first  An input iterator.
                       *  @param  last  An input iterator.
                       *  @param  a  An allocator object.
                       *
                       *  Create a %list consisting of copies of the elements from
                       *  [@a first,@a last).  This is linear in N (where N is
                       *  distance(@a first,@a last)).
                       */
                      template<typename _InputIterator>
                        list(_InputIterator __first, _InputIterator __last,
                	     const allocator_type& __a = allocator_type())
                        : _Base(__a)
                        { 
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_initialize_dispatch(__first, __last, _Integral());
                	}
                
                      /**
                       *  No explicit dtor needed as the _Base dtor takes care of
                       *  things.  The _Base dtor only erases the elements, and note
                       *  that if the elements themselves are pointers, the pointed-to
                       *  memory is not touched in any way.  Managing the pointer is
                       *  the user's responsibility.
                       */
                
                      /**
                       *  @brief  %List assignment operator.
                       *  @param  x  A %list of identical element and allocator types.
                       *
                       *  All the elements of @a x are copied, but unlike the copy
                       *  constructor, the allocator object is not copied.
                       */
                      list&
                      operator=(const list& __x);
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      /**
                       *  @brief  %List move assignment operator.
                       *  @param  x  A %list of identical element and allocator types.
                       *
                       *  The contents of @a x are moved into this %list (without copying).
                       *  @a x is a valid, but unspecified %list
                       */
                      list&
                      operator=(list&& __x)
                      {
                	// NB: DR 1204.
                	// NB: DR 675.
                	this->clear();
                	this->swap(__x);
                	return *this;
                      }
                
                      /**
                       *  @brief  %List initializer list assignment operator.
                       *  @param  l  An initializer_list of value_type.
                       *
                       *  Replace the contents of the %list with copies of the elements
                       *  in the initializer_list @a l.  This is linear in l.size().
                       */
                      list&
                      operator=(initializer_list<value_type> __l)
                      {
                	this->assign(__l.begin(), __l.end());
                	return *this;
                      }
                #endif
                
                      /**
                       *  @brief  Assigns a given value to a %list.
                       *  @param  n  Number of elements to be assigned.
                       *  @param  val  Value to be assigned.
                       *
                       *  This function fills a %list with @a n copies of the given
                       *  value.  Note that the assignment completely changes the %list
                       *  and that the resulting %list's size is the same as the number
                       *  of elements assigned.  Old data may be lost.
                       */
                      void
                      assign(size_type __n, const value_type& __val)
                      { _M_fill_assign(__n, __val); }
                
                      /**
                       *  @brief  Assigns a range to a %list.
                       *  @param  first  An input iterator.
                       *  @param  last   An input iterator.
                       *
                       *  This function fills a %list with copies of the elements in the
                       *  range [@a first,@a last).
                       *
                       *  Note that the assignment completely changes the %list and
                       *  that the resulting %list's size is the same as the number of
                       *  elements assigned.  Old data may be lost.
                       */
                      template<typename _InputIterator>
                        void
                        assign(_InputIterator __first, _InputIterator __last)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_assign_dispatch(__first, __last, _Integral());
                	}
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      /**
                       *  @brief  Assigns an initializer_list to a %list.
                       *  @param  l  An initializer_list of value_type.
                       *
                       *  Replace the contents of the %list with copies of the elements
                       *  in the initializer_list @a l.  This is linear in l.size().
                       */
                      void
                      assign(initializer_list<value_type> __l)
                      { this->assign(__l.begin(), __l.end()); }
                #endif
                
                      /// Get a copy of the memory allocation object.
                      allocator_type
                      get_allocator() const
                      { return _Base::get_allocator(); }
                
                      // iterators
                      /**
                       *  Returns a read/write iterator that points to the first element in the
                       *  %list.  Iteration is done in ordinary element order.
                       */
                      iterator
                      begin()
                      { return iterator(this->_M_impl._M_node._M_next); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %list.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
                      begin() const
                      { return const_iterator(this->_M_impl._M_node._M_next); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  element in the %list.  Iteration is done in ordinary element
                       *  order.
                       */
                      iterator
                      end()
                      { return iterator(&this->_M_impl._M_node); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %list.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
                      end() const
                      { return const_iterator(&this->_M_impl._M_node); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the last
                       *  element in the %list.  Iteration is done in reverse element
                       *  order.
                       */
                      reverse_iterator
                      rbegin()
                      { return reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points to
                       *  the last element in the %list.  Iteration is done in reverse
                       *  element order.
                       */
                      const_reverse_iterator
                      rbegin() const
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one
                       *  before the first element in the %list.  Iteration is done in
                       *  reverse element order.
                       */
                      reverse_iterator
                      rend()
                      { return reverse_iterator(begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points to one
                       *  before the first element in the %list.  Iteration is done in reverse
                       *  element order.
                       */
                      const_reverse_iterator
                      rend() const
                      { return const_reverse_iterator(begin()); }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %list.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
                      cbegin() const
                      { return const_iterator(this->_M_impl._M_node._M_next); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %list.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
                      cend() const
                      { return const_iterator(&this->_M_impl._M_node); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points to
                       *  the last element in the %list.  Iteration is done in reverse
                       *  element order.
                       */
                      const_reverse_iterator
                      crbegin() const
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points to one
                       *  before the first element in the %list.  Iteration is done in reverse
                       *  element order.
                       */
                      const_reverse_iterator
                      crend() const
                      { return const_reverse_iterator(begin()); }
                #endif
                
                      // [23.2.2.2] capacity
                      /**
                       *  Returns true if the %list is empty.  (Thus begin() would equal
                       *  end().)
                       */
                      bool
                      empty() const
                      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }
                
                      /**  Returns the number of elements in the %list.  */
                      size_type
                      size() const
                      { return std::distance(begin(), end()); }
                
                      /**  Returns the size() of the largest possible %list.  */
                      size_type
                      max_size() const
                      { return _M_get_Node_allocator().max_size(); }
                
                      /**
                       *  @brief Resizes the %list to the specified number of elements.
                       *  @param new_size Number of elements the %list should contain.
                       *  @param x Data with which new elements should be populated.
                       *
                       *  This function will %resize the %list to the specified number
                       *  of elements.  If the number is smaller than the %list's
                       *  current size the %list is truncated, otherwise the %list is
                       *  extended and new elements are populated with given data.
                       */
                      void
                      resize(size_type __new_size, value_type __x = value_type());
                
                      // element access
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %list.
                       */
                      reference
                      front()
                      { return *begin(); }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %list.
                       */
                      const_reference
                      front() const
                      { return *begin(); }
                
                      /**
                       *  Returns a read/write reference to the data at the last element
                       *  of the %list.
                       */
                      reference
                      back()
                      { 
                	iterator __tmp = end();
                	--__tmp;
                	return *__tmp;
                      }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the last
                       *  element of the %list.
                       */
                      const_reference
                      back() const
                      { 
                	const_iterator __tmp = end();
                	--__tmp;
                	return *__tmp;
                      }
                
                      // [23.2.2.3] modifiers
                      /**
                       *  @brief  Add data to the front of the %list.
                       *  @param  x  Data to be added.
                       *
                       *  This is a typical stack operation.  The function creates an
                       *  element at the front of the %list and assigns the given data
                       *  to it.  Due to the nature of a %list this operation can be
                       *  done in constant time, and does not invalidate iterators and
                       *  references.
                       */
                      void
                      push_front(const value_type& __x)
                      { this->_M_insert(begin(), __x); }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      void
                      push_front(value_type&& __x)
                      { this->_M_insert(begin(), std::move(__x)); }
                
                      template<typename... _Args>
                        void
                        emplace_front(_Args&&... __args)
                        { this->_M_insert(begin(), std::forward<_Args>(__args)...); }
                #endif
                
                      /**
                       *  @brief  Removes first element.
                       *
                       *  This is a typical stack operation.  It shrinks the %list by
                       *  one.  Due to the nature of a %list this operation can be done
                       *  in constant time, and only invalidates iterators/references to
                       *  the element being removed.
                       *
                       *  Note that no data is returned, and if the first element's data
                       *  is needed, it should be retrieved before pop_front() is
                       *  called.
                       */
                      void
                      pop_front()
                      { this->_M_erase(begin()); }
                
                      /**
                       *  @brief  Add data to the end of the %list.
                       *  @param  x  Data to be added.
                       *
                       *  This is a typical stack operation.  The function creates an
                       *  element at the end of the %list and assigns the given data to
                       *  it.  Due to the nature of a %list this operation can be done
                       *  in constant time, and does not invalidate iterators and
                       *  references.
                       */
                      void
                      push_back(const value_type& __x)
                      { this->_M_insert(end(), __x); }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      void
                      push_back(value_type&& __x)
                      { this->_M_insert(end(), std::move(__x)); }
                
                      template<typename... _Args>
                        void
                        emplace_back(_Args&&... __args)
                        { this->_M_insert(end(), std::forward<_Args>(__args)...); }
                #endif
                
                      /**
                       *  @brief  Removes last element.
                       *
                       *  This is a typical stack operation.  It shrinks the %list by
                       *  one.  Due to the nature of a %list this operation can be done
                       *  in constant time, and only invalidates iterators/references to
                       *  the element being removed.
                       *
                       *  Note that no data is returned, and if the last element's data
                       *  is needed, it should be retrieved before pop_back() is called.
                       */
                      void
                      pop_back()
                      { this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      /**
                       *  @brief  Constructs object in %list before specified iterator.
                       *  @param  position  A const_iterator into the %list.
                       *  @param  args  Arguments.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert an object of type T constructed
                       *  with T(std::forward<Args>(args)...) before the specified
                       *  location.  Due to the nature of a %list this operation can
                       *  be done in constant time, and does not invalidate iterators
                       *  and references.
                       */
                      template<typename... _Args>
                        iterator
                        emplace(iterator __position, _Args&&... __args);
                #endif
                
                      /**
                       *  @brief  Inserts given value into %list before specified iterator.
                       *  @param  position  An iterator into the %list.
                       *  @param  x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given value before
                       *  the specified location.  Due to the nature of a %list this
                       *  operation can be done in constant time, and does not
                       *  invalidate iterators and references.
                       */
                      iterator
                      insert(iterator __position, const value_type& __x);
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      /**
                       *  @brief  Inserts given rvalue into %list before specified iterator.
                       *  @param  position  An iterator into the %list.
                       *  @param  x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given rvalue before
                       *  the specified location.  Due to the nature of a %list this
                       *  operation can be done in constant time, and does not
                       *  invalidate iterators and references.
                        */
                      iterator
                      insert(iterator __position, value_type&& __x)
                      { return emplace(__position, std::move(__x)); }
                
                      /**
                       *  @brief  Inserts the contents of an initializer_list into %list
                       *          before specified iterator.
                       *  @param  p  An iterator into the %list.
                       *  @param  l  An initializer_list of value_type.
                       *
                       *  This function will insert copies of the data in the
                       *  initializer_list @a l into the %list before the location
                       *  specified by @a p.
                       *
                       *  This operation is linear in the number of elements inserted and
                       *  does not invalidate iterators and references.
                       */
                      void
                      insert(iterator __p, initializer_list<value_type> __l)
                      { this->insert(__p, __l.begin(), __l.end()); }
                #endif
                
                      /**
                       *  @brief  Inserts a number of copies of given data into the %list.
                       *  @param  position  An iterator into the %list.
                       *  @param  n  Number of elements to be inserted.
                       *  @param  x  Data to be inserted.
                       *
                       *  This function will insert a specified number of copies of the
                       *  given data before the location specified by @a position.
                       *
                       *  This operation is linear in the number of elements inserted and
                       *  does not invalidate iterators and references.
                       */
                      void
                      insert(iterator __position, size_type __n, const value_type& __x)
                      {  
                	list __tmp(__n, __x, _M_get_Node_allocator());
                	splice(__position, __tmp);
                      }
                
                      /**
                       *  @brief  Inserts a range into the %list.
                       *  @param  position  An iterator into the %list.
                       *  @param  first  An input iterator.
                       *  @param  last   An input iterator.
                       *
                       *  This function will insert copies of the data in the range [@a
                       *  first,@a last) into the %list before the location specified by
                       *  @a position.
                       *
                       *  This operation is linear in the number of elements inserted and
                       *  does not invalidate iterators and references.
                       */
                      template<typename _InputIterator>
                        void
                        insert(iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                        {
                	  list __tmp(__first, __last, _M_get_Node_allocator());
                	  splice(__position, __tmp);
                	}
                
                      /**
                       *  @brief  Remove element at given position.
                       *  @param  position  Iterator pointing to element to be erased.
                       *  @return  An iterator pointing to the next element (or end()).
                       *
                       *  This function will erase the element at the given position and thus
                       *  shorten the %list by one.
                       *
                       *  Due to the nature of a %list this operation can be done in
                       *  constant time, and only invalidates iterators/references to
                       *  the element being removed.  The user is also cautioned that
                       *  this function only erases the element, and that if the element
                       *  is itself a pointer, the pointed-to memory is not touched in
                       *  any way.  Managing the pointer is the user's responsibility.
                       */
                      iterator
                      erase(iterator __position);
                
                      /**
                       *  @brief  Remove a range of elements.
                       *  @param  first  Iterator pointing to the first element to be erased.
                       *  @param  last  Iterator pointing to one past the last element to be
                       *                erased.
                       *  @return  An iterator pointing to the element pointed to by @a last
                       *           prior to erasing (or end()).
                       *
                       *  This function will erase the elements in the range @a
                       *  [first,last) and shorten the %list accordingly.
                       *
                       *  This operation is linear time in the size of the range and only
                       *  invalidates iterators/references to the element being removed.
                       *  The user is also cautioned that this function only erases the
                       *  elements, and that if the elements themselves are pointers, the
                       *  pointed-to memory is not touched in any way.  Managing the pointer
                       *  is the user's responsibility.
                       */
                      iterator
                      erase(iterator __first, iterator __last)
                      {
                	while (__first != __last)
                	  __first = erase(__first);
                	return __last;
                      }
                
                      /**
                       *  @brief  Swaps data with another %list.
                       *  @param  x  A %list of the same element and allocator types.
                       *
                       *  This exchanges the elements between two lists in constant
                       *  time.  Note that the global std::swap() function is
                       *  specialized such that std::swap(l1,l2) will feed to this
                       *  function.
                       */
                      void
                      swap(list& __x)
                      {
                	_List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node);
                
                	// _GLIBCXX_RESOLVE_LIB_DEFECTS
                	// 431. Swapping containers with unequal allocators.
                	std::__alloc_swap<typename _Base::_Node_alloc_type>::
                	  _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator());
                      }
                
                      /**
                       *  Erases all the elements.  Note that this function only erases
                       *  the elements, and that if the elements themselves are
                       *  pointers, the pointed-to memory is not touched in any way.
                       *  Managing the pointer is the user's responsibility.
                       */
                      void
                      clear()
                      {
                        _Base::_M_clear();
                        _Base::_M_init();
                      }
                
                      // [23.2.2.4] list operations
                      /**
                       *  @brief  Insert contents of another %list.
                       *  @param  position  Iterator referencing the element to insert before.
                       *  @param  x  Source list.
                       *
                       *  The elements of @a x are inserted in constant time in front of
                       *  the element referenced by @a position.  @a x becomes an empty
                       *  list.
                       *
                       *  Requires this != @a x.
                       */
                      void
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      splice(iterator __position, list&& __x)
                #else
                      splice(iterator __position, list& __x)
                #endif
                      {
                	if (!__x.empty())
                	  {
                	    _M_check_equal_allocators(__x);
                
                	    this->_M_transfer(__position, __x.begin(), __x.end());
                	  }
                      }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      void
                      splice(iterator __position, list& __x)
                      { splice(__position, std::move(__x)); }
                #endif
                
                      /**
                       *  @brief  Insert element from another %list.
                       *  @param  position  Iterator referencing the element to insert before.
                       *  @param  x  Source list.
                       *  @param  i  Iterator referencing the element to move.
                       *
                       *  Removes the element in list @a x referenced by @a i and
                       *  inserts it into the current list before @a position.
                       */
                      void
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      splice(iterator __position, list&& __x, iterator __i)
                #else
                      splice(iterator __position, list& __x, iterator __i)
                #endif
                      {
                	iterator __j = __i;
                	++__j;
                	if (__position == __i || __position == __j)
                	  return;
                
                	if (this != &__x)
                	  _M_check_equal_allocators(__x);
                
                	this->_M_transfer(__position, __i, __j);
                      }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      void
                      splice(iterator __position, list& __x, iterator __i)
                      { splice(__position, std::move(__x), __i); }
                #endif
                
                      /**
                       *  @brief  Insert range from another %list.
                       *  @param  position  Iterator referencing the element to insert before.
                       *  @param  x  Source list.
                       *  @param  first  Iterator referencing the start of range in x.
                       *  @param  last  Iterator referencing the end of range in x.
                       *
                       *  Removes elements in the range [first,last) and inserts them
                       *  before @a position in constant time.
                       *
                       *  Undefined if @a position is in [first,last).
                       */
                      void
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      splice(iterator __position, list&& __x, iterator __first,
                	     iterator __last)
                #else
                      splice(iterator __position, list& __x, iterator __first,
                	     iterator __last)
                #endif
                      {
                	if (__first != __last)
                	  {
                	    if (this != &__x)
                	      _M_check_equal_allocators(__x);
                
                	    this->_M_transfer(__position, __first, __last);
                	  }
                      }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      void
                      splice(iterator __position, list& __x, iterator __first, iterator __last)
                      { splice(__position, std::move(__x), __first, __last); }
                #endif
                
                      /**
                       *  @brief  Remove all elements equal to value.
                       *  @param  value  The value to remove.
                       *
                       *  Removes every element in the list equal to @a value.
                       *  Remaining elements stay in list order.  Note that this
                       *  function only erases the elements, and that if the elements
                       *  themselves are pointers, the pointed-to memory is not
                       *  touched in any way.  Managing the pointer is the user's
                       *  responsibility.
                       */
                      void
                      remove(const _Tp& __value);
                
                      /**
                       *  @brief  Remove all elements satisfying a predicate.
                       *  @param  Predicate  Unary predicate function or object.
                       *
                       *  Removes every element in the list for which the predicate
                       *  returns true.  Remaining elements stay in list order.  Note
                       *  that this function only erases the elements, and that if the
                       *  elements themselves are pointers, the pointed-to memory is
                       *  not touched in any way.  Managing the pointer is the user's
                       *  responsibility.
                       */
                      template<typename _Predicate>
                        void
                        remove_if(_Predicate);
                
                      /**
                       *  @brief  Remove consecutive duplicate elements.
                       *
                       *  For each consecutive set of elements with the same value,
                       *  remove all but the first one.  Remaining elements stay in
                       *  list order.  Note that this function only erases the
                       *  elements, and that if the elements themselves are pointers,
                       *  the pointed-to memory is not touched in any way.  Managing
                       *  the pointer is the user's responsibility.
                       */
                      void
                      unique();
                
                      /**
                       *  @brief  Remove consecutive elements satisfying a predicate.
                       *  @param  BinaryPredicate  Binary predicate function or object.
                       *
                       *  For each consecutive set of elements [first,last) that
                       *  satisfy predicate(first,i) where i is an iterator in
                       *  [first,last), remove all but the first one.  Remaining
                       *  elements stay in list order.  Note that this function only
                       *  erases the elements, and that if the elements themselves are
                       *  pointers, the pointed-to memory is not touched in any way.
                       *  Managing the pointer is the user's responsibility.
                       */
                      template<typename _BinaryPredicate>
                        void
                        unique(_BinaryPredicate);
                
                      /**
                       *  @brief  Merge sorted lists.
                       *  @param  x  Sorted list to merge.
                       *
                       *  Assumes that both @a x and this list are sorted according to
                       *  operator<().  Merges elements of @a x into this list in
                       *  sorted order, leaving @a x empty when complete.  Elements in
                       *  this list precede elements in @a x that are equal.
                       */
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      void
                      merge(list&& __x);
                
                      void
                      merge(list& __x)
                      { merge(std::move(__x)); }
                #else
                      void
                      merge(list& __x);
                #endif
                
                      /**
                       *  @brief  Merge sorted lists according to comparison function.
                       *  @param  x  Sorted list to merge.
                       *  @param StrictWeakOrdering Comparison function defining
                       *  sort order.
                       *
                       *  Assumes that both @a x and this list are sorted according to
                       *  StrictWeakOrdering.  Merges elements of @a x into this list
                       *  in sorted order, leaving @a x empty when complete.  Elements
                       *  in this list precede elements in @a x that are equivalent
                       *  according to StrictWeakOrdering().
                       */
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      template<typename _StrictWeakOrdering>
                        void
                        merge(list&&, _StrictWeakOrdering);
                
                      template<typename _StrictWeakOrdering>
                        void
                        merge(list& __x, _StrictWeakOrdering __comp)
                        { merge(std::move(__x), __comp); }
                #else
                      template<typename _StrictWeakOrdering>
                        void
                        merge(list&, _StrictWeakOrdering);
                #endif
                
                      /**
                       *  @brief  Reverse the elements in list.
                       *
                       *  Reverse the order of elements in the list in linear time.
                       */
                      void
                      reverse()
                      { this->_M_impl._M_node._M_reverse(); }
                
                      /**
                       *  @brief  Sort the elements.
                       *
                       *  Sorts the elements of this list in NlogN time.  Equivalent
                       *  elements remain in list order.
                       */
                      void
                      sort();
                
                      /**
                       *  @brief  Sort the elements according to comparison function.
                       *
                       *  Sorts the elements of this list in NlogN time.  Equivalent
                       *  elements remain in list order.
                       */
                      template<typename _StrictWeakOrdering>
                        void
                        sort(_StrictWeakOrdering);
                
                    protected:
                      // Internal constructor functions follow.
                
                      // Called by the range constructor to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
                        { _M_fill_initialize(static_cast<size_type>(__n), __x); }
                
                      // Called by the range constructor to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
                			       __false_type)
                        {
                	  for (; __first != __last; ++__first)
                	    push_back(*__first);
                	}
                
                      // Called by list(n,v,a), and the range constructor when it turns out
                      // to be the same thing.
                      void
                      _M_fill_initialize(size_type __n, const value_type& __x)
                      {
                	for (; __n > 0; --__n)
                	  push_back(__x);
                      }
                
                
                      // Internal assign functions follow.
                
                      // Called by the range assign to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
                        { _M_fill_assign(__n, __val); }
                
                      // Called by the range assign to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
                			   __false_type);
                
                      // Called by assign(n,t), and the range assign when it turns out
                      // to be the same thing.
                      void
                      _M_fill_assign(size_type __n, const value_type& __val);
                
                
                      // Moves the elements from [first,last) before position.
                      void
                      _M_transfer(iterator __position, iterator __first, iterator __last)
                      { __position._M_node->_M_transfer(__first._M_node, __last._M_node); }
                
                      // Inserts new element at position given and with value given.
                #ifndef __GXX_EXPERIMENTAL_CXX0X__
                      void
                      _M_insert(iterator __position, const value_type& __x)
                      {
                        _Node* __tmp = _M_create_node(__x);
                        __tmp->_M_hook(__position._M_node);
                      }
                #else
                     template<typename... _Args>
                       void
                       _M_insert(iterator __position, _Args&&... __args)
                       {
                	 _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
                	 __tmp->_M_hook(__position._M_node);
                       }
                #endif
                
                      // Erases element at position given.
                      void
                      _M_erase(iterator __position)
                      {
                        __position._M_node->_M_unhook();
                        _Node* __n = static_cast<_Node*>(__position._M_node);
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                        _M_get_Node_allocator().destroy(__n);
                #else
                	_M_get_Tp_allocator().destroy(&__n->_M_data);
                #endif
                        _M_put_node(__n);
                      }
                
                      // To implement the splice (and merge) bits of N1599.
                      void
                      _M_check_equal_allocators(list& __x)
                      {
                	if (std::__alloc_neq<typename _Base::_Node_alloc_type>::
                	    _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator()))
                	  __throw_runtime_error(__N("list::_M_check_equal_allocators"));
                      }
                    };
                
                  /**
                   *  @brief  List equality comparison.
                   *  @param  x  A %list.
                   *  @param  y  A %list of the same type as @a x.
                   *  @return  True iff the size and elements of the lists are equal.
                   *
                   *  This is an equivalence relation.  It is linear in the size of
                   *  the lists.  Lists are considered equivalent if their sizes are
                   *  equal, and if corresponding elements compare equal.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
                    {
                      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
                      const_iterator __end1 = __x.end();
                      const_iterator __end2 = __y.end();
                
                      const_iterator __i1 = __x.begin();
                      const_iterator __i2 = __y.begin();
                      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
                	{
                	  ++__i1;
                	  ++__i2;
                	}
                      return __i1 == __end1 && __i2 == __end2;
                    }
                
                  /**
                   *  @brief  List ordering relation.
                   *  @param  x  A %list.
                   *  @param  y  A %list of the same type as @a x.
                   *  @return  True iff @a x is lexicographically less than @a y.
                   *
                   *  This is a total ordering relation.  It is linear in the size of the
                   *  lists.  The elements must be comparable with @c <.
                   *
                   *  See std::lexicographical_compare() for how the determination is made.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
                    { return std::lexicographical_compare(__x.begin(), __x.end(),
                					  __y.begin(), __y.end()); }
                
                  /// Based on operator==
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
                    { return __y < __x; }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
                    { return !(__y < __x); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
                    { return !(__x < __y); }
                
                  /// See std::list::swap().
                  template<typename _Tp, typename _Alloc>
                    inline void
                    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
                    { __x.swap(__y); }
                
                _GLIBCXX_END_NESTED_NAMESPACE
                
                #endif /* _STL_LIST_H */


Top 10 Lines:

     Line      Count

      128        456
      300        100
      303        100
      341        100
      359        100
      418        100
      499        100
       96         75
      102         75
      204         72

Execution Summary:

       10   Executable lines in this file
       10   Lines executed
   100.00   Percent of the file executed

     1278   Total number of line executions
   127.80   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/manager/GgafDx9EffectManager.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                
                GgafDx9Effect* GgafDx9EffectManager::_pEffect_Active = NULL;
                
           1 -> GgafDx9EffectManager::GgafDx9EffectManager(const char* prm_manager_name) :
                    GgafResourceManager<GgafDx9Effect> (prm_manager_name) {
                }
                
                GgafDx9Effect* GgafDx9EffectManager::processCreateResource(char* prm_idstr, void* prm_p) {
                    //U
                    char effect_type = *prm_idstr; //
                    char* effect_name = prm_idstr + 2; //R~
                    GgafDx9Effect* pResourceEffect;
                    switch (effect_type) {
                        case 'D':
                        case 'd':
                        case 'X':
                            pResourceEffect = NEW GgafDx9MeshEffect(effect_name);
                            break;
                        case 'x':
                            pResourceEffect = NEW GgafDx9MeshSetEffect(effect_name);
                            break;
                        case 'G':
                            pResourceEffect = NEW GgafDx9CubeMapMeshEffect(effect_name);
                            break;
                        case 'g':
                            pResourceEffect = NEW GgafDx9CubeMapMeshSetEffect(effect_name);
                            break;
                        case 'A':
                            pResourceEffect = NEW GgafDx9D3DXAniMeshEffect(effect_name);
                            break;
                        case 'M':
                            pResourceEffect = NEW GgafDx9MorphMeshEffect(effect_name);
                            break;
                        case 'H':
                            pResourceEffect = NEW GgafDx9CubeMapMorphMeshEffect(effect_name);
                            break;
                        case 'S':
                            pResourceEffect = NEW GgafDx9SpriteEffect(effect_name);
                            break;
                        case 's':
                            pResourceEffect = NEW GgafDx9SpriteSetEffect(effect_name);
                            break;
                        case 'B':
                            pResourceEffect = NEW GgafDx9BoardEffect(effect_name);
                            break;
                        case 'b':
                            pResourceEffect = NEW GgafDx9BoardSetEffect(effect_name);
                            break;
                        case 'P':
                            pResourceEffect = NEW GgafDx9PointSpriteEffect(effect_name);
                            break;
                        default:
                            TRACE("GgafDx9EffectManager::processCreateResource("<<prm_idstr<<") ");
                            throwGgafCriticalException("GgafDx9EffectManager::processCreateResource("<<prm_idstr<<") GbtFNgm");
                            pResourceEffect = NULL;
                            break;
                    }
                    TRACE3("GgafDx9EffectManager::processCreateResource("<<prm_idstr<<")");
                    return  pResourceEffect;
                }
                
                void GgafDx9EffectManager::onDeviceLostAll() {
                    TRACE3("GgafDx9EffectManager::onDeviceLostAll() start-->");
                    GgafResourceConnection<GgafDx9Effect>* pCurrent = _pFirstConnection;
                    HRESULT hr;
                    while (pCurrent) {
                        hr = pCurrent->refer()->_pID3DXEffect->OnLostDevice();
                        checkDxException(hr, D3D_OK, "GgafDx9EffectManager::onDeviceLostAll GtFNg["<<pCurrent->getIdStr()<<"] OnLostDevice() sB");
                        TRACE3("onDeviceLostAll pCurrent="<<pCurrent->getIdStr() << " OnLostDevice() execute");
                        pCurrent = pCurrent->getNext();
                    }
                    TRACE3("GgafDx9EffectManager::onDeviceLostAll() end<--");
                }
                
                void GgafDx9EffectManager::restoreAll() {
                    TRACE3("GgafDx9EffectManager::restoreAll() start-->");
                    GgafResourceConnection<GgafDx9Effect>* pCurrent = _pFirstConnection;
                    HRESULT hr;
                    while (pCurrent) {
                        hr = pCurrent->refer()->_pID3DXEffect->OnResetDevice();
                        checkDxException(hr, D3D_OK, "GgafDx9EffectManager::restoreAll() GtFNg["<<pCurrent->getIdStr()<<"] OnResetDevice() sB");
                        TRACE3("restoreAll pCurrent="<<pCurrent->getIdStr() << " restoreAll() execute");
                        pCurrent = pCurrent->getNext();
                    }
                    TRACE3("GgafDx9EffectManager::restoreAll() end<--");
                }
                void GgafDx9EffectManager::setParamPerFrameAll() {
                    GgafResourceConnection<GgafDx9Effect>* pCurrent = _pFirstConnection;
                    while (pCurrent) {
                        pCurrent->refer()->setParamPerFrame();
                        pCurrent = pCurrent->getNext();
                    }
                }
                GgafResourceConnection<GgafDx9Effect>* GgafDx9EffectManager::processCreateConnection(char* prm_idstr,
                                                                                                     GgafDx9Effect* prm_pResource) {
                    TRACE3(" GgafDx9EffectManager::processCreateConnection "<<prm_idstr<<" JnB");
                    GgafDx9EffectConnection* pConnection = NEW GgafDx9EffectConnection(prm_idstr, prm_pResource);
                    TRACE3(" GgafDx9EffectManager::processCreateConnection "<<prm_idstr<<" IB");
                    return pConnection;
                }
                


Top 10 Lines:

     Line      Count

        9          1

Execution Summary:

        2   Executable lines in this file
        1   Lines executed
    50.00   Percent of the file executed

        1   Total number of line executions
     0.50   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9Core/include/jp/ggaf/dx9core/manager/GgafDx9EffectManager.h:
                #ifndef GGAFDX9EFFECTMANAGER_H_
                #define GGAFDX9EFFECTMANAGER_H_
                namespace GgafDx9Core {
                
                /**
                 * GgafDx9EffectConnection NX .
                 *  GgafDx9EffectConnection IuWFNgo^AgB
                 * @version 1.00
                 * @since 2009/02/09
                 * @author Masatoshi Tsuge
                 */
                class GgafDx9EffectManager : public GgafCore::GgafResourceManager<GgafDx9Effect> {
                
                public:
                
                    static GgafDx9Effect* _pEffect_Active;
                
                    /**
                     * RXgN^
                     * @param prm_manager_name }l[W(eK{)
                     */
                    GgafDx9EffectManager(const char* prm_manager_name);
                
                    /**
                     * GtFNgIDAGtFNguWFNg .
                     * <pre>
                     * prm_idstr`
                     * prm_idstrA
                     * wGtFNg^Cv  + "/" + fxt@C(gq .fx )x
                     * BGtFNg^Cv
                     * 'D': GgafDx9MeshEffect IuWFNg
                     * 'd': GgafDx9MeshEffect IuWFNg
                     * 'X': GgafDx9MeshEffect IuWFNg
                     * 'x': GgafDx9MeshSetEffect IuWFNg
                     * 'A': GgafDx9D3DXAniMeshEffect IuWFNg
                     * 'M': GgafDx9MorphMeshEffect IuWFNg
                     * 'S': GgafDx9SpriteEffect IuWFNg
                     * 's': GgafDx9SpriteSetEffect IuWFNg
                     * 'B': GgafDx9BoardEffect IuWFNg
                     * 'b': GgafDx9BoardSetEffect IuWFNg
                     *
                     * F"x/LaserChipEffect" B
                     * "LaserChipEffect.fx" GgafDx9MeshSetEffectCX^X B
                     * </pre>
                     * @param prm_idstr GtFNgID
                     * @return GtFNgIuWFNg
                     */
                    GgafDx9Effect* processCreateResource(char* prm_idstr, void* prm_p);
                
                    /**
                     * I[o[Ch
                     */
                    GgafCore::GgafResourceConnection<GgafDx9Effect>* processCreateConnection(char* prm_idstr, GgafDx9Effect* prm_pResource);
                
                    void setParamPerFrameAll();
                
                    void restoreAll();
                
                    void onDeviceLostAll();
                
                
                
                
           2 ->     virtual ~GgafDx9EffectManager() {
                    }
                };
                
                }
                #endif /*GGAFDX9EFFECTMANAGER_H_*/


Top 10 Lines:

     Line      Count

       64          2

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     2.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/util/GgafDx9CollisionPart.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
        3542 -> GgafDx9CollisionPart::GgafDx9CollisionPart() : GgafObject() {
                    _shape_kind = 0;
                    _is_valid_flg = false;
                    _dx = _dy = _dz = 0;
                    _cx = _cy = _cz = 0;
                    _base_cx = _base_cy = _base_cz = 0;
                    _aab_x1 = _aab_y1 = _aab_z1 = _aab_x2 = _aab_y2 = _aab_z2 = 0;
                    _rotX = _rotY = _rotZ = false;
                }
                
        3542 -> GgafDx9CollisionPart::~GgafDx9CollisionPart() {
                    TRACE("GgafDx9CollisionPart::~GgafDx9CollisionPart()");
                }


Top 10 Lines:

     Line      Count

        6       3542
       16       3542

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

     7084   Total number of line executions
  2361.33   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/util/GgafDx9CollisionArea.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
        2562 -> GgafDx9CollisionArea::GgafDx9CollisionArea(int prm_nColliPart) : GgafObject() {
                    if (prm_nColliPart > 0) {
                        _nColliPart = prm_nColliPart;
                        _papColliPart = NEW GgafDx9CollisionPart*[_nColliPart];
                        for (int i = 0; i < _nColliPart; i++) {
                            _papColliPart[i] = NULL;
                        }
                    } else {
                        throwGgafCriticalException("GgafDx9CollisionArea::GgafDx9CollisionArea vfsBprm_nColliPart="<<prm_nColliPart);
                    }
                    _AABB_X1=_AABB_Y1=_AABB_Z1=_AABB_X2=_AABB_Y2=_AABB_Z2 = 0;
                }
                
                void GgafDx9CollisionArea::updateAABB() {
                    _AABB_X1 = _AABB_Y1 = _AABB_Z1 = _AABB_X2 = _AABB_Y2 = _AABB_Z2 = 0;
                    GgafDx9CollisionPart* pColliPart = NULL;
                    for (int i = 0; i < _nColliPart; i++) {
                        pColliPart = _papColliPart[i];
                        if (pColliPart->_is_valid_flg) {
                            if (pColliPart->_aab_x1 < _AABB_X1) {
                                _AABB_X1 = pColliPart->_aab_x1;
                            }
                            if (pColliPart->_aab_y1 < _AABB_Y1) {
                                _AABB_Y1 = pColliPart->_aab_y1;
                            }
                            if (pColliPart->_aab_z1 < _AABB_Z1) {
                                _AABB_Z1 = pColliPart->_aab_z1;
                            }
                
                            if (pColliPart->_aab_x2 > _AABB_X2) {
                                _AABB_X2 = pColliPart->_aab_x2;
                            }
                            if (pColliPart->_aab_y2 > _AABB_Y2) {
                                _AABB_Y2 = pColliPart->_aab_y2;
                            }
                            if (pColliPart->_aab_z2 > _AABB_Z2) {
                                _AABB_Z2 = pColliPart->_aab_z2;
                            }
                        }
                    }
                }
                
        5124 -> GgafDx9CollisionArea::~GgafDx9CollisionArea() {
                    for (int i = 0; i < _nColliPart; i++) {
                        DELETE_POSSIBLE_NULL(_papColliPart[i]);
                    }
                    DELETEARR_IMPOSSIBLE_NULL(_papColliPart);
                
                    TRACE("GgafDx9CollisionArea::~GgafDx9CollisionArea()");
                }


Top 10 Lines:

     Line      Count

       48       5124
        6       2562

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

     7686   Total number of line executions
  2562.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/supporter/GgafDx9Checker.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
        4646 -> GgafDx9Checker::GgafDx9Checker(GgafDx9GeometricActor* prm_pActor) :
                    GgafObject() {
                    _pCollisionArea = NULL;
                    _pActor = prm_pActor;
                    _blown_sgn_vX = 0;
                    _blown_sgn_vY = 0;
                    _blown_sgn_vZ = 0;
                }
                
                
        4647 -> GgafDx9Checker::~GgafDx9Checker() {
                }


Top 10 Lines:

     Line      Count

       16       4647
        6       4646

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

     9293   Total number of line executions
  3097.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/GgafDx9PointSpriteActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                
           1 -> GgafDx9PointSpriteActor::GgafDx9PointSpriteActor(const char* prm_name,
                                                   const char* prm_model_id,
                                                   const char* prm_effect_id,
                                                   const char* prm_technique,
                                                   GgafDx9Checker* prm_pChecker) :
                
                                                       GgafDx9DrawableActor(prm_name,
                                                                            prm_model_id,
                                                                            "P",
                                                                            prm_effect_id,
                                                                            "P",
                                                                            prm_technique,
                                                                            prm_pChecker) {
                    _obj_class |= Obj_GgafDx9PointSpriteActor;
                    _class_name = "GgafDx9PointSpriteActor";
                    _pPointSpriteModel = (GgafDx9PointSpriteModel*)_pGgafDx9Model;
                    _pPointSpriteEffect = (GgafDx9PointSpriteEffect*)_pGgafDx9Effect;
                    _pFunc_calcRotMvWorldMatrix = GgafDx9Util::setWorldMatrix_RxRzRyMv;
                    _pUvFlipper = NEW GgafDx9UvFlipper(this);
                //    _pUvFlipper->setTextureUvRotation(_pPointSpriteModel->_texture_split_rowcol,
                //                                      1.0 / _pPointSpriteModel->_texture_split_rowcol,
                //                                      1.0 / _pPointSpriteModel->_texture_split_rowcol );
                    _pUvFlipper->forcePtnNoRange(0, _pPointSpriteModel->_texture_split_rowcol * _pPointSpriteModel->_texture_split_rowcol - 1);
                    _pUvFlipper->setPtnNo(0);
                    _pUvFlipper->setFlipMethod(NOT_ANIMATED, 1);
                    setZEnable(false);
                    setZWriteEnable(false);
                }
                
                
                void GgafDx9PointSpriteActor::setAlpha(float prm_fAlpha) {
                    _fAlpha = prm_fAlpha;
                    //GgafDx9PointSpriteActorbViVF[_[Qj
                    _paD3DMaterial9[0].Ambient.a = _fAlpha;
                    _paD3DMaterial9[0].Diffuse.a = _fAlpha;
                }
                
                void GgafDx9PointSpriteActor::addAlpha(float prm_fAlpha) {
                    _fAlpha += prm_fAlpha;
                    //GgafDx9PointSpriteActorbViVF[_[Qj
                    _paD3DMaterial9[0].Ambient.a = _fAlpha;
                    _paD3DMaterial9[0].Diffuse.a = _fAlpha;
                }
                
                void GgafDx9PointSpriteActor::processDraw() {
                    ID3DXEffect* pID3DXEffect = _pPointSpriteEffect->_pID3DXEffect;
                    HRESULT hr;
                //    hr = pID3DXEffect->SetMatrix(_pPointSpriteEffect->_h_matView, &P_CAM->_vMatrixView );
                //    checkDxException(hr, D3D_OK, "GgafDx9PointSpriteActor::processDraw() SetMatrix(g_matView) sB");
                    //(*_pFunc_calcRotMvWorldMatrix)(this, _matWorld);
                    hr = pID3DXEffect->SetMatrix(_pPointSpriteEffect->_h_matWorld, &_matWorld );
                    checkDxException(hr, D3D_OK, "GgafDx9PointSpriteActor::processDraw() SetMatrix(g_matWorld) sB");
                    hr = pID3DXEffect->SetFloat(_pPointSpriteEffect->_h_dist_VpFrontPlane, -_fDist_VpPlnFront);
                    checkDxException(hr, D3D_OK, "GgafDx9PointSpriteActor::processDraw() SetFloat(g_h_dist_VpFrontPlane) sB");
                    hr = pID3DXEffect->SetInt(_pPointSpriteEffect->_hUvFlipPtnNo, _pUvFlipper->_pattno_uvflip_now);
                //    _TRACE_("_pUvFlipper->_pattno_uvflip_now="<<_pUvFlipper->_pattno_uvflip_now);
                    checkDxException(hr, D3D_OK, "GgafDx9PointSpriteActor::processDraw() SetInt(_hUvFlipPtnNo) sB");
                    // Zobt@
                    //|CgXvCgON
                    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_POINTSPRITEENABLE, TRUE);
                    //|CgXP[ON
                    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_POINTSCALEENABLE, TRUE);
                    _pPointSpriteModel->draw(this);
                    //|CgXvCgOFF
                    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_POINTSPRITEENABLE, FALSE);
                    //|CgXP[OFF
                    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_POINTSCALEENABLE, FALSE);
                }
                
           1 -> GgafDx9PointSpriteActor::~GgafDx9PointSpriteActor() {
                    DELETE_IMPOSSIBLE_NULL(_pUvFlipper);
                }


Top 10 Lines:

     Line      Count

        7          1
       76          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        2   Total number of line executions
     0.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/ex/GgafDx9SpriteMeshActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
           1 -> GgafDx9SpriteMeshActor::GgafDx9SpriteMeshActor(const char* prm_name,
                                                       const char* prm_model,
                                                       GgafDx9Checker* prm_pChecker) :
                
                                                        GgafDx9MeshActor(prm_name,
                                                                         prm_model,
                                                                         "SpriteMeshEffect",
                                                                         "SpriteMeshTechnique",
                                                                         prm_pChecker) {
                
                    _obj_class |= Obj_GgafDx9SpriteMeshActor;
                    _class_name = "GgafDx9SpriteMeshActor";
                    _pUvFlipper = NEW GgafDx9UvFlipper(this);
                    _pUvFlipper->forcePtnNoRange(0, 1);
                    _pUvFlipper->setPtnNo(0);
                    _pUvFlipper->setFlipMethod(NOT_ANIMATED, 1);
                }
                
                
                void GgafDx9SpriteMeshActor::processDraw() {
                    ID3DXEffect* pID3DXEffect = _pMeshEffect->_pID3DXEffect;
                    HRESULT hr;
                //    hr = pID3DXEffect->SetMatrix(_pMeshEffect->_h_matView, &P_CAM->_vMatrixView );
                //    checkDxException(hr, D3D_OK, "GgafDx9MeshActor::processDraw() SetMatrix(g_matView) sB");
                    //(*_pFunc_calcRotMvWorldMatrix)(this, _matWorld);
                    hr = pID3DXEffect->SetMatrix(_pMeshEffect->_h_matWorld, &_matWorld );
                    checkDxException(hr, D3D_OK, "GgafDx9MeshActor::processDraw() SetMatrix(g_matWorld) sB");
                    float u = 0;
                    float v = 0;
                    _pUvFlipper->getUV(u, v);
                    hr = pID3DXEffect->SetFloat(_pMeshEffect->_h_offset_u, u);
                    checkDxException(hr, D3D_OK, "GgafDx9MeshActor::processDraw() SetMatrix(_h_offset_u) sB");
                    hr = pID3DXEffect->SetFloat(_pMeshEffect->_h_offset_v, v);
                    checkDxException(hr, D3D_OK, "GgafDx9MeshActor::processDraw() SetMatrix(_h_offset_v) sB");
                    _pMeshModel->draw(this);
                
                }
                
                
           1 -> GgafDx9SpriteMeshActor::~GgafDx9SpriteMeshActor() {
                    DELETE_IMPOSSIBLE_NULL(_pUvFlipper);
                }


Top 10 Lines:

     Line      Count

        6          1
       45          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        2   Total number of line executions
     0.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/GgafDx9SpriteActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
          11 -> GgafDx9SpriteActor::GgafDx9SpriteActor(const char* prm_name,
                                                       const char* prm_model_id,
                                                       const char* prm_effect_id,
                                                       const char* prm_technique,
                                                       GgafDx9Checker* prm_pChecker) :
                
                                                           GgafDx9DrawableActor(prm_name,
                                                                                prm_model_id,
                                                                                "S",
                                                                                prm_effect_id,
                                                                                "S",
                                                                                prm_technique,
                                                                                prm_pChecker) {
                    _obj_class |= Obj_GgafDx9SpriteActor;
                    _class_name = "GgafDx9SpriteActor";
                
                    _pSpriteModel = (GgafDx9SpriteModel*)_pGgafDx9Model;
                    _pSpriteEffect = (GgafDx9SpriteEffect*)_pGgafDx9Effect;
                    _pUvFlipper = NEW GgafDx9UvFlipper(this);
                    _pUvFlipper->forcePtnNoRange(0, _pSpriteModel->_pattno_uvflip_Max);
                    _pUvFlipper->setPtnNo(0);
                    _pUvFlipper->setFlipMethod(NOT_ANIMATED, 1);
                    _pFunc_calcRotMvWorldMatrix = GgafDx9Util::setWorldMatrix_RxRzRyMv;
                }
                
                void GgafDx9SpriteActor::processDraw() {
                    ID3DXEffect* pID3DXEffect = _pSpriteEffect->_pID3DXEffect;
                    HRESULT hr;
                //    hr = pID3DXEffect->SetMatrix(_pSpriteEffect->_h_matView, &P_CAM->_vMatrixView );
                //    checkDxException(hr, D3D_OK, "GgafDx9MeshActor::GgafDx9MeshEffect SetMatrix(g_matView) sB");
                    //(*_pFunc_calcRotMvWorldMatrix)(this, _matWorld);
                    hr = pID3DXEffect->SetMatrix(_pSpriteEffect->_h_matWorld, &_matWorld );
                    checkDxException(hr, D3D_OK, "GgafDx9SpriteActor::processDraw SetMatrix(_h_matWorld) sB");
                    hr = pID3DXEffect->SetFloat(_pSpriteEffect->_hAlpha, _fAlpha);
                    checkDxException(hr, D3D_OK, "GgafDx9SpriteActor::processDraw SetFloat(_fAlpha) sB");
                
                //    // Zobt@
                //    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
                //    // Zobt@s
                //    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
                
                    _pSpriteModel->draw(this);
                
                //    // Zobt@L
                //    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
                //    // Zobt@
                //    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
                
                }
                
                void GgafDx9SpriteActor::setAlpha(float prm_fAlpha) {
                    _fAlpha = prm_fAlpha;
                    //A}eADiffuseOW
                    _paD3DMaterial9[0].Ambient.a = _fAlpha;
                    _paD3DMaterial9[0].Diffuse.a = _fAlpha;
                }
                
                void GgafDx9SpriteActor::addAlpha(float prm_fAlpha) {
                    _fAlpha += prm_fAlpha;
                    //A}eADiffuseOW
                    _paD3DMaterial9[0].Ambient.a = _fAlpha;
                    _paD3DMaterial9[0].Diffuse.a = _fAlpha;
                }
                
                
          11 -> GgafDx9SpriteActor::~GgafDx9SpriteActor() {
                    DELETE_IMPOSSIBLE_NULL(_pUvFlipper);
                }


Top 10 Lines:

     Line      Count

        6         11
       71         11

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       22   Total number of line executions
     7.33   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/GgafDx9Camera.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                int GgafDx9Camera::_X_ScreenLeft   = 0;
                int GgafDx9Camera::_X_ScreenRight  = 0;
                int GgafDx9Camera::_Y_ScreenTop    = 0;
                int GgafDx9Camera::_Y_ScreenBottom = 0;
                
                
                
           1 -> GgafDx9Camera::GgafDx9Camera(const char* prm_name, float prm_rad_fovX, float prm_dep) : GgafDx9GeometricActor(prm_name, NULL) {
                    _class_name = "GgafDx9Camera";
                
                    //SfovXl
                    _rad_fovX = prm_rad_fovX;
                    //
                    _rad_half_fovX = _rad_fovX / 2.0f;
                    //AXyNg(w/h)
                    _screen_aspect = (FLOAT)(1.0f * GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH) / GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT));
                    //fovXAXyNgfovYvZ
                    float xzRatio = tan( _rad_fovX/2 );
                    float yRatio = xzRatio / _screen_aspect;
                    _rad_fovY = atan( yRatio )*2.0f;
                    _TRACE_("GgafDx9Camera::GgafDx9Camera AXyNgF"<<_screen_aspect);
                    _TRACE_("GgafDx9Camera::GgafDx9Camera FovX="<<prm_rad_fovX<<" FovY="<<_rad_fovY);
                
                    //
                    _rad_half_fovY = _rad_fovY / 2.0f;
                    //tanl
                    _tan_half_fovY = tan(_rad_fovY/2.0);
                    _tan_half_fovX = tan(_rad_fovX/2.0);
                    //Ju_(0,0,Z)A_(0,0,0)
                    //ZALZ=0XYxLlsNZvJ
                    _cameraZ = -1.0f * ((GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT) / PX_UNIT) / 2.0f) / _tan_half_fovY;
                    _cameraZ_org = _cameraZ;
                    _TRACE_("GgafDx9Camera::GgafDx9Camera Ju(0,0,"<<_cameraZ<<")");
                    _pVecCamFromPoint   = NEW D3DXVECTOR3( 0.0f, 0.0f, (FLOAT)_cameraZ); //u
                    _pVecCamLookatPoint = NEW D3DXVECTOR3( 0.0f, 0.0f, 0.0f ); //
                    _pVecCamUp          = NEW D3DXVECTOR3( 0.0f, 1.0f, 0.0f ); //
                
                    // VIEWs
                    D3DXMatrixLookAtLH(
                       &_vMatrixView,         // pOut [in, out] Z D3DXMATRIX \|C^B
                        _pVecCamFromPoint,    // pEye [in] _` D3DXVECTOR3 \|C^BlAsgpB
                        _pVecCamLookatPoint,  // pAt  [in] J` D3DXVECTOR3 \|C^B
                        _pVecCamUp            // pUp  [in] Jg [hA [0, 1, 0] ` D3DXVECTOR3 \|C^B
                    );
                
                    // esiRcj
                    _dep = prm_dep;
                    _zn = 0.01;
                    _zf = -_cameraZ_org*(_dep+1.0f);
                    _TRACE_("GgafDx9Camera::GgafDx9Camera  ["<<_zn<<" ~ "<<_zf<<"]");
                    D3DXMatrixPerspectiveFovLH(
                            &_vMatrixProj,
                            _rad_fovY,        //ypfBA(0`)
                            _screen_aspect,   //AXyNg  640~480   640/480
                            _zn,             //zn:JNbv(\j0
                            _zf              //zf:JNbv(\j> zn
                            //(FLOAT)(-1.0f*dCam*4)
                            //(-1.0f*fCam)-30,
                            //(-1.0f*fCam)+30
                    );
                    /*
                     //Wne
                     D3DXMatrixOrthoLH(
                     &_vMatrixProj,
                     GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH),
                     GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT),
                     1.0f,
                     GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT)
                     );
                     */
                
                    _X = _pVecCamFromPoint->x * LEN_UNIT * PX_UNIT;
                    _Y = _pVecCamFromPoint->y * LEN_UNIT * PX_UNIT;
                    _Z = _pVecCamFromPoint->z * LEN_UNIT * PX_UNIT;
                
                    _pKuroko->setMvAng(0,0,0);
                    _pKuroko->setMvVelo(0);
                    _pKuroko->setRzMvAngVelo(0);
                    _pKuroko->setRyMvAngVelo(0);
                    _pKuroko->_mv_ang_rz_target_flg = true;
                    _pKuroko->_mv_ang_ry_target_flg = true;
                    setHitAble(false);
                
                    _pViewPoint = NEW GgafDx9CameraViewPoint();
                    _pViewPoint->_X = _pVecCamLookatPoint->x * LEN_UNIT * PX_UNIT;
                    _pViewPoint->_Y = _pVecCamLookatPoint->y * LEN_UNIT * PX_UNIT;
                    _pViewPoint->_Z = _pVecCamLookatPoint->z * LEN_UNIT * PX_UNIT;
                
                    _X_ScreenLeft   = (int)(-1 * GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH) * LEN_UNIT / 2);
                    _X_ScreenRight  = (int)(GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH) * LEN_UNIT / 2);
                    _Y_ScreenTop    = (int)(GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT) * LEN_UNIT / 2);
                    _Y_ScreenBottom = (int)(-1 * GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT) * LEN_UNIT / 2);
                    GgafDx9God::_pID3DDevice9->GetViewport(&_viewport);
                }
                
                void GgafDx9Camera::initialize() {
                    addSubLast(_pViewPoint);
                }
                
                void GgafDx9Camera::processBehavior() {
                    //if (_frame_of_behaving % 2 == 0) { //10t[PvZ
                    HRESULT hr;
                    //XN[SNCAgB
                
                    // _viewport.MinZ / MaxZ A 0 / 1
                    float x1 = (float)_viewport.X;
                    float y1 = (float)_viewport.Y;
                    float x2 = (float)_viewport.X + (float)_viewport.Width;
                    float y2 = (float)_viewport.Y + (float)_viewport.Height;
                
                    // W_i[CX^X
                    _vecNear[0] = D3DXVECTOR3( x1, y1, _viewport.MinZ ); //  ()
                    _vecNear[1] = D3DXVECTOR3( x2, y1, _viewport.MinZ ); // E ()
                    _vecNear[2] = D3DXVECTOR3( x1, y2, _viewport.MinZ ); //  ()
                    _vecNear[3] = D3DXVECTOR3( x2, y2, _viewport.MinZ ); // E ()
                
                    _vecFar[0]  = D3DXVECTOR3( x1, y1, _viewport.MaxZ ); //  ()
                    _vecFar[1]  = D3DXVECTOR3( x2, y1, _viewport.MaxZ ); // E ()
                    _vecFar[2]  = D3DXVECTOR3( x1, y2, _viewport.MaxZ ); //  ()
                    _vecFar[3]  = D3DXVECTOR3( x2, y2, _viewport.MaxZ ); // E ()
                
                
                
                
                    // W_vZ
                    static D3DXMATRIX mat_world;
                    D3DXMatrixIdentity( &mat_world );
                    // [h  r[  e  XN[ ts
                    for( int i = 0; i < 4; ++i ) {
                        D3DXVec3Unproject(
                            &_vecNear[i],   //D3DXVECTOR3 *pOut,              [in, out] Z D3DXVECTOR3 \|C^B
                            &_vecNear[i],   //CONST D3DXVECTOR3 *pV,          [in]  D3DXVECTOR3 \|C^B
                            &_viewport,      //CONST D3DVIEWPORT9 *pViewport,[in] r[|[g\ D3DVIEWPORT9 \|C^B
                            &_vMatrixProj,  //CONST D3DXMATRIX *pProjection,  [in] es\ D3DXMATRIX \|C^B
                            &_vMatrixView,  //CONST D3DXMATRIX *pView,        [in] r[s\ D3DXMATRIX \|C^B
                            &mat_world      //CONST D3DXMATRIX *pWorld        [in] [hs\ D3DXMATRIX \|C^B
                        );
                        D3DXVec3Unproject(
                            &_vecFar[i],
                            &_vecFar[i],
                            &_viewport,
                            &_vMatrixProj,
                            &_vMatrixView,
                            &mat_world
                        );
                    }
                    //-------------------------------------------------
                    //  Fax+by+cz+d
                    //  @xNgFn = (a, b, c)
                    //  1_Ap = (x0, y0, z0) A
                    //  @xNg1_Fd = n*p
                    //
                    //  \A_ p = (x0, y0, z0)A
                    //  p = (x0, y0, z0, 1) A
                    //  Fa*x0 + b*y0 + c*z0 + d*1 = ans
                    //  ans > 0 \Aans < 0 Aans == 0 AB
                    //  DXPlaneDotCoord() As
                    //
                    //  Ap = (x0, y0, z0, 0) vZsA
                    //  pxWB
                    //   D3DXPlaneDotNormal()
                    //-------------------------------------------------
                
                
                     //  ( FANANE )
                    D3DXPlaneNormalize(
                        &_plnTop,
                        D3DXPlaneFromPoints(&_plnTop, &(_vecFar[2]), &(_vecNear[2]), &(_vecNear[3]))
                    );
                    //  ( FANEAN )
                    D3DXPlaneNormalize(
                        &_plnBottom,
                        D3DXPlaneFromPoints(&_plnBottom, &(_vecFar[0]), &(_vecNear[1]), &(_vecNear[0]))
                    );
                    //  ( FANAN )
                    D3DXPlaneNormalize(
                        &_plnLeft,
                        D3DXPlaneFromPoints(&_plnLeft, &(_vecFar[0]), &(_vecNear[0]), &(_vecNear[2]))
                    );
                    // E ( FEANEANE )
                    D3DXPlaneNormalize(
                        &_plnRight,
                        D3DXPlaneFromPoints(&_plnRight, &(_vecFar[1]), &(_vecNear[3]), &(_vecNear[1]))
                    );
                    // O ( NANANE)
                    D3DXPlaneNormalize(
                        &_plnFront,
                        D3DXPlaneFromPoints(&_plnFront, &(_vecNear[2]), &(_vecNear[0]), &(_vecNear[3]))
                    );
                    //  ( FEAFAF)
                    D3DXPlaneNormalize(
                        &_plnBack,
                        D3DXPlaneFromPoints(&_plnBack, &(_vecFar[3]), &(_vecFar[0]), &(_vecFar[2]))
                    );
                
                    // S i{[pgpj
                    _vecVerticalCenter[0] = D3DXVECTOR3( (_vecFar[1].x + _vecFar[0].x)/2.0,
                                                         (_vecFar[1].y + _vecFar[0].y)/2.0,
                                                         (_vecFar[1].z + _vecFar[0].z)/2.0
                                                       );
                    _vecVerticalCenter[1] = D3DXVECTOR3( (_vecNear[3].x + _vecNear[2].x)/2.0,
                                                         (_vecNear[3].y + _vecNear[2].y)/2.0,
                                                         (_vecNear[3].z + _vecNear[2].z)/2.0
                                                       );
                    _vecVerticalCenter[2] = D3DXVECTOR3( (_vecNear[1].x + _vecNear[0].x)/2.0,
                                                         (_vecNear[1].y + _vecNear[0].y)/2.0,
                                                         (_vecNear[1].z + _vecNear[0].z)/2.0
                                                       );
                    D3DXPlaneNormalize(
                        &_plnVerticalCenter,
                        D3DXPlaneFromPoints(&_plnVerticalCenter, &(_vecVerticalCenter[0]),
                                                                 &(_vecVerticalCenter[1]),
                                                                 &(_vecVerticalCenter[2])
                                            )
                    );
                
                    //}
                
                //    xaxis.x           yaxis.x           zaxis.x          0
                //    xaxis.y           yaxis.y           zaxis.y          0
                //    xaxis.z           yaxis.z           zaxis.z          0
                //   -dot(xaxis, eye)  -dot(yaxis, eye)  -dot(zaxis, eye)  1
                
                
                    //_TRACE_(_vMatrixView._14<<","<<_vMatrixView._24<<","<<_vMatrixView._34);
                
                }
                
                
                
                void GgafDx9Camera::processJudgement() {
                    _pVecCamFromPoint->x = _fX;
                    _pVecCamFromPoint->y = _fY;
                    _pVecCamFromPoint->z = _fZ;
                    _pVecCamLookatPoint->x = (1.0f * _pViewPoint->_X ) / LEN_UNIT / PX_UNIT;
                    _pVecCamLookatPoint->y = (1.0f * _pViewPoint->_Y ) / LEN_UNIT / PX_UNIT;
                    _pVecCamLookatPoint->z = (1.0f * _pViewPoint->_Z ) / LEN_UNIT / PX_UNIT;
                    D3DXMatrixLookAtLH(&_vMatrixView, _pVecCamFromPoint, _pVecCamLookatPoint, _pVecCamUp);
                }
                
                void GgafDx9Camera::setViewPoint(int prm_tX, int prm_tY, int prm_tZ) {
                    _pViewPoint->_X = prm_tX;
                    _pViewPoint->_Y = prm_tY;
                    _pViewPoint->_Z = prm_tZ;
                }
                
                void GgafDx9Camera::setViewPoint(GgafDx9GeometricActor* prm_pActor) {
                    _pViewPoint->locateAs(prm_pActor);
                }
                
                
                void GgafDx9Camera::setDefaultPosition() {
                    _X = 0;
                    _Y = 0;
                    _Z = _cameraZ_org * LEN_UNIT * PX_UNIT;
                    _pViewPoint->_X = 0;
                    _pViewPoint->_Y = 0;
                    _pViewPoint->_Z = 0;
                }
                
                
           1 -> GgafDx9Camera::~GgafDx9Camera() {
                    DELETE_IMPOSSIBLE_NULL(_pVecCamFromPoint);
                    DELETE_IMPOSSIBLE_NULL(_pVecCamLookatPoint);
                    DELETE_IMPOSSIBLE_NULL(_pVecCamUp);
                }


Top 10 Lines:

     Line      Count

       13          1
      267          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        2   Total number of line executions
     0.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/util/spline/GgafDx9SplineProgram.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
       ##### -> GgafDx9SplineProgram::GgafDx9SplineProgram(GgafDx9GeometricActor* prm_pActor_target) : GgafObject() {
                    _pActor_target = prm_pActor_target;
                    _sp = NULL;
                    _SPframe = 0;
                    _is_create_sp = false;
                    _rate_X = 1.0;
                    _rate_Y = 1.0;
                    _rate_Z = 1.0;
                    _X_begin = 0;
                    _Y_begin = 0;
                    _Z_begin = 0;
                }
                
       ##### -> GgafDx9SplineProgram::GgafDx9SplineProgram(GgafDx9GeometricActor* prm_pActor_target,
                                                           double prm_paaCriteriaPoints[][3],
                                                           int prm_point_num,
                                                           double prm_accuracy) : GgafObject() {
                    _pActor_target = prm_pActor_target;
                    _sp = NEW GgafDx9Spline3D(prm_paaCriteriaPoints, prm_point_num, prm_accuracy);
                    _SPframe = 0;
                    _is_create_sp = true;
                    _rate_X = 1.0;
                    _rate_Y = 1.0;
                    _rate_Z = 1.0;
                    _X_begin = 0;
                    _Y_begin = 0;
                    _Z_begin = 0;
                    _offset_X = 0;
                    _offset_Y = 0;
                    _offset_Z = 0;
                }
                
         884 -> GgafDx9SplineProgram::GgafDx9SplineProgram(GgafDx9GeometricActor* prm_pActor_target, GgafDx9Spline3D* prm_sp) {
                    _pActor_target = prm_pActor_target;
                    _sp = prm_sp;
                    _is_create_sp = false;
                    _rate_X = 1.0;
                    _rate_Y = 1.0;
                    _rate_Z = 1.0;
                    _X_begin = 0;
                    _Y_begin = 0;
                    _Z_begin = 0;
                    _offset_X = 0;
                    _offset_Y = 0;
                    _offset_Z = 0;
                }
                
                void GgafDx9SplineProgram::setSpline(GgafDx9Spline3D* prm_sp) {
                    _sp = prm_sp;
                    _is_create_sp = false;
                }
                
                void GgafDx9SplineProgram::begin(int prm_option) {
                    if (_sp) {
                        _is_executing = true;
                
                        _SPframe = 0;
                
                        _X_begin = _sp->_X_compute[0]*_rate_X + _offset_X;
                        _Y_begin = _sp->_Y_compute[0]*_rate_Y + _offset_Y;
                        _Z_begin = _sp->_Z_compute[0]*_rate_Z + _offset_Z;
                    }
                }
                
                void GgafDx9SplineProgram::setAbsoluteBeginCoordinate() {
                    _pActor_target->_X = _sp->_X_compute[0]*_rate_X + _offset_X;
                    _pActor_target->_Y = _sp->_Y_compute[0]*_rate_Y + _offset_Y;
                    _pActor_target->_Z = _sp->_Z_compute[0]*_rate_Z + _offset_Z;
                }
                void GgafDx9SplineProgram::behave() {
                
                    if (_is_executing) {
                        //_INDEX
                        int SPPointIndex = _SPframe;
                        if ( SPPointIndex == _sp->_rnum) {
                            //I
                            _is_executing = false;
                            return;
                        }
                
                        _pActor_target->_X = (int)(_sp->_X_compute[SPPointIndex]*_rate_X + _offset_X);
                        _pActor_target->_Y = (int)(_sp->_Y_compute[SPPointIndex]*_rate_Y + _offset_Y);
                        _pActor_target->_Z = (int)(_sp->_Z_compute[SPPointIndex]*_rate_Z + _offset_Z);
                
                        _SPframe++;
                
                    }
                
                }
         884 -> GgafDx9SplineProgram::~GgafDx9SplineProgram() {
                    if (_is_create_sp) {
                        DELETE_IMPOSSIBLE_NULL(_sp);
                    }
                }


Top 10 Lines:

     Line      Count

       38        884
       95        884

Execution Summary:

        5   Executable lines in this file
        4   Lines executed
    80.00   Percent of the file executed

     1768   Total number of line executions
   353.60   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/GgafDx9FormationActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
          15 -> GgafDx9FormationActor::GgafDx9FormationActor(const char* prm_name, frame prm_frame_offset_end) :
                    GgafDx9GeometricActor(prm_name, NULL)
                {
                    _obj_class |= Obj_GgafDx9FormationActor;
                    _class_name = "FormationsActor";
                    _frame_offset_end = prm_frame_offset_end;
                    setHitAble(false);
                    _num_sub = 0;
                }
                
                
                void GgafDx9FormationActor::addSubLast(GgafActor* prm_pSub) {
                
                    if (_pSubFirst == NULL) {
                        //p
                        _pStatus->set(STAT_DEFAULT_ACTOR_KIND, prm_pSub->_pStatus->get(STAT_DEFAULT_ACTOR_KIND));
                
                    } else {
                        if (_pStatus->get(STAT_DEFAULT_ACTOR_KIND) != prm_pSub->_pStatus->get(STAT_DEFAULT_ACTOR_KIND)) {
                            throwGgafCriticalException("GgafActorDispatcher::addSubLast AN^[o^B \n"<<
                                                       "z="<<_pStatus->get(STAT_DEFAULT_ACTOR_KIND)<<"[_pSubFirst="<<_pSubFirst->getName()<<"] \n"<<
                                                       "="<<prm_pSub->_pStatus->get(STAT_DEFAULT_ACTOR_KIND)<<"["<<prm_pSub->getName()<<"]");
                        }
                    }
                    _num_sub++;
                    GgafDx9GeometricActor::addSubLast(prm_pSub);
                }
                
                
                void GgafDx9FormationActor::processBehavior() {
                }
                
                void GgafDx9FormationActor::processJudgement() {
                    if (wasDeclaredEnd() || _will_inactivate_after_flg) {
                        //I
                    } else {
                        if (getSubFirst() == NULL) {
                            sayonara(_frame_offset_end);
                        }
                    }
                }
                
                
                void GgafDx9FormationActor::wasDestroyedFollower(GgafDx9GeometricActor* prm_pActor) {
                    _num_sub--;
                    if (_num_sub == 0) {
                        wasDestroyedFormation(prm_pActor);
                    }
                }
                
                
                
          15 -> GgafDx9FormationActor::~GgafDx9FormationActor() {
                }


Top 10 Lines:

     Line      Count

        6         15
       58         15

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       30   Total number of line executions
    10.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/util/CmRandomNumberGenerator.cpp:
                // vO{AmJ
                // Mersenne Twister@CvOIWiB
                // CmRandomNumberGenerator NXATakayuki HARUKI 
                // Singletonp^[R[hB
                // {R[heACmRandomNumberGenerator ApB
                //
                // wAJFlh\ApB
                //
                //                                         2008/09/09 Masatoshi Tsuge
                //
                // yMersenne Twister Home Pagez
                // http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/mt.html
                // yCmRandomNumberGenerator_E[hz
                // http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/VERSIONS/C-LANG/Singleton.zip
                
                
                //#include "CmRandomNumberGenerator.h"
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                //!< Period Parameter for Mersenne Twister
                #define	MATRIX_A	(0x9908b0dfUL)	//!< constant vector a
                #define	UPPER_MASK	(0x80000000UL)	//!< most significant w-r bits
                #define	LOWER_MASK	(0x7fffffffUL)	//!< least significant r bits
                /**
                 * @file	CmRandomNumberGenerator.cpp
                 * @brief	Random Number Generator CPP file
                 * @author  Takayuki HARUKI (University of Toyama, Japan)
                 * @since	Nov. 2005
                 *
                 */
                CmRandomNumberGenerator* CmRandomNumberGenerator::s_pInstance = NULL;
                
                unsigned long CmRandomNumberGenerator::mt[N];
                int CmRandomNumberGenerator::mti = N + 1;
                
                /******************************************************************************
                 *
                 * 			Constructor
                 *
                 * @author  Takayuki HARUKI (University of Toyama, Japan)
                 * @date	Nov. 2005
                 *
                 ******************************************************************************/
           1 -> CmRandomNumberGenerator::CmRandomNumberGenerator() {
                }
                
                /******************************************************************************
                 *
                 * 			Destructor
                 *
                 * @author  Takayuki HARUKI (University of Toyama, Japan)
                 * @date	Nov. 2005
                 *
                 ******************************************************************************/
           2 -> CmRandomNumberGenerator::~CmRandomNumberGenerator() {
                }
                
                /******************************************************************************
                 *
                 * 			Get Instance
                 *
                 * @return	Instance Pointer
                 * @author  Takayuki HARUKI (University of Toyama, Japan)
                 * @date	Nov. 2005
                 *
                 ******************************************************************************/
                CmRandomNumberGenerator* CmRandomNumberGenerator::getInstance() {
                    if (NULL == s_pInstance) {
                        s_pInstance = NEW CmRandomNumberGenerator();
                    }
                
                    return s_pInstance;
                }
                
                /******************************************************************************
                 *
                 * 			Release Instance
                 *
                 * @author  Takayuki HARUKI (University of Toyama, Japan)
                 * @date	Nov. 2005
                 *
                 ******************************************************************************/
                void CmRandomNumberGenerator::release() {
                    DELETE_POSSIBLE_NULL(s_pInstance);
                }
                
                /******************************************************************************
                 *
                 * 			Get Float Type Random Number [0, 1]
                 *
                 * @return	Float Type Random Number
                 * @author  Takayuki HARUKI (University of Toyama, Japan)
                 * @date	Nov. 2005
                 *
                 ******************************************************************************/
                float CmRandomNumberGenerator::getFloat() {
                    return (float)genrand_real1();
                }
                
                /******************************************************************************
                 *
                 * 			Get Double Type Random Number [0, 1]
                 *
                 * @return	Double Type Random Number
                 * @author  Takayuki HARUKI (University of Toyama, Japan)
                 * @date	Nov. 2005
                 *
                 ******************************************************************************/
                double CmRandomNumberGenerator::getDouble() {
                    return genrand_real1();
                }
                
                /******************************************************************************
                 *
                 * 			Change Seed for Generating Random Numbers
                 *
                 * @param	a_ulSeed	(I)	Seed of Random Generator
                 * @author  Takayuki HARUKI (University of Toyama, Japan)
                 * @date	Nov. 2005
                 *
                 ******************************************************************************/
                void CmRandomNumberGenerator::changeSeed(unsigned long a_ulSeed) {
                    init_genrand(a_ulSeed);
                }
                
                /******************************************************************************
                 * 			Mersenne Twister
                 ******************************************************************************/
                
                /* initializes mt[N] with a seed */
                void CmRandomNumberGenerator::init_genrand(unsigned long s) {
                    mt[0] = s & 0xffffffffUL;
                
                    for (mti = 1; mti < N; mti++) {
                        mt[mti] = (1812433253UL * (mt[mti - 1] ^ (mt[mti - 1] >> 30)) + mti);
                        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
                        /* In the previous versions, MSBs of the seed affect   */
                        /* only MSBs of the array mt[].                        */
                        /* 2002/01/09 modified by Makoto Matsumoto             */
                        mt[mti] &= 0xffffffffUL;
                        /* for >32 bit machines */
                    }
                }
                
                /* generates a random number on [0,0xffffffff]-interval */
                unsigned long CmRandomNumberGenerator::genrand_int32(void) {
                    unsigned long y;
                    static unsigned long mag01[2] = {0x0UL, MATRIX_A};
                    /* mag01[x] = x * MATRIX_A  for x=0,1 */
                
                    if (mti >= N) {
                        /* generate N words at one time */
                        int kk;
                
                        if (mti == N + 1) /* if init_genrand() has not been called, */
                        init_genrand(5489UL); /* a default initial seed is used */
                
                        for (kk = 0; kk < N - M; kk++) {
                            y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
                            mt[kk] = mt[kk + M] ^ (y >> 1) ^ mag01[y & 0x1UL];
                        }
                
                        for (; kk < N - 1; kk++) {
                            y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);
                            mt[kk] = mt[kk + (M - N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
                        }
                
                        y = (mt[N - 1] & UPPER_MASK) | (mt[0] & LOWER_MASK);
                        mt[N - 1] = mt[M - 1] ^ (y >> 1) ^ mag01[y & 0x1UL];
                
                        mti = 0;
                    }
                
                    y = mt[mti++];
                
                    /* Tempering */
                    y ^= (y >> 11);
                    y ^= (y << 7) & 0x9d2c5680UL;
                    y ^= (y << 15) & 0xefc60000UL;
                    y ^= (y >> 18);
                
                    return y;
                }
                
                /* generates a random number on [0,0x7fffffff]-interval */
                long CmRandomNumberGenerator::genrand_int31(void) {
                    return (long)(genrand_int32() >> 1);
                }
                
                /* generates a random number on [0,1]-real-interval */
                double CmRandomNumberGenerator::genrand_real1(void) {
                    return genrand_int32() * (1.0 / 4294967295.0);
                    /* divided by 2^32-1 */
                }
                
                /* generates a random number on [0,1)-real-interval */
                double CmRandomNumberGenerator::genrand_real2(void) {
                    return genrand_int32() * (1.0 / 4294967296.0);
                    /* divided by 2^32 */
                }
                
                /* generates a random number on (0,1)-real-interval */
                double CmRandomNumberGenerator::genrand_real3(void) {
                    return (((double)genrand_int32()) + 0.5) * (1.0 / 4294967296.0);
                    /* divided by 2^32 */
                }


Top 10 Lines:

     Line      Count

       58          2
       47          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/ex/GgafDx9StringBoardActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
          25 -> GgafDx9StringBoardActor::GgafDx9StringBoardActor(const char* prm_name, const char* prm_model)
                  : GgafDx9BoardSetActor(prm_name, prm_model, "StringBoardEffect", "StringBoardTechnique") {
                
                    _class_name = "GgafDx9StringBoardActor";
                    _draw_string = '\0';
                    _len = 0;
                    _buf = NEW char[1024];
                    //ftHgP(px)
                    for (int i = 0; i < 256; i++) {
                        _aWidthPx[i] = (int)(_pBoardSetModel->_fSize_BoardSetModelWidthPx);
                    }
                    _chr_width = (int)(_pBoardSetModel->_fSize_BoardSetModelWidthPx); //P(px)
                }
                
                void GgafDx9StringBoardActor::onCreateModel() {
                
                }
                
                
                void GgafDx9StringBoardActor::update(float prm_x, float prm_y, const char* prm_str) {
                    update(prm_str);
                    _x = prm_x;
                    _y = prm_y;
                }
                
                void GgafDx9StringBoardActor::update(float prm_x, float prm_y, char* prm_str) {
                    update(prm_str);
                    _x = prm_x;
                    _y = prm_y;
                }
                
                void GgafDx9StringBoardActor::update(float prm_x, float prm_y, float prm_z, const char* prm_str) {
                    update(prm_str);
                    _x = prm_x;
                    _y = prm_y;
                    _z = prm_z;
                }
                
                void GgafDx9StringBoardActor::update(float prm_x, float prm_y, float prm_z, char* prm_str) {
                    update(prm_str);
                    _x = prm_x;
                    _y = prm_y;
                    _z = prm_z;
                
                }
                
                void GgafDx9StringBoardActor::update(const char* prm_str) {
                    _draw_string = (char*)prm_str;
                    _len = strlen(prm_str);
                    _len_pack_num = _len/_pBoardSetModel->_set_num;
                    _remainder_len = _len%_pBoardSetModel->_set_num;
                }
                
                void GgafDx9StringBoardActor::update(char* prm_str) {
                    _draw_string = _buf;
                    strcpy(_draw_string, prm_str);
                    _len = strlen(prm_str);
                    _len_pack_num = _len/_pBoardSetModel->_set_num;
                    _remainder_len = _len%_pBoardSetModel->_set_num;
                }
                
                void GgafDx9StringBoardActor::update(float prm_x, float prm_y, float prm_z) {
                    _x = prm_x;
                    _y = prm_y;
                    _z = prm_z;
                }
                
                void GgafDx9StringBoardActor::update(float prm_x, float prm_y) {
                    _x = prm_x;
                    _y = prm_y;
                }
                
                void GgafDx9StringBoardActor::processDraw() {
                    if (_len == 0) {
                        return;
                    }
                    ID3DXEffect* pID3DXEffect = _pBoardSetEffect->_pID3DXEffect;
                    GgafDx9RectUV* pRectUV_Active;
                    HRESULT hr;
                
                    hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahTransformedY[0], _y);
                    checkDxException(hr, D3D_OK, "GgafDx9BoardSetModel::draw SetFloat(_ahTransformedY) sB");
                    hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahDepthZ[0], _z);
                    checkDxException(hr, D3D_OK, "GgafDx9BoardSetModel::draw SetFloat(_ahDepthZ) sB");
                    hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahAlpha[0], _fAlpha);
                    checkDxException(hr, D3D_OK, "GgafDx9BoardSetModel::draw SetFloat(_ahAlpha) sB");
                    int strindex, pattno;
                    int x = _x;
                    int x_tmp = x;
                    for (int pack = 0; pack < _len_pack_num+(_remainder_len == 0 ? 0 : 1); pack++) {
                        _draw_set_num = pack < _len_pack_num ? _pBoardSetModel->_set_num : _remainder_len;
                        for (int i = 0; i < _draw_set_num; i++) {
                            strindex = pack * _pBoardSetModel->_set_num + i;
                            if (_draw_string[strindex] == '\0') {
                                break;
                            } else if (_draw_string[strindex] - ' ' < 0) {
                                pattno = '?' - ' '; //O"?"\
                            } else {
                                pattno = _draw_string[strindex] - ' '; //
                            }
                            //v|[VivZ
                            int w = ((_chr_width - _aWidthPx[(unsigned char)(_draw_string[strindex])]) / 2);
                            x = x_tmp - w;
                            x_tmp = x + _chr_width - w;
                            hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahTransformedX[i], x);
                            checkDxException(hr, D3D_OK, "GgafDx9BoardSetModel::draw SetFloat(_ahTransformedX) sB");
                            pRectUV_Active = _pBoardSetModel->_paRectUV + pattno; //eNX`
                            hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahOffsetU[i], pRectUV_Active->_aUV[0].tu);
                            checkDxException(hr, D3D_OK, "GgafDx9BoardModel::draw() SetFloat(_hOffsetU) sB");
                            hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahOffsetV[i], pRectUV_Active->_aUV[0].tv);
                            checkDxException(hr, D3D_OK, "GgafDx9BoardModel::draw() SetFloat(_hOffsetV) sB");
                        }
                        _pBoardSetModel->draw(this, _draw_set_num);
                    }
                }
                
          25 -> GgafDx9StringBoardActor::~GgafDx9StringBoardActor() {
                    DELETE_IMPOSSIBLE_NULL(_buf);
                }
                


Top 10 Lines:

     Line      Count

        6         25
      122         25

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       50   Total number of line executions
    16.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/GgafDx9D3DXMeshActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                DWORD GgafDx9D3DXMeshActor::FVF = (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_DIFFUSE | D3DFVF_TEX1);
           1 -> GgafDx9D3DXMeshActor::GgafDx9D3DXMeshActor(const char* prm_name,
                                                                 const char* prm_model_id,
                                                                 const char* prm_effect_id,
                                                                 const char* prm_technique,
                                                                 GgafDx9Checker* prm_pChecker) :
                
                                                           GgafDx9DrawableActor(prm_name,
                                                                                prm_model_id,
                                                                                "D",
                                                                                prm_effect_id,
                                                                                "X",
                                                                                prm_technique,
                                                                                prm_pChecker) {
                    _obj_class |= Obj_GgafDx9D3DXMeshActor;
                    _class_name = "GgafDx9D3DXMeshActor";
                    _pD3DXMeshModel = (GgafDx9D3DXMeshModel*)_pGgafDx9Model;
                    _pMeshEffect = (GgafDx9MeshEffect*)_pGgafDx9Effect;
                    _pFunc_calcRotMvWorldMatrix = GgafDx9Util::setWorldMatrix_RxRzRyMv;
                }
                
                void GgafDx9D3DXMeshActor::setAlpha(float prm_fAlpha) {
                    _fAlpha = prm_fAlpha;
                    //GgafDx9D3DXMeshActorbViVF[_[Qj
                    for (DWORD i = 0; i < _pD3DXMeshModel->_dwNumMaterials; i++) {
                        _paD3DMaterial9[i].Ambient.a = _fAlpha;
                        _paD3DMaterial9[i].Diffuse.a = _fAlpha;
                    }
                }
                
                void GgafDx9D3DXMeshActor::addAlpha(float prm_fAlpha) {
                    _fAlpha += prm_fAlpha;
                    //GgafDx9D3DXMeshActorbViVF[_[Qj
                    for (DWORD i = 0; i < _pD3DXMeshModel->_dwNumMaterials; i++) {
                        _paD3DMaterial9[i].Ambient.a = _fAlpha;
                        _paD3DMaterial9[i].Diffuse.a = _fAlpha;
                    }
                }
                
                void GgafDx9D3DXMeshActor::processDraw() {
                    ID3DXEffect* pID3DXEffect = _pMeshEffect->_pID3DXEffect;
                    HRESULT hr;
                //    hr = pID3DXEffect->SetMatrix(_pMeshEffect->_h_matView, &P_CAM->_vMatrixView );
                //    checkDxException(hr, D3D_OK, "GgafDx9D3DXMeshActor::processDraw() SetMatrix(g_matView) sB");
                    //(*_pFunc_calcRotMvWorldMatrix)(this, _matWorld);
                    hr = pID3DXEffect->SetMatrix(_pMeshEffect->_h_matWorld, &_matWorld );
                    checkDxException(hr, D3D_OK, "GgafDx9D3DXMeshActor::processDraw() SetMatrix(g_matWorld) sB");
                
                    // Zobt@L
                    //GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
                    // Zobt@
                    //GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
                
                    _pD3DXMeshModel->draw(this);
                
                    // Zobt@
                    //GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
                    // Zobt@s
                    //GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_ZWRITEENABLE, FALSE );
                
                }
                
           1 -> GgafDx9D3DXMeshActor::~GgafDx9D3DXMeshActor() {
                }


Top 10 Lines:

     Line      Count

        7          1
       68          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        2   Total number of line executions
     0.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/GgafDx9MeshActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                
           4 -> GgafDx9MeshActor::GgafDx9MeshActor(const char* prm_name,
                                                   const char* prm_model_id,
                                                   const char* prm_effect_id,
                                                   const char* prm_technique,
                                                   GgafDx9Checker* prm_pChecker) :
                
                                                       GgafDx9DrawableActor(prm_name,
                                                                            prm_model_id,
                                                                            "X",
                                                                            prm_effect_id,
                                                                            "X",
                                                                            prm_technique,
                                                                            prm_pChecker) {
                    _obj_class |= Obj_GgafDx9MeshActor;
                    _class_name = "GgafDx9MeshActor";
                    _pMeshModel = (GgafDx9MeshModel*)_pGgafDx9Model;
                    _pMeshEffect = (GgafDx9MeshEffect*)_pGgafDx9Effect;
                    _pFunc_calcRotMvWorldMatrix = GgafDx9Util::setWorldMatrix_RxRzRyMv;
                }
                
       ##### -> GgafDx9MeshActor::GgafDx9MeshActor(const char* prm_name,
                                                   const char* prm_model_id,
                                                   const char* prm_model_type,
                                                   const char* prm_effect_id,
                                                   const char* prm_effect_type,
                                                   const char* prm_technique,
                                                   GgafDx9Checker* prm_pChecker) :
                
                                                     GgafDx9DrawableActor(prm_name,
                                                                          prm_model_id,
                                                                          prm_model_type,
                                                                          prm_effect_id,
                                                                          prm_effect_type,
                                                                          prm_technique,
                                                                          prm_pChecker) {
                    _obj_class |= Obj_GgafDx9MeshActor;
                    _class_name = "GgafDx9MeshActor";
                    _pMeshModel = (GgafDx9MeshModel*)_pGgafDx9Model;
                    _pMeshEffect = (GgafDx9MeshEffect*)_pGgafDx9Effect;
                    _pFunc_calcRotMvWorldMatrix = GgafDx9Util::setWorldMatrix_RxRzRyMv;
                }
                
                void GgafDx9MeshActor::setAlpha(float prm_fAlpha) {
                    _fAlpha = prm_fAlpha;
                    //GgafDx9MeshActorbViVF[_[Qj
                    for (DWORD i = 0; i < _pMeshModel->_dwNumMaterials; i++) {
                        _paD3DMaterial9[i].Ambient.a = _fAlpha;
                        _paD3DMaterial9[i].Diffuse.a = _fAlpha;
                    }
                }
                
                void GgafDx9MeshActor::addAlpha(float prm_fAlpha) {
                    _fAlpha += prm_fAlpha;
                    //GgafDx9MeshActorbViVF[_[Qj
                    for (DWORD i = 0; i < _pMeshModel->_dwNumMaterials; i++) {
                        _paD3DMaterial9[i].Ambient.a = _fAlpha;
                        _paD3DMaterial9[i].Diffuse.a = _fAlpha;
                    }
                }
                
                
                void GgafDx9MeshActor::processDraw() {
                    ID3DXEffect* pID3DXEffect = _pMeshEffect->_pID3DXEffect;
                    HRESULT hr;
                //    hr = pID3DXEffect->SetMatrix(_pMeshEffect->_h_matView, &P_CAM->_vMatrixView );
                //    checkDxException(hr, D3D_OK, "GgafDx9MeshActor::processDraw() SetMatrix(g_matView) sB");
                    //(*_pFunc_calcRotMvWorldMatrix)(this, _matWorld);
                    hr = pID3DXEffect->SetMatrix(_pMeshEffect->_h_matWorld, &_matWorld );
                    checkDxException(hr, D3D_OK, "GgafDx9MeshActor::processDraw() SetMatrix(g_matWorld) sB");
                
                    _pMeshModel->draw(this);
                
                }
                
           4 -> GgafDx9MeshActor::~GgafDx9MeshActor() {
                }


Top 10 Lines:

     Line      Count

        7          4
       81          4

Execution Summary:

        4   Executable lines in this file
        3   Lines executed
    75.00   Percent of the file executed

        8   Total number of line executions
     2.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/GgafDx9God.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                
                //TODO:RgBB
                
                
                HWND GgafDx9God::_hWnd = NULL;
                HINSTANCE GgafDx9God::_hInstance = NULL;
                
                IDirect3D9* GgafDx9God::_pID3D9 = NULL;
                IDirect3DDevice9* GgafDx9God::_pID3DDevice9 = NULL;
                D3DLIGHT9 GgafDx9God::_d3dlight9_default;
                D3DLIGHT9 GgafDx9God::_d3dlight9_temp;
                DWORD GgafDx9God::_dwAmbientBrightness_default = 0xff404040;
                
                RECT GgafDx9God::_rectPresentDest;
                
                //double GgafDx9God::_cameraZ = 0;
                //double GgafDx9God::_cameraZ_org = 0;
                //double GgafDx9God::_tan_half_fovY = 0;
                //double GgafDx9God::_dCamHarfXfovTan = 0;
                //double GgafDx9God::_screen_aspect = 0;
                
                
                D3DFILLMODE GgafDx9God::_d3dfillmode = D3DFILL_SOLID;//D3DFILL_WIREFRAME;//D3DFILL_SOLID;
                
                GgafDx9ModelManager* GgafDx9God::_pModelManager = NULL;
                GgafDx9EffectManager* GgafDx9God::_pEffectManager = NULL;
                //int const GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)  = 1024;
                //int const GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT) = 600;
                D3DPRESENT_PARAMETERS GgafDx9God::_structD3dPresent_Parameters;
                bool GgafDx9God::_is_device_lost_flg = false;
                bool GgafDx9God::_adjustGameScreen = false;
                bool GgafDx9God::_FULLSCRREEN = false;
                
           1 -> GgafDx9God::GgafDx9God(HINSTANCE prm_hInstance, HWND _hWnd) :
                    GgafGod() {
                    TRACE("GgafDx9God::GgafDx9God(HINSTANCE prm_hInstance, HWND prmGgafDx9God::_hWnd) ");
                    GgafDx9God::_hWnd = _hWnd;
                    GgafDx9God::_hInstance = prm_hInstance;
                    _is_device_lost_flg = false;
                    _adjustGameScreen = false;
                    CmRandomNumberGenerator::getInstance()->changeSeed(19740722UL); //19740722 Seed
                }
                
                HRESULT GgafDx9God::init() {
                    _FULLSCRREEN = GGAFDX9_PROPERTY(FULL_SCREEN);
                    _rectPresentDest.left = 0;
                    _rectPresentDest.top = 0;
                    _rectPresentDest.right = GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH);
                    _rectPresentDest.bottom = GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT);
                
                    HRESULT hr;
                
                    //IDirect3D9R|[lg
                    if (!(GgafDx9God::_pID3D9 = Direct3DCreate9(D3D_SDK_VERSION))) {
                        throwGgafCriticalException("Direct3DCreate9 s");
                        return E_FAIL; //s
                    }
                    //    //QJE^]BRfXgN^foCXQB
                    //    GgafDx9God::_pID3D9->AddRef();
                    //    GgafDx9God::_pID3D9->AddRef();
                
                    //fXvC[h
                    D3DDISPLAYMODE structD3DDisplayMode; //i[\
                    hr = GgafDx9God::_pID3D9->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &structD3DDisplayMode);
                    checkDxException(hr, D3D_OK, "GetAdapterDisplayMode s");
                
                    //foCX
                    ZeroMemory(&_structD3dPresent_Parameters, sizeof(D3DPRESENT_PARAMETERS));
                    //obNobt@cTCY
                    _structD3dPresent_Parameters.BackBufferHeight = GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT);
                    //_structD3dPresent_Parameters.BackBufferHeight = GGAFDX9_PROPERTY(VIEW_SCREEN_HEIGHT);
                    //obNobt@TCY
                    _structD3dPresent_Parameters.BackBufferWidth = GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH);
                    //_structD3dPresent_Parameters.BackBufferWidth = GGAFDX9_PROPERTY(VIEW_SCREEN_WIDTH);
                    //obNobt@tH[}bg
                    if (_FULLSCRREEN) {
                        _structD3dPresent_Parameters.BackBufferFormat = D3DFMT_X8R8G8B8;//D3DFMT_A8R8G8B8;//D3DFMT_X8R8G8B8; //D3DFMT_R5G6B5;	//tXN[
                    } else {
                        _structD3dPresent_Parameters.BackBufferFormat = structD3DDisplayMode.Format; //EBhE
                        //_structD3dPresent_Parameters.BackBufferFormat = D3DFMT_UNKNOWN;   //[hp
                    }
                
                    //obNobt@
                    _structD3dPresent_Parameters.BackBufferCount = 1;
                
                    //Xbvw
                    if (_FULLSCRREEN) {
                        _structD3dPresent_Parameters.SwapEffect = D3DSWAPEFFECT_DISCARD;
                    } else {
                        _structD3dPresent_Parameters.SwapEffect = D3DSWAPEFFECT_COPY;
                    }
                
                    //EBhEnh
                    _structD3dPresent_Parameters.hDeviceWindow = NULL;
                    //EBhE[h
                    if (_FULLSCRREEN) {
                        _structD3dPresent_Parameters.Windowed = false; //tXN[
                    } else {
                        _structD3dPresent_Parameters.Windowed = true; //EBhE
                    }
                    //[xXeVobt@
                    //_structD3dPresent_Parameters.EnableAutoDepthStencil = FALSE;
                    //_structD3dPresent_Parameters.AutoDepthStencilFormat = 0;
                    _structD3dPresent_Parameters.EnableAutoDepthStencil = 1; //Z obt@
                    _structD3dPresent_Parameters.AutoDepthStencilFormat = D3DFMT_D24S8;//D3DFMT_D16;
                    //0
                    _structD3dPresent_Parameters.Flags = 0;
                    //tXN[tbV[g(EBhE[h0w)
                    if (_FULLSCRREEN) {
                        _structD3dPresent_Parameters.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT; //tXN[
                    } else {
                        _structD3dPresent_Parameters.FullScreen_RefreshRateInHz = 0; //EBhE
                    }
                    //Xbv^C~O
                    if (_FULLSCRREEN) {
                        _structD3dPresent_Parameters.PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;
                    } else {
                        _structD3dPresent_Parameters.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE; //
                        //TODO:Window[hHAD3DPRESENT_INTERVAL_ONE H
                    }
                
                
                    //A`ACAX`FbN
                    UINT32 qualityLevels = D3DMULTISAMPLE_NONE;
                    D3DMULTISAMPLE_TYPE multiSampleType = D3DMULTISAMPLE_NONE;
                
                    //	if( SUCCEEDED(GgafDx9God::_pID3D9->CheckDeviceMultiSampleType(
                    //		D3DADAPTER_DEFAULT,
                    //		D3DDEVTYPE_HAL,
                    //		D3DFMT_A8R8G8B8,
                    //		_FULLSCRREEN ? FALSE : TRUE,
                    //		D3DMULTISAMPLE_2_SAMPLES,
                    //		&qualityLevels) ) )
                    //	{
                    //		if( SUCCEEDED(GgafDx9God::_pID3D9->CheckDeviceMultiSampleType(
                    //			D3DADAPTER_DEFAULT,
                    //			D3DDEVTYPE_HAL,
                    //			D3DFMT_D24S8,
                    //			_FULLSCRREEN ? FALSE : TRUE,
                    //			D3DMULTISAMPLE_2_SAMPLES,
                    //			NULL) ) )
                    //		{
                    //			multiSampleType = D3DMULTISAMPLE_2_SAMPLES;
                    //			_TRACE_("MultiSampleType = D3DMULTISAMPLE_2_SAMPLES");
                    //		}
                    //	}
                    //}`Tv
                    _structD3dPresent_Parameters.MultiSampleType = multiSampleType;//D3DMULTISAMPLE_NONE;
                    //}`Tvix
                    _structD3dPresent_Parameters.MultiSampleQuality = 0;//qualityLevels - (qualityLevels > 0 ? 1 : 0);
                
                    //tXN[o
                    if (_FULLSCRREEN) {
                        int cc = GgafDx9God::_pID3D9->GetAdapterModeCount(D3DADAPTER_DEFAULT,
                                                                          _structD3dPresent_Parameters.BackBufferFormat);
                        if (cc) {
                            D3DDISPLAYMODE adp;
                            for (int i = 0; i < cc; i++) {
                                GgafDx9God::_pID3D9->EnumAdapterModes(D3DADAPTER_DEFAULT,
                                                                      _structD3dPresent_Parameters.BackBufferFormat, i, &adp);
                                if (adp.Format == _structD3dPresent_Parameters.BackBufferFormat && adp.Width
                                        == (UINT)GGAFDX9_PROPERTY(VIEW_SCREEN_WIDTH) && adp.Height
                                        == (UINT)GGAFDX9_PROPERTY(VIEW_SCREEN_HEIGHT)) {
                                    //OK
                                    break;
                                }
                                if (cc == i) {
                                    //vgx
                                    throwGgafCriticalException(GGAFDX9_PROPERTY(VIEW_SCREEN_WIDTH) <<"x"<<GGAFDX9_PROPERTY(VIEW_SCREEN_HEIGHT) << "tXN[[hB");
                                    return E_FAIL;
                                }
                            }
                        } else {
                            throwGgafCriticalException("GetAdapterModeCount s");
                            return E_FAIL;
                        }
                    }
                
                
                    //default
                    UINT AdapterToUse = D3DADAPTER_DEFAULT;
                    D3DDEVTYPE DeviceType = D3DDEVTYPE_HAL;
                    // NVIDIA PerfHUD p begin --------------------------------------------->
                
                #ifdef MY_DEBUG
                
                #if SHIPPING_VERSION
                    // When building a shipping version, disable PerfHUD (opt-out)
                #else
                    _TRACE_("Look for 'NVIDIA PerfHUD' adapter...");
                    // If it is present, override default settings
                    for (UINT Adapter = 0; Adapter < GgafDx9God::_pID3D9->GetAdapterCount(); Adapter++) {
                        D3DADAPTER_IDENTIFIER9 Identifier;
                        HRESULT Res;
                        Res = GgafDx9God::_pID3D9->GetAdapterIdentifier(Adapter, 0, &Identifier);
                        if (strstr(Identifier.Description, "PerfHUD") != 0) {
                            _TRACE_("found NVIDIA PerfHUD!");
                            AdapterToUse = Adapter;
                            DeviceType = D3DDEVTYPE_REF;
                            break;
                        }
                    }
                #endif
                
                #endif
                    // <------------------------------------------------ NVIDIA PerfHUD p end
                
                
                    //foCX GgafDx9God::_pID3DDevice9 B
                    //n[hEFA_AX^CYsfoCXBHAL(pure vp)
                    hr = GgafDx9God::_pID3D9->CreateDevice(AdapterToUse, DeviceType, GgafDx9God::_hWnd,
                                                           D3DCREATE_PUREDEVICE | D3DCREATE_MULTITHREADED,
                //                                           D3DCREATE_MIXED_VERTEXPROCESSING|D3DCREATE_MULTITHREADED,
                //                                           D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_MULTITHREADED,
                                                           &_structD3dPresent_Parameters, &GgafDx9God::_pID3DDevice9);
                
                    if (hr != D3D_OK) {
                        //\tgEFA_An[hEFAX^CYsfoCXBHAL(soft vp)
                        hr = GgafDx9God::_pID3D9->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, GgafDx9God::_hWnd,
                                                               D3DCREATE_SOFTWARE_VERTEXPROCESSING | D3DCREATE_MULTITHREADED,
                                                               &_structD3dPresent_Parameters, &GgafDx9God::_pID3DDevice9);
                        if (hr != D3D_OK) {
                            //\tgEFA_AX^CYsfoCXBREF
                            hr = GgafDx9God::_pID3D9->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_REF, GgafDx9God::_hWnd,
                                                                   D3DCREATE_SOFTWARE_VERTEXPROCESSING | D3DCREATE_MULTITHREADED,
                                                                   &_structD3dPresent_Parameters, &GgafDx9God::_pID3DDevice9);
                            if (hr != D3D_OK) {
                                //foCXs
                                MessageBox(GgafDx9God::_hWnd, TEXT("Direct3Ds"), TEXT("ERROR"), MB_OK | MB_ICONSTOP);
                                return E_FAIL;
                            } else {
                                _TRACE_("GgafDx9God::init foCX REF B");
                            }
                
                        } else {
                            _TRACE_("GgafDx9God::init foCX HAL(soft vp) B");
                        }
                
                    } else {
                        _TRACE_("GgafDx9God::init foCX HAL(mix vp) B");
                    }
                
                    //sNZVF[_[A_VF[_[o[W`FbN
                    D3DCAPS9 caps;
                    GgafDx9God::_pID3D9->GetDeviceCaps(D3DADAPTER_DEFAULT, // [in] fBXvC A_v^B
                                                       //      D3DADAPTER_DEFAULT 
                                                       //      vC} fBXvC A_v^
                                                       D3DDEVTYPE_HAL, // [in] foCXB D3DDEVTYPE^o
                                                       &caps); // [out] foCX\i[
                
                    UINT32 vs_v = caps.VertexShaderVersion;
                    UINT32 ps_v = caps.PixelShaderVersion;
                    _TRACE_("Hardware Vertex Shader Version = "<<D3DSHADER_VERSION_MAJOR(vs_v)<<"_"<<D3DSHADER_VERSION_MINOR(vs_v));
                    _TRACE_("Hardware Pixel Shader Version  = "<<D3DSHADER_VERSION_MAJOR(ps_v)<<"_"<<D3DSHADER_VERSION_MINOR(ps_v));
                    if (vs_v < D3DVS_VERSION(2, 0) || ps_v < D3DPS_VERSION(2, 0)) {
                        _TRACE_("rfIJ[hn[h_VF[_[sNZVF[_[Ao[W 2_0 B");
                        _TRACE_("gprfIJ[hAB");
                    }
                
                    //Kv
                    _pModelManager = NEW GgafDx9ModelManager("ModelManager");
                    _pEffectManager = NEW GgafDx9EffectManager("EffectManager");
                    GgafDx9Util::init(); //[eBeB
                    GgafDx9Input::init(); //DirectInput
                    GgafDx9Sound::init(); //DirectSound
                    _adjustGameScreen = true;
                    return initDx9Device();
                
                }
                
                HRESULT GgafDx9God::initDx9Device() {
                    // ftHgCg
                    /*
                     ZeroMemory(&_d3dlight9_default, sizeof(D3DLIGHT9) );
                     GgafDx9God::_d3dlight9_default.Type = D3DLIGHT_DIRECTIONAL; //sAF
                     GgafDx9God::_d3dlight9_default.Direction = D3DXVECTOR3(-1.0f, -1.0f, 1.0f);
                     GgafDx9God::_d3dlight9_default.Diffuse = D3DXCOLOR(1.0f, 1.0f, 1.0f, 0.0f);
                     GgafDx9God::_d3dlight9_default.Ambient = D3DXCOLOR(1.0f, 1.0f, 1.0f, 0.0f);
                     //sW
                     //GgafDx9God::_d3dlight9_default.Position = D3DXVECTOR3(-1*GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)/2, -1*GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT)/2, -1*GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT)/2);
                     //GgafDx9God::_d3dlight9_default.Range = 1000;
                     */
                
                    //Cg\AVF[_[p[^KvB
                    D3DXVECTOR3 vecDirection(1.0f, -1.0f, 1.0f);
                    D3DXVec3Normalize(&vecDirection, &vecDirection);
                    ZeroMemory(&_d3dlight9_default, sizeof(D3DLIGHT9));
                    GgafDx9God::_d3dlight9_default.Direction = vecDirection;
                    GgafDx9God::_d3dlight9_default.Type = D3DLIGHT_DIRECTIONAL;
                    GgafDx9God::_d3dlight9_default.Diffuse.a = 1.0f;
                    GgafDx9God::_d3dlight9_default.Diffuse.r = 1.0f;
                    GgafDx9God::_d3dlight9_default.Diffuse.g = 1.0f;
                    GgafDx9God::_d3dlight9_default.Diffuse.b = 1.0f;
                
                    GgafDx9God::_d3dlight9_default.Ambient.a = 1.0f;
                    GgafDx9God::_d3dlight9_default.Ambient.r = 0.3f; //ArGgCgSetRenderState(D3DRS_AMBIENT, 0x00303030)
                    GgafDx9God::_d3dlight9_default.Ambient.g = 0.3f;
                    GgafDx9God::_d3dlight9_default.Ambient.b = 0.3f;
                
                    //GgafDx9God::_d3dlight9_default.Range = 1000.0f;
                
                
                    //CgZbg
                    //    GgafDx9God::_pID3DDevice9->SetLight(0, &GgafDx9God::_d3dlight9_default);
                    //CgXCb`ON
                    //    GgafDx9God::_pID3DDevice9->LightEnable(0, TRUE);
                    //GgafDx9God::_pID3DDevice9->LightEnable(0, FALSE);
                    //_CgeiAejL
                    //    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_LIGHTING, TRUE);
                    //_CgeiAej (sNZVF[_[sj
                    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_LIGHTING, FALSE);
                    //_AEArGgCgL`
                    //   GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_AMBIENT, _dwAmbientBrightness_default);
                
                    // Zobt@L
                    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
                    // Zobt@
                    //GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
                    //Zobt@
                    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
                    //Zobt@s
                    //GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_ZWRITEENABLE, FALSE );
                
                    //D3DRENDERSTATE_ZFUNC
                
                    //XeVeXg@
                    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_STENCILFUNC, D3DCMP_ALWAYS); //eXgpX
                    //sXeVl
                    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_STENCILFAIL, D3DSTENCILOP_KEEP); //
                    //ZeXgsXeVl
                    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_STENCILZFAIL, D3DSTENCILOP_KEEP); //
                
                
                    //ivjJO Wn
                    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
                    //JO
                    //GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
                
                    // fBUO
                    //GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_DITHERENABLE, TRUE );
                    // }`TvOA`GCAX(tXN[H)TODO:
                //    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);
                //    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_MULTISAMPLEMASK, 0x00ffffff);
                
                    //sNZPAt@eXgL
                    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
                
                    //VF[_[Rg
                    // At@uhnm
                    //    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
                    //2iKAeNX`\t|SobNobt@i_[^[Qbgj
                    //FZo@
                    //GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_BLENDOPALPHA, D3DBLENDOP_ADD); //D3DBLENDOP_ADD=]]Z
                    //W
                    //    //@(VF[_[e)
                    //    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA); //SRC,D3DBLEND_SRCALPHA=`B|SAt@lZ`BAt@llAZ`B
                    //    //n@(VF[_[e)
                    //    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA); //DIST,D3DBLEND_INVSRCALPHA=`|SAt@lZAn`B
                
                
                    //_J[
                    //GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_COLORVERTEX, FALSE );
                    // GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_COLORVERTEX, TRUE );
                    //    //ArGgA}eAQBi_J[Q D3DMCS_COLOR1)
                    //    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_AMBIENTMATERIALSOURCE, D3DMCS_MATERIAL);
                    //    //ft[YA}eAQBi_J[Q D3DMCS_COLOR1)
                    //    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_MATERIAL);
                    //    //G~bVuA}eAQBi_J[Q D3DMCS_COLOR1)
                    //    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
                    //    //XyLA}eAQBi_J[Q D3DMCS_COLOR1)
                    //    GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_SPECULARMATERIALSOURCE, D3DMCS_MATERIAL);
                
                    //_gp
                    //GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_DIFFUSEMATERIALSOURCE , D3DMCS_COLOR1);
                
                    //
                    //
                    // A`GCAXw
                    //GgafDx9God::_pID3DDevice9->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
                    //GgafDx9God::_pID3DDevice9->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
                    //	TypeD3DSAMP_MINFILTER/D3DSAMP_MAGFILTERig/kj ??D3DTSS_MAGFILTER
                    //	ValueD3DTEXTUREFILTERTYPE^w
                    //	D3DTEXF_POINT@@@@FtB^B`
                    //	D3DTEXF_LINEAR@@@FjAtB^i`j
                    //	D3DTEXF_ANISOTROPIC@FtB^Bn\AgkOg
                    //	D3DTEXF_PYRAMIDALQUADFegtB^BjAtB^
                    //	D3DTEXF_GAUSSIANQUAD FKEVAtB^BtB^
                    //	wB
                
                    //2009/3/4 SetSamplerStateB
                    //SetSamplerStateeNX`TvOijB
                    //A`GCAXAeNX`A`GCAXB
                    //sNZVF[_[SAASB
                
                
                    //A`GCAX_OXe[g
                    //GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS,TRUE);
                    //GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_MULTISAMPLEMASK,0x7fffffff);
                
                    //FSVF[_[Rg
                    //SetTextureStageStatep~H
                    //  1iK|SeNX`@
                    //    //eNX`[FA_J[DIFFUSEFZ
                    //    GgafDx9God::_pID3DDevice9->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
                    //    GgafDx9God::_pID3DDevice9->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
                    //    GgafDx9God::_pID3DDevice9->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
                    //    //eNX`[A_J[Z
                    //    GgafDx9God::_pID3DDevice9->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
                    //    GgafDx9God::_pID3DDevice9->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
                    //    GgafDx9God::_pID3DDevice9->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
                
                
                    //GgafDx9Camera
                    // VIEWiJuj
                    //D3DXMATRIX _vMatrixView; // r[s
                    //    DELETE_POSSIBLE_NULL(_pVecCamFromPoint);
                    //    DELETE_POSSIBLE_NULL(_pVecCamLookatPoint);
                    //    DELETE_POSSIBLE_NULL(_pVecCamUp);
                
                    //GgafDx9Camera
                    // eiRcj
                    //D3DXMATRIX _vMatrixProj; // es
                    //GgafDx9God::_pID3DDevice9->SetTransform(D3DTS_PROJECTION, &_vMatrixProj);
                
                
                    return S_OK;
                }
                
                // J]s
                // r{[hVIEWs
                D3DXMATRIX GgafDx9God::getInvRotateMat() {
                    D3DXMATRIX Inv;
                    //   D3DXMatrixIdentity(&Inv);
                    //   D3DXMatrixLookAtLH(&Inv, &D3DXVECTOR3(0,0,0), &D3DXVECTOR3( 0.0f, 0.0f, 0.0f ), &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ));
                    //   D3DXMatrixInverse(&Inv, NULL, &Inv);
                
                    return Inv;
                }
                
                void GgafDx9God::makeUniversalMaterialize() {
                    TRACE("GgafDx9God::materialize() start");
                    HRESULT hr;
                    if (_is_device_lost_flg) {
                        //foCXXgBfoCX\[XAB
                        if (GgafDx9God::_pID3DDevice9->TestCooperativeLevel() == D3DERR_DEVICENOTRESET) {
                            //Hx~
                            GgafFactory::beginRest();
                            ___EndSynchronized; // <----- rI
                            for (int i = 0; GgafFactory::isResting() == false; i++) {
                                Sleep(60); //H
                                if (i > 2000) {
                                    _TRACE_("GgafDx9God::makeUniversalMaterialize() Q@AHBv");
                                }
                            }
                            //            while (GgafFactory::isResting() == false) { //H
                            //                Sleep(10);
                            //            }
                            ___BeginSynchronized; // ----->rJn
                            _TRACE_("foCXXgBBegin");
                            //GtFNgAfoCXXg
                            GgafDx9God::_pEffectManager->onDeviceLostAll();
                            //f
                            GgafDx9God::_pModelManager->onDeviceLostAll();
                            //Sm[hCxg
                            getUniverse()->throwEventToLowerTree(GGAF_EVENT_ON_DEVICE_LOST, this);
                
                            //foCXZbg
                            hr = GgafDx9God::_pID3DDevice9->Reset(&(GgafDx9God::_structD3dPresent_Parameters));
                            checkDxException(hr, D3D_OK, "GgafDx9God::makeUniversalMaterialize() foCXXgZbgsB");
                
                            //foCX
                            GgafDx9God::initDx9Device();
                            //GtFNgZbg
                            GgafDx9God::_pEffectManager->restoreAll();
                            //f
                            GgafDx9God::_pModelManager->restoreAll();
                            //Sm[hCxg
                            getUniverse()->throwEventToLowerTree(GGAF_EVENT_DEVICE_LOST_RESTORE, this);
                            //O`f
                            GgafDx9God::_pModelManager->_pModelLastDraw = NULL;
                            _is_device_lost_flg = false;
                
                            //HJ
                            GgafFactory::finishRest();
                            _TRACE_("foCXXgBEnd");
                        }
                    } else {
                        //ifoCXXgj
                
                        //obt@NA
                        hr = GgafDx9God::_pID3DDevice9->Clear(0, // NA`
                                                              NULL, // `
                                                              D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, // _O^[Qbg[xobt@NA
                                                              //D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, // _O^[Qbg[xobt@NA
                                                              D3DCOLOR_RGBA(0, 0, 0, 0), //wiNA //D3DCOLOR_XRGB( 0, 0, 0 ), //wiNA
                                                              1.0f, // Zobt@NAl
                                                              0 // XeVobt@NAl
                                );
                        checkDxException(hr, D3D_OK, "GgafDx9God::_pID3DDevice9->Clear() sB");
                
                        //`O
                        hr = GgafDx9God::_pID3DDevice9->BeginScene();
                        checkDxException(hr, D3D_OK, "GgafDx9God::_pID3DDevice9->BeginScene() sB");
                        //SIi`j
                #ifdef MY_DEBUG
                        GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_FILLMODE, GgafDx9God::_d3dfillmode);
                #endif
                        GgafGod::makeUniversalMaterialize(); //X[p[materializes
                        //`
                        hr = GgafDx9God::_pID3DDevice9->EndScene();
                        checkDxException(hr, D3D_OK, "GgafDx9God::_pID3DDevice9->EndScene() sB");
                
                    }
                    TRACE("GgafDx9God::makeUniversalMaterialize() end");
                }
                
                void GgafDx9God::presentUniversalVisualize() {
                    if (_is_device_lost_flg != true) {
                        //obNobt@vC}obt@]
                        //if (GgafDx9God::_pID3DDevice9->Present(NULL,&_rectPresentDest,NULL,NULL) == D3DERR_DEVICELOST) {
                        //        static D3DRASTER_STATUS rs;
                        //        while (SUCCEEDED(GgafDx9God::_pID3DDevice9->GetRasterStatus(0, &rs)) ) {
                        //            if(rs.InVBlank) {
                        //                break; //A
                        //            } else {
                        //                Sleep(1);
                        //            }
                        //        }
                
                        if (_adjustGameScreen) {
                            adjustGameScreen();
                        }
                
                        HRESULT hr;
                //        hr = GgafDx9God::_pID3DDevice9->Present(NULL, NULL, NULL, NULL);
                
                        if (_FULLSCRREEN) {
                            //tXN[
                            hr = GgafDx9God::_pID3DDevice9->Present(NULL, NULL, NULL, NULL);
                        } else {
                            //EBhE[h
                            if (GGAFDX9_PROPERTY(FIXED_VIEW_ASPECT)) {
                                //c[h
                                hr = GgafDx9God::_pID3DDevice9->Present(NULL, &_rectPresentDest, NULL, NULL);
                            } else {
                                //cXgb`[h
                                hr = GgafDx9God::_pID3DDevice9->Present(NULL, NULL, NULL, NULL);
                            }
                        }
                        if (hr == D3DERR_DEVICELOST) {
                            //onfIlI
                            _TRACE_("foCXXgIPresent()");
                            _is_device_lost_flg = true;
                        } else if (hr == D3DERR_DRIVERINTERNALERROR) {
                            //PresentAfoCXXgB
                            _TRACE_("Present() == D3DERR_DRIVERINTERNALERROR!! Reset()Bij");
                            //Hx~
                            GgafFactory::beginRest();
                            ___EndSynchronized; // <----- rI
                            for (int i = 0; GgafFactory::isResting() == false; i++) {
                                Sleep(60); //H
                                if (i > 1000) {
                                    _TRACE_("GgafDx9God::presentUniversalVisualize() 1@AHBbreakBv");
                                }
                            }
                            ___BeginSynchronized; // ----->rJn
                            _TRACE_("D3DERR_DRIVERINTERNALERRORI Begin");
                            //GtFNgAfoCXXg
                            GgafDx9God::_pEffectManager->onDeviceLostAll();
                            //f
                            GgafDx9God::_pModelManager->onDeviceLostAll();
                            //Sm[hCxg
                            getUniverse()->throwEventToLowerTree(GGAF_EVENT_ON_DEVICE_LOST, this);
                            //foCXZbg
                            hr = GgafDx9God::_pID3DDevice9->Reset(&(GgafDx9God::_structD3dPresent_Parameters));
                            checkDxException(hr, D3D_OK, "GgafDx9God::makeUniversalMaterialize() D3DERR_DRIVERINTERNALERROR  Reset() AB");
                            //foCX
                            GgafDx9God::initDx9Device();
                            //GtFNgZbg
                            GgafDx9God::_pEffectManager->restoreAll();
                            //f
                            GgafDx9God::_pModelManager->restoreAll();
                            //Sm[hCxg
                            getUniverse()->throwEventToLowerTree(GGAF_EVENT_DEVICE_LOST_RESTORE, this);
                            //O`f
                            GgafDx9God::_pModelManager->_pModelLastDraw = NULL;
                
                            //HJ
                            GgafFactory::finishRest();
                            _TRACE_("D3DERR_DRIVERINTERNALERRORI End");
                        }
                    }
                }
                
                void GgafDx9God::clean() {
                    if (!_was_cleaned) {
                        _TRACE_("GgafDx9God::clean() begin");
                
                        for( int i=0; i<8; ++i ) { GgafDx9God::_pID3DDevice9->SetTexture( i, NULL ); }
                        for( int i=0; i<8; ++i ) { GgafDx9God::_pID3DDevice9->SetStreamSource( i, NULL, 0, 0 ); }
                        GgafDx9God::_pID3DDevice9->SetIndices( NULL );
                        GgafDx9God::_pID3DDevice9->SetPixelShader( NULL );
                        GgafDx9God::_pID3DDevice9->SetVertexShader( NULL );
                        GgafDx9God::_pID3DDevice9->SetVertexDeclaration( NULL );
                
                        GgafGod::clean();
                
                        CmRandomNumberGenerator::getInstance()->release();
                        //f
                        DELETE_IMPOSSIBLE_NULL(_pModelManager);
                        DELETE_IMPOSSIBLE_NULL(_pEffectManager);
                
                        _TRACE_("GgafDx9God::clean() end");
                    }
                }
                
                void GgafDx9God::adjustGameScreen() {
                     RECT rect;
                    if (GGAFDX9_PROPERTY(FIXED_VIEW_ASPECT)) {
                        HRESULT hr;
                        hr = GgafDx9God::_pID3DDevice9->Clear(0, // NA`
                                                              NULL, // `
                                                              D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, // _O^[Qbg[xobt@NA
                                                              //D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, // _O^[Qbg[xobt@NA
                                                              D3DCOLOR_RGBA(0, 0, 0, 0), //wiNA //D3DCOLOR_XRGB( 0, 0, 0 ), //wiNA
                                                              1.0f, // Zobt@NAl
                                                              0 // XeVobt@NAl
                                );
                        checkDxException(hr, D3D_OK, "GgafDx9God::_pID3DDevice9->Clear() sB");
                        if (::GetClientRect(_hWnd, &rect)) {
                            if (1.0f * rect.right / rect.bottom > 1.0f * GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH) / GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT)) {
                                //
                                float rate = 1.0f * rect.bottom / GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT); //k=c
                                GgafDx9God::_rectPresentDest.left = (rect.right / 2.0f)
                                        - (GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH) * rate / 2.0f);
                                GgafDx9God::_rectPresentDest.top = 0;
                                GgafDx9God::_rectPresentDest.right = (rect.right / 2.0f)
                                        + (GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH) * rate / 2.0f);
                                GgafDx9God::_rectPresentDest.bottom = GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT) * rate;
                            } else {
                                //c
                                float rate = 1.0f * rect.right / GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH); //k=
                                GgafDx9God::_rectPresentDest.left = 0;
                                GgafDx9God::_rectPresentDest.top = (rect.bottom / 2.0f)
                                        - (GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT) * rate / 2.0f);
                                GgafDx9God::_rectPresentDest.right = GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH) * rate;
                                GgafDx9God::_rectPresentDest.bottom = (rect.bottom / 2.0f)
                                        + (GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT) * rate / 2.0f);
                            }
                            _adjustGameScreen = false;
                        }
                    } else {
                        if (::GetClientRect(_hWnd, &rect)) {
                            GgafDx9God::_rectPresentDest.top = rect.top;
                            GgafDx9God::_rectPresentDest.left = rect.left;
                            GgafDx9God::_rectPresentDest.right = rect.right;
                            GgafDx9God::_rectPresentDest.bottom = rect.bottom;
                            _adjustGameScreen = false;
                        }
                    }
                    GgafDx9God::_pID3DDevice9->GetViewport(&(P_CAM->_viewport));
                }
                
                //void GgafDx9God::adjustGameScreen() {
                //     RECT rect;
                //    if (GGAFDX9_PROPERTY(FIXED_VIEW_ASPECT)) {
                //
                //        D3DVIEWPORT9 vClient;
                //        vClient.MinZ = 0.0f;
                //        vClient.MaxZ = 1.0f;
                //        vClient.X = (DWORD)0;
                //        vClient.Y = (DWORD)0;
                //        vClient.Width = (DWORD)(GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH));
                //        vClient.Height = (DWORD)(GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT));
                //        _pID3DDevice9->SetViewport(&vClient);
                //        HRESULT hr;
                //        hr = GgafDx9God::_pID3DDevice9->Clear(0, // NA`
                //                                              NULL, // `
                //                                              D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, // _O^[Qbg[xobt@NA
                //                                              //D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, // _O^[Qbg[xobt@NA
                //                                              D3DCOLOR_RGBA(0, 0, 0, 0), //wiNA //D3DCOLOR_XRGB( 0, 0, 0 ), //wiNA
                //                                              1.0f, // Zobt@NAl
                //                                              0 // XeVobt@NAl
                //                );
                //        checkDxException(hr, D3D_OK, "GgafDx9God::_pID3DDevice9->Clear() sB");
                //
                //
                //        if (::GetClientRect(_hWnd, &rect)) {
                //            D3DVIEWPORT9 vp;    //r[|[g
                //            vp.MinZ = 0.0f;
                //            vp.MaxZ = 1.0f;
                //            double aspect_client = 1.0 * rect.right / rect.bottom;
                //            double aspect_buffer = 1.0 * GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH) / GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT);
                ////            _TRACE_("aspect_client = "<<aspect_client<<" aspect_buffer="<<aspect_buffer);
                //            if (aspect_client > aspect_buffer) {
                //                //
                //                float rate = (1.0 * GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH) / GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT) / (1.0 *rect.right / rect.bottom));
                //                vp.X = (DWORD)((GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH) / 2.0) - (GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH) * rate / 2.0)) ;
                //                vp.Y = (DWORD)0;
                //                vp.Width = (DWORD)(GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH) * rate);
                //                vp.Height = (DWORD)(GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT));
                //            } else {
                //                //c
                //                float rate = (1.0 * GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT) / GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH) / (1.0 *rect.bottom / rect.right));
                //                vp.X = (DWORD)0;
                //                vp.Y = (DWORD)((GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT) / 2.0) - (GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT) * rate / 2.0)) ;;
                //                vp.Width = (DWORD)(GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH));
                //                vp.Height = (DWORD)(GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT) * rate);
                //
                //            }
                ////            _TRACE_("new vp="<<vp.X<<","<<vp.Y<<","<<vp.Width<<","<<vp.Height);
                //            _pID3DDevice9->SetViewport(&vp);
                //            _adjustGameScreen = false;
                //        }
                //    } else {
                //        if (::GetClientRect(_hWnd, &rect)) {
                //            GgafDx9God::_rectPresentDest.top = rect.top;
                //            GgafDx9God::_rectPresentDest.left = rect.left;
                //            GgafDx9God::_rectPresentDest.right = rect.right;
                //            GgafDx9God::_rectPresentDest.bottom = rect.bottom;
                //            _adjustGameScreen = false;
                //        }
                //    }
                //}
                
           1 -> GgafDx9God::~GgafDx9God() {
                
                    clean();
                    _was_cleaned = true;
                
                    //DirectSound
                    GgafDx9Sound::release();
                    //DirectInput
                    GgafDx9Input::release();
                    _TRACE_("_pID3DDevice9 [");
                    Sleep(60);
                    RELEASE_IMPOSSIBLE_NULL(_pID3DDevice9); //{Kv
                    RELEASE_IMPOSSIBLE_NULL(_pID3D9);
                //    tXN[IAu[XN[B
                //    gsB
                //    VISTA, GeForce go 7600 iJ}VAHP DV9200) NB
                //    NBrfIJ[hhCoADV9200LHI
                
                
                }


Top 10 Lines:

     Line      Count

       39          1
      731          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        2   Total number of line executions
     0.67   Average executions per line


*** File C:/Program Files/Microsoft DirectX SDK (February 2010)/Include/d3dx9math.inl:
                //////////////////////////////////////////////////////////////////////////////
                //
                //  Copyright (C) Microsoft Corporation.  All Rights Reserved.
                //
                //  File:       d3dx9math.inl
                //  Content:    D3DX math inline functions
                //
                //////////////////////////////////////////////////////////////////////////////
                
                #ifndef __D3DX9MATH_INL__
                #define __D3DX9MATH_INL__
                
                //===========================================================================
                //
                // Inline Class Methods
                //
                //===========================================================================
                
                #ifdef __cplusplus
                
                //--------------------------
                // Float16
                //--------------------------
                
                D3DXINLINE
                D3DXFLOAT16::D3DXFLOAT16( FLOAT f )
                {
                    D3DXFloat32To16Array(this, &f, 1);
                }
                
                D3DXINLINE
                D3DXFLOAT16::D3DXFLOAT16( CONST D3DXFLOAT16& f )
                {
                    value = f.value;
                }
                
                // casting
                D3DXINLINE
                D3DXFLOAT16::operator FLOAT ()
                {
                    FLOAT f;
                    D3DXFloat16To32Array(&f, this, 1);
                    return f;
                }
                
                // binary operators
                D3DXINLINE BOOL
                D3DXFLOAT16::operator == ( CONST D3DXFLOAT16& f ) const
                {
                    return value == f.value;
                }
                
                D3DXINLINE BOOL
                D3DXFLOAT16::operator != ( CONST D3DXFLOAT16& f ) const
                {
                    return value != f.value;
                }
                
                
                //--------------------------
                // 2D Vector
                //--------------------------
                
                D3DXINLINE
                D3DXVECTOR2::D3DXVECTOR2( CONST FLOAT *pf )
                {
                #ifdef D3DX_DEBUG
                    if(!pf)
                        return;
                #endif
                
                    x = pf[0];
                    y = pf[1];
                }
                
                D3DXINLINE
                D3DXVECTOR2::D3DXVECTOR2( CONST D3DXFLOAT16 *pf )
                {
                #ifdef D3DX_DEBUG
                    if(!pf)
                        return;
                #endif
                
                    D3DXFloat16To32Array(&x, pf, 2);    
                }
                
                D3DXINLINE
                D3DXVECTOR2::D3DXVECTOR2( FLOAT fx, FLOAT fy )
                {
                    x = fx;
                    y = fy;
                }
                
                
                // casting
                D3DXINLINE
                D3DXVECTOR2::operator FLOAT* ()
                {
                    return (FLOAT *) &x;
                }
                
                D3DXINLINE
                D3DXVECTOR2::operator CONST FLOAT* () const
                {
                    return (CONST FLOAT *) &x;
                }
                
                
                // assignment operators
                D3DXINLINE D3DXVECTOR2&
                D3DXVECTOR2::operator += ( CONST D3DXVECTOR2& v )
                {
                    x += v.x;
                    y += v.y;
                    return *this;
                }
                
                D3DXINLINE D3DXVECTOR2&
                D3DXVECTOR2::operator -= ( CONST D3DXVECTOR2& v )
                {
                    x -= v.x;
                    y -= v.y;
                    return *this;
                }
                
                D3DXINLINE D3DXVECTOR2&
                D3DXVECTOR2::operator *= ( FLOAT f )
                {
                    x *= f;
                    y *= f;
                    return *this;
                }
                
                D3DXINLINE D3DXVECTOR2&
                D3DXVECTOR2::operator /= ( FLOAT f )
                {
                    FLOAT fInv = 1.0f / f;
                    x *= fInv;
                    y *= fInv;
                    return *this;
                }
                
                
                // unary operators
                D3DXINLINE D3DXVECTOR2
                D3DXVECTOR2::operator + () const
                {
                    return *this;
                }
                
                D3DXINLINE D3DXVECTOR2
                D3DXVECTOR2::operator - () const
                {
                    return D3DXVECTOR2(-x, -y);
                }
                
                
                // binary operators
                D3DXINLINE D3DXVECTOR2
                D3DXVECTOR2::operator + ( CONST D3DXVECTOR2& v ) const
                {
                    return D3DXVECTOR2(x + v.x, y + v.y);
                }
                
                D3DXINLINE D3DXVECTOR2
                D3DXVECTOR2::operator - ( CONST D3DXVECTOR2& v ) const
                {
                    return D3DXVECTOR2(x - v.x, y - v.y);
                }
                
                D3DXINLINE D3DXVECTOR2
                D3DXVECTOR2::operator * ( FLOAT f ) const
                {
                    return D3DXVECTOR2(x * f, y * f);
                }
                
                D3DXINLINE D3DXVECTOR2
                D3DXVECTOR2::operator / ( FLOAT f ) const
                {
                    FLOAT fInv = 1.0f / f;
                    return D3DXVECTOR2(x * fInv, y * fInv);
                }
                
                D3DXINLINE D3DXVECTOR2
                operator * ( FLOAT f, CONST D3DXVECTOR2& v )
                {
                    return D3DXVECTOR2(f * v.x, f * v.y);
                }
                
                D3DXINLINE BOOL
                D3DXVECTOR2::operator == ( CONST D3DXVECTOR2& v ) const
                {
                    return x == v.x && y == v.y;
                }
                
                D3DXINLINE BOOL
                D3DXVECTOR2::operator != ( CONST D3DXVECTOR2& v ) const
                {
                    return x != v.x || y != v.y;
                }
                
                
                
                //--------------------------
                // 2D Vector (16 bit)
                //--------------------------
                
                D3DXINLINE
                D3DXVECTOR2_16F::D3DXVECTOR2_16F( CONST FLOAT *pf )
                {
                #ifdef D3DX_DEBUG
                    if(!pf)
                        return;
                #endif
                
                    D3DXFloat32To16Array(&x, pf, 2);
                }
                
                D3DXINLINE
                D3DXVECTOR2_16F::D3DXVECTOR2_16F( CONST D3DXFLOAT16 *pf )
                {
                #ifdef D3DX_DEBUG
                    if(!pf)
                        return;
                #endif
                
                    *((DWORD *) &x) = *((DWORD *) &pf[0]);
                }
                
                D3DXINLINE
                D3DXVECTOR2_16F::D3DXVECTOR2_16F( CONST D3DXFLOAT16 &fx, CONST D3DXFLOAT16 &fy )
                {
                    x = fx;
                    y = fy;
                }
                
                
                // casting
                D3DXINLINE
                D3DXVECTOR2_16F::operator D3DXFLOAT16* ()
                {
                    return (D3DXFLOAT16*) &x;
                }
                
                D3DXINLINE
                D3DXVECTOR2_16F::operator CONST D3DXFLOAT16* () const
                {
                    return (CONST D3DXFLOAT16*) &x;
                }
                
                
                // binary operators
                D3DXINLINE BOOL 
                D3DXVECTOR2_16F::operator == ( CONST D3DXVECTOR2_16F &v ) const
                {
                    return *((DWORD *) &x) == *((DWORD *) &v.x);
                }
                
                D3DXINLINE BOOL 
                D3DXVECTOR2_16F::operator != ( CONST D3DXVECTOR2_16F &v ) const
                {
                    return *((DWORD *) &x) != *((DWORD *) &v.x);
                }
                
                
                //--------------------------
                // 3D Vector
                //--------------------------
                D3DXINLINE
                D3DXVECTOR3::D3DXVECTOR3( CONST FLOAT *pf )
                {
                #ifdef D3DX_DEBUG
                    if(!pf)
                        return;
                #endif
                
                    x = pf[0];
                    y = pf[1];
                    z = pf[2];
                }
                
                D3DXINLINE
                D3DXVECTOR3::D3DXVECTOR3( CONST D3DVECTOR& v )
                {
                    x = v.x;
                    y = v.y;
                    z = v.z;
                }
                
                D3DXINLINE
                D3DXVECTOR3::D3DXVECTOR3( CONST D3DXFLOAT16 *pf )
                {
                #ifdef D3DX_DEBUG
                    if(!pf)
                        return;
                #endif
                
                    D3DXFloat16To32Array(&x, pf, 3);
                }
                
                D3DXINLINE
      221052 -> D3DXVECTOR3::D3DXVECTOR3( FLOAT fx, FLOAT fy, FLOAT fz )
                {
                    x = fx;
                    y = fy;
                    z = fz;
                }
                
                
                // casting
                D3DXINLINE
                D3DXVECTOR3::operator FLOAT* ()
                {
                    return (FLOAT *) &x;
                }
                
                D3DXINLINE
                D3DXVECTOR3::operator CONST FLOAT* () const
                {
                    return (CONST FLOAT *) &x;
                }
                
                
                // assignment operators
                D3DXINLINE D3DXVECTOR3&
                D3DXVECTOR3::operator += ( CONST D3DXVECTOR3& v )
                {
                    x += v.x;
                    y += v.y;
                    z += v.z;
                    return *this;
                }
                
                D3DXINLINE D3DXVECTOR3&
                D3DXVECTOR3::operator -= ( CONST D3DXVECTOR3& v )
                {
                    x -= v.x;
                    y -= v.y;
                    z -= v.z;
                    return *this;
                }
                
                D3DXINLINE D3DXVECTOR3&
                D3DXVECTOR3::operator *= ( FLOAT f )
                {
                    x *= f;
                    y *= f;
                    z *= f;
                    return *this;
                }
                
                D3DXINLINE D3DXVECTOR3&
                D3DXVECTOR3::operator /= ( FLOAT f )
                {
                    FLOAT fInv = 1.0f / f;
                    x *= fInv;
                    y *= fInv;
                    z *= fInv;
                    return *this;
                }
                
                
                // unary operators
                D3DXINLINE D3DXVECTOR3
                D3DXVECTOR3::operator + () const
                {
                    return *this;
                }
                
                D3DXINLINE D3DXVECTOR3
                D3DXVECTOR3::operator - () const
                {
                    return D3DXVECTOR3(-x, -y, -z);
                }
                
                
                // binary operators
                D3DXINLINE D3DXVECTOR3
                D3DXVECTOR3::operator + ( CONST D3DXVECTOR3& v ) const
                {
                    return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);
                }
                
                D3DXINLINE D3DXVECTOR3
                D3DXVECTOR3::operator - ( CONST D3DXVECTOR3& v ) const
                {
                    return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);
                }
                
                D3DXINLINE D3DXVECTOR3
                D3DXVECTOR3::operator * ( FLOAT f ) const
                {
                    return D3DXVECTOR3(x * f, y * f, z * f);
                }
                
                D3DXINLINE D3DXVECTOR3
                D3DXVECTOR3::operator / ( FLOAT f ) const
                {
                    FLOAT fInv = 1.0f / f;
                    return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);
                }
                
                
                D3DXINLINE D3DXVECTOR3
                operator * ( FLOAT f, CONST struct D3DXVECTOR3& v )
                {
                    return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);
                }
                
                
                D3DXINLINE BOOL
                D3DXVECTOR3::operator == ( CONST D3DXVECTOR3& v ) const
                {
                    return x == v.x && y == v.y && z == v.z;
                }
                
                D3DXINLINE BOOL
                D3DXVECTOR3::operator != ( CONST D3DXVECTOR3& v ) const
                {
                    return x != v.x || y != v.y || z != v.z;
                }
                
                
                
                //--------------------------
                // 3D Vector (16 bit)
                //--------------------------
                
                D3DXINLINE
                D3DXVECTOR3_16F::D3DXVECTOR3_16F( CONST FLOAT *pf )
                {
                #ifdef D3DX_DEBUG
                    if(!pf)
                        return;
                #endif
                
                    D3DXFloat32To16Array(&x, pf, 3);
                }
                
                D3DXINLINE
                D3DXVECTOR3_16F::D3DXVECTOR3_16F( CONST D3DVECTOR& v )
                {
                    D3DXFloat32To16Array(&x, &v.x, 1);
                    D3DXFloat32To16Array(&y, &v.y, 1);
                    D3DXFloat32To16Array(&z, &v.z, 1);
                }
                
                D3DXINLINE
                D3DXVECTOR3_16F::D3DXVECTOR3_16F( CONST D3DXFLOAT16 *pf )
                {
                #ifdef D3DX_DEBUG
                    if(!pf)
                        return;
                #endif
                
                    *((DWORD *) &x) = *((DWORD *) &pf[0]);
                    *((WORD  *) &z) = *((WORD  *) &pf[2]);
                }
                
                D3DXINLINE
                D3DXVECTOR3_16F::D3DXVECTOR3_16F( CONST D3DXFLOAT16 &fx, CONST D3DXFLOAT16 &fy, CONST D3DXFLOAT16 &fz )
                {
                    x = fx;
                    y = fy;
                    z = fz;
                }
                
                
                // casting
                D3DXINLINE
                D3DXVECTOR3_16F::operator D3DXFLOAT16* ()
                {
                    return (D3DXFLOAT16*) &x;
                }
                
                D3DXINLINE
                D3DXVECTOR3_16F::operator CONST D3DXFLOAT16* () const
                {
                    return (CONST D3DXFLOAT16*) &x;
                }
                
                
                // binary operators
                D3DXINLINE BOOL 
                D3DXVECTOR3_16F::operator == ( CONST D3DXVECTOR3_16F &v ) const
                {
                    return *((DWORD *) &x) == *((DWORD *) &v.x) &&
                           *((WORD  *) &z) == *((WORD  *) &v.z);
                }
                
                D3DXINLINE BOOL 
                D3DXVECTOR3_16F::operator != ( CONST D3DXVECTOR3_16F &v ) const
                {
                    return *((DWORD *) &x) != *((DWORD *) &v.x) ||
                           *((WORD  *) &z) != *((WORD  *) &v.z);
                }
                
                
                //--------------------------
                // 4D Vector
                //--------------------------
                D3DXINLINE
                D3DXVECTOR4::D3DXVECTOR4( CONST FLOAT *pf )
                {
                #ifdef D3DX_DEBUG
                    if(!pf)
                        return;
                #endif
                
                    x = pf[0];
                    y = pf[1];
                    z = pf[2];
                    w = pf[3];
                }
                
                D3DXINLINE
                D3DXVECTOR4::D3DXVECTOR4( CONST D3DXFLOAT16 *pf )
                {
                #ifdef D3DX_DEBUG
                    if(!pf)
                        return;
                #endif
                
                    D3DXFloat16To32Array(&x, pf, 4);
                }
                
                D3DXINLINE
                D3DXVECTOR4::D3DXVECTOR4( CONST D3DVECTOR& v, FLOAT f )
                {
                    x = v.x;
                    y = v.y;
                    z = v.z;
                    w = f;
                }
                
                D3DXINLINE
                D3DXVECTOR4::D3DXVECTOR4( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
                {
                    x = fx;
                    y = fy;
                    z = fz;
                    w = fw;
                }
                
                
                // casting
                D3DXINLINE
                D3DXVECTOR4::operator FLOAT* ()
                {
                    return (FLOAT *) &x;
                }
                
                D3DXINLINE
                D3DXVECTOR4::operator CONST FLOAT* () const
                {
                    return (CONST FLOAT *) &x;
                }
                
                
                // assignment operators
                D3DXINLINE D3DXVECTOR4&
                D3DXVECTOR4::operator += ( CONST D3DXVECTOR4& v )
                {
                    x += v.x;
                    y += v.y;
                    z += v.z;
                    w += v.w;
                    return *this;
                }
                
                D3DXINLINE D3DXVECTOR4&
                D3DXVECTOR4::operator -= ( CONST D3DXVECTOR4& v )
                {
                    x -= v.x;
                    y -= v.y;
                    z -= v.z;
                    w -= v.w;
                    return *this;
                }
                
                D3DXINLINE D3DXVECTOR4&
                D3DXVECTOR4::operator *= ( FLOAT f )
                {
                    x *= f;
                    y *= f;
                    z *= f;
                    w *= f;
                    return *this;
                }
                
                D3DXINLINE D3DXVECTOR4&
                D3DXVECTOR4::operator /= ( FLOAT f )
                {
                    FLOAT fInv = 1.0f / f;
                    x *= fInv;
                    y *= fInv;
                    z *= fInv;
                    w *= fInv;
                    return *this;
                }
                
                
                // unary operators
                D3DXINLINE D3DXVECTOR4
                D3DXVECTOR4::operator + () const
                {
                    return *this;
                }
                
                D3DXINLINE D3DXVECTOR4
                D3DXVECTOR4::operator - () const
                {
                    return D3DXVECTOR4(-x, -y, -z, -w);
                }
                
                
                // binary operators
                D3DXINLINE D3DXVECTOR4
                D3DXVECTOR4::operator + ( CONST D3DXVECTOR4& v ) const
                {
                    return D3DXVECTOR4(x + v.x, y + v.y, z + v.z, w + v.w);
                }
                
                D3DXINLINE D3DXVECTOR4
                D3DXVECTOR4::operator - ( CONST D3DXVECTOR4& v ) const
                {
                    return D3DXVECTOR4(x - v.x, y - v.y, z - v.z, w - v.w);
                }
                
                D3DXINLINE D3DXVECTOR4
                D3DXVECTOR4::operator * ( FLOAT f ) const
                {
                    return D3DXVECTOR4(x * f, y * f, z * f, w * f);
                }
                
                D3DXINLINE D3DXVECTOR4
                D3DXVECTOR4::operator / ( FLOAT f ) const
                {
                    FLOAT fInv = 1.0f / f;
                    return D3DXVECTOR4(x * fInv, y * fInv, z * fInv, w * fInv);
                }
                
                D3DXINLINE D3DXVECTOR4
                operator * ( FLOAT f, CONST D3DXVECTOR4& v )
                {
                    return D3DXVECTOR4(f * v.x, f * v.y, f * v.z, f * v.w);
                }
                
                
                D3DXINLINE BOOL
                D3DXVECTOR4::operator == ( CONST D3DXVECTOR4& v ) const
                {
                    return x == v.x && y == v.y && z == v.z && w == v.w;
                }
                
                D3DXINLINE BOOL
                D3DXVECTOR4::operator != ( CONST D3DXVECTOR4& v ) const
                {
                    return x != v.x || y != v.y || z != v.z || w != v.w;
                }
                
                
                
                //--------------------------
                // 4D Vector (16 bit)
                //--------------------------
                
                D3DXINLINE
                D3DXVECTOR4_16F::D3DXVECTOR4_16F( CONST FLOAT *pf )
                {
                #ifdef D3DX_DEBUG
                    if(!pf)
                        return;
                #endif
                
                    D3DXFloat32To16Array(&x, pf, 4);
                }
                
                D3DXINLINE
                D3DXVECTOR4_16F::D3DXVECTOR4_16F( CONST D3DXFLOAT16 *pf )
                {
                #ifdef D3DX_DEBUG
                    if(!pf)
                        return;
                #endif
                
                    *((DWORD *) &x) = *((DWORD *) &pf[0]);
                    *((DWORD *) &z) = *((DWORD *) &pf[2]);
                }
                
                D3DXINLINE
                D3DXVECTOR4_16F::D3DXVECTOR4_16F( CONST D3DXVECTOR3_16F& v, CONST D3DXFLOAT16& f )
                {
                    x = v.x;
                    y = v.y;
                    z = v.z;
                    w = f;
                }
                
                D3DXINLINE
                D3DXVECTOR4_16F::D3DXVECTOR4_16F( CONST D3DXFLOAT16 &fx, CONST D3DXFLOAT16 &fy, CONST D3DXFLOAT16 &fz, CONST D3DXFLOAT16 &fw )
                {
                    x = fx;
                    y = fy;
                    z = fz;
                    w = fw;
                }
                
                
                // casting
                D3DXINLINE
                D3DXVECTOR4_16F::operator D3DXFLOAT16* ()
                {
                    return (D3DXFLOAT16*) &x;
                }
                
                D3DXINLINE
                D3DXVECTOR4_16F::operator CONST D3DXFLOAT16* () const
                {
                    return (CONST D3DXFLOAT16*) &x;
                }
                
                
                // binary operators
                D3DXINLINE BOOL 
                D3DXVECTOR4_16F::operator == ( CONST D3DXVECTOR4_16F &v ) const
                {
                    return *((DWORD *) &x) == *((DWORD *) &v.x) &&
                           *((DWORD *) &z) == *((DWORD *) &v.z);
                }
                
                D3DXINLINE BOOL 
                D3DXVECTOR4_16F::operator != ( CONST D3DXVECTOR4_16F &v ) const
                {
                    return *((DWORD *) &x) != *((DWORD *) &v.x) ||
                           *((DWORD *) &z) != *((DWORD *) &v.z);
                }
                
                
                //--------------------------
                // Matrix
                //--------------------------
                D3DXINLINE
                D3DXMATRIX::D3DXMATRIX( CONST FLOAT* pf )
                {
                #ifdef D3DX_DEBUG
                    if(!pf)
                        return;
                #endif
                
                    memcpy(&_11, pf, sizeof(D3DXMATRIX));
                }
                
                D3DXINLINE
                D3DXMATRIX::D3DXMATRIX( CONST D3DMATRIX& mat )
                {
                    memcpy(&_11, &mat, sizeof(D3DXMATRIX));
                }
                
                D3DXINLINE
                D3DXMATRIX::D3DXMATRIX( CONST D3DXFLOAT16* pf )
                {
                #ifdef D3DX_DEBUG
                    if(!pf)
                        return;
                #endif
                
                    D3DXFloat16To32Array(&_11, pf, 16);
                }
                
                D3DXINLINE
                D3DXMATRIX::D3DXMATRIX( FLOAT f11, FLOAT f12, FLOAT f13, FLOAT f14,
                                        FLOAT f21, FLOAT f22, FLOAT f23, FLOAT f24,
                                        FLOAT f31, FLOAT f32, FLOAT f33, FLOAT f34,
                                        FLOAT f41, FLOAT f42, FLOAT f43, FLOAT f44 )
                {
                    _11 = f11; _12 = f12; _13 = f13; _14 = f14;
                    _21 = f21; _22 = f22; _23 = f23; _24 = f24;
                    _31 = f31; _32 = f32; _33 = f33; _34 = f34;
                    _41 = f41; _42 = f42; _43 = f43; _44 = f44;
                }
                
                
                
                // access grants
                D3DXINLINE FLOAT&
                D3DXMATRIX::operator () ( UINT iRow, UINT iCol )
                {
                    return m[iRow][iCol];
                }
                
                D3DXINLINE FLOAT
                D3DXMATRIX::operator () ( UINT iRow, UINT iCol ) const
                {
                    return m[iRow][iCol];
                }
                
                
                // casting operators
                D3DXINLINE
                D3DXMATRIX::operator FLOAT* ()
                {
                    return (FLOAT *) &_11;
                }
                
                D3DXINLINE
                D3DXMATRIX::operator CONST FLOAT* () const
                {
                    return (CONST FLOAT *) &_11;
                }
                
                
                // assignment operators
                D3DXINLINE D3DXMATRIX&
                D3DXMATRIX::operator *= ( CONST D3DXMATRIX& mat )
                {
                    D3DXMatrixMultiply(this, this, &mat);
                    return *this;
                }
                
                D3DXINLINE D3DXMATRIX&
                D3DXMATRIX::operator += ( CONST D3DXMATRIX& mat )
                {
                    _11 += mat._11; _12 += mat._12; _13 += mat._13; _14 += mat._14;
                    _21 += mat._21; _22 += mat._22; _23 += mat._23; _24 += mat._24;
                    _31 += mat._31; _32 += mat._32; _33 += mat._33; _34 += mat._34;
                    _41 += mat._41; _42 += mat._42; _43 += mat._43; _44 += mat._44;
                    return *this;
                }
                
                D3DXINLINE D3DXMATRIX&
                D3DXMATRIX::operator -= ( CONST D3DXMATRIX& mat )
                {
                    _11 -= mat._11; _12 -= mat._12; _13 -= mat._13; _14 -= mat._14;
                    _21 -= mat._21; _22 -= mat._22; _23 -= mat._23; _24 -= mat._24;
                    _31 -= mat._31; _32 -= mat._32; _33 -= mat._33; _34 -= mat._34;
                    _41 -= mat._41; _42 -= mat._42; _43 -= mat._43; _44 -= mat._44;
                    return *this;
                }
                
                D3DXINLINE D3DXMATRIX&
                D3DXMATRIX::operator *= ( FLOAT f )
                {
                    _11 *= f; _12 *= f; _13 *= f; _14 *= f;
                    _21 *= f; _22 *= f; _23 *= f; _24 *= f;
                    _31 *= f; _32 *= f; _33 *= f; _34 *= f;
                    _41 *= f; _42 *= f; _43 *= f; _44 *= f;
                    return *this;
                }
                
                D3DXINLINE D3DXMATRIX&
                D3DXMATRIX::operator /= ( FLOAT f )
                {
                    FLOAT fInv = 1.0f / f;
                    _11 *= fInv; _12 *= fInv; _13 *= fInv; _14 *= fInv;
                    _21 *= fInv; _22 *= fInv; _23 *= fInv; _24 *= fInv;
                    _31 *= fInv; _32 *= fInv; _33 *= fInv; _34 *= fInv;
                    _41 *= fInv; _42 *= fInv; _43 *= fInv; _44 *= fInv;
                    return *this;
                }
                
                
                // unary operators
                D3DXINLINE D3DXMATRIX
                D3DXMATRIX::operator + () const
                {
                    return *this;
                }
                
                D3DXINLINE D3DXMATRIX
                D3DXMATRIX::operator - () const
                {
                    return D3DXMATRIX(-_11, -_12, -_13, -_14,
                                      -_21, -_22, -_23, -_24,
                                      -_31, -_32, -_33, -_34,
                                      -_41, -_42, -_43, -_44);
                }
                
                
                // binary operators
                D3DXINLINE D3DXMATRIX
                D3DXMATRIX::operator * ( CONST D3DXMATRIX& mat ) const
                {
                    D3DXMATRIX matT;
                    D3DXMatrixMultiply(&matT, this, &mat);
                    return matT;
                }
                
                D3DXINLINE D3DXMATRIX
                D3DXMATRIX::operator + ( CONST D3DXMATRIX& mat ) const
                {
                    return D3DXMATRIX(_11 + mat._11, _12 + mat._12, _13 + mat._13, _14 + mat._14,
                                      _21 + mat._21, _22 + mat._22, _23 + mat._23, _24 + mat._24,
                                      _31 + mat._31, _32 + mat._32, _33 + mat._33, _34 + mat._34,
                                      _41 + mat._41, _42 + mat._42, _43 + mat._43, _44 + mat._44);
                }
                
                D3DXINLINE D3DXMATRIX
                D3DXMATRIX::operator - ( CONST D3DXMATRIX& mat ) const
                {
                    return D3DXMATRIX(_11 - mat._11, _12 - mat._12, _13 - mat._13, _14 - mat._14,
                                      _21 - mat._21, _22 - mat._22, _23 - mat._23, _24 - mat._24,
                                      _31 - mat._31, _32 - mat._32, _33 - mat._33, _34 - mat._34,
                                      _41 - mat._41, _42 - mat._42, _43 - mat._43, _44 - mat._44);
                }
                
                D3DXINLINE D3DXMATRIX
                D3DXMATRIX::operator * ( FLOAT f ) const
                {
                    return D3DXMATRIX(_11 * f, _12 * f, _13 * f, _14 * f,
                                      _21 * f, _22 * f, _23 * f, _24 * f,
                                      _31 * f, _32 * f, _33 * f, _34 * f,
                                      _41 * f, _42 * f, _43 * f, _44 * f);
                }
                
                D3DXINLINE D3DXMATRIX
                D3DXMATRIX::operator / ( FLOAT f ) const
                {
                    FLOAT fInv = 1.0f / f;
                    return D3DXMATRIX(_11 * fInv, _12 * fInv, _13 * fInv, _14 * fInv,
                                      _21 * fInv, _22 * fInv, _23 * fInv, _24 * fInv,
                                      _31 * fInv, _32 * fInv, _33 * fInv, _34 * fInv,
                                      _41 * fInv, _42 * fInv, _43 * fInv, _44 * fInv);
                }
                
                
                D3DXINLINE D3DXMATRIX
                operator * ( FLOAT f, CONST D3DXMATRIX& mat )
                {
                    return D3DXMATRIX(f * mat._11, f * mat._12, f * mat._13, f * mat._14,
                                      f * mat._21, f * mat._22, f * mat._23, f * mat._24,
                                      f * mat._31, f * mat._32, f * mat._33, f * mat._34,
                                      f * mat._41, f * mat._42, f * mat._43, f * mat._44);
                }
                
                
                D3DXINLINE BOOL
                D3DXMATRIX::operator == ( CONST D3DXMATRIX& mat ) const
                {
                    return 0 == memcmp(this, &mat, sizeof(D3DXMATRIX));
                }
                
                D3DXINLINE BOOL
                D3DXMATRIX::operator != ( CONST D3DXMATRIX& mat ) const
                {
                    return 0 != memcmp(this, &mat, sizeof(D3DXMATRIX));
                }
                
                
                
                //--------------------------
                // Aligned Matrices
                //--------------------------
                
                D3DXINLINE
                _D3DXMATRIXA16::_D3DXMATRIXA16( CONST FLOAT* f ) : 
                    D3DXMATRIX( f ) 
                {
                }
                
                D3DXINLINE
                _D3DXMATRIXA16::_D3DXMATRIXA16( CONST D3DMATRIX& m ) : 
                    D3DXMATRIX( m ) 
                {
                }
                
                D3DXINLINE
                _D3DXMATRIXA16::_D3DXMATRIXA16( CONST D3DXFLOAT16* f ) : 
                    D3DXMATRIX( f ) 
                {
                }
                
                D3DXINLINE
                _D3DXMATRIXA16::_D3DXMATRIXA16( FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,
                                                FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,
                                                FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,
                                                FLOAT _41, FLOAT _42, FLOAT _43, FLOAT _44 ) :
                    D3DXMATRIX(_11, _12, _13, _14,
                               _21, _22, _23, _24,
                               _31, _32, _33, _34,
                               _41, _42, _43, _44) 
                {
                }
                
                #ifndef SIZE_MAX
                #define SIZE_MAX ((SIZE_T)-1)
                #endif
                
                D3DXINLINE void* 
                _D3DXMATRIXA16::operator new( size_t s )
                {
                    if (s > (SIZE_MAX-16))
                	return NULL;
                    LPBYTE p = ::new BYTE[s + 16];
                    if (p)
                    {
                        BYTE offset = (BYTE)(16 - ((UINT_PTR)p & 15));
                        p += offset;
                        p[-1] = offset;
                    }
                    return p;
                }
                
                D3DXINLINE void* 
                _D3DXMATRIXA16::operator new[]( size_t s )
                {
                    if (s > (SIZE_MAX-16))
                	return NULL;
                    LPBYTE p = ::new BYTE[s + 16];
                    if (p)
                    {
                        BYTE offset = (BYTE)(16 - ((UINT_PTR)p & 15));
                        p += offset;
                        p[-1] = offset;
                    }
                    return p;
                }
                
                D3DXINLINE void 
                _D3DXMATRIXA16::operator delete(void* p)
                {
                    if(p)
                    {
                        BYTE* pb = static_cast<BYTE*>(p);
                        pb -= pb[-1];
                        ::delete [] pb;
                    }
                }
                
                D3DXINLINE void 
                _D3DXMATRIXA16::operator delete[](void* p)
                {
                    if(p)
                    {
                        BYTE* pb = static_cast<BYTE*>(p);
                        pb -= pb[-1];
                        ::delete [] pb;
                    }
                }
                
                D3DXINLINE _D3DXMATRIXA16& 
                _D3DXMATRIXA16::operator=(CONST D3DXMATRIX& rhs)
                {
                    memcpy(&_11, &rhs, sizeof(D3DXMATRIX));
                    return *this;
                }
                
                
                //--------------------------
                // Quaternion
                //--------------------------
                
                D3DXINLINE
                D3DXQUATERNION::D3DXQUATERNION( CONST FLOAT* pf )
                {
                #ifdef D3DX_DEBUG
                    if(!pf)
                        return;
                #endif
                
                    x = pf[0];
                    y = pf[1];
                    z = pf[2];
                    w = pf[3];
                }
                
                D3DXINLINE
                D3DXQUATERNION::D3DXQUATERNION( CONST D3DXFLOAT16* pf )
                {
                #ifdef D3DX_DEBUG
                    if(!pf)
                        return;
                #endif
                
                    D3DXFloat16To32Array(&x, pf, 4);
                }
                
                D3DXINLINE
                D3DXQUATERNION::D3DXQUATERNION( FLOAT fx, FLOAT fy, FLOAT fz, FLOAT fw )
                {
                    x = fx;
                    y = fy;
                    z = fz;
                    w = fw;
                }
                
                
                // casting
                D3DXINLINE
                D3DXQUATERNION::operator FLOAT* ()
                {
                    return (FLOAT *) &x;
                }
                
                D3DXINLINE
                D3DXQUATERNION::operator CONST FLOAT* () const
                {
                    return (CONST FLOAT *) &x;
                }
                
                
                // assignment operators
                D3DXINLINE D3DXQUATERNION&
                D3DXQUATERNION::operator += ( CONST D3DXQUATERNION& q )
                {
                    x += q.x;
                    y += q.y;
                    z += q.z;
                    w += q.w;
                    return *this;
                }
                
                D3DXINLINE D3DXQUATERNION&
                D3DXQUATERNION::operator -= ( CONST D3DXQUATERNION& q )
                {
                    x -= q.x;
                    y -= q.y;
                    z -= q.z;
                    w -= q.w;
                    return *this;
                }
                
                D3DXINLINE D3DXQUATERNION&
                D3DXQUATERNION::operator *= ( CONST D3DXQUATERNION& q )
                {
                    D3DXQuaternionMultiply(this, this, &q);
                    return *this;
                }
                
                D3DXINLINE D3DXQUATERNION&
                D3DXQUATERNION::operator *= ( FLOAT f )
                {
                    x *= f;
                    y *= f;
                    z *= f;
                    w *= f;
                    return *this;
                }
                
                D3DXINLINE D3DXQUATERNION&
                D3DXQUATERNION::operator /= ( FLOAT f )
                {
                    FLOAT fInv = 1.0f / f;
                    x *= fInv;
                    y *= fInv;
                    z *= fInv;
                    w *= fInv;
                    return *this;
                }
                
                
                // unary operators
                D3DXINLINE D3DXQUATERNION
                D3DXQUATERNION::operator + () const
                {
                    return *this;
                }
                
                D3DXINLINE D3DXQUATERNION
                D3DXQUATERNION::operator - () const
                {
                    return D3DXQUATERNION(-x, -y, -z, -w);
                }
                
                
                // binary operators
                D3DXINLINE D3DXQUATERNION
                D3DXQUATERNION::operator + ( CONST D3DXQUATERNION& q ) const
                {
                    return D3DXQUATERNION(x + q.x, y + q.y, z + q.z, w + q.w);
                }
                
                D3DXINLINE D3DXQUATERNION
                D3DXQUATERNION::operator - ( CONST D3DXQUATERNION& q ) const
                {
                    return D3DXQUATERNION(x - q.x, y - q.y, z - q.z, w - q.w);
                }
                
                D3DXINLINE D3DXQUATERNION
                D3DXQUATERNION::operator * ( CONST D3DXQUATERNION& q ) const
                {
                    D3DXQUATERNION qT;
                    D3DXQuaternionMultiply(&qT, this, &q);
                    return qT;
                }
                
                D3DXINLINE D3DXQUATERNION
                D3DXQUATERNION::operator * ( FLOAT f ) const
                {
                    return D3DXQUATERNION(x * f, y * f, z * f, w * f);
                }
                
                D3DXINLINE D3DXQUATERNION
                D3DXQUATERNION::operator / ( FLOAT f ) const
                {
                    FLOAT fInv = 1.0f / f;
                    return D3DXQUATERNION(x * fInv, y * fInv, z * fInv, w * fInv);
                }
                
                
                D3DXINLINE D3DXQUATERNION
                operator * (FLOAT f, CONST D3DXQUATERNION& q )
                {
                    return D3DXQUATERNION(f * q.x, f * q.y, f * q.z, f * q.w);
                }
                
                
                D3DXINLINE BOOL
                D3DXQUATERNION::operator == ( CONST D3DXQUATERNION& q ) const
                {
                    return x == q.x && y == q.y && z == q.z && w == q.w;
                }
                
                D3DXINLINE BOOL
                D3DXQUATERNION::operator != ( CONST D3DXQUATERNION& q ) const
                {
                    return x != q.x || y != q.y || z != q.z || w != q.w;
                }
                
                
                
                //--------------------------
                // Plane
                //--------------------------
                
                D3DXINLINE
                D3DXPLANE::D3DXPLANE( CONST FLOAT* pf )
                {
                #ifdef D3DX_DEBUG
                    if(!pf)
                        return;
                #endif
                
                    a = pf[0];
                    b = pf[1];
                    c = pf[2];
                    d = pf[3];
                }
                
                D3DXINLINE
                D3DXPLANE::D3DXPLANE( CONST D3DXFLOAT16* pf )
                {
                #ifdef D3DX_DEBUG
                    if(!pf)
                        return;
                #endif
                
                    D3DXFloat16To32Array(&a, pf, 4);
                }
                
                D3DXINLINE
                D3DXPLANE::D3DXPLANE( FLOAT fa, FLOAT fb, FLOAT fc, FLOAT fd )
                {
                    a = fa;
                    b = fb;
                    c = fc;
                    d = fd;
                }
                
                
                // casting
                D3DXINLINE
                D3DXPLANE::operator FLOAT* ()
                {
                    return (FLOAT *) &a;
                }
                
                D3DXINLINE
                D3DXPLANE::operator CONST FLOAT* () const
                {
                    return (CONST FLOAT *) &a;
                }
                
                
                // assignment operators
                D3DXINLINE D3DXPLANE&
                D3DXPLANE::operator *= ( FLOAT f )
                {
                    a *= f;
                    b *= f;
                    c *= f;
                    d *= f;
                    return *this;
                }
                
                D3DXINLINE D3DXPLANE&
                D3DXPLANE::operator /= ( FLOAT f )
                {
                    FLOAT fInv = 1.0f / f;
                    a *= fInv;
                    b *= fInv;
                    c *= fInv;
                    d *= fInv;
                    return *this;
                }
                
                
                // unary operators
                D3DXINLINE D3DXPLANE
                D3DXPLANE::operator + () const
                {
                    return *this;
                }
                
                D3DXINLINE D3DXPLANE
                D3DXPLANE::operator - () const
                {
                    return D3DXPLANE(-a, -b, -c, -d);
                }
                
                
                // binary operators
                D3DXINLINE D3DXPLANE
                D3DXPLANE::operator * ( FLOAT f ) const
                {
                    return D3DXPLANE(a * f, b * f, c * f, d * f);
                }
                
                D3DXINLINE D3DXPLANE
                D3DXPLANE::operator / ( FLOAT f ) const
                {
                    FLOAT fInv = 1.0f / f;
                    return D3DXPLANE(a * fInv, b * fInv, c * fInv, d * fInv);
                }
                
                D3DXINLINE D3DXPLANE
                operator * (FLOAT f, CONST D3DXPLANE& p )
                {
                    return D3DXPLANE(f * p.a, f * p.b, f * p.c, f * p.d);
                }
                
                D3DXINLINE BOOL
                D3DXPLANE::operator == ( CONST D3DXPLANE& p ) const
                {
                    return a == p.a && b == p.b && c == p.c && d == p.d;
                }
                
                D3DXINLINE BOOL
                D3DXPLANE::operator != ( CONST D3DXPLANE& p ) const
                {
                    return a != p.a || b != p.b || c != p.c || d != p.d;
                }
                
                
                
                
                //--------------------------
                // Color
                //--------------------------
                
                D3DXINLINE
                D3DXCOLOR::D3DXCOLOR( DWORD dw )
                {
                    CONST FLOAT f = 1.0f / 255.0f;
                    r = f * (FLOAT) (unsigned char) (dw >> 16);
                    g = f * (FLOAT) (unsigned char) (dw >>  8);
                    b = f * (FLOAT) (unsigned char) (dw >>  0);
                    a = f * (FLOAT) (unsigned char) (dw >> 24);
                }
                
                D3DXINLINE
                D3DXCOLOR::D3DXCOLOR( CONST FLOAT* pf )
                {
                #ifdef D3DX_DEBUG
                    if(!pf)
                        return;
                #endif
                
                    r = pf[0];
                    g = pf[1];
                    b = pf[2];
                    a = pf[3];
                }
                
                D3DXINLINE
                D3DXCOLOR::D3DXCOLOR( CONST D3DXFLOAT16* pf )
                {
                #ifdef D3DX_DEBUG
                    if(!pf)
                        return;
                #endif
                
                    D3DXFloat16To32Array(&r, pf, 4);
                }
                
                D3DXINLINE
                D3DXCOLOR::D3DXCOLOR( CONST D3DCOLORVALUE& c )
                {
                    r = c.r;
                    g = c.g;
                    b = c.b;
                    a = c.a;
                }
                
                D3DXINLINE
                D3DXCOLOR::D3DXCOLOR( FLOAT fr, FLOAT fg, FLOAT fb, FLOAT fa )
                {
                    r = fr;
                    g = fg;
                    b = fb;
                    a = fa;
                }
                
                
                // casting
                D3DXINLINE
                D3DXCOLOR::operator DWORD () const
                {
                    DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);
                    DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);
                    DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);
                    DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);
                
                    return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;
                }
                
                
                D3DXINLINE
                D3DXCOLOR::operator FLOAT * ()
                {
                    return (FLOAT *) &r;
                }
                
                D3DXINLINE
                D3DXCOLOR::operator CONST FLOAT * () const
                {
                    return (CONST FLOAT *) &r;
                }
                
                
                D3DXINLINE
                D3DXCOLOR::operator D3DCOLORVALUE * ()
                {
                    return (D3DCOLORVALUE *) &r;
                }
                
                D3DXINLINE
                D3DXCOLOR::operator CONST D3DCOLORVALUE * () const
                {
                    return (CONST D3DCOLORVALUE *) &r;
                }
                
                
                D3DXINLINE
                D3DXCOLOR::operator D3DCOLORVALUE& ()
                {
                    return *((D3DCOLORVALUE *) &r);
                }
                
                D3DXINLINE
                D3DXCOLOR::operator CONST D3DCOLORVALUE& () const
                {
                    return *((CONST D3DCOLORVALUE *) &r);
                }
                
                
                // assignment operators
                D3DXINLINE D3DXCOLOR&
                D3DXCOLOR::operator += ( CONST D3DXCOLOR& c )
                {
                    r += c.r;
                    g += c.g;
                    b += c.b;
                    a += c.a;
                    return *this;
                }
                
                D3DXINLINE D3DXCOLOR&
                D3DXCOLOR::operator -= ( CONST D3DXCOLOR& c )
                {
                    r -= c.r;
                    g -= c.g;
                    b -= c.b;
                    a -= c.a;
                    return *this;
                }
                
                D3DXINLINE D3DXCOLOR&
                D3DXCOLOR::operator *= ( FLOAT f )
                {
                    r *= f;
                    g *= f;
                    b *= f;
                    a *= f;
                    return *this;
                }
                
                D3DXINLINE D3DXCOLOR&
                D3DXCOLOR::operator /= ( FLOAT f )
                {
                    FLOAT fInv = 1.0f / f;
                    r *= fInv;
                    g *= fInv;
                    b *= fInv;
                    a *= fInv;
                    return *this;
                }
                
                
                // unary operators
                D3DXINLINE D3DXCOLOR
                D3DXCOLOR::operator + () const
                {
                    return *this;
                }
                
                D3DXINLINE D3DXCOLOR
                D3DXCOLOR::operator - () const
                {
                    return D3DXCOLOR(-r, -g, -b, -a);
                }
                
                
                // binary operators
                D3DXINLINE D3DXCOLOR
                D3DXCOLOR::operator + ( CONST D3DXCOLOR& c ) const
                {
                    return D3DXCOLOR(r + c.r, g + c.g, b + c.b, a + c.a);
                }
                
                D3DXINLINE D3DXCOLOR
                D3DXCOLOR::operator - ( CONST D3DXCOLOR& c ) const
                {
                    return D3DXCOLOR(r - c.r, g - c.g, b - c.b, a - c.a);
                }
                
                D3DXINLINE D3DXCOLOR
                D3DXCOLOR::operator * ( FLOAT f ) const
                {
                    return D3DXCOLOR(r * f, g * f, b * f, a * f);
                }
                
                D3DXINLINE D3DXCOLOR
                D3DXCOLOR::operator / ( FLOAT f ) const
                {
                    FLOAT fInv = 1.0f / f;
                    return D3DXCOLOR(r * fInv, g * fInv, b * fInv, a * fInv);
                }
                
                
                D3DXINLINE D3DXCOLOR
                operator * (FLOAT f, CONST D3DXCOLOR& c )
                {
                    return D3DXCOLOR(f * c.r, f * c.g, f * c.b, f * c.a);
                }
                
                
                D3DXINLINE BOOL
                D3DXCOLOR::operator == ( CONST D3DXCOLOR& c ) const
                {
                    return r == c.r && g == c.g && b == c.b && a == c.a;
                }
                
                D3DXINLINE BOOL
                D3DXCOLOR::operator != ( CONST D3DXCOLOR& c ) const
                {
                    return r != c.r || g != c.g || b != c.b || a != c.a;
                }
                
                
                #endif //__cplusplus
                
                
                
                //===========================================================================
                //
                // Inline functions
                //
                //===========================================================================
                
                
                //--------------------------
                // 2D Vector
                //--------------------------
                
                D3DXINLINE FLOAT D3DXVec2Length
                    ( CONST D3DXVECTOR2 *pV )
                {
                #ifdef D3DX_DEBUG
                    if(!pV)
                        return 0.0f;
                #endif
                
                #ifdef __cplusplus
                    return sqrtf(pV->x * pV->x + pV->y * pV->y);
                #else
                    return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y);
                #endif
                }
                
                D3DXINLINE FLOAT D3DXVec2LengthSq
                    ( CONST D3DXVECTOR2 *pV )
                {
                #ifdef D3DX_DEBUG
                    if(!pV)
                        return 0.0f;
                #endif
                
                    return pV->x * pV->x + pV->y * pV->y;
                }
                
                D3DXINLINE FLOAT D3DXVec2Dot
                    ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
                {
                #ifdef D3DX_DEBUG
                    if(!pV1 || !pV2)
                        return 0.0f;
                #endif
                
                    return pV1->x * pV2->x + pV1->y * pV2->y;
                }
                
                D3DXINLINE FLOAT D3DXVec2CCW
                    ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
                {
                #ifdef D3DX_DEBUG
                    if(!pV1 || !pV2)
                        return 0.0f;
                #endif
                
                    return pV1->x * pV2->y - pV1->y * pV2->x;
                }
                
                D3DXINLINE D3DXVECTOR2* D3DXVec2Add
                    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pV1 || !pV2)
                        return NULL;
                #endif
                
                    pOut->x = pV1->x + pV2->x;
                    pOut->y = pV1->y + pV2->y;
                    return pOut;
                }
                
                D3DXINLINE D3DXVECTOR2* D3DXVec2Subtract
                    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pV1 || !pV2)
                        return NULL;
                #endif
                
                    pOut->x = pV1->x - pV2->x;
                    pOut->y = pV1->y - pV2->y;
                    return pOut;
                }
                
                D3DXINLINE D3DXVECTOR2* D3DXVec2Minimize
                    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pV1 || !pV2)
                        return NULL;
                #endif
                
                    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
                    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
                    return pOut;
                }
                
                D3DXINLINE D3DXVECTOR2* D3DXVec2Maximize
                    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 )
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pV1 || !pV2)
                        return NULL;
                #endif
                
                    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
                    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
                    return pOut;
                }
                
                D3DXINLINE D3DXVECTOR2* D3DXVec2Scale
                    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s )
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pV)
                        return NULL;
                #endif
                
                    pOut->x = pV->x * s;
                    pOut->y = pV->y * s;
                    return pOut;
                }
                
                D3DXINLINE D3DXVECTOR2* D3DXVec2Lerp
                    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
                      FLOAT s )
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pV1 || !pV2)
                        return NULL;
                #endif
                
                    pOut->x = pV1->x + s * (pV2->x - pV1->x);
                    pOut->y = pV1->y + s * (pV2->y - pV1->y);
                    return pOut;
                }
                
                
                //--------------------------
                // 3D Vector
                //--------------------------
                
                D3DXINLINE FLOAT D3DXVec3Length
                    ( CONST D3DXVECTOR3 *pV )
                {
                #ifdef D3DX_DEBUG
                    if(!pV)
                        return 0.0f;
                #endif
                
                #ifdef __cplusplus
                    return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
                #else
                    return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
                #endif
                }
                
                D3DXINLINE FLOAT D3DXVec3LengthSq
                    ( CONST D3DXVECTOR3 *pV )
                {
                #ifdef D3DX_DEBUG
                    if(!pV)
                        return 0.0f;
                #endif
                
                    return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;
                }
                
                D3DXINLINE FLOAT D3DXVec3Dot
                    ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
                {
                #ifdef D3DX_DEBUG
                    if(!pV1 || !pV2)
                        return 0.0f;
                #endif
                
                    return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;
                }
                
                D3DXINLINE D3DXVECTOR3* D3DXVec3Cross
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
                {
                    D3DXVECTOR3 v;
                
                #ifdef D3DX_DEBUG
                    if(!pOut || !pV1 || !pV2)
                        return NULL;
                #endif
                
                    v.x = pV1->y * pV2->z - pV1->z * pV2->y;
                    v.y = pV1->z * pV2->x - pV1->x * pV2->z;
                    v.z = pV1->x * pV2->y - pV1->y * pV2->x;
                
                    *pOut = v;
                    return pOut;
                }
                
                D3DXINLINE D3DXVECTOR3* D3DXVec3Add
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pV1 || !pV2)
                        return NULL;
                #endif
                
                    pOut->x = pV1->x + pV2->x;
                    pOut->y = pV1->y + pV2->y;
                    pOut->z = pV1->z + pV2->z;
                    return pOut;
                }
                
                D3DXINLINE D3DXVECTOR3* D3DXVec3Subtract
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pV1 || !pV2)
                        return NULL;
                #endif
                
                    pOut->x = pV1->x - pV2->x;
                    pOut->y = pV1->y - pV2->y;
                    pOut->z = pV1->z - pV2->z;
                    return pOut;
                }
                
                D3DXINLINE D3DXVECTOR3* D3DXVec3Minimize
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pV1 || !pV2)
                        return NULL;
                #endif
                
                    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
                    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
                    pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
                    return pOut;
                }
                
                D3DXINLINE D3DXVECTOR3* D3DXVec3Maximize
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 )
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pV1 || !pV2)
                        return NULL;
                #endif
                
                    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
                    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
                    pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
                    return pOut;
                }
                
                D3DXINLINE D3DXVECTOR3* D3DXVec3Scale
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, FLOAT s)
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pV)
                        return NULL;
                #endif
                
                    pOut->x = pV->x * s;
                    pOut->y = pV->y * s;
                    pOut->z = pV->z * s;
                    return pOut;
                }
                
                D3DXINLINE D3DXVECTOR3* D3DXVec3Lerp
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
                      FLOAT s )
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pV1 || !pV2)
                        return NULL;
                #endif
                
                    pOut->x = pV1->x + s * (pV2->x - pV1->x);
                    pOut->y = pV1->y + s * (pV2->y - pV1->y);
                    pOut->z = pV1->z + s * (pV2->z - pV1->z);
                    return pOut;
                }
                
                
                //--------------------------
                // 4D Vector
                //--------------------------
                
                D3DXINLINE FLOAT D3DXVec4Length
                    ( CONST D3DXVECTOR4 *pV )
                {
                #ifdef D3DX_DEBUG
                    if(!pV)
                        return 0.0f;
                #endif
                
                #ifdef __cplusplus
                    return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
                #else
                    return (FLOAT) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
                #endif
                }
                
                D3DXINLINE FLOAT D3DXVec4LengthSq
                    ( CONST D3DXVECTOR4 *pV )
                {
                #ifdef D3DX_DEBUG
                    if(!pV)
                        return 0.0f;
                #endif
                
                    return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w;
                }
                
                D3DXINLINE FLOAT D3DXVec4Dot
                    ( CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2 )
                {
                #ifdef D3DX_DEBUG
                    if(!pV1 || !pV2)
                        return 0.0f;
                #endif
                
                    return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z + pV1->w * pV2->w;
                }
                
                D3DXINLINE D3DXVECTOR4* D3DXVec4Add
                    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pV1 || !pV2)
                        return NULL;
                #endif
                
                    pOut->x = pV1->x + pV2->x;
                    pOut->y = pV1->y + pV2->y;
                    pOut->z = pV1->z + pV2->z;
                    pOut->w = pV1->w + pV2->w;
                    return pOut;
                }
                
                D3DXINLINE D3DXVECTOR4* D3DXVec4Subtract
                    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pV1 || !pV2)
                        return NULL;
                #endif
                
                    pOut->x = pV1->x - pV2->x;
                    pOut->y = pV1->y - pV2->y;
                    pOut->z = pV1->z - pV2->z;
                    pOut->w = pV1->w - pV2->w;
                    return pOut;
                }
                
                D3DXINLINE D3DXVECTOR4* D3DXVec4Minimize
                    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pV1 || !pV2)
                        return NULL;
                #endif
                
                    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
                    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
                    pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
                    pOut->w = pV1->w < pV2->w ? pV1->w : pV2->w;
                    return pOut;
                }
                
                D3DXINLINE D3DXVECTOR4* D3DXVec4Maximize
                    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2)
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pV1 || !pV2)
                        return NULL;
                #endif
                
                    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
                    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
                    pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
                    pOut->w = pV1->w > pV2->w ? pV1->w : pV2->w;
                    return pOut;
                }
                
                D3DXINLINE D3DXVECTOR4* D3DXVec4Scale
                    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV, FLOAT s)
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pV)
                        return NULL;
                #endif
                
                    pOut->x = pV->x * s;
                    pOut->y = pV->y * s;
                    pOut->z = pV->z * s;
                    pOut->w = pV->w * s;
                    return pOut;
                }
                
                D3DXINLINE D3DXVECTOR4* D3DXVec4Lerp
                    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
                      FLOAT s )
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pV1 || !pV2)
                        return NULL;
                #endif
                
                    pOut->x = pV1->x + s * (pV2->x - pV1->x);
                    pOut->y = pV1->y + s * (pV2->y - pV1->y);
                    pOut->z = pV1->z + s * (pV2->z - pV1->z);
                    pOut->w = pV1->w + s * (pV2->w - pV1->w);
                    return pOut;
                }
                
                
                //--------------------------
                // 4D Matrix
                //--------------------------
                
                D3DXINLINE D3DXMATRIX* D3DXMatrixIdentity
                    ( D3DXMATRIX *pOut )
       19480 -> {
                #ifdef D3DX_DEBUG
                    if(!pOut)
                        return NULL;
                #endif
                
                    pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =
                    pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
                    pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
                    pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
                
                    pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;
                    return pOut;
                }
                
                
                D3DXINLINE BOOL D3DXMatrixIsIdentity
                    ( CONST D3DXMATRIX *pM )
                {
                #ifdef D3DX_DEBUG
                    if(!pM)
                        return FALSE;
                #endif
                
                    return pM->m[0][0] == 1.0f && pM->m[0][1] == 0.0f && pM->m[0][2] == 0.0f && pM->m[0][3] == 0.0f &&
                           pM->m[1][0] == 0.0f && pM->m[1][1] == 1.0f && pM->m[1][2] == 0.0f && pM->m[1][3] == 0.0f &&
                           pM->m[2][0] == 0.0f && pM->m[2][1] == 0.0f && pM->m[2][2] == 1.0f && pM->m[2][3] == 0.0f &&
                           pM->m[3][0] == 0.0f && pM->m[3][1] == 0.0f && pM->m[3][2] == 0.0f && pM->m[3][3] == 1.0f;
                }
                
                
                //--------------------------
                // Quaternion
                //--------------------------
                
                D3DXINLINE FLOAT D3DXQuaternionLength
                    ( CONST D3DXQUATERNION *pQ )
                {
                #ifdef D3DX_DEBUG
                    if(!pQ)
                        return 0.0f;
                #endif
                
                #ifdef __cplusplus
                    return sqrtf(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
                #else
                    return (FLOAT) sqrt(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
                #endif
                }
                
                D3DXINLINE FLOAT D3DXQuaternionLengthSq
                    ( CONST D3DXQUATERNION *pQ )
                {
                #ifdef D3DX_DEBUG
                    if(!pQ)
                        return 0.0f;
                #endif
                
                    return pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w;
                }
                
                D3DXINLINE FLOAT D3DXQuaternionDot
                    ( CONST D3DXQUATERNION *pQ1, CONST D3DXQUATERNION *pQ2 )
                {
                #ifdef D3DX_DEBUG
                    if(!pQ1 || !pQ2)
                        return 0.0f;
                #endif
                
                    return pQ1->x * pQ2->x + pQ1->y * pQ2->y + pQ1->z * pQ2->z + pQ1->w * pQ2->w;
                }
                
                
                D3DXINLINE D3DXQUATERNION* D3DXQuaternionIdentity
                    ( D3DXQUATERNION *pOut )
                {
                #ifdef D3DX_DEBUG
                    if(!pOut)
                        return NULL;
                #endif
                
                    pOut->x = pOut->y = pOut->z = 0.0f;
                    pOut->w = 1.0f;
                    return pOut;
                }
                
                D3DXINLINE BOOL D3DXQuaternionIsIdentity
                    ( CONST D3DXQUATERNION *pQ )
                {
                #ifdef D3DX_DEBUG
                    if(!pQ)
                        return FALSE;
                #endif
                
                    return pQ->x == 0.0f && pQ->y == 0.0f && pQ->z == 0.0f && pQ->w == 1.0f;
                }
                
                
                D3DXINLINE D3DXQUATERNION* D3DXQuaternionConjugate
                    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ )
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pQ)
                        return NULL;
                #endif
                
                    pOut->x = -pQ->x;
                    pOut->y = -pQ->y;
                    pOut->z = -pQ->z;
                    pOut->w =  pQ->w;
                    return pOut;
                }
                
                
                //--------------------------
                // Plane
                //--------------------------
                
                D3DXINLINE FLOAT D3DXPlaneDot
                    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR4 *pV)
                {
                #ifdef D3DX_DEBUG
                    if(!pP || !pV)
                        return 0.0f;
                #endif
                
                    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d * pV->w;
                }
                
                D3DXINLINE FLOAT D3DXPlaneDotCoord
                    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV)
                {
                #ifdef D3DX_DEBUG
                    if(!pP || !pV)
                        return 0.0f;
                #endif
                
                    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;
                }
                
                D3DXINLINE FLOAT D3DXPlaneDotNormal
                    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV)
                {
                #ifdef D3DX_DEBUG
                    if(!pP || !pV)
                        return 0.0f;
                #endif
                
                    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z;
                }
                
                D3DXINLINE D3DXPLANE* D3DXPlaneScale
                    (D3DXPLANE *pOut, CONST D3DXPLANE *pP, FLOAT s)
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pP)
                        return NULL;
                #endif
                
                    pOut->a = pP->a * s;
                    pOut->b = pP->b * s;
                    pOut->c = pP->c * s;
                    pOut->d = pP->d * s;
                    return pOut;
                }
                
                
                //--------------------------
                // Color
                //--------------------------
                
                D3DXINLINE D3DXCOLOR* D3DXColorNegative
                    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC)
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pC)
                        return NULL;
                #endif
                
                    pOut->r = 1.0f - pC->r;
                    pOut->g = 1.0f - pC->g;
                    pOut->b = 1.0f - pC->b;
                    pOut->a = pC->a;
                    return pOut;
                }
                
                D3DXINLINE D3DXCOLOR* D3DXColorAdd
                    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2)
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pC1 || !pC2)
                        return NULL;
                #endif
                
                    pOut->r = pC1->r + pC2->r;
                    pOut->g = pC1->g + pC2->g;
                    pOut->b = pC1->b + pC2->b;
                    pOut->a = pC1->a + pC2->a;
                    return pOut;
                }
                
                D3DXINLINE D3DXCOLOR* D3DXColorSubtract
                    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2)
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pC1 || !pC2)
                        return NULL;
                #endif
                
                    pOut->r = pC1->r - pC2->r;
                    pOut->g = pC1->g - pC2->g;
                    pOut->b = pC1->b - pC2->b;
                    pOut->a = pC1->a - pC2->a;
                    return pOut;
                }
                
                D3DXINLINE D3DXCOLOR* D3DXColorScale
                    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT s)
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pC)
                        return NULL;
                #endif
                
                    pOut->r = pC->r * s;
                    pOut->g = pC->g * s;
                    pOut->b = pC->b * s;
                    pOut->a = pC->a * s;
                    return pOut;
                }
                
                D3DXINLINE D3DXCOLOR* D3DXColorModulate
                    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2)
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pC1 || !pC2)
                        return NULL;
                #endif
                
                    pOut->r = pC1->r * pC2->r;
                    pOut->g = pC1->g * pC2->g;
                    pOut->b = pC1->b * pC2->b;
                    pOut->a = pC1->a * pC2->a;
                    return pOut;
                }
                
                D3DXINLINE D3DXCOLOR* D3DXColorLerp
                    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2, FLOAT s)
                {
                #ifdef D3DX_DEBUG
                    if(!pOut || !pC1 || !pC2)
                        return NULL;
                #endif
                
                    pOut->r = pC1->r + s * (pC2->r - pC1->r);
                    pOut->g = pC1->g + s * (pC2->g - pC1->g);
                    pOut->b = pC1->b + s * (pC2->b - pC1->b);
                    pOut->a = pC1->a + s * (pC2->a - pC1->a);
                    return pOut;
                }
                
                
                #endif // __D3DX9MATH_INL__
                


Top 10 Lines:

     Line      Count

      302     221052
     1988      19480

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

   240532   Total number of line executions
120266.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/GgafDx9SpriteSetActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
         173 -> GgafDx9SpriteSetActor::GgafDx9SpriteSetActor(const char* prm_name,
                                                       const char* prm_model_id,
                                                       const char* prm_effect_id,
                                                       const char* prm_technique,
                                                       GgafDx9Checker* prm_pChecker) :
                
                                                           GgafDx9DrawableActor(prm_name,
                                                                                prm_model_id,
                                                                                "s",
                                                                                prm_effect_id,
                                                                                "s",
                                                                                prm_technique,
                                                                                prm_pChecker) {
                    _obj_class |= Obj_GgafDx9SpriteSetActor;
                    _class_name = "GgafDx9SpriteSetActor";
                
                    //f
                    _pSpriteSetModel = (GgafDx9SpriteSetModel*)_pGgafDx9Model;
                    _pSpriteSetEffect = (GgafDx9SpriteSetEffect*)_pGgafDx9Effect;
                    _pUvFlipper = NEW GgafDx9UvFlipper(this);
                    _pUvFlipper->forcePtnNoRange(0, _pSpriteSetModel->_pattno_uvflip_Max);
                    _pUvFlipper->setPtnNo(0);
                    _pUvFlipper->setFlipMethod(NOT_ANIMATED, 1);
                    _pFunc_calcRotMvWorldMatrix = GgafDx9Util::setWorldMatrix_RxRzRyMv;
                }
                
                void GgafDx9SpriteSetActor::processDraw() {
                    _draw_set_num = 0; //GgafDx9SpriteSetActorfeNjbN
                                       //AJEgB`[xx`B
                    ID3DXEffect* pID3DXEffect = _pSpriteSetEffect->_pID3DXEffect;
                    HRESULT hr;
                
                    GgafDx9DrawableActor* pDrawActor = this;
                    GgafDx9SpriteSetActor* pSpriteSetActor;
                    GgafDx9RectUV* pRectUV_Active;
                    while (true) {
                        if (pDrawActor)  {
                            if (pDrawActor->_pGgafDx9Model == _pSpriteSetModel && pDrawActor->_hash_technique == _hash_technique) {
                                pSpriteSetActor = (GgafDx9SpriteSetActor*)pDrawActor;
                
                                hr = pID3DXEffect->SetMatrix(_pSpriteSetEffect->_ah_matWorld[_draw_set_num], &(pDrawActor->_matWorld) );
                                checkDxException(hr, D3D_OK, "GgafDx9SpriteSetActor::processDraw SetMatrix(_h_matWorld) sB");
                                //`UV
                                pRectUV_Active = _pSpriteSetModel->_paRectUV + (((GgafDx9SpriteSetActor*)(pDrawActor))->_pUvFlipper->_pattno_uvflip_now);
                                hr = pID3DXEffect->SetFloat(_pSpriteSetEffect->_ahOffsetU[_draw_set_num], pRectUV_Active->_aUV[0].tu);
                                checkDxException(hr, D3D_OK, "GgafDx9SpriteSetActor::processDraw() SetFloat(_hOffsetU) sB");
                                hr = pID3DXEffect->SetFloat(_pSpriteSetEffect->_ahOffsetV[_draw_set_num], pRectUV_Active->_aUV[0].tv);
                                checkDxException(hr, D3D_OK, "GgafDx9SpriteSetActor::processDraw() SetFloat(_hOffsetV) sB");
                                hr = pID3DXEffect->SetFloat(_pSpriteSetEffect->_ahAlpha[_draw_set_num], pDrawActor->_fAlpha);
                                checkDxException(hr, D3D_OK, "GgafDx9SpriteSetActor::processDraw SetFloat(_fAlpha) sB");
                
                                _draw_set_num++;
                                if (_draw_set_num >= _pSpriteSetModel->_set_num) {
                                    break;
                                }
                                pDrawActor = pDrawActor->_pNext_TheSameDrawDepthLevel;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    GgafDx9Universe::_pActor_DrawActive = pSpriteSetActor; //`ZbgAN^[Zbg
                    _pSpriteSetModel->draw(this, _draw_set_num);
                }
                
                void GgafDx9SpriteSetActor::setAlpha(float prm_fAlpha) {
                    _fAlpha = prm_fAlpha;
                    //A}eADiffuseOW
                    _paD3DMaterial9[0].Ambient.a = _fAlpha; //[
                    _paD3DMaterial9[0].Diffuse.a = _fAlpha;
                }
                
                void GgafDx9SpriteSetActor::addAlpha(float prm_fAlpha) {
                    _fAlpha += prm_fAlpha;
                    //A}eADiffuseOW
                    _paD3DMaterial9[0].Ambient.a = _fAlpha; //[
                    _paD3DMaterial9[0].Diffuse.a = _fAlpha;
                }
                
         173 -> GgafDx9SpriteSetActor::~GgafDx9SpriteSetActor() {
                    DELETE_IMPOSSIBLE_NULL(_pUvFlipper);
                }


Top 10 Lines:

     Line      Count

        6        173
       87        173

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      346   Total number of line executions
   115.33   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/model/supporter/GgafDx9TextureBlinker.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
          26 -> GgafDx9TextureBlinker::GgafDx9TextureBlinker(GgafDx9Model* prm_pModel) :
                    GgafObject() {
                    _pModel = prm_pModel;
                    _fPowerBlink = 1.0f;
                    _velo_fPowerBlink = 0.0f;
                    _acce_fPowerBlink = 0.0f;
                    _target_fPowerBlink = 1.0f;
                    _top_fPowerBlink = 1000.0f;
                    _bottom_fPowerBlink = 0.0f;
                    _one_way_cnt = 0;
                    _beat_attack_frame = 0;
                    _beat_rest_frame = 0;
                    _beat_begin_frame = 0;
                    _beat_spend_frame = 0;
                    _stop_one_way_num = -1;
                    _method = NOBLINK;
                }
                
                void GgafDx9TextureBlinker::behave() {
                
                    if (_method == NOBLINK) {
                        return;
                    } else if (_method == TARGET_BLINK_LINER) {
                
                        _fPowerBlink += _velo_fPowerBlink;
                
                        //_TRACE_("_velo_fPowerBlink["<<<<"]="<<_velo_fPowerBlink<<"/_target_fPowerBlink["<<<<"]="<<_target_fPowerBlink<<"/_fPowerBlink["<<<<"]="<<_fPowerBlink);
                        if (_velo_fPowerBlink > 0.0f && _target_fPowerBlink <= _fPowerBlink) {
                            //_TRACE_("END1");
                            _fPowerBlink = _target_fPowerBlink;
                            _method = NOBLINK;
                        } else if (_velo_fPowerBlink < 0.0f && _target_fPowerBlink >= _fPowerBlink) {
                            //_TRACE_("END2");
                            _fPowerBlink = _target_fPowerBlink;
                            _method = NOBLINK;
                        }
                    } if (_method == TARGET_BLINK_ACCELERATION) {
                        _fPowerBlink += _velo_fPowerBlink;
                        if (_velo_fPowerBlink > 0.0f && _target_fPowerBlink <= _fPowerBlink) {
                            _fPowerBlink = _target_fPowerBlink;
                            _method = NOBLINK;
                        } else if (_velo_fPowerBlink < 0.0f && _target_fPowerBlink >= _fPowerBlink) {
                            _fPowerBlink = _target_fPowerBlink;
                            _method = NOBLINK;
                        }
                        _velo_fPowerBlink += _acce_fPowerBlink;
                    } else if (_method == BEAT_BLINK_LINER) {
                        _fPowerBlink += _velo_fPowerBlink;
                        if (_top_fPowerBlink <= _fPowerBlink) {
                            _fPowerBlink = _top_fPowerBlink;
                            _velo_fPowerBlink = -2.0f * (_top_fPowerBlink - _bottom_fPowerBlink) / (int)_beat_spend_frame;
                            _one_way_cnt++;
                            if (_one_way_cnt == _stop_one_way_num) {
                                _method = NOBLINK;
                            }
                        } else if (_bottom_fPowerBlink >= _fPowerBlink) {
                            _fPowerBlink = _bottom_fPowerBlink;
                            _velo_fPowerBlink = 2.0f * (_top_fPowerBlink - _bottom_fPowerBlink) / (int)_beat_spend_frame;
                            _one_way_cnt++;
                            if (_one_way_cnt == _stop_one_way_num) {
                                _method = NOBLINK;
                            }
                        }
                
                    } else if (_method == BEAT_BLINK_TRIANGLEWAVE) {
                        _fPowerBlink += _velo_fPowerBlink;
                        //_TRACE_("_beat_begin_frame="<<_beat_begin_frame<<" _beat_attack_frame="<<_beat_attack_frame<<" _pModel->_frame_blinker="<<_pModel->_frame_blinker<<" | _fPowerBlink="<<_fPowerBlink<<" _velo_fPowerBlink="<<_velo_fPowerBlink<<"");
                        if (_beat_begin_frame + _beat_attack_frame == _pModel->_frame_blinker) { //A^bN_
                            _fPowerBlink = _top_fPowerBlink;
                            _velo_fPowerBlink = (_bottom_fPowerBlink - _top_fPowerBlink) / ((int)_beat_spend_frame - (int)_beat_attack_frame - (int)_beat_rest_frame);
                            _one_way_cnt++;
                            if (_one_way_cnt == _stop_one_way_num) {
                                _method = NOBLINK;
                            }
                        } else if (_bottom_fPowerBlink > _fPowerBlink) {  //if (_bottom_fPowerBlink >= _fPowerBlink) sI
                            _fPowerBlink = _bottom_fPowerBlink;
                            _velo_fPowerBlink = 0;
                        } else if (_beat_begin_frame + _beat_spend_frame == _pModel->_frame_blinker) { //[vI
                            _beat_begin_frame = _pModel->_frame_blinker;
                            _velo_fPowerBlink = (_top_fPowerBlink - _bottom_fPowerBlink) / (int)_beat_attack_frame;
                            _one_way_cnt++;
                            if (_one_way_cnt == _stop_one_way_num) {
                                _method = NOBLINK;
                            }
                        }
                    }
                    //Modelf
                    _pModel->_fPowerBlink = _fPowerBlink;
                    _pModel->_frame_blinker++;
                }
                
                //g
                //            _TRACE_("---sO");
                //            _TRACE_("_pModel->_frame_blinker="<<_pModel->_frame_blinker);
                //            _TRACE_("_bottom_fPowerBlink["<<<<"]="<<_bottom_fPowerBlink);
                //            _TRACE_("_top_fPowerBlink["<<<<"]="<<_top_fPowerBlink);
                //            _TRACE_("_beat_spend_frame["<<<<"]="<<_beat_spend_frame);
                //            _TRACE_("_beat_attack_frame["<<<<"]="<<_beat_attack_frame);
                //            _TRACE_("_beat_rest_frame["<<<<"]="<<_beat_rest_frame);
                //            _TRACE_("_beat_spend_frame["<<<<"] - _beat_attack_frame["<<<<"] - _beat_rest_frame["<<<<"]) = " << (_beat_spend_frame - _beat_attack_frame - _beat_rest_frame));
                //            _TRACE_("(_bottom_fPowerBlink["<<<<"] - _top_fPowerBlink["<<<<"]) / (_beat_spend_frame["<<<<"] - _beat_attack_frame["<<<<"] - _beat_rest_frame["<<<<"])="<<((int)(_bottom_fPowerBlink - _top_fPowerBlink) / (int)(_beat_spend_frame - _beat_attack_frame - _beat_rest_frame)));
                //            _TRACE_("_bottom_fPowerBlink["<<<<"] - _top_fPowerBlink["<<<<"]" << (_bottom_fPowerBlink - _top_fPowerBlink));
                //            _TRACE_("_fPowerBlink["<<<<"] _velo_fPowerBlink["<<<<"]="<<_fPowerBlink<<" "<<_velo_fPowerBlink);
                
                void GgafDx9TextureBlinker::intoTargetBlinkLinerUntil(float prm_target_fPowerBlink, frame prm_spend_frame) {
                    //_TRACE_("intoTargetBlinkLinerUntil prm_="<<prm_<<"/prm_target_fPowerBlink="<<prm_target_fPowerBlink<<"/prm_spend_frame="<<prm_spend_frame);
                    _method = TARGET_BLINK_LINER;
                    _target_fPowerBlink = prm_target_fPowerBlink;
                    _velo_fPowerBlink = (prm_target_fPowerBlink - _fPowerBlink) / (int)prm_spend_frame;
                    //_TRACE_("intoTargetBlinkLinerUntil prm_target_fPowerBlink="<<prm_target_fPowerBlink<<"/ _fPowerBlink["<<prm_<<"]="<<_fPowerBlink);
                    //_TRACE_("intoTargetBlinkLinerUntil _velo_fPowerBlink["<<prm_<<"]="<<_velo_fPowerBlink);
                    if (_velo_fPowerBlink == 0.0f) {
                        _method = NOBLINK;
                    }
                }
                
                void GgafDx9TextureBlinker::intoTargetBlinkAcceStep(float prm_target_fPowerBlink, float prm_velo_fPowerBlink, float prm_acce_fPowerBlink) {
                    _method = TARGET_BLINK_ACCELERATION;
                    _target_fPowerBlink = prm_target_fPowerBlink;
                    _velo_fPowerBlink = prm_velo_fPowerBlink;
                    _acce_fPowerBlink = prm_acce_fPowerBlink;
                }
                
                void GgafDx9TextureBlinker::intoTargetBlinkLinerStep(float prm_target_fPowerBlink, float prm_velo_fPowerBlink) {
                    _method = TARGET_BLINK_LINER;
                    _target_fPowerBlink = prm_target_fPowerBlink;
                    _velo_fPowerBlink = sgn(prm_target_fPowerBlink - _fPowerBlink)*prm_velo_fPowerBlink;
                }
                
                void GgafDx9TextureBlinker::loopLiner(frame prm_beat_spend_frame, float prm_beat_num) {
                    _method = BEAT_BLINK_LINER;
                    _one_way_cnt = 0;
                    _stop_one_way_num = (int)(prm_beat_num*2.0f);
                    _beat_spend_frame = prm_beat_spend_frame;
                    _velo_fPowerBlink = (_top_fPowerBlink - _fPowerBlink) / ((int)prm_beat_spend_frame / 2);
                    if (_velo_fPowerBlink == 0.0f) {
                        _velo_fPowerBlink = 0.1f; //0
                    }
                }
                
                
                void GgafDx9TextureBlinker::beat(frame prm_beat_spend_frame, frame prm_attack_frame, frame prm_rest_frame, float prm_beat_num) {
                    _method = BEAT_BLINK_TRIANGLEWAVE;
                    _one_way_cnt = 0;
                    _stop_one_way_num = (int)(prm_beat_num*2.0f);
                
                    _beat_attack_frame = prm_attack_frame;
                    _beat_rest_frame = prm_rest_frame;
                    _beat_begin_frame = _pModel->_frame_blinker;
                    _beat_spend_frame = prm_beat_spend_frame;
                
                    _velo_fPowerBlink = (_top_fPowerBlink - _fPowerBlink) / (int)prm_attack_frame;
                //    if (_velo_fPowerBlink == 0.0f) {
                //        _velo_fPowerBlink = 0.0f;
                //    }
                }
                
                void GgafDx9TextureBlinker::stopImmediately() {
                    _method = NOBLINK;
                }
                
          52 -> GgafDx9TextureBlinker::~GgafDx9TextureBlinker() {
                }


Top 10 Lines:

     Line      Count

      167         52
        6         26

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       78   Total number of line executions
    26.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/util/GgafDx9Quaternion.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                
                
                
           8 -> GgafDx9Quaternion::~GgafDx9Quaternion() {
                }


Top 10 Lines:

     Line      Count

        9          8

Execution Summary:

        2   Executable lines in this file
        1   Lines executed
    50.00   Percent of the file executed

        8   Total number of line executions
     4.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/supporter/GgafDx9Scaler.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
        2004 -> GgafDx9Scaler::GgafDx9Scaler(GgafDx9GeometricActor* prm_pActor) :
                    GgafObject() {
                    _pActor = prm_pActor;
                
                    for (int axis = 0; axis < 3; axis++) {
                        _scale[axis] = LEN_UNIT;
                        _velo_scale[axis] = 0;
                        _target_scale[axis] = LEN_UNIT;
                        _top_scale[axis] = INT_MAX;
                        _bottom_scale[axis] = 1;
                        _one_way_cnt[axis] = 0;
                        _beat_attack_frame[axis] = 0;
                        _beat_rest_frame[axis] = 0;
                        _beat_begin_frame[axis] = 0;
                        _beat_spend_frame[axis] = 0;
                        _stop_one_way_num[axis] = -1;
                        _method[axis] = NOSCALE;
                    }
                }
                
                void GgafDx9Scaler::behave() {
                    for (int axis = 0; axis < 3; axis++) {
                        if (_method[axis] == NOSCALE) {
                            continue;
                        } else if (_method[axis] == TARGET_SCALE_LINER) {
                
                            _scale[axis] += _velo_scale[axis];
                
                            //_TRACE_("_velo_scale["<<axis<<"]="<<_velo_scale[axis]<<"/_target_scale["<<axis<<"]="<<_target_scale[axis]<<"/_scale["<<axis<<"]="<<_scale[axis]);
                            if (_velo_scale[axis] > 0 && _target_scale[axis] <= _scale[axis]) {
                                //_TRACE_("END1");
                                _scale[axis] = _target_scale[axis];
                                _method[axis] = NOSCALE;
                            } else if (_velo_scale[axis] < 0 && _target_scale[axis] >= _scale[axis]) {
                                //_TRACE_("END2");
                                _scale[axis] = _target_scale[axis];
                                _method[axis] = NOSCALE;
                            }
                        } if (_method[axis] == TARGET_SCALE_ACCELERATION) {
                            _scale[axis] += _velo_scale[axis];
                            //if (_velo_scale[axis] > 0 && _target_scale[axis] <= _scale[axis]) {
                            if (_acce_scale[axis] > 0 && _target_scale[axis] <= _scale[axis]) {
                                _scale[axis] = _target_scale[axis];
                                _method[axis] = NOSCALE;
                            //} else if (_velo_scale[axis] < 0 && _target_scale[axis] >= _scale[axis]) {
                            } else if (_acce_scale[axis] < 0 && _target_scale[axis] >= _scale[axis]) {
                                _scale[axis] = _target_scale[axis];
                                _method[axis] = NOSCALE;
                            }
                            _velo_scale[axis] += _acce_scale[axis];
                        } else if (_method[axis] == BEAT_SCALE_LINER) {
                            _scale[axis] += _velo_scale[axis];
                            if (_top_scale[axis] <= _scale[axis]) {
                                _scale[axis] = _top_scale[axis];
                                _velo_scale[axis] = -2 * (_top_scale[axis] - _bottom_scale[axis]) / (int)_beat_spend_frame[axis];
                                _one_way_cnt[axis]++;
                                if (_one_way_cnt[axis] == _stop_one_way_num[axis]) {
                                    _method[axis] = NOSCALE;
                                }
                            } else if (_bottom_scale[axis] >= _scale[axis]) {
                                _scale[axis] = _bottom_scale[axis];
                                _velo_scale[axis] = 2 * (_top_scale[axis] - _bottom_scale[axis]) / (int)_beat_spend_frame[axis];
                                _one_way_cnt[axis]++;
                                if (_one_way_cnt[axis] == _stop_one_way_num[axis]) {
                                    _method[axis] = NOSCALE;
                                }
                            }
                
                        } else if (_method[axis] == BEAT_SCALE_TRIANGLEWAVE) {
                            //setScale(axis, _scale[axis] += _velo_scale[axis]);
                            _scale[axis] += _velo_scale[axis];
                            if (_beat_begin_frame[axis] + _beat_attack_frame[axis] == _pActor->_frame_of_behaving) { //A^bN_
                                _scale[axis] = _top_scale[axis];
                                _velo_scale[axis] = (_bottom_scale[axis] - _top_scale[axis]) / ((int)_beat_spend_frame[axis] - (int)_beat_attack_frame[axis] - (int)_beat_rest_frame[axis]);
                                _one_way_cnt[axis]++;
                                if (_one_way_cnt[axis] == _stop_one_way_num[axis]) {
                                    _method[axis] = NOSCALE;
                                }
                            } else if (_bottom_scale[axis] > _scale[axis]) {  //if (_bottom_scale[axis] >= _scale[axis]) sI
                                _scale[axis] = _bottom_scale[axis];
                                _velo_scale[axis] = 0;
                            } else if (_beat_begin_frame[axis] + _beat_spend_frame[axis] == _pActor->_frame_of_behaving) { //[vI
                                _beat_begin_frame[axis] = _pActor->_frame_of_behaving;
                                _velo_scale[axis] = (_top_scale[axis] - _bottom_scale[axis]) / (int)_beat_attack_frame[axis];
                                _one_way_cnt[axis]++;
                                if (_one_way_cnt[axis] == _stop_one_way_num[axis]) {
                                    _method[axis] = NOSCALE;
                                }
                            }
                        }
                    }
                    //Actorf
                    _pActor->_SX = _scale[AXIS_X];
                    _pActor->_SY = _scale[AXIS_Y];
                    _pActor->_SZ = _scale[AXIS_Z];
                }
                
                //g
                //            _TRACE_("---sO");
                //            _TRACE_("_pActor->_frame_of_behaving="<<_pActor->_frame_of_behaving);
                //            _TRACE_("_bottom_scale["<<axis<<"]="<<_bottom_scale[axis]);
                //            _TRACE_("_top_scale["<<axis<<"]="<<_top_scale[axis]);
                //            _TRACE_("_beat_spend_frame["<<axis<<"]="<<_beat_spend_frame[axis]);
                //            _TRACE_("_beat_attack_frame["<<axis<<"]="<<_beat_attack_frame[axis]);
                //            _TRACE_("_beat_rest_frame["<<axis<<"]="<<_beat_rest_frame[axis]);
                //            _TRACE_("_beat_spend_frame["<<axis<<"] - _beat_attack_frame["<<axis<<"] - _beat_rest_frame["<<axis<<"]) = " << (_beat_spend_frame[axis] - _beat_attack_frame[axis] - _beat_rest_frame[axis]));
                //            _TRACE_("(_bottom_scale["<<axis<<"] - _top_scale["<<axis<<"]) / (_beat_spend_frame["<<axis<<"] - _beat_attack_frame["<<axis<<"] - _beat_rest_frame["<<axis<<"])="<<((int)(_bottom_scale[axis] - _top_scale[axis]) / (int)(_beat_spend_frame[axis] - _beat_attack_frame[axis] - _beat_rest_frame[axis])));
                //            _TRACE_("_bottom_scale["<<axis<<"] - _top_scale["<<axis<<"]" << (_bottom_scale[axis] - _top_scale[axis]));
                //            _TRACE_("_scale["<<axis<<"] _velo_scale["<<axis<<"]="<<_scale[axis]<<" "<<_velo_scale[axis]);
                
                void GgafDx9Scaler::intoTargetScaleLinerUntil(int prm_target_scale, frame prm_spend_frame) {
                    for (int axis = 0; axis < 3; axis++) {
                        intoTargetScaleLinerUntil(axis, prm_target_scale, prm_spend_frame);
                    }
                }
                
                void GgafDx9Scaler::intoTargetScaleLinerUntil(int prm_axis, int prm_target_scale, frame prm_spend_frame) {
                    //_TRACE_("intoTargetScaleLinerUntil prm_axis="<<prm_axis<<"/prm_target_scale="<<prm_target_scale<<"/prm_spend_frame="<<prm_spend_frame);
                    _method[prm_axis] = TARGET_SCALE_LINER;
                    _target_scale[prm_axis] = prm_target_scale;
                    _velo_scale[prm_axis] = (prm_target_scale - _scale[prm_axis]) / (int)prm_spend_frame;
                    //_TRACE_("intoTargetScaleLinerUntil prm_target_scale="<<prm_target_scale<<"/ _scale["<<prm_axis<<"]="<<_scale[prm_axis]);
                    //_TRACE_("intoTargetScaleLinerUntil _velo_scale["<<prm_axis<<"]="<<_velo_scale[prm_axis]);
                    if (_velo_scale[prm_axis] == 0) {
                        _velo_scale[prm_axis] = prm_target_scale - _scale[prm_axis];
                    }
                }
                
                void GgafDx9Scaler::intoTargetScaleAcceStep(int prm_target_scale, int prm_velo_scale, int prm_acce_scale) {
                    for (int axis = 0; axis < 3; axis++) {
                        intoTargetScaleAcceStep(axis, prm_target_scale, prm_velo_scale, prm_acce_scale);
                    }
                }
                
                void GgafDx9Scaler::intoTargetScaleAcceStep(int prm_axis, int prm_target_scale, int prm_velo_scale, int prm_acce_scale) {
                    _method[prm_axis] = TARGET_SCALE_ACCELERATION;
                    _target_scale[prm_axis] = prm_target_scale;
                    _velo_scale[prm_axis] = prm_velo_scale;
                    _acce_scale[prm_axis] = prm_acce_scale;
                }
                
                void GgafDx9Scaler::intoTargetScaleLinerStep(int prm_target_scale, int prm_velo_scale) {
                    for (int axis = 0; axis < 3; axis++) {
                        intoTargetScaleLinerStep(axis, prm_target_scale, prm_velo_scale);
                    }
                }
                
                void GgafDx9Scaler::intoTargetScaleLinerStep(int prm_axis, int prm_target_scale, int prm_velo_scale) {
                    _method[prm_axis] = TARGET_SCALE_LINER;
                    _target_scale[prm_axis] = prm_target_scale;
                    _velo_scale[prm_axis] = sgn(prm_target_scale - _scale[prm_axis])*prm_velo_scale;
                }
                
                
                void GgafDx9Scaler::loopLiner(frame prm_beat_spend_frame, float prm_beat_num) {
                    for (int axis = 0; axis < 3; axis++) {
                        loopLiner(axis, prm_beat_spend_frame, prm_beat_num);
                    }
                }
                
                void GgafDx9Scaler::loopLiner(int prm_axis, frame prm_beat_spend_frame, float prm_beat_num) {
                    _method[prm_axis] = BEAT_SCALE_LINER;
                    _one_way_cnt[prm_axis] = 0;
                    _stop_one_way_num[prm_axis] = (int)(prm_beat_num*2.0f);
                    _beat_spend_frame[prm_axis] = prm_beat_spend_frame;
                    _velo_scale[prm_axis] = (_top_scale[prm_axis] - _scale[prm_axis]) / ((int)prm_beat_spend_frame / 2);
                    if (_velo_scale[prm_axis] == 0) {
                        _velo_scale[prm_axis] = _top_scale[prm_axis] - _scale[prm_axis];
                    }
                }
                
                void GgafDx9Scaler::beat(frame prm_beat_spend_frame, frame prm_attack_frame, frame prm_rest_frame, float prm_beat_num) {
                    for (int axis = 0; axis < 3; axis++) {
                        beat(axis, prm_beat_spend_frame, prm_attack_frame, prm_rest_frame, prm_beat_num);
                    }
                }
                
                
                void GgafDx9Scaler::beat(int prm_axis, frame prm_beat_spend_frame, frame prm_attack_frame, frame prm_rest_frame, float prm_beat_num) {
                    _method[prm_axis] = BEAT_SCALE_TRIANGLEWAVE;
                    _one_way_cnt[prm_axis] = 0;
                    _stop_one_way_num[prm_axis] = (int)(prm_beat_num*2.0f);
                
                    _beat_attack_frame[prm_axis] = prm_attack_frame;
                    _beat_rest_frame[prm_axis] = prm_rest_frame;
                    _beat_begin_frame[prm_axis] = _pActor->_frame_of_behaving;
                    _beat_spend_frame[prm_axis] = prm_beat_spend_frame;
                
                    _velo_scale[prm_axis] = (_top_scale[prm_axis] - _scale[prm_axis]) / (int)prm_attack_frame;
                    if (_velo_scale[prm_axis] == 0) {
                        _velo_scale[prm_axis] = _top_scale[prm_axis] - _scale[prm_axis];
                    }
                
                }
                
                void GgafDx9Scaler::stopImmediately() {
                    for (int axis = 0; axis < 3; axis++) {
                        stopImmediately(axis);
                    }
                }
                
                void GgafDx9Scaler::stopImmediately(int prm_axis) {
                    _method[prm_axis] = NOSCALE;
                }
                
                
        4010 -> GgafDx9Scaler::~GgafDx9Scaler() {
                }


Top 10 Lines:

     Line      Count

      212       4010
        6       2004

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

     6014   Total number of line executions
  2004.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/supporter/GgafDx9UvFlipper.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
         216 -> GgafDx9UvFlipper::GgafDx9UvFlipper(GgafDx9GeometricActor* prm_pActor) : GgafObject() {
                    _pActor = prm_pActor;
                    _pattno_uvflip_top = 0;
                    _pattno_uvflip_bottom = 0;
                    _pattno_uvflip_now = 0;
                    _frame_uvflip_interval = 1;
                    _uvflip_method = FLIP_ORDER_LOOP;
                    _frame_counter_uvflip = 0;
                    _is_reverse_order_in_oscillate_animation_flg = false;
                    _tex_width = 1.0f;
                    _tex_height = 1.0f;
                    _tex_col_num = 1;
                    _paInt_PtnOffset_Customized = NULL;
                    _nPtn_Customized = 0;
                    _cnt_Customized = 0;
                }
                
                void GgafDx9UvFlipper::setTextureUvRotation(int prm_tex_col_num, float prm_tex_width, float prm_tex_height)  {
                    if (prm_tex_col_num < 0) {
                        throwGgafCriticalException("GgafDx9UvFlipper::setTextureUvRotation prm_tex_col_num0B");
                    }
                    _tex_width = prm_tex_width;
                    _tex_height = prm_tex_height;
                    _tex_col_num = prm_tex_col_num;
                }
                
                void GgafDx9UvFlipper::setPtnNo(int prm_pattno_uvflip) {
                    if (_pattno_uvflip_top <= prm_pattno_uvflip && prm_pattno_uvflip <= _pattno_uvflip_bottom) {
                        _pattno_uvflip_now = prm_pattno_uvflip;
                    } else if (prm_pattno_uvflip < _pattno_uvflip_top) {
                        _pattno_uvflip_now = _pattno_uvflip_top;
                    } else if (prm_pattno_uvflip > _pattno_uvflip_bottom) {
                        _pattno_uvflip_now = _pattno_uvflip_bottom;
                    }
                }
                
                void GgafDx9UvFlipper::setPtnNoToTop() {
                    _pattno_uvflip_now = _pattno_uvflip_top;
                }
                
                void GgafDx9UvFlipper::forcePtnNoRange(int prm_top, int prm_bottom) {
                #ifdef MY_DEBUG
                    if (prm_top < 0) {
                        _TRACE_("GgafDx9UvFlipper::forcePtnNoRange prm_top="<<prm_top<<" TOPB}H");
                    }
                    if (prm_top > prm_bottom) {
                        throwGgafCriticalException("GgafDx9UvFlipper::forcePtnNoRange prm_top="<<prm_top<<",prm_bottom="<<prm_bottom<<" ");
                    }
                #endif
                    _pattno_uvflip_top = prm_top;
                    _pattno_uvflip_bottom = prm_bottom;
                }
                
                void GgafDx9UvFlipper::setFlipMethod(GgafDx9UvFlipMethod prm_method, int prm_interval) {
                    _uvflip_method = prm_method;
                    _frame_uvflip_interval = prm_interval;
                }
                
                void GgafDx9UvFlipper::behave() {
                //    _TRACE_(getName()<<":_pattno_uvflip_now="<<_pattno_uvflip_now<<"/_pattno_uvflip_bottom="<<_pattno_uvflip_bottom<<"/_pattno_uvflip_top="<<_pattno_uvflip_top<<"/_is_reverse_order_in_oscillate_animation_flg="<<_is_reverse_order_in_oscillate_animation_flg<<"");
                
                    _frame_counter_uvflip++;
                    if (_frame_uvflip_interval < _frame_counter_uvflip) {
                        if (_uvflip_method == FLIP_ORDER_LOOP) { //F0,1,2,3,4,5,0,1,2,3,4,5,...
                            if (_pattno_uvflip_bottom > _pattno_uvflip_now) {
                                _pattno_uvflip_now++;
                            } else {
                                _pattno_uvflip_now = _pattno_uvflip_top;
                            }
                        } else if (_uvflip_method == FLIP_REVERSE_LOOP) { //F5,4,3,2,1,0,5,4,3,2,1,0,5,4...
                            if (_pattno_uvflip_top < _pattno_uvflip_now) {
                                _pattno_uvflip_now--;
                            } else {
                                _pattno_uvflip_now = _pattno_uvflip_bottom;
                            }
                        } else if (_uvflip_method == FLIP_ORDER_NOLOOP) { //F0,1,2,3,4,5,5,5,5,5,5,5...
                            if (_pattno_uvflip_bottom > _pattno_uvflip_now) {
                                _pattno_uvflip_now++;
                            } else {
                                _pattno_uvflip_now = _pattno_uvflip_bottom;
                                _pActor->onCatchEvent(GGAF_EVENT_NOLOOP_UVFLIP_FINISHED, this); //Aj[Vim
                                _uvflip_method = NOT_ANIMATED;
                            }
                        } else if (_uvflip_method == FLIP_REVERSE_NOLOOP) { //F5,4,3,2,1,0,0,0,0,0,0...
                            if (_pattno_uvflip_top < _pattno_uvflip_now) {
                                _pattno_uvflip_now--;
                            } else {
                                _pattno_uvflip_now = _pattno_uvflip_top;
                                _pActor->onCatchEvent(GGAF_EVENT_NOLOOP_UVFLIP_FINISHED, this); //Aj[Vim
                                _uvflip_method = NOT_ANIMATED;
                            }
                        } else if (_uvflip_method == FLIP_OSCILLATE_LOOP) { //F0,1,2,3,4,5,4,3,2,1,0,1,2,3,4,5,...
                            //TODO: ig@j
                            if (_is_reverse_order_in_oscillate_animation_flg) { //t
                                if (_pattno_uvflip_top < _pattno_uvflip_now) {
                                    _pattno_uvflip_now--;
                                } else {
                                    _pattno_uvflip_now++;
                                    _is_reverse_order_in_oscillate_animation_flg = false;
                                }
                            } else {                                            //
                                if (_pattno_uvflip_bottom > _pattno_uvflip_now) {
                                    _pattno_uvflip_now++;
                                } else {
                                    _pattno_uvflip_now--;
                                    _is_reverse_order_in_oscillate_animation_flg = true;
                                }
                            }
                        } else if (_uvflip_method == FLIP_CUSTOMIZED_LOOP) {
                            //TODO: ig@j
                            if (_paInt_PtnOffset_Customized) {
                                _pattno_uvflip_now = _paInt_PtnOffset_Customized[_cnt_Customized];
                                _cnt_Customized ++;
                                if (_cnt_Customized == _nPtn_Customized) {
                                    _cnt_Customized = 0;
                                }
                            }
                        } else if (_uvflip_method == FLIP_CUSTOMIZED_NOLOOP) {
                            //TODO: ig@j
                            if (_paInt_PtnOffset_Customized) {
                                _pattno_uvflip_now = _paInt_PtnOffset_Customized[_cnt_Customized];
                                _cnt_Customized ++;
                                if (_cnt_Customized == _nPtn_Customized) {
                                    _pActor->onCatchEvent(GGAF_EVENT_NOLOOP_UVFLIP_FINISHED, this); //Aj[Vim
                                    _cnt_Customized = 0;
                                    _uvflip_method = NOT_ANIMATED;
                                }
                            }
                        } else if (_uvflip_method == NOT_ANIMATED) {
                            //
                        }
                        _frame_counter_uvflip = 0;
                    }
                
                }
                
                void GgafDx9UvFlipper::customizePtnOrder(int prm_aPtnOffset[], int prm_num) {
                    _paInt_PtnOffset_Customized = NEW int[prm_num];
                    _nPtn_Customized = prm_num;
                    for (int i = 0; i < prm_num; i++) {
                        _paInt_PtnOffset_Customized[i] = prm_aPtnOffset[i];
                    }
                }
                
                
                void GgafDx9UvFlipper::getUV(float& out_u, float& out_v) {
                #ifdef MY_DEBUG
                    if (_tex_col_num == 0) {
                        throwGgafCriticalException("GgafDx9UvFlipper::getUV [ZB_tex_col_numlsB");
                    }
                #endif
                    out_u = ((int)(_pattno_uvflip_now % _tex_col_num)) * _tex_height;
                    out_v = ((int)(_pattno_uvflip_now / _tex_col_num)) * _tex_width;
                }
                
         432 -> GgafDx9UvFlipper::~GgafDx9UvFlipper() {
                }


Top 10 Lines:

     Line      Count

      161        432
        6        216

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      648   Total number of line executions
   216.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/supporter/GgafDx9SeTransmitter.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                
        4697 -> GgafDx9SeTransmitter::GgafDx9SeTransmitter(GgafDx9GeometricActor* prm_pActor) :
                                                       GgafObject() {
                    _pActor = prm_pActor;
                    _se_num = 0;
                    _papSeCon = NULL;
                    _pa_is3D = NULL;
                }
                
                void GgafDx9SeTransmitter::useSe(int prm_se_num) {
                    _se_num = prm_se_num;
                    _papSeCon = NEW GgafDx9SeConnection*[_se_num];
                    _pa_is3D = NEW bool[_se_num];
                    for (int i = 0; i < _se_num; i++) {
                        _papSeCon[i] = NULL;
                        _pa_is3D[i] = false;
                    }
                }
                
                void GgafDx9SeTransmitter::set(int prm_id, const char* prm_se_name, int prm_cannel) {
                #ifdef MY_DEBUG
                    if (_se_num <= 0) {
                        throwGgafCriticalException("GgafDx9SeTransmitter::set() useSegpSeOB_pActor="<<_pActor->getName()<<" prm_id="<<prm_id);
                    }
                    if (prm_id < 0 || prm_id >= _se_num) {
                        throwGgafCriticalException("GgafDx9SeTransmitter::set() IDOB0~"<<(_se_num-1)<<"B_pActor="<<_pActor->getName()<<" prm_id="<<prm_id);
                    }
                #endif
                    char idstr[129];
                    sprintf(idstr, "%d/%s", prm_cannel, prm_se_name);
                    _papSeCon[prm_id] = (GgafDx9SeConnection*)GgafDx9Sound::_pSeManager->getConnection(idstr);
                }
                
                void GgafDx9SeTransmitter::playImmediately(int prm_id) {
                #ifdef MY_DEBUG
                    if (prm_id < 0 || prm_id >= _se_num) {
                        throwGgafCriticalException("GgafDx9SeTransmitter::play() IDOB0~"<<(_se_num-1)<<"B_pActor="<<_pActor->getName()<<" prm_id="<<prm_id);
                    }
                #endif
                    _papSeCon[prm_id]->refer()->play(GGAF_MAX_VOLUME, 0.0);
                    _pa_is3D[prm_id] = false;
                }
                
                
                void GgafDx9SeTransmitter::play(int prm_id) {
                #ifdef MY_DEBUG
                    if (prm_id < 0 || prm_id >= _se_num) {
                        throwGgafCriticalException("GgafDx9SeTransmitter::play() IDOB0~"<<(_se_num-1)<<"B_pActor="<<_pActor->getName()<<" prm_id="<<prm_id);
                    }
                #endif
                    P_UNIVERSE->registSe(_papSeCon[prm_id]->refer(), GGAF_MAX_VOLUME, 0.0, 1.0, 0);
                    _pa_is3D[prm_id] = false;
                }
                void GgafDx9SeTransmitter::play3D(int prm_id) {
                #ifdef MY_DEBUG
                    if (prm_id < 0 || prm_id >= _se_num) {
                        throwGgafCriticalException("GgafDx9SeTransmitter::play3D() IDOB0~"<<(_se_num-1)<<"B_pActor="<<_pActor->getName()<<" prm_id="<<prm_id);
                    }
                #endif
                    static const int VOLUME_MAX_3D = GGAF_MAX_VOLUME;
                    static const int VOLUME_MIN_3D = GGAF_MIN_VOLUME;
                    static const int VOLUME_RANGE_3D = VOLUME_MAX_3D - VOLUME_MIN_3D;
                    GgafDx9Camera* pCam = P_CAM;
                    //vZ
                    //xA100P_CAM
                    //gP_CAM
                    int DX = (pCam->_X - _pActor->_X) / LEN_UNIT;
                    int DY = (pCam->_Y - _pActor->_Y) / LEN_UNIT;
                    int DZ = (pCam->_Z - _pActor->_Z) / LEN_UNIT;
                    double d = GgafUtil::sqrt_fast(double(DX*DX + DY*DY + DZ*DZ));
                    LONG vol =  VOLUME_MIN_3D + ((1.0 - (d / (pCam->_zf*PX_UNIT*0.75))) * VOLUME_RANGE_3D); // 0.75 
                    if (VOLUME_MAX_3D < vol) {
                        vol = VOLUME_MAX_3D;
                    } else if (VOLUME_MIN_3D > vol) {
                        vol = VOLUME_MIN_3D;
                    }
                
                    float fDist_VpVerticalCenter  =
                            pCam->_plnVerticalCenter.a*_pActor->_fX +
                            pCam->_plnVerticalCenter.b*_pActor->_fY +
                            pCam->_plnVerticalCenter.c*_pActor->_fZ +
                            pCam->_plnVerticalCenter.d;
                
                    angle ang = GgafDx9Util::getAngle2D(fDist_VpVerticalCenter, -_pActor->_fDist_VpPlnFront );
                    float pan = GgafDx9Util::COS[ang/ANGLE_RATE] * 0.7; //0.7SE
                
                    int delay = (d / (pCam->_zf*PX_UNIT))*MAX_SE_DELAY-10; //10t[
                    if (delay < 0) {
                        delay = 0;
                    } else if (delay > MAX_SE_DELAY) {
                        delay = MAX_SE_DELAY;
                    }
                
                    float rate_frequency = 1.0;
                    if (_pActor->_fDist_VpPlnFront > 0) {
                        rate_frequency = 0.9; //wgAB
                    }
                
                
                    P_UNIVERSE->registSe(_papSeCon[prm_id]->refer(), vol, pan, rate_frequency, delay); // + (GgafDx9Se::VOLUME_RANGE / 6) 
                
                    _pa_is3D[prm_id] = true;
                    //^
                   //                float dPlnLeft = abs(_fDist_VpPlnLeft);
                   //                float dPlnRight = abs(_fDist_VpPlnRight);
                   //                if (dPlnLeft < dPlnRight) {
                   //                    //sin = dPlnLeft/d;
                   //                    // = asin(dPlnLeft/d)
                   //                    //X = (_rad_half_fovY - )
                   //                    //tan X =  / d
                   //                    //d * tan X = 
                   //                    //d * tan (_rad_half_fovY - ) = 
                   //                    //d * tan (_rad_half_fovY - asin(dPlnLeft/d)) = 
                   //                    //{H
                
                
                
                   // _papSe[prm_id]->play();
                }
                
                void GgafDx9SeTransmitter::updatePanVolume3D() {
                    static const int VOLUME_MAX_3D = GGAF_MAX_VOLUME;
                    static const int VOLUME_MIN_3D = GGAF_MIN_VOLUME;
                    static const int VOLUME_RANGE_3D = VOLUME_MAX_3D - VOLUME_MIN_3D;
                    float pan;
                    LONG vol;
                    float rate_frequency;
                    bool calc_flg = true;
                    for (int i = 0; i < _se_num; i++) {
                        if (_pa_is3D[i]) {
                            if (_papSeCon[i]->refer()->isPlaying()) {
                                rate_frequency = 1.0;
                                if (calc_flg) {
                                    calc_flg = false;
                                    GgafDx9Camera* pCam = P_CAM;
                                    //vZ
                                    //xA100P_CAM
                                    //gP_CAM
                                    int DX = (pCam->_X - _pActor->_X) / LEN_UNIT;
                                    int DY = (pCam->_Y - _pActor->_Y) / LEN_UNIT;
                                    int DZ = (pCam->_Z - _pActor->_Z) / LEN_UNIT;
                
                                    //Y^
                                    //A_pActor->_X AlQB
                                    // GGAF_SAYONARA_DELAY dv
                
                                    double d = GgafUtil::sqrt_fast(double(DX*DX + DY*DY + DZ*DZ));
                                    vol =  VOLUME_MIN_3D + ((1.0 - (d / (pCam->_zf*PX_UNIT*0.75))) * VOLUME_RANGE_3D);
                                    if (VOLUME_MAX_3D < vol) {
                                        vol = VOLUME_MAX_3D;
                                    } else if (VOLUME_MIN_3D > vol) {
                                        vol = VOLUME_MIN_3D;
                                    }
                
                                    float fDist_VpVerticalCenter  =
                                            pCam->_plnVerticalCenter.a*_pActor->_fX +
                                            pCam->_plnVerticalCenter.b*_pActor->_fY +
                                            pCam->_plnVerticalCenter.c*_pActor->_fZ +
                                            pCam->_plnVerticalCenter.d;
                                    angle ang = GgafDx9Util::getAngle2D(fDist_VpVerticalCenter, -_pActor->_fDist_VpPlnFront );
                                    pan = GgafDx9Util::COS[ang/ANGLE_RATE] * 0.7; //0.7SE
                
                                    if (_pActor->_fDist_VpPlnFront > 0) {
                                        rate_frequency = 0.9; //wgAB
                                    }
                                }
                                _papSeCon[i]->refer()->setPan(pan);
                                _papSeCon[i]->refer()->setVolume(vol);
                                _papSeCon[i]->refer()->setFrequencyRate(rate_frequency);
                            } else {
                                _pa_is3D[i] = false;
                            }
                        }
                    }
                }
                
                void GgafDx9SeTransmitter::behave() {
                    if (_pActor->_frame_of_life % 4 == 0) {
                        updatePanVolume3D();
                    }
                }
                
        9394 -> GgafDx9SeTransmitter::~GgafDx9SeTransmitter() {
                    for (int i = 0; i < _se_num; i++) {
                        if (_papSeCon[i]) {
                            _papSeCon[i]->close();
                        }
                    }
                    DELETEARR_POSSIBLE_NULL(_papSeCon);
                    DELETEARR_POSSIBLE_NULL(_pa_is3D);
                }
                


Top 10 Lines:

     Line      Count

      188       9394
        7       4697

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

    14091   Total number of line executions
  4697.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/GgafDx9MeshSetActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
        4458 -> GgafDx9MeshSetActor::GgafDx9MeshSetActor(const char* prm_name,
                                                         const char* prm_model_id,
                                                         const char* prm_effect_id,
                                                         const char* prm_technique,
                                                         GgafDx9Checker* prm_pChecker) :
                
                                                             GgafDx9DrawableActor(prm_name,
                                                                                  prm_model_id,
                                                                                  "x",
                                                                                  prm_effect_id,
                                                                                  "x",
                                                                                  prm_technique,
                                                                                  prm_pChecker) {
                    _obj_class |= Obj_GgafDx9MeshSetActor;
                    _class_name = "GgafDx9MeshSetActor";
                    _pMeshSetModel = (GgafDx9MeshSetModel*)_pGgafDx9Model;
                    _pMeshSetEffect = (GgafDx9MeshSetEffect*)_pGgafDx9Effect;
                    _pFunc_calcRotMvWorldMatrix = GgafDx9Util::setWorldMatrix_RxRzRyMv;
                }
                
       ##### -> GgafDx9MeshSetActor::GgafDx9MeshSetActor(const char* prm_name,
                                                         const char* prm_model_id,
                                                         const char* prm_model_type,
                                                         const char* prm_effect_id,
                                                         const char* prm_effect_type,
                                                         const char* prm_technique,
                                                         GgafDx9Checker* prm_pChecker) :
                
                                                             GgafDx9DrawableActor(prm_name,
                                                                                  prm_model_id,
                                                                                  prm_model_type,
                                                                                  prm_effect_id,
                                                                                  prm_effect_type,
                                                                                  prm_technique,
                                                                                  prm_pChecker) {
                    _obj_class |= Obj_GgafDx9MeshSetActor;
                    _class_name = "GgafDx9MeshSetActor";
                    _pMeshSetModel = (GgafDx9MeshSetModel*)_pGgafDx9Model;
                    _pMeshSetEffect = (GgafDx9MeshSetEffect*)_pGgafDx9Effect;
                    _pFunc_calcRotMvWorldMatrix = GgafDx9Util::setWorldMatrix_RxRzRyMv;
                }
                
                void GgafDx9MeshSetActor::setAlpha(float prm_fAlpha) {
                    _fAlpha = prm_fAlpha;
                    //GgafDx9MeshSetActorbViVF[_[Qj
                    for (DWORD i = 0; i < _pMeshSetModel->_dwNumMaterials; i++) {
                        _paD3DMaterial9[i].Ambient.a = _fAlpha;
                        _paD3DMaterial9[i].Diffuse.a = _fAlpha;
                    }
                }
                
                void GgafDx9MeshSetActor::addAlpha(float prm_fAlpha) {
                    _fAlpha += prm_fAlpha;
                    //GgafDx9MeshSetActorbViVF[_[Qj
                    for (DWORD i = 0; i < _pMeshSetModel->_dwNumMaterials; i++) {
                        _paD3DMaterial9[i].Ambient.a = _fAlpha;
                        _paD3DMaterial9[i].Diffuse.a = _fAlpha;
                    }
                }
                
                void GgafDx9MeshSetActor::processDraw() {
                    _draw_set_num = 0; //GgafDx9MeshSetActorfeNjbN
                                       //AJEgB`[xx`B
                    ID3DXEffect* pID3DXEffect = _pMeshSetEffect->_pID3DXEffect;
                    HRESULT hr;
                    GgafDx9DrawableActor* pDrawActor = this;
                    GgafDx9MeshSetActor* pMeshSetActor;
                    while (true) {
                        if (pDrawActor)  {
                            if (pDrawActor->_pGgafDx9Model == _pMeshSetModel && pDrawActor->_hash_technique == _hash_technique) {
                                pMeshSetActor = (GgafDx9MeshSetActor*)pDrawActor;
                                //(*_pFunc_calcRotMvWorldMatrix)(pDrawActor, pDrawActor->_matWorld);
                                //GgafDx9Util::setWorldMatrix_ScRxRzRyMv(pDrawActor, pDrawActor->_matWorld);
                                hr = pID3DXEffect->SetMatrix(_pMeshSetEffect->_ah_matWorld[_draw_set_num], &(pMeshSetActor->_matWorld));
                                checkDxException(hr, D3D_OK, "GgafDx9MeshSetActor::processDraw() SetMatrix(g_matWorld) sB");
                                hr = pID3DXEffect->SetValue(_pMeshSetEffect->_ah_materialDiffuse[_draw_set_num], &(pMeshSetActor->_paD3DMaterial9[0].Diffuse), sizeof(D3DCOLORVALUE) );
                                //yGgafDx9MeshSetActor}eAJ[lzY^
                                //{}eAPIuWFNgA}eAXgO[vAsxKgpWX^AeZbg[0]}eAS}eAB
                                //GgafDx9MeshSetActor}eAF8ZbgSPFs\B
                                //PFA}eAFIuWFNg_J[B
                                //{NXAfIuWFNgA8Zbg`Xs[hAbv}INXA}eAO[vIuWFNgsB
                                //PeNX`EEEjB}eAFF GgafDx9MeshActor gB
                                checkDxException(hr, D3D_OK, "GgafDx9MeshSetModel::draw() SetValue(g_colMaterialDiffuse) sB");
                                _draw_set_num++;
                                if (_draw_set_num >= _pMeshSetModel->_set_num) {
                                    break;
                                }
                                pDrawActor = pDrawActor->_pNext_TheSameDrawDepthLevel;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    GgafDx9Universe::_pActor_DrawActive = pMeshSetActor; //`ZbgAN^[Zbg
                    _pMeshSetModel->draw(this, _draw_set_num);
                }
                
        4459 -> GgafDx9MeshSetActor::~GgafDx9MeshSetActor() {
                }


Top 10 Lines:

     Line      Count

      105       4459
        6       4458

Execution Summary:

        4   Executable lines in this file
        3   Lines executed
    75.00   Percent of the file executed

     8917   Total number of line executions
  2229.25   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/supporter/GgafDx9Kuroko.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                // yz{NXlP\
                //
                // Q
                // uLvtBAQP`Bupijvu]pijvB
                // upijvLis\BuxvALWB
                // u]pijvLiOj\B
                // LN^ALN^@B
                // AELABQKvB
                //
                // pijQ\@
                // LiApA_P\LxNg (_vX, _vY, _vZ) \@A
                // Q]AOl (_angRzMv, _angRyMv) \@QpBNH[^jIB
                // _angRzMv  Z]pA _angRyMv  Y]p B0xAxNg(1, 0, 0) `B
                // xNgAxoxAipAW}XjWAvB
                // AY]pox AZ]px AZ]p  Y]pB
                // ( Y]p  Z]p ]AZ]px )
                // {NXAuZ]  Y]Z]pvAPuZ]pv\B
                // \AupiZjvupiYjvB
                //
                // \[XR[hA\bh
                // uRzv\LupiZjiAZ]  Y]jvB
                // uRyv\LupiYjvB
                // uRzRyv\uZ]  Y]pv\B
                //
                // Z]pAY]p0xAxNg(1, 0, 0) `B
                // Z]pAZvB
                // Y]pAYvBB
                //
                // upvZ]pY]pw(_angRzMv, _angRyMv)PxNgw(_vX, _vY, _vZ) A
                // upvlAxNgiXYZljwvB
                // NXAgOA{NX\bh _angRzMv  _angRyMv B
                // AII [hsAuPxNg(_vX, _vY, _vZ)*x vvZKvB
                // PxNgAW]vZA^ _angRzMv  _angRyMv sA
                // PPxNgBlAvB
                // TODO:K]nciAjB
                //
                // {NXCuA(_angRzMv, _angRyMv)AxNg(_vX, _vY, _vZ) B
                // (_vX, _vY, _vZ)\bhgA(_angRzMv, _angRyMv)B
                // {NX\bhgpANB
                //
                // x:Velo or MvVelo
                // Luxv(_veloMv)B@PA{It[upvuxvB
                // upv(_vX, _vY, _vZ)uxv(_veloMv)|ZBPt[W
                // (_vX*_veloMv, _vY*_veloMv, _vZ*_veloMv) B  {CuP(Q[Pl{lj|B
                // A(_vX*_veloMv*LEN_UNIT, _vY*_veloMv*LEN_UNIT, _vZ*_veloMv*LEN_UNIT)Pt[WB
                
                // ]p:AngFace
                // L[JWpiju]pvB
                //u]pvA[hs]]@B
                // [hs]AX]pAY]pAZ]pAA
                // _angFace[AXIS_X], _angFace[AXIS_Y], _angFace[AXIS_Z] B
                // {CuAL[JWnP\LxNg(1, 0, 0) LuOvB
                // Xt@CbVfAXmBAfuvi0, 1, 0)B
                // [hs]s|A{I uX]s > Z]s > Y]s > s > (gk) v B
                // (  X > Y > Z Ij
                // AX]p]ALAcZ]pAY]pLB
                // X]pLXsAQpiZ]pEY]pjLuOvpA
                // u]pvupvAZ]pY]pixox)QAOl
                // (_angFace[AXIS_Z], _angFace[AXIS_Y])\B
                // AuOv Z]pEY]p0xAuv[Z]p,Y]p]=[0x,180x] \BB
                // PuZ]pvAupvZ]pAu]pvZ]pBA
                // u]p(Z)vu]p(Y)vBiu]p(X)vAXs\ej
                // APLpAQANZX@BA
                // uO(1, 0, 0)^Ev  []p(Z), ]p(Y)]=[0, 90x] or [180x,270x] \B
                // i]p(Y)nWYvj
                //  uOv  [180x,180x]\Au^v  [0x,180x]  [180x,0x] \B
                // Ap(L)BpLB
                // RAupvAQANZX@ABpxvZeB
                
                
                // O@\
                //  upiZjvupiYjvAu]p(Z)vu]p(Y)v Rs[A
                // pALN^PI
                // uO@\vAupvAIu]pvB
                // IAt[AAOlRs[ijBZi`jB
                //  EpiZj  ]p(Z)
                //  EpiYj  ]p(Y)
                // u]pvupvitAjB
                
                // px:AngVelo
                // upiZjvupiYjvAu]p(Z)vu]p(Y)vAupxvB
                // 90xEALJNAt[pxpZA
                // B
                // upxvKvBvAvB
                // ]A^[QbgpxBANZX@QAl5B
                // uvsvuvsvupsvupsvusv
                // BprAIvVAIBB
                
                // : VxMv VyMv VzMv
                // LnA XAYAZswB
                // uXxvuYxvuZxvAt[(_X,_Y,_Z)
                // ZB
                
                //L
                //ExAppxA]ppxAxB
                //EXvC_A_\BiGj
                //E]A{ Z > X > Y ]IBOTOZAB
                //   X > Z > Y AZOXB
                //  2DXN[V[eBOvA X > Z vsAB
                //  A3DV[eBOvEEE
                
                //2010/02/19L
                // uRyRzv\iuRzRyvjAuY]  Z]pv\B
                // @AupiZjv]m
                // @uRzRyRzvuRyRzRzvBiPuRzvuRzRyRzvj
                
                //L
                //E\I
                
                //TODO:
                //xixj
                //C]iNH[^jIj
                //NX
                //yzZ
                
                
                
        4695 -> GgafDx9Kuroko::GgafDx9Kuroko(GgafDx9GeometricActor* prm_pActor) :
                    GgafObject() {
                    _pActor = prm_pActor;
                
                
                    for (int i = 0; i < 3; i++) { // i=0:XA1:YA2:Z \
                
                        //]p
                        _angFace[i] = 0; //0 angle  Rp
                        //]ppxi]pj= 0 angle/fream
                        _angveloFace[i] = 0; //1t[Z]ppBftHg]ppAUB
                        //]ppx  360,000 angle/fream
                        _angveloTopFace[i] = ANGLE360; //_angveloFace[n] BftHg1t[D]pUo
                        //]ppx  -360,000 angle/fream
                        _angveloBottomFace[i] = ANGLE360 * -1; //_angveloFace[n] BftHg1t[D]pUo
                        //]ppxipxj  0 angle/fream^2
                        _angacceFace[i] = 0; //_angveloFace[n] BftHg]ppx
                
                        _angjerkFace[i] = 0;
                        //W]ptO = 
                        _face_ang_targeting_flg[i] = false;
                        //W]p~tO = 
                        _face_ang_targeting_stop_flg[i] = false;
                        //W]p
                        _angTargetFace[i] = 0; //W]ptO = A
                        //W]p~@\L]
                        _face_ang_target_allow_way[i] = TURN_BOTH;
                        //W]p~@\Lpxi]j
                        _face_ang_target_allow_velo[i] = ANGLE180;
                    }
                
                    //////////////////////////////////////////////////////
                    //LpPxNg
                    _vX = 1.0f;
                    _vY = _vZ = 0.0f;
                    //pZ]
                    _angRzMv = 0;
                    //pY]
                    _angRyMv = 0;
                    //x
                    _veloMv = 0;
                    //x = 256 px/fream
                    _veloTopMv = 256 * LEN_UNIT; //_veloMv  256000(=256px) AIW 256px }B
                    //x = 0   px/fream
                    _veloBottomMv = -256 * LEN_UNIT; //_veloMv  -256000(-256px) AIW -256000px }B
                    //xixj = 0 px/fream^2
                    _accMv = 0; //_veloMv BftHg
                
                    _jerkMv = 0;
                    //piZ]jpx = 0 angle/fream
                    _angveloRzMv = 0; //1t[ZppBftHgppAB
                    //piZ]jpx = +360,000 angle/fream
                    _angveloRzTopMv = ANGLE360; //_angveloRzMv BftHg1t[DXo
                    //piZ]jpx = -360,000 angle/fream
                    _angveloRzBottomMv = ANGLE360 * -1; //_angveloRzMv BftHg1t[DXo
                    //piZ]jpx = 0 angle/fream^2
                    _angacceRzMv = 0; //_angveloRzMv BftHgppx
                
                    _angjerkRzMv = 0;
                    //WpiZ]jtO = 
                    _mv_ang_rz_target_flg = false;
                    //WpiZ]j~tO = 
                    _mv_ang_rz_target_stop_flg = false;
                
                    //WpiZ]j
                    _angTargetRzMv = 0;
                    //WpiZ]j~@\L]
                    _mv_ang_rz_target_allow_way = TURN_BOTH;
                    //WpiZ]j~@\Lppx(px)
                    _mv_ang_rz_target_allow_velo = ANGLE180;
                    //piZ]jZ]p@\tO  
                    _relate_RzFaceAng_to_RzMvAng_flg = false; //LApZ]pB
                
                    //piY]jpx = 0 angle/fream
                    _angveloRyMv = 0; //1t[ZppBftHgppAB
                    //piY]jpx = +360,000 angle/fream
                    _angveloRyTopMv = ANGLE360; //_angveloRyMv BftHg1t[DXo
                    //piY]jpx = -360,000 angle/fream
                    _angveloRyBottomMv = ANGLE360 * -1; //_angveloRyMv BftHg1t[DXo
                    //piY]jpx = 0 angle/fream^2
                    _angacceRyMv = 0; //_angveloRyMv BftHgppx
                
                    _angjerkRyMv = 0;
                    //WpiY]jtO = 
                    _mv_ang_ry_target_flg = false;
                    //WpiY]j~tO = 
                    _mv_ang_ry_target_stop_flg = false;
                    //WpiY]j
                    _angTargetRyMv = 0;
                    //WpiY]j~@\L]
                    _mv_ang_ry_target_allow_way = TURN_BOTH;
                    //WpiY]j~@\Lppx(px)
                    _mv_ang_ry_target_allow_velo = ANGLE180;
                    //piY]jZ]p@\tO  
                    _relate_RyFaceAng_to_RyMvAng_flg = false; //LApZ]pB
                
                    //XxiXWj 0 px/fream
                    _veloVxMv = 0;
                    //Xx  256 px/fream
                    _veloTopVxMv = 256 * LEN_UNIT;
                    //Xx  256 px/fream
                    _veloBottomVxMv = -256 * LEN_UNIT;
                    //Xxx  0 px/fream^2  ()
                    _acceVxMv = 0;
                    _acceTopVxMv = 256 * LEN_UNIT;
                    _acceBottomVxMv = -256 * LEN_UNIT;
                    //YxiYWj 0 px/fream
                    _veloVyMv = 0;
                    //Yx  256 px/fream
                    _veloTopVyMv = 256 * LEN_UNIT;
                    //Yx  256 px/fream
                    _veloBottomVyMv = -256 * LEN_UNIT;
                    //Yxx  0 px/fream^2  ()
                    _acceVyMv = 0;
                
                    _acceTopVyMv = 256 * LEN_UNIT;
                    _acceBottomVyMv = -256 * LEN_UNIT;
                
                    //ZxiZWj 0 px/fream
                    _veloVzMv = 0;
                    //Zx  256 px/fream
                    _veloTopVzMv = 256 * LEN_UNIT;
                    //Zx  256 px/fream
                    _veloBottomVzMv = -256 * LEN_UNIT;
                    //Zxx  0 px/fream^2  ()
                    _acceVzMv = 0;
                    _acceTopVzMv = 256 * LEN_UNIT;
                    _acceBottomVzMv = -256 * LEN_UNIT;
                
                    _smooth_mv_velo_seq_flg = false;
                    _smooth_mv_velo_seq_endacc_flg = true;
                    _smooth_mv_velo_seq_top_velo = 0;
                    _smooth_mv_velo_seq_end_velo = 0;
                    _smooth_mv_velo_seq_distance_of_target = 0;
                    _smooth_mv_velo_seq_mv_distance = 0;
                    _smooth_mv_velo_seq_frame_of_spend = 0;
                    _smooth_mv_velo_seq_spend_frame = 0;
                    _smooth_mv_velo_seq_p1 = 0;
                    _smooth_mv_velo_seq_p2 = 0;
                    _smooth_mv_velo_seq_progress = -1;
                
                
                    _gravitation_mv_seq_target_X = 0;
                    _gravitation_mv_seq_target_Y = 0;
                    _gravitation_mv_seq_target_Z = 0;
                    _gravitation_mv_seq_pActor_target = NULL;
                    _gravitation_mv_seq_max_velo = 1000;
                    _gravitation_mv_seq_acce = 1000;
                    _gravitation_mv_seq_stop_renge = 1000;
                    _gravitation_mv_seq_flg = false;
                
                    _taget_mv_ang_alltime_flg = false;
                    _taget_mv_ang_alltime_pActor = NULL;
                    _taget_mv_ang_alltime_tX = 0;
                    _taget_mv_ang_alltime_tY = 0;
                    _taget_mv_ang_alltime_tZ = 0;
                    _taget_mv_ang_alltime_angVelo = 0;
                    _taget_mv_ang_alltime_angAcce = 0;
                    _taget_mv_ang_alltime_way = TURN_CLOSE_TO;
                    _taget_mv_ang_alltime_optimize_ang = true;
                
                }
                
                void GgafDx9Kuroko::behave() {
                
                    //]p
                    angle angDistance;
                    for (int i = 0; i < 3; i++) {
                        if (_face_ang_targeting_flg[i]) { //^[Qbg
                            _angveloFace[i] += _angacceFace[i];
                            setFaceAngVelo(i, _angveloFace[i]);
                
                            if (_angveloFace[i] > 0) { //v
                                angDistance = getFaceAngDistance(i, _angTargetFace[i], TURN_COUNTERCLOCKWISE);
                                if (_angveloFace[i] > angDistance && _face_ang_target_allow_way[i] != TURN_CLOCKWISE
                                        && _face_ang_target_allow_velo[i] >= _angveloFace[i]) {
                
                                    //_TRACE_("STOP1 _angveloFace["<<i<<"]="<<_angveloFace[i]<<" angDistance="<<angDistance<<" _face_ang_target_allow_velo["<<i<<"]="<<_face_ang_target_allow_velo[i]<<" _angveloFace["<<i<<"]="<<_angveloFace[i]);
                                    addFaceAng(i, angDistance);
                                    if (_face_ang_targeting_stop_flg[i]) {
                                        _face_ang_targeting_flg[i] = false; //tOI
                                        _face_ang_targeting_stop_flg[i] = false;
                                    }
                                } else {
                                    addFaceAng(i, _angveloFace[i]);
                                }
                            } else if (_angveloFace[i] < 0) { //v
                                angDistance = getFaceAngDistance(i, _angTargetFace[i], TURN_CLOCKWISE);
                                if (_angveloFace[i] < angDistance && _face_ang_target_allow_way[i] != TURN_COUNTERCLOCKWISE
                                        && -1 * _face_ang_target_allow_velo[i] <= _angveloFace[i]) { //WsEEE
                                    addFaceAng(i, angDistance);
                                    if (_face_ang_targeting_stop_flg[i]) { //~L
                                        _face_ang_targeting_flg[i] = false; //tOI
                                    }
                                } else {
                                    addFaceAng(i, _angveloFace[i]);
                                }
                            } else {
                                //_angveloFace[i] == 0
                                addFaceAng(i, 0);
                            }
                
                            if (_face_ang_targeting_flg[i] == false) {
                                //WB
                                //_angveloTopFace[i] = ANGLE360; //]ppx  360,000 angle/fream
                                //_angveloBottomFace[i] = ANGLE360 * -1; //]ppx  -360,000 angle/fream
                
                                //WBA~s
                                _angacceFace[i] = 0; //]pApxO
                                setFaceAngVelo(i, 0); //]pApxO
                            }
                
                        } else {
                            //if (_angacceFace[i] != 0) {
                            //t[]p
                            _angveloFace[i] += _angacceFace[i];
                            if (_angveloFace[i] != 0) {
                                addFaceAng(i, _angveloFace[i]);
                            }
                            //}
                        }
                    }
                
                    //Actorf
                    _pActor->_RX = _angFace[AXIS_X];
                    _pActor->_RY = _angFace[AXIS_Y];
                    _pActor->_RZ = _angFace[AXIS_Z];
                
                    ///////////////////////////////////////////////////Mover
                
                    if(_gravitation_mv_seq_flg) {
                        int dX, dY, dZ;
                        if (_gravitation_mv_seq_pActor_target) {
                            dX = _gravitation_mv_seq_pActor_target->_X - _pActor->_X;
                            dY = _gravitation_mv_seq_pActor_target->_Y - _pActor->_Y;
                            dZ = _gravitation_mv_seq_pActor_target->_Z - _pActor->_Z;
                        } else {
                            dX = _gravitation_mv_seq_target_X - _pActor->_X;
                            dY = _gravitation_mv_seq_target_Y - _pActor->_Y;
                            dZ = _gravitation_mv_seq_target_Z - _pActor->_Z;
                        }
                
                        velo last_veloVxMv = _veloVxMv;
                        velo new_veloVxMv = _gravitation_mv_seq_max_velo * (dX * 1.0 / _gravitation_mv_seq_stop_renge);
                        if (last_veloVxMv - _gravitation_mv_seq_acce <= new_veloVxMv &&
                                                                        new_veloVxMv <= last_veloVxMv + _gravitation_mv_seq_acce) {
                            _veloVxMv = new_veloVxMv;
                        } else {
                            if (last_veloVxMv - _gravitation_mv_seq_acce > new_veloVxMv) {
                                _veloVxMv = last_veloVxMv - _gravitation_mv_seq_acce;
                            } else if (new_veloVxMv > last_veloVxMv + _gravitation_mv_seq_acce) {
                                _veloVxMv = last_veloVxMv + _gravitation_mv_seq_acce;
                            }
                        }
                
                        velo last_veloVyMv = _veloVyMv;
                        velo new_veloVyMv = _gravitation_mv_seq_max_velo * (dY * 1.0 / _gravitation_mv_seq_stop_renge);
                        if (last_veloVyMv - _gravitation_mv_seq_acce <= new_veloVyMv &&
                                                                        new_veloVyMv <= last_veloVyMv + _gravitation_mv_seq_acce) {
                            _veloVyMv = new_veloVyMv;
                        } else {
                            if (last_veloVyMv - _gravitation_mv_seq_acce > new_veloVyMv) {
                                _veloVyMv = last_veloVyMv - _gravitation_mv_seq_acce;
                            } else if (new_veloVyMv > last_veloVyMv + _gravitation_mv_seq_acce) {
                                _veloVyMv = last_veloVyMv + _gravitation_mv_seq_acce;
                            }
                        }
                
                        velo last_veloVzMv = _veloVzMv;
                        velo new_veloVzMv = _gravitation_mv_seq_max_velo * (dZ * 1.0 / _gravitation_mv_seq_stop_renge);
                        if (last_veloVzMv - _gravitation_mv_seq_acce <= new_veloVzMv &&
                                                                        new_veloVzMv <= last_veloVzMv + _gravitation_mv_seq_acce) {
                            _veloVzMv = new_veloVzMv;
                        } else {
                            if (last_veloVzMv - _gravitation_mv_seq_acce > new_veloVzMv) {
                                _veloVzMv = last_veloVzMv - _gravitation_mv_seq_acce;
                            } else if (new_veloVzMv > last_veloVzMv + _gravitation_mv_seq_acce) {
                                _veloVzMv = last_veloVzMv + _gravitation_mv_seq_acce;
                            }
                        }
                    }
                
                
                    //Xx
                    _veloVxMv += _acceVxMv;
                    setVxMvVelo(_veloVxMv);
                    //Yx
                    _veloVyMv += _acceVyMv;
                    setVyMvVelo(_veloVyMv);
                    //Zx
                    _veloVzMv += _acceVzMv;
                    setVzMvVelo(_veloVzMv);
                
                    //V[NGXN
                    if (_smooth_mv_velo_seq_flg) {
                        if (_smooth_mv_velo_seq_frame_of_spend < 0) {
                            //Ww
                            if (_smooth_mv_velo_seq_progress == 0) {
                                //
                                setMvAcce(_smooth_mv_velo_seq_p1, _smooth_mv_velo_seq_top_velo);
                                _smooth_mv_velo_seq_progress++;
                            } else if (_smooth_mv_velo_seq_progress == 1) {
                                //
                                if (_smooth_mv_velo_seq_mv_distance >= _smooth_mv_velo_seq_p1) {
                                    //p1 B 
                                    setMvAcce(0);
                                    setMvVelo(_smooth_mv_velo_seq_top_velo);
                                    _smooth_mv_velo_seq_progress++;
                                }
                            } else if (_smooth_mv_velo_seq_progress == 2) {
                                //
                                if (_smooth_mv_velo_seq_mv_distance >= _smooth_mv_velo_seq_p2) {
                                    //p2 B t[
                                    setMvAcce(_smooth_mv_velo_seq_distance_of_target - _smooth_mv_velo_seq_mv_distance, _smooth_mv_velo_seq_end_velo);
                                    _smooth_mv_velo_seq_progress++;
                                }
                            } else if (_smooth_mv_velo_seq_progress == 3) {
                                //
                                if (_smooth_mv_velo_seq_mv_distance >= _smooth_mv_velo_seq_distance_of_target) {
                                    //WB
                                    setMvVelo(_smooth_mv_velo_seq_end_velo);
                                    if (_smooth_mv_velo_seq_endacc_flg) {
                                        setMvAcce(0);
                                    }
                                    _smooth_mv_velo_seq_progress++;
                                    _smooth_mv_velo_seq_flg = false; //
                                }
                            }
                        } else {
                            //Ww
                            if (_smooth_mv_velo_seq_progress == 0) {
                                //
                                setMvAcce(_smooth_mv_velo_seq_p1, _smooth_mv_velo_seq_top_velo);
                                _smooth_mv_velo_seq_progress++;
                            } else if (_smooth_mv_velo_seq_progress == 1) {
                                //
                                if (_smooth_mv_velo_seq_spend_frame >= _smooth_mv_velo_seq_p1) {
                                    //p1 B 
                                    setMvAcce(0);
                                    setMvVelo(_smooth_mv_velo_seq_top_velo);
                                    _smooth_mv_velo_seq_progress++;
                                }
                            } else if (_smooth_mv_velo_seq_progress == 2) {
                                //
                                if (_smooth_mv_velo_seq_spend_frame >= _smooth_mv_velo_seq_p2) {
                                    //p2 B t[
                                    setMvAcce2(_smooth_mv_velo_seq_frame_of_spend - _smooth_mv_velo_seq_spend_frame, _smooth_mv_velo_seq_end_velo);
                                    _smooth_mv_velo_seq_progress++;
                                }
                            } else if (_smooth_mv_velo_seq_progress == 3) {
                                //
                                if (_smooth_mv_velo_seq_spend_frame >= _smooth_mv_velo_seq_frame_of_spend) {
                                    //WB
                                    setMvVelo(_smooth_mv_velo_seq_end_velo);
                                    if (_smooth_mv_velo_seq_endacc_flg) {
                                        setMvAcce(0);
                                    }
                                    _smooth_mv_velo_seq_progress++;
                                    _smooth_mv_velo_seq_flg = false; //
                                }
                            }
                
                        }
                
                
                    }
                
                    _accMv += _jerkMv;
                    //x
                    _veloMv += _accMv;
                    setMvVelo(_veloMv);
                
                    if (_smooth_mv_velo_seq_flg) {
                        if (_smooth_mv_velo_seq_frame_of_spend < 0) {
                            _smooth_mv_velo_seq_mv_distance+=abs(_veloMv);
                        } else {
                            _smooth_mv_velo_seq_spend_frame++;
                        }
                    }
                
                    ///////////
                    //WpiZ]jAO~@\gp
                    if (_mv_ang_rz_target_flg) {
                
                        _angveloRzMv += _angacceRzMv;
                        setRzMvAngVelo(_angveloRzMv);
                
                        if (_angveloRzMv > 0) { //v
                            angle angDistance = getRzMvAngDistance(_angTargetRzMv, TURN_COUNTERCLOCKWISE);
                            if (_angveloRzMv > angDistance && _mv_ang_rz_target_allow_way != TURN_CLOCKWISE
                                    && _mv_ang_rz_target_allow_velo >= _angveloRzMv) { //WsEEE
                                addRzMvAng(angDistance);
                                if (_mv_ang_rz_target_stop_flg) { //~w
                                    _mv_ang_rz_target_flg = false; //tOI
                                }
                            } else {
                                addRzMvAng(_angveloRzMv);
                            }
                        } else if (_angveloRzMv < 0) { //v
                
                            angle angDistance = getRzMvAngDistance(_angTargetRzMv, TURN_CLOCKWISE);
                            if (_angveloRzMv < angDistance && _mv_ang_rz_target_allow_way != TURN_COUNTERCLOCKWISE
                                    && -1*_mv_ang_rz_target_allow_velo <= _angveloRzMv) {
                                addRzMvAng(angDistance);
                                if (_mv_ang_rz_target_stop_flg) { //~w
                                    _mv_ang_rz_target_flg = false; //tOI
                                }
                            } else {
                                addRzMvAng(_angveloRzMv);
                            }
                        } else {
                            addRzMvAng(0);
                        }
                        if (_mv_ang_rz_target_flg == false) {
                            //_angveloRzTopMv = ANGLE360; //piZ]jpx  360,000 angle/fream
                            //_angveloRzBottomMv = ANGLE360 * -1; //piZ]jpx  -360,000 angle/fream
                
                            //WBA~s
                            _angacceRzMv = 0; //ZpApxO
                            setRzMvAngVelo(0); //ZpApxO
                        }
                
                    } else {
                        //if (_angacceRzMv != 0) {
                
                        _angacceRzMv += _angjerkRzMv;
                        //t[piZ]j
                        _angveloRzMv += _angacceRzMv;
                        if (_angveloRzMv != 0) {
                            addRzMvAng(_angveloRzMv);
                        }
                        //}
                    }
                    ////////////////
                    //WpiY]jAO~@\gp
                    if (_mv_ang_ry_target_flg) {
                
                        _angveloRyMv += _angacceRyMv;
                        setRyMvAngVelo(_angveloRyMv);
                
                        if (_angveloRyMv > 0) { //v
                            angle angDistance = getRyMvAngDistance(_angTargetRyMv, TURN_COUNTERCLOCKWISE);
                            if (_angveloRyMv > angDistance &&
                                _mv_ang_ry_target_allow_way != TURN_CLOCKWISE &&
                                _mv_ang_ry_target_allow_velo >= _angveloRyMv)
                            { //WsEEE
                                addRyMvAng(angDistance);
                                if (_mv_ang_ry_target_stop_flg) { //~w
                                    _mv_ang_ry_target_flg = false; //tOI
                                }
                            } else {
                                addRyMvAng(_angveloRyMv);
                            }
                        } else if (_angveloRyMv < 0) { //v
                
                            angle angDistance = getRyMvAngDistance(_angTargetRyMv, TURN_CLOCKWISE);
                            if (_angveloRyMv < angDistance &&
                                _mv_ang_ry_target_allow_way != TURN_COUNTERCLOCKWISE &&
                                -1*_mv_ang_ry_target_allow_velo <= _angveloRyMv)
                            {
                                addRyMvAng(angDistance);
                                if (_mv_ang_ry_target_stop_flg) { //~w
                                    _mv_ang_ry_target_flg = false; //tOI
                                }
                            } else {
                                addRyMvAng(_angveloRyMv);
                            }
                        } else {
                            //_angveloRyMv==0
                            addRyMvAng(0);
                        }
                        if (_mv_ang_ry_target_flg == false) {
                            //_angveloRyTopMv = ANGLE360; //piY]jpx  360,000 angle/fream
                            //_angveloRyBottomMv = ANGLE360*-1; //piY]jpx  -360,000 angle/fream
                
                            //WBA~s
                            _angacceRyMv = 0; //YpApxO
                            setRyMvAngVelo(0); //YpApxO
                        }
                
                    } else {
                        //if (_angacceRyMv != 0) {
                        _angacceRyMv += _angjerkRyMv;
                        //t[piY]j
                        _angveloRyMv += _angacceRyMv;
                        if(_angveloRyMv != 0) {
                            addRyMvAng(_angveloRyMv);
                        }
                        //}
                    }
                    ///////////////
                    if (_taget_mv_ang_alltime_pActor && _mv_ang_ry_target_flg == false && _mv_ang_ry_target_flg == false) {
                        if (_taget_mv_ang_alltime_pActor) {
                            keepTagetingMvAngAllTime(
                                    _taget_mv_ang_alltime_pActor,
                                    _taget_mv_ang_alltime_angVelo,
                                    _taget_mv_ang_alltime_angAcce,
                                    _taget_mv_ang_alltime_optimize_ang);
                        } else {
                            keepTagetingMvAngAllTime(
                                    _taget_mv_ang_alltime_pActor->_X - _pActor->_X,
                                    _taget_mv_ang_alltime_pActor->_Y - _pActor->_Y,
                                    _taget_mv_ang_alltime_pActor->_Z - _pActor->_Z,
                                    _taget_mv_ang_alltime_angVelo,
                                    _taget_mv_ang_alltime_angAcce,
                                    _taget_mv_ang_alltime_optimize_ang);
                        }
                
                    }
                    //Actorf
                    _pActor->_X += (int)(_vX * _veloMv + _veloVxMv);
                    _pActor->_Y += (int)(_vY * _veloMv + _veloVyMv);
                    _pActor->_Z += (int)(_vZ * _veloMv + _veloVzMv);
                
                
                }
                
                void GgafDx9Kuroko::setFaceAng(int prm_axis, angle prm_angFace) {
                    _angFace[prm_axis] = GgafDx9Util::simplifyAng(prm_angFace);
                }
                
                void GgafDx9Kuroko::setFaceAng(int prm_tX, int prm_tY, int prm_tZ) {
                    GgafDx9Util::getRzRyAng(
                                   prm_tX - _pActor->_X,
                                   prm_tY - _pActor->_Y,
                                   prm_tZ - _pActor->_Z,
                                   _angFace[AXIS_Z],
                                   _angFace[AXIS_Y]
                                 );
                }
                
                void GgafDx9Kuroko::addFaceAng(int prm_axis, angle prm_angDistance) {
                    angle angOffsetrot_FaceAng;
                    angOffsetrot_FaceAng = prm_angDistance;
                    if (_angveloBottomFace[prm_axis] > prm_angDistance) {
                        angOffsetrot_FaceAng = _angveloBottomFace[prm_axis];
                    } else if (prm_angDistance > _angveloTopFace[prm_axis]) {
                        angOffsetrot_FaceAng = _angveloTopFace[prm_axis];
                    }
                    setFaceAng(prm_axis, _angFace[prm_axis] + angOffsetrot_FaceAng);
                }
                
                void GgafDx9Kuroko::setFaceAngVelo(int prm_axis, angvelo prm_angveloRot) {
                    if (prm_angveloRot > _angveloTopFace[prm_axis]) {
                        _angveloFace[prm_axis] = _angveloTopFace[prm_axis];
                    } else if (prm_angveloRot < _angveloBottomFace[prm_axis]) {
                        _angveloFace[prm_axis] = _angveloBottomFace[prm_axis];
                    } else {
                        _angveloFace[prm_axis] = prm_angveloRot;
                    }
                }
                
                void GgafDx9Kuroko::forceFaceAngVeloRange(int prm_axis,
                                                               angvelo prm_angveloRot01,
                                                               angvelo prm_angveloRot02) {
                    if (prm_angveloRot01 < prm_angveloRot02) {
                        _angveloTopFace[prm_axis] = prm_angveloRot02;
                        _angveloBottomFace[prm_axis] = prm_angveloRot01;
                    } else {
                        _angveloTopFace[prm_axis] = prm_angveloRot01;
                        _angveloBottomFace[prm_axis] = prm_angveloRot02;
                    }
                    setFaceAngVelo(prm_axis, _angveloFace[prm_axis]); //
                }
                
                void GgafDx9Kuroko::setFaceAngAcce(int prm_axis, angacce prm_angacceRot) {
                    _angacceFace[prm_axis] = prm_angacceRot;
                }
                
                void GgafDx9Kuroko::setStopTarget_FaceAngV(int prm_axis,
                                                                  int prm_tX,
                                                                  int prm_tY,
                                                                  int prm_way_allow,
                                                                  angvelo prm_angveloAllowRyMv) {
                    setStopTarget_FaceAng(
                      prm_axis,
                      GgafDx9Util::getAngle2D(prm_tX - (_pActor->_X), prm_tY - (_pActor->_Y)),
                      prm_way_allow,
                      prm_angveloAllowRyMv
                    );
                }
                
                void GgafDx9Kuroko::setStopTarget_FaceAng(int prm_axis,
                                                                 angle prm_angTargetRot,
                                                                 int prm_way_allow,
                                                                 angvelo prm_angveloAllow) {
                    _face_ang_targeting_flg[prm_axis] = true;
                    _face_ang_targeting_stop_flg[prm_axis] = true;
                    _angTargetFace[prm_axis] = GgafDx9Util::simplifyAng(prm_angTargetRot);
                    _face_ang_target_allow_way[prm_axis] = prm_way_allow;
                    _face_ang_target_allow_velo[prm_axis] = prm_angveloAllow;
                }
                
                angle GgafDx9Kuroko::getFaceAngDistance(int prm_axis, int prm_tX, int prm_tY, int prm_way) {
                    return getFaceAngDistance(prm_axis, GgafDx9Util::getAngle2D(prm_tX - (_pActor->_X), prm_tY
                            - (_pActor->_Y)), prm_way);
                }
                
                angle GgafDx9Kuroko::getFaceAngDistance(int prm_axis, angle prm_angTargetRot, int prm_way) {
                    angle _angTargetRot;
                    _angTargetRot = GgafDx9Util::simplifyAng(prm_angTargetRot);
                    if (prm_way == TURN_CLOSE_TO) { //]
                        if (0 <= _angFace[prm_axis] && _angFace[prm_axis] < ANGLE180) {
                            if (0 <= _angTargetRot && _angTargetRot < _angFace[prm_axis]) {
                                return -1 * (_angFace[prm_axis] - _angTargetRot);
                            } else if (_angTargetRot == _angFace[prm_axis]) {
                                //d
                                return 0;
                            } else if (_angFace[prm_axis] < _angTargetRot && _angTargetRot < _angFace[prm_axis]
                                    + ANGLE180) {
                                return _angTargetRot - _angFace[prm_axis];
                            } else if (_angTargetRot == _angFace[prm_axis] + ANGLE180) {
                                //ij
                                //dlB
                                return ANGLE180;
                            } else if (_angFace[prm_axis] + ANGLE180 < _angTargetRot && _angTargetRot <= ANGLE360) {
                                return -1 * (_angFace[prm_axis] + (ANGLE360 - _angTargetRot));
                            } else {
                                //
                                _TRACE_("_angFace["<<prm_axis<<"]=" << _angFace[prm_axis] << "/_angTargetRot=" << _angTargetRot);
                                throwGgafCriticalException("GgafDx9Kuroko::getFaceAngDistance() ]pAOlA^[QbgAOlO(1)B_pActor="<<_pActor->getName());
                            }
                        } else if (ANGLE180 <= _angFace[prm_axis] && _angFace[prm_axis] <= ANGLE360) {
                            if (0 <= _angTargetRot && _angTargetRot < _angFace[prm_axis] - ANGLE180) {
                                return ANGLE360 - _angFace[prm_axis] + _angTargetRot;
                            } else if (_angTargetRot == _angFace[prm_axis] - ANGLE180) {
                                //ij
                                //dlB
                                return -ANGLE180;
                            } else if (_angFace[prm_axis] - ANGLE180 < _angTargetRot && _angTargetRot
                                    < _angFace[prm_axis]) {
                                return -1 * (_angFace[prm_axis] - _angTargetRot);
                            } else if (_angFace[prm_axis] == _angTargetRot) {
                                //d
                                return 0;
                            } else if (_angFace[prm_axis] < _angTargetRot && _angTargetRot <= ANGLE360) {
                                return _angTargetRot - _angFace[prm_axis];
                            } else {
                                //
                                _TRACE_("_angFace["<<prm_axis<<"]=" << _angFace[prm_axis] << "/_angTargetRot=" << _angTargetRot);
                                throwGgafCriticalException("GgafDx9Kuroko::getFaceAngDistance() ]pAOlA^[QbgAOlO(2)B_pActor="<<_pActor->getName());
                            }
                        }
                    } else if (prm_way == TURN_ANTICLOSE_TO) { //]
                        if (0 <= _angFace[prm_axis] && _angFace[prm_axis] < ANGLE180) {
                            if (0 <= _angTargetRot && _angTargetRot < _angFace[prm_axis]) {
                                return ANGLE360 - _angFace[prm_axis] + _angTargetRot;
                            } else if (_angTargetRot == _angFace[prm_axis]) {
                                //d
                                return ANGLE360;
                            } else if (_angFace[prm_axis] < _angTargetRot && _angTargetRot < _angFace[prm_axis] + ANGLE180) {
                                return -1 * ( _angFace[prm_axis] + (ANGLE360 -_angTargetRot));
                            } else if (_angTargetRot == _angFace[prm_axis] + ANGLE180) {
                                //ij
                                //dlB
                                return ANGLE180;
                            } else if (_angFace[prm_axis] + ANGLE180 < _angTargetRot && _angTargetRot <= ANGLE360) {
                                return _angTargetRot - _angFace[prm_axis];
                            } else {
                                //
                                _TRACE_("_angFace["<<prm_axis<<"]=" << _angFace[prm_axis] << "/_angTargetRot=" << _angTargetRot);
                                throwGgafCriticalException("GgafDx9Kuroko::getFaceAngDistance() ]pAOlA^[QbgAOlO(1)B_pActor="<<_pActor->getName());
                            }
                        } else if (ANGLE180 <= _angFace[prm_axis] && _angFace[prm_axis] <= ANGLE360) {
                            if (0 <= _angTargetRot && _angTargetRot < _angFace[prm_axis] - ANGLE180) {
                                return -1 * (_angTargetRot - _angFace[prm_axis]);
                            } else if (_angTargetRot == _angFace[prm_axis] - ANGLE180) {
                                //ij
                                //dlB
                                return -ANGLE180;
                            } else if (_angFace[prm_axis] - ANGLE180 < _angTargetRot && _angTargetRot < _angFace[prm_axis]) {
                                return (ANGLE360 - _angFace[prm_axis]) + _angTargetRot;
                            } else if (_angFace[prm_axis] == _angTargetRot) {
                                //d
                                return -ANGLE360;
                            } else if (_angFace[prm_axis] < _angTargetRot && _angTargetRot <= ANGLE360) {
                                return (_angFace[prm_axis] + (ANGLE360 - _angTargetRot)) ;
                            } else {
                                //
                                _TRACE_("_angFace["<<prm_axis<<"]=" << _angFace[prm_axis] << "/_angTargetRot=" << _angTargetRot);
                                throwGgafCriticalException("GgafDx9Kuroko::getFaceAngDistance() ]pAOlA^[QbgAOlO(2)B_pActor="<<_pActor->getName());
                            }
                        }
                    } else if (prm_way == TURN_COUNTERCLOCKWISE) { //v
                        if (0 <= _angFace[prm_axis] && _angFace[prm_axis] < _angTargetRot) {
                            return (_angTargetRot - _angFace[prm_axis]);
                        } else if (_angTargetRot < _angFace[prm_axis] && _angFace[prm_axis] <= ANGLE360) {
                            return ANGLE360 - _angFace[prm_axis] + _angTargetRot;
                        } else if (_angFace[prm_axis] == _angTargetRot) {
                            //d
                            return 0;
                        } else {
                            //
                            _TRACE_("_angFace["<<prm_axis<<"]=" << _angFace[prm_axis] << "/_angTargetRot=" << _angTargetRot);
                            throwGgafCriticalException("GgafDx9Kuroko::getFaceAngDistance() ]pAOlA^[QbgAOlO(3)B_pActor="<<_pActor->getName());
                        }
                    } else if (prm_way == TURN_CLOCKWISE) { //v
                        if (0 <= _angFace[prm_axis] && _angFace[prm_axis] < _angTargetRot) {
                            return -1 * (_angFace[prm_axis] + ANGLE360 - _angTargetRot);
                        } else if (_angTargetRot < _angFace[prm_axis] && _angFace[prm_axis] <= ANGLE360) {
                            return -1 * (_angFace[prm_axis] - _angTargetRot);
                        } else if (_angFace[prm_axis] == _angTargetRot) {
                            //d
                            return 0;
                        } else {
                            //
                            _TRACE_("_angFace["<<prm_axis<<"]=" << _angFace[prm_axis] << "/_angTargetRot=" << _angTargetRot);
                            throwGgafCriticalException("GgafDx9Kuroko::getFaceAngDistance() ]pAOlA^[QbgAOlO(4)B_pActor="<<_pActor->getName());
                        }
                    }
                    _TRACE_("_angFace["<<prm_axis<<"]=" << _angFace[prm_axis] << "/_angTargetRot=" << _angTargetRot);
                    throwGgafCriticalException("GgafDx9Kuroko::getFaceAngDistance() p(2)B_pActor="<<_pActor->getName());
                }
                
                void GgafDx9Kuroko::forceMvVeloRange(int prm_velo) {
                    forceMvVeloRange(-prm_velo, prm_velo);
                }
                
                void GgafDx9Kuroko::forceMvVeloRange(int prm_veloMv01, int prm_veloMv02) {
                    if (prm_veloMv01 < prm_veloMv02) {
                        _veloTopMv = prm_veloMv02;
                        _veloBottomMv = prm_veloMv01;
                    } else {
                        _veloTopMv = prm_veloMv01;
                        _veloBottomMv = prm_veloMv02;
                    }
                    setMvVelo(_veloMv); //
                }
                
                void GgafDx9Kuroko::setMvVelo(int prm_veloMv) {
                    if (prm_veloMv > _veloTopMv) {
                        _veloMv = _veloTopMv;
                    } else if (prm_veloMv < _veloBottomMv) {
                        _veloMv = _veloBottomMv;
                    } else {
                        _veloMv = prm_veloMv;
                    }
                }
                
                void GgafDx9Kuroko::addMvVelo(int prm_veloMv_Offset) {
                    setMvVelo(_veloMv + prm_veloMv_Offset);
                }
                
                void GgafDx9Kuroko::setMvAcce(int prm_acceMove) {
                    _accMv = prm_acceMove;
                }
                
                void GgafDx9Kuroko::setMvAcceToStop(int prm_distance_of_target) {
                    // a = -(v0^2) / 2S
                    _accMv  =  -(1.0*_veloMv*_veloMv) / (2.0*prm_distance_of_target);
                    if (_accMv < 0) {
                        _accMv += 1;
                    } else {
                        _accMv -= 1;
                    }
                    //(frame)((2.0*prm_distance_of_target) / _veloMv); //gpt[
                }
                void GgafDx9Kuroko::setMvAcce2(int prm_frame_of_spend, velo prm_velo_target) {
                    //a = (vx-v0) / t
                    _accMv = (prm_velo_target - _veloMv) / (1.0f*prm_velo_target);
                }
                void GgafDx9Kuroko::setMvAcce(int prm_distance_of_target, velo prm_velo_target) {
                    // a = (vx^2 - v0^2) / 2S
                    _accMv =  ((1.0f*prm_velo_target*prm_velo_target) - (1.0f*_veloMv*_veloMv)) / (2.0f*prm_distance_of_target);
                    if (_accMv < 0) {
                        _accMv += 1;
                    } else {
                        _accMv -= 1;
                    }
                    //(frame)((1.0*prm_velo_target - _veloMv) / _accMv); //gpt[
                
                    // yz
                    // v0 <= 0    vx <= 0 A  v0 >= 0    vx >= 0  AS(W)LB
                    // 
                    // v0 < 0     vx > 0  A  v0 > 0     vx < 0   AH
                    //
                    //    x
                    //     ^        a:x
                    //     |        S:iWBxBj
                    //     |       v0:_x
                    //     |       vx:WBx
                    //     |       tx:WBxBit[j
                    //  v0 |
                    //     |_
                    //     |  _  Xa
                    //     | S1 _
                    //     |      _ tc     tx
                    //   --+--------_------+---> (t[)
                    //   0 |          _ S2 |
                    //     |            _  |
                    //   vx|.............._|
                    //     |
                    //
                    //
                    //    S = S1 - S2 , _ tc 
                    //
                    //    S1 = (1/2) v0 tc
                    //    S2 = (1/2) -vx (tx - tc)
                    //    S = S1 - S2 
                    //    S = (1/2) v0 tc -  { (1/2) -vx (tx - tc) }
                    //      = (v0 tc + vx tx - vx tc) / 2    EEE@
                    //
                    //     v = a t + v0  v = 0  t  tc 
                    //    tc = -v0 / a
                    //     @ 
                    //    S = (v0 (-v0 / a) + vx tx - vx (-v0 / a)) / 2 EEEA
                    //
                    //     a = (vx - v0) / tx 
                    //    tx = (vx - v0) / a  A 
                    //    
                    //    S = (v0 (-v0 / a) + vx ((vx - v0) / a) - vx (-v0 / a)) / 2
                    //
                    //    a 
                    //
                    //    S = {( -(v0^2) / a  + (vx (vx - v0)) / a + (vx v0) / a)) / 2
                    //    aS = { -(v0^2) + (vx (vx - v0)) + (vx v0) } / 2
                    //    a = { -(v0^2) + (vx (vx - v0)) + (vx v0) } / 2S
                    //    a = (-(v0^2) + vx^2 - vx v0 + vx v0) / 2S
                    //    a = (vx^2 -v0^2) / 2S
                    //
                    //     a = (vx^2 - v0^2) / 2S 
                    //    v0 <= 0    vx <= 0 A  v0 >= 0    vx >= 0  
                
                
                }
                
                void GgafDx9Kuroko::orderSmoothMvVeloSequence(velo prm_top_velo, velo prm_end_velo, int prm_distance_of_target,
                                                                    bool prm_endacc_flg) {
                    _smooth_mv_velo_seq_flg = true;
                    _smooth_mv_velo_seq_endacc_flg = prm_endacc_flg;
                    _smooth_mv_velo_seq_top_velo = prm_top_velo;
                    _smooth_mv_velo_seq_end_velo = prm_end_velo;
                    _smooth_mv_velo_seq_distance_of_target = prm_distance_of_target;
                    _smooth_mv_velo_seq_mv_distance = 0;
                    _smooth_mv_velo_seq_frame_of_spend = -1; //Wg(gp)
                    _smooth_mv_velo_seq_spend_frame = 0;
                    _smooth_mv_velo_seq_p1 = (int)(prm_distance_of_target*1.0 / 4.0);
                    _smooth_mv_velo_seq_p2 = (int)(prm_distance_of_target*3.0 / 4.0);
                    _smooth_mv_velo_seq_progress = 0;
                }
                
                
                void GgafDx9Kuroko::orderSmoothMvVeloSequence2(velo prm_top_velo, velo prm_end_velo, int prm_frame_of_spend,
                                                                    bool prm_endacc_flg) {
                    _smooth_mv_velo_seq_flg = true;
                    _smooth_mv_velo_seq_endacc_flg = prm_endacc_flg;
                    _smooth_mv_velo_seq_top_velo = prm_top_velo;
                    _smooth_mv_velo_seq_end_velo = prm_end_velo;
                    _smooth_mv_velo_seq_distance_of_target = 0;
                    _smooth_mv_velo_seq_mv_distance = 0;
                    _smooth_mv_velo_seq_frame_of_spend = prm_frame_of_spend;
                    _smooth_mv_velo_seq_spend_frame = 0;
                    _smooth_mv_velo_seq_p1 = (int)(prm_frame_of_spend*1.0 / 4.0);
                    _smooth_mv_velo_seq_p2 = (int)(prm_frame_of_spend*3.0 / 4.0);
                    _smooth_mv_velo_seq_progress = 0;
                }
                
                void GgafDx9Kuroko::orderSmoothMvVeloSequence3(velo prm_end_velo, int prm_distance_of_target, int prm_frame_of_spend,
                                                                      bool prm_endacc_flg) {
                    _smooth_mv_velo_seq_flg = true;
                    _smooth_mv_velo_seq_p1 = (int)(prm_distance_of_target*1.0 / 4.0);
                    _smooth_mv_velo_seq_p2 = (int)(prm_distance_of_target*3.0 / 4.0);
                    _smooth_mv_velo_seq_end_velo = prm_end_velo;
                    _smooth_mv_velo_seq_distance_of_target = prm_distance_of_target;
                    _smooth_mv_velo_seq_mv_distance = 0;
                    _smooth_mv_velo_seq_frame_of_spend = -1; //Wg(_smooth_mv_velo_seq_top_velovZl)
                    _smooth_mv_velo_seq_spend_frame = 0;
                    _smooth_mv_velo_seq_progress = 0;
                
                    //    x
                    //     ^
                    //     |                          S:
                    //     |                         vs:_x
                    //     |                         vx:1/4 ` 3/4 x
                    //     |                         ve:IWBx
                    //   vx|....QQQQQ            t:WBxBit[j
                    //     |   /|         |_
                    //   ve|../.|.........|.._
                    //     | /  |         |    |
                    //     |/   |         |    |
                    //   vs|    |    S    |    |
                    //     |    |         |    |
                    //   --+----+----+----+----+-----> (t[)
                    //   0 | (1/4)t    (3/4)t  t
                
                    //  `{`{` 
                    // S  = (1/2) (vs + vx) (1/4)t  + vx (2/4)t  +  (1/2) (ve + vx) (1/4)t
                    // vx
                    // 8S = (vs + vx)t + 4 vx t + (ve + vx)t
                    // 8S/t = vs + vx + 4vx + ve + vx
                    // 6vx = 8S/t - vs - ve
                    // vx = (8S/t - vs - ve) / 6
                    _smooth_mv_velo_seq_top_velo = (8.0*prm_distance_of_target/prm_frame_of_spend - _veloMv - prm_end_velo) / 6.0;
                }
                
                bool GgafDx9Kuroko::isMoveingSmooth() {
                    return _smooth_mv_velo_seq_flg;
                }
                
                
                void GgafDx9Kuroko::setRzMvAng(int prm_tX, int prm_tY) {
                    setRzMvAng(GgafDx9Util::getAngle2D(prm_tX - (_pActor->_X), prm_tY - (_pActor->_Y)));
                }
                
                void GgafDx9Kuroko::setRzMvAng(angle prm_ang) {
                    if (prm_ang !=  _angRzMv) {
                        _angRzMv = GgafDx9Util::simplifyAng(prm_ang);
                        GgafDx9Util::getNormalizeVectorZY(_angRzMv, _angRyMv, _vX, _vY, _vZ);
                    }
                    if (_relate_RzFaceAng_to_RzMvAng_flg) {
                        setFaceAng(AXIS_Z, _angRzMv);
                    }
                }
                
                void GgafDx9Kuroko::addRzMvAng(angle prm_angDistance) {
                    angle angOffset = prm_angDistance;
                    if (_angveloRzBottomMv > prm_angDistance) {
                        angOffset = _angveloRzBottomMv;
                    } else if (prm_angDistance > _angveloRzTopMv) {
                        angOffset = _angveloRzTopMv;
                    }
                    setRzMvAng(_angRzMv + angOffset);
                }
                
                void GgafDx9Kuroko::setRzMvAngVelo(angvelo prm_angveloRzMv) {
                    if (prm_angveloRzMv > _angveloRzTopMv) {
                        _angveloRzMv = _angveloRzTopMv;
                    } else if (prm_angveloRzMv < _angveloRzBottomMv) {
                        _angveloRzMv = _angveloRzBottomMv;
                    } else {
                        _angveloRzMv = prm_angveloRzMv;
                    }
                }
                
                void GgafDx9Kuroko::setRzMvAngAcce(angacce prm_angacceRzMv) {
                    _angacceRzMv = prm_angacceRzMv;
                }
                
                void GgafDx9Kuroko::forceRzMvAngVeloRange(angvelo prm_angveloRzMv01,
                                                                 angvelo prm_angveloRzMv02) {
                    if (prm_angveloRzMv01 < prm_angveloRzMv02) {
                        _angveloRzTopMv = prm_angveloRzMv02;
                        _angveloRzBottomMv = prm_angveloRzMv01;
                    } else {
                        _angveloRzTopMv = prm_angveloRzMv01;
                        _angveloRzBottomMv = prm_angveloRzMv02;
                    }
                    setRzMvAngVelo(_angveloRzMv); //
                }
                
                void GgafDx9Kuroko::setStopTarget_RzMvAng(angle prm_angTargetRzMv,
                                                                 int prm_way_allow,
                                                                 angvelo prm_angveloAllowRyMv) {
                    _mv_ang_rz_target_flg = true;
                    _mv_ang_rz_target_stop_flg = true;
                    _angTargetRzMv = GgafDx9Util::simplifyAng(prm_angTargetRzMv);
                    _mv_ang_rz_target_allow_way = prm_way_allow;
                    _mv_ang_rz_target_allow_velo = prm_angveloAllowRyMv;
                }
                
                void GgafDx9Kuroko::setStopTarget_RzMvAngV(int prm_tX,
                                                                  int prm_tY,
                                                                  int prm_way_allow,
                                                                  angvelo prm_angveloAllowRyMv) {
                    setStopTarget_RzMvAng(GgafDx9Util::getAngle2D(prm_tX - (_pActor->_X), prm_tY - (_pActor->_Y)), prm_way_allow);
                }
                
                angle GgafDx9Kuroko::getRzMvAngDistance(int prm_tX, int prm_tY, int prm_way) {
                    return getRzMvAngDistance(GgafDx9Util::getAngle2D(prm_tX - (_pActor->_X), prm_tY - (_pActor->_Y)),
                                                        prm_way);
                }
                
                angle GgafDx9Kuroko::getRzMvAngDistance(angle prm_angTargetRzMv, int prm_way) {
                    angle angTargetRzMv = GgafDx9Util::simplifyAng(prm_angTargetRzMv);
                    if (prm_way == TURN_CLOSE_TO) { //]
                        if (0 <= _angRzMv && _angRzMv < ANGLE180) {
                            if (0 <= angTargetRzMv && angTargetRzMv < _angRzMv) {
                                return -1 * (_angRzMv - angTargetRzMv);
                            } else if (angTargetRzMv == _angRzMv) {
                                //d
                                return 0;
                            } else if (_angRzMv < angTargetRzMv && angTargetRzMv < _angRzMv + ANGLE180) {
                                return angTargetRzMv - _angRzMv;
                            } else if (angTargetRzMv == _angRzMv + ANGLE180) {
                                //ij
                                //dlB
                                return ANGLE180;
                            } else if (_angRzMv + ANGLE180 < angTargetRzMv && angTargetRzMv <= ANGLE360) {
                                return -1 * (_angRzMv + (ANGLE360 - angTargetRzMv));
                            } else {
                                //
                                _TRACE_("_angRzMv=" << _angRzMv << "/angTargetRzMv=" << angTargetRzMv);
                                throwGgafCriticalException("GgafDx9Kuroko::behave() piZ]jAOlA^[QbgAOlO(1)B_pActor="<<_pActor->getName());
                            }
                        } else if (ANGLE180 <= _angRzMv && _angRzMv <= ANGLE360) {
                            if (0 <= angTargetRzMv && angTargetRzMv < _angRzMv - ANGLE180) {
                                return ANGLE360 - _angRzMv + angTargetRzMv;
                            } else if (angTargetRzMv == _angRzMv - ANGLE180) {
                                //ij
                                //dlB
                                return -ANGLE180;
                            } else if (_angRzMv - ANGLE180 < angTargetRzMv && angTargetRzMv < _angRzMv) {
                                return -1 * (_angRzMv - angTargetRzMv);
                            } else if (_angRzMv == angTargetRzMv) {
                                //d
                                return 0;
                            } else if (_angRzMv < angTargetRzMv && angTargetRzMv <= ANGLE360) {
                                return angTargetRzMv - _angRzMv;
                            } else {
                                //
                                _TRACE_("_angRzMv=" << _angRzMv << "/angTargetRzMv=" << angTargetRzMv);
                                throwGgafCriticalException("GgafDx9Kuroko::getRzMvAngDistance() piZ]jAOlA^[QbgAOlO(2)B_pActor="<<_pActor->getName());
                            }
                        }
                    } else if (prm_way == TURN_ANTICLOSE_TO) { //]
                        if (0 <= _angRzMv && _angRzMv < ANGLE180) {
                            if (0 <= angTargetRzMv && angTargetRzMv < _angRzMv) {
                                return ANGLE360 - _angRzMv + angTargetRzMv;
                            } else if (angTargetRzMv == _angRzMv) {
                                //d
                                return ANGLE360;
                            } else if (_angRzMv < angTargetRzMv && angTargetRzMv < _angRzMv + ANGLE180) {
                                return -1*(_angRzMv + (ANGLE360-angTargetRzMv));
                            } else if (angTargetRzMv == _angRzMv + ANGLE180) {
                                //ij
                                //dlB
                                return ANGLE180;
                            } else if (_angRzMv + ANGLE180 < angTargetRzMv && angTargetRzMv <= ANGLE360) {
                                return angTargetRzMv - _angRzMv;
                            } else {
                                //
                                _TRACE_("_angRzMv=" << _angRzMv << "/angTargetRzMv=" << angTargetRzMv);
                                throwGgafCriticalException("GgafDx9Kuroko::behave() piZ]jAOlA^[QbgAOlO(1)B_pActor="<<_pActor->getName());
                            }
                        } else if (ANGLE180 <= _angRzMv && _angRzMv <= ANGLE360) {
                            if (0 <= angTargetRzMv && angTargetRzMv < _angRzMv - ANGLE180) {
                                return  -1*(_angRzMv - angTargetRzMv);
                            } else if (angTargetRzMv == _angRzMv - ANGLE180) {
                                //ij
                                //dlB
                                return -ANGLE180;
                            } else if (_angRzMv - ANGLE180 < angTargetRzMv && angTargetRzMv < _angRzMv) {
                                return _angRzMv + (ANGLE360 - angTargetRzMv);
                            } else if (_angRzMv == angTargetRzMv) {
                                //d
                                return -ANGLE360;
                            } else if (_angRzMv < angTargetRzMv && angTargetRzMv <= ANGLE360) {
                                return angTargetRzMv + (ANGLE360 - _angRzMv);
                            } else {
                                //
                                _TRACE_("_angRzMv=" << _angRzMv << "/angTargetRzMv=" << angTargetRzMv);
                                throwGgafCriticalException("GgafDx9Kuroko::getRzMvAngDistance() piZ]jAOlA^[QbgAOlO(2)B_pActor="<<_pActor->getName());
                            }
                        }
                    } else if (prm_way == TURN_COUNTERCLOCKWISE) { //v
                        if (0 <= _angRzMv && _angRzMv < angTargetRzMv) {
                            return (angTargetRzMv - _angRzMv);
                        } else if (angTargetRzMv < _angRzMv && _angRzMv <= ANGLE360) {
                            return ANGLE360 - _angRzMv + angTargetRzMv;
                        } else if (_angRzMv == angTargetRzMv) {
                            //d
                            return 0;
                        } else {
                            //
                            _TRACE_("_angRzMv=" << _angRzMv << "/angTargetRzMv=" << angTargetRzMv);
                            throwGgafCriticalException("GgafDx9Kuroko::getRzMvAngDistance() piZ]jAOlA^[QbgAOlO(3)B_pActor="<<_pActor->getName());
                        }
                    } else if (prm_way == TURN_CLOCKWISE) { //v
                        if (0 <= _angRzMv && _angRzMv < angTargetRzMv) {
                            return -1 * (_angRzMv + ANGLE360 - angTargetRzMv);
                        } else if (angTargetRzMv < _angRzMv && _angRzMv <= ANGLE360) {
                            return -1 * (_angRzMv - angTargetRzMv);
                        } else if (_angRzMv == angTargetRzMv) {
                            //d
                            return 0;
                        } else {
                            //
                            _TRACE_("_angRzMv=" << _angRzMv << "/angTargetRzMv=" << angTargetRzMv);
                            throwGgafCriticalException("GgafDx9Kuroko::getRzMvAngDistance() piZ]jAOlA^[QbgAOlO(4)B_pActor="<<_pActor->getName());
                        }
                    }
                    _TRACE_("_angRzMv=" << _angRzMv << "/angTargetRzMv=" << angTargetRzMv);
                    throwGgafCriticalException("GgafDx9Kuroko::getRzMvAngDistance() p(1)B_pActor="<<_pActor->getName());
                }
                
                
                void GgafDx9Kuroko::setRyMvAng(int prm_tX, int prm_tY) {
                    setRyMvAng(GgafDx9Util::getAngle2D(prm_tX - (_pActor->_X), prm_tY - (_pActor->_Y)));
                }
                
                void GgafDx9Kuroko::setRyMvAng(angle prm_ang) {
                    if (prm_ang != _angRyMv) {
                        _angRyMv = GgafDx9Util::simplifyAng(prm_ang);
                        GgafDx9Util::getNormalizeVectorZY(_angRzMv, _angRyMv, _vX, _vY, _vZ);
                    }
                    if (_relate_RyFaceAng_to_RyMvAng_flg) {
                        setFaceAng(AXIS_Y, _angRyMv);
                    }
                }
                
                void GgafDx9Kuroko::addRyMvAng(angle prm_angDistance) {
                    angle angOffset = prm_angDistance;
                    if (_angveloRyBottomMv > prm_angDistance) {
                        angOffset = _angveloRyBottomMv;
                    } else if (prm_angDistance > _angveloRyTopMv) {
                        angOffset = _angveloRyTopMv;
                    }
                    setRyMvAng(_angRyMv + angOffset);
                }
                
                void GgafDx9Kuroko::setRyMvAngVelo(angvelo prm_angveloRyMv) {
                    if (prm_angveloRyMv > _angveloRyTopMv) {
                        _angveloRyMv = _angveloRyTopMv;
                    } else if (prm_angveloRyMv < _angveloRyBottomMv) {
                        _angveloRyMv = _angveloRyBottomMv;
                    } else {
                        _angveloRyMv = prm_angveloRyMv;
                    }
                }
                
                void GgafDx9Kuroko::setRyMvAngAcce(angacce prm_angacceRyMv) {
                    _angacceRyMv = prm_angacceRyMv;
                }
                
                void GgafDx9Kuroko::forceRyMvAngVeloRange(angvelo prm_angveloRyMv01,
                                                               angvelo prm_angveloRyMv02) {
                    if (prm_angveloRyMv01 < prm_angveloRyMv02) {
                        _angveloRyTopMv = prm_angveloRyMv02;
                        _angveloRyBottomMv = prm_angveloRyMv01;
                    } else {
                        _angveloRyTopMv = prm_angveloRyMv01;
                        _angveloRyBottomMv = prm_angveloRyMv02;
                    }
                    setRyMvAngVelo(_angveloRyMv); //
                }
                
                void GgafDx9Kuroko::setStopTarget_RyMvAng(angle prm_angTargetRyMv,
                                                          int prm_way_allow,
                                                          angvelo prm_angveloAllowRyMv) {
                    _mv_ang_ry_target_flg = true;
                    _mv_ang_ry_target_stop_flg = true;
                    _angTargetRyMv = GgafDx9Util::simplifyAng(prm_angTargetRyMv);
                    _mv_ang_ry_target_allow_way = prm_way_allow;
                    _mv_ang_ry_target_allow_velo = prm_angveloAllowRyMv;
                }
                
                void GgafDx9Kuroko::setStopTarget_RyMvAngV(int prm_tX,
                                                                  int prm_tY,
                                                                  int prm_way_allow,
                                                                  angvelo prm_angveloAllowRyMv) {
                    setStopTarget_RyMvAng(GgafDx9Util::getAngle2D(prm_tX - (_pActor->_X), prm_tY - (_pActor->_Y)), prm_way_allow);
                }
                
                angle GgafDx9Kuroko::getRyMvAngDistance(int prm_tX, int prm_tY, int prm_way) {
                    return getRyMvAngDistance(GgafDx9Util::getAngle2D(prm_tX - (_pActor->_X), prm_tY - (_pActor->_Y)),
                                                        prm_way);
                }
                
                angle GgafDx9Kuroko::getRyMvAngDistance(angle prm_angTargetRyMv, int prm_way) {
                    angle angTargetRyMv;
                    angTargetRyMv = GgafDx9Util::simplifyAng(prm_angTargetRyMv);
                    if (prm_way == TURN_CLOSE_TO) { //]
                        if (0 <= _angRyMv && _angRyMv < ANGLE180) {
                            if (0 <= angTargetRyMv && angTargetRyMv < _angRyMv) {
                                return -1 * (_angRyMv - angTargetRyMv);
                            } else if (angTargetRyMv == _angRyMv) {
                                //d
                                return 0;
                            } else if (_angRyMv < angTargetRyMv && angTargetRyMv < _angRyMv + ANGLE180) {
                                return angTargetRyMv - _angRyMv;
                            } else if (angTargetRyMv == _angRyMv + ANGLE180) {
                                //ij
                                //dlB
                                return ANGLE180;
                            } else if (_angRyMv + ANGLE180 < angTargetRyMv && angTargetRyMv <= ANGLE360) {
                                return -1 * (_angRyMv + (ANGLE360 - angTargetRyMv));
                            } else {
                                //
                                _TRACE_("_angRyMv=" << _angRyMv << "/angTargetRyMv=" << angTargetRyMv);
                                throwGgafCriticalException("GgafDx9Kuroko::behave() piY]jAOlA^[QbgAOlO(1)B_pActor="<<_pActor->getName());
                            }
                        } else if (ANGLE180 <= _angRyMv && _angRyMv <= ANGLE360) {
                            if (0 <= angTargetRyMv && angTargetRyMv < _angRyMv - ANGLE180) {
                                return ANGLE360 - _angRyMv + angTargetRyMv;
                            } else if (angTargetRyMv == _angRyMv - ANGLE180) {
                                //ij
                                //dlB
                                return -ANGLE180;
                            } else if (_angRyMv - ANGLE180 < angTargetRyMv && angTargetRyMv < _angRyMv) {
                                return -1 * (_angRyMv - angTargetRyMv);
                            } else if (_angRyMv == angTargetRyMv) {
                                //d
                                return 0;
                            } else if (_angRyMv < angTargetRyMv && angTargetRyMv <= ANGLE360) {
                                return angTargetRyMv - _angRyMv;
                            } else {
                                //
                                _TRACE_("_angRyMv=" << _angRyMv << "/angTargetRyMv=" << angTargetRyMv);
                                throwGgafCriticalException("GgafDx9Kuroko::getRyMvAngDistance() piY]jAOlA^[QbgAOlO(2)B_pActor="<<_pActor->getName());
                            }
                        }
                    } else if (prm_way == TURN_ANTICLOSE_TO) { //]
                        if (0 <= _angRyMv && _angRyMv < ANGLE180) {
                            if (0 <= angTargetRyMv && angTargetRyMv < _angRyMv) {
                                return ANGLE360 - _angRyMv + angTargetRyMv;
                            } else if (angTargetRyMv == _angRyMv) {
                                //d
                                return ANGLE360;
                            } else if (_angRyMv < angTargetRyMv && angTargetRyMv < _angRyMv + ANGLE180) {
                                return -1*(_angRyMv + (ANGLE360-angTargetRyMv));
                            } else if (angTargetRyMv == _angRyMv + ANGLE180) {
                                //ij
                                //dlB
                                return ANGLE180;
                            } else if (_angRyMv + ANGLE180 < angTargetRyMv && angTargetRyMv <= ANGLE360) {
                                return angTargetRyMv - _angRyMv;
                            } else {
                                //
                                _TRACE_("_angRyMv=" << _angRyMv << "/angTargetRyMv=" << angTargetRyMv);
                                throwGgafCriticalException("GgafDx9Kuroko::behave() piZ]jAOlA^[QbgAOlO(1)B_pActor="<<_pActor->getName());
                            }
                        } else if (ANGLE180 <= _angRyMv && _angRyMv <= ANGLE360) {
                            if (0 <= angTargetRyMv && angTargetRyMv < _angRyMv - ANGLE180) {
                                return  -1*(_angRyMv - angTargetRyMv);
                            } else if (angTargetRyMv == _angRyMv - ANGLE180) {
                                //ij
                                //dlB
                                return -ANGLE180;
                            } else if (_angRyMv - ANGLE180 < angTargetRyMv && angTargetRyMv < _angRyMv) {
                                return _angRyMv + (ANGLE360 - angTargetRyMv);
                            } else if (_angRyMv == angTargetRyMv) {
                                //d
                                return -ANGLE360;
                            } else if (_angRyMv < angTargetRyMv && angTargetRyMv <= ANGLE360) {
                                return angTargetRyMv + (ANGLE360 - _angRyMv);
                            } else {
                                //
                                _TRACE_("_angRyMv=" << _angRyMv << "/angTargetRyMv=" << angTargetRyMv);
                                throwGgafCriticalException("GgafDx9Kuroko::getRyMvAngDistance() piZ]jAOlA^[QbgAOlO(2)B_pActor="<<_pActor->getName());
                            }
                        }
                    } else if (prm_way == TURN_COUNTERCLOCKWISE) { //v
                        if (0 <= _angRyMv && _angRyMv < angTargetRyMv) {
                            return (angTargetRyMv - _angRyMv);
                        } else if (angTargetRyMv < _angRyMv && _angRyMv <= ANGLE360) {
                            return ANGLE360 - _angRyMv + angTargetRyMv;
                        } else if (_angRyMv == angTargetRyMv) {
                            //d
                            return 0;
                        } else {
                            //
                            _TRACE_("_angRyMv=" << _angRyMv << "/angTargetRyMv=" << angTargetRyMv);
                            throwGgafCriticalException("GgafDx9Kuroko::getRyMvAngDistance() piY]jAOlA^[QbgAOlO(3)B_pActor="<<_pActor->getName());
                        }
                    } else if (prm_way == TURN_CLOCKWISE) { //v
                        if (0 <= _angRyMv && _angRyMv < angTargetRyMv) {
                            return -1 * (_angRyMv + ANGLE360 - angTargetRyMv);
                        } else if (angTargetRyMv < _angRyMv && _angRyMv <= ANGLE360) {
                            return -1 * (_angRyMv - angTargetRyMv);
                        } else if (_angRyMv == angTargetRyMv) {
                            //d
                            return 0;
                        } else {
                            //
                            _TRACE_("_angRyMv=" << _angRyMv << "/angTargetRyMv=" << angTargetRyMv);
                            throwGgafCriticalException("GgafDx9Kuroko::getRyMvAngDistance() piY]jAOlA^[QbgAOlO(4)B_pActor="<<_pActor->getName());
                        }
                    }
                    _TRACE_("_angRyMv=" << _angRyMv << "/angTargetRyMv=" << angTargetRyMv);
                    throwGgafCriticalException("GgafDx9Kuroko::getRyMvAngDistance() p(1)B_pActor="<<_pActor->getName());
                }
                
                void GgafDx9Kuroko::getRzRyMvAngDistance(int prm_way,
                                                                angle prm_target_angRz, angle prm_target_angRy,
                                                                angle& out_d_angRz, angle& out_d_angRy,
                                                                angle& out_target_angRz, angle& out_target_angRy) {
                //_TRACE_("getRzRyMvAngDistance ---->");
                //_TRACE_("this: angMvRz="<<_angRzMv<<" _angRyMv="<<_angRyMv);
                //_TRACE_("prm_target_angRz="<<prm_target_angRz<<" prm_target_angRy="<<prm_target_angRy);
                    angle target_angRz = prm_target_angRz;
                    angle target_angRy = prm_target_angRy;
                    if (prm_way == TURN_CLOSE_TO) { //]
                        //WBAQp^[B
                        //Q_lixDjrAvpB
                
                        //_TRACE_("1 target_angRz="<<target_angRz<<" target_angRy="<<target_angRy);
                        angle d1_angRz = getRzMvAngDistance(target_angRz, TURN_CLOSE_TO); //Rz
                        angle d1_angRy = getRyMvAngDistance(target_angRy, TURN_CLOSE_TO);
                        //_TRACE_("1 d1_angRz="<<d1_angRz<<" d1_angRy="<<d1_angRy);
                        angle d1 = abs(d1_angRz) > abs(d1_angRy) ? abs(d1_angRz) : abs(d1_angRy);
                        //_TRACE_("1  d1="<<((float)d1));
                
                        GgafDx9Util::anotherRzRy(target_angRz, target_angRy);
                        //_TRACE_("2 anotherRzRy target_angRz="<<target_angRz<<" target_angRy="<<target_angRy);
                        angle d2_angRz = getRzMvAngDistance(target_angRz, TURN_CLOSE_TO);
                        angle d2_angRy = getRyMvAngDistance(target_angRy, TURN_CLOSE_TO);
                        //_TRACE_("2 d2_angRz="<<d2_angRz<<" d2_angRy="<<d2_angRy);
                        angle d2 = abs(d2_angRz) > abs(d2_angRy) ? abs(d2_angRz) : abs(d2_angRy);
                        //_TRACE_("2  d2="<<((float)d2));
                        if (d1 <= d2) {
                            //_TRACE_("d1 <= d2 d1p");
                            out_d_angRz = d1_angRz;
                            out_d_angRy = d1_angRy;
                            out_target_angRz = prm_target_angRz;
                            out_target_angRy = prm_target_angRy;
                        } else {
                            //_TRACE_("d1 > d2  d2p");
                            out_d_angRz = d2_angRz;
                            out_d_angRy = d2_angRy;
                            out_target_angRz = target_angRz;
                            out_target_angRy = target_angRy;
                        }
                        //_TRACE_("<--- getRzRyMvAngDistance");
                    } else if (prm_way == TURN_ANTICLOSE_TO) { //]
                        angle d1_angRz = getRzMvAngDistance(target_angRz, TURN_ANTICLOSE_TO);
                        angle d1_angRy = getRyMvAngDistance(target_angRy, TURN_ANTICLOSE_TO);
                        angle d1 = abs(d1_angRz) > abs(d1_angRy) ? abs(d1_angRz) : abs(d1_angRy);
                        GgafDx9Util::anotherRzRy(target_angRz, target_angRy);
                        angle d2_angRz = getRzMvAngDistance(target_angRz, TURN_ANTICLOSE_TO);
                        angle d2_angRy = getRyMvAngDistance(target_angRy, TURN_ANTICLOSE_TO);
                        angle d2 = abs(d2_angRz) > abs(d2_angRy) ? abs(d2_angRz) : abs(d2_angRy);
                        if (d1 >= d2) {
                            out_d_angRz = d1_angRz;
                            out_d_angRy = d1_angRy;
                            out_target_angRz = prm_target_angRz;
                            out_target_angRy = prm_target_angRy;
                        } else {
                            out_d_angRz = d2_angRz;
                            out_d_angRy = d2_angRy;
                            out_target_angRz = target_angRz;
                            out_target_angRy = target_angRy;
                        }
                    } else if (prm_way == TURN_COUNTERCLOCKWISE) { //v
                        out_d_angRz = getRzMvAngDistance(target_angRz, TURN_COUNTERCLOCKWISE);
                        out_d_angRy = getRyMvAngDistance(target_angRy, TURN_COUNTERCLOCKWISE);
                        out_target_angRz = target_angRz;
                        out_target_angRy = target_angRy;
                    } else if (prm_way == TURN_CLOCKWISE) { //v
                        out_d_angRz = getRzMvAngDistance(target_angRz, TURN_CLOCKWISE);
                        out_d_angRy = getRyMvAngDistance(target_angRy, TURN_CLOCKWISE);
                        out_target_angRz = target_angRz;
                        out_target_angRy = target_angRy;
                    } else {
                        //
                        throwGgafCriticalException("GgafDx9Kuroko::getRzRyMvAngDistance() prm_way="<<prm_way<<" zOB_pActor="<<_pActor->getName());
                    }
                }
                
                void GgafDx9Kuroko::getRzRyFaceAngDistance(int prm_way,
                                                                  angle prm_target_angRz, angle prm_target_angRy,
                                                                  angle& out_d_angRz, angle& out_d_angRy,
                                                                  angle& out_target_angRz, angle& out_target_angRy) {
                    angle target_angRz = prm_target_angRz;
                    angle target_angRy = prm_target_angRy;
                    if (prm_way == TURN_CLOSE_TO) { //]
                        angle d1_angRz = getFaceAngDistance(AXIS_Z, target_angRz, TURN_CLOSE_TO);
                        angle d1_angRy = getFaceAngDistance(AXIS_Y, target_angRy, TURN_CLOSE_TO);
                        angle d1 = abs(d1_angRz) > abs(d1_angRy) ? abs(d1_angRz) : abs(d1_angRy);
                        GgafDx9Util::anotherRzRy(target_angRz, target_angRy);
                        angle d2_angRz = getFaceAngDistance(AXIS_Z, target_angRz, TURN_CLOSE_TO);
                        angle d2_angRy = getFaceAngDistance(AXIS_Y, target_angRy, TURN_CLOSE_TO) * ((GgafDx9Util::COS[GgafDx9Util::simplifyAng(target_angRz*2)/ANGLE_RATE]/2.0) + 0.5);
                        angle d2 = abs(d2_angRz) > abs(d2_angRy) ? abs(d2_angRz) : abs(d2_angRy);
                        if (d1 <= d2) {
                            out_d_angRz = d1_angRz;
                            out_d_angRy = d1_angRy;
                            out_target_angRz = prm_target_angRz;
                            out_target_angRy = prm_target_angRy;
                        } else {
                            out_d_angRz = d2_angRz;
                            out_d_angRy = d2_angRy;
                            out_target_angRz = target_angRz;
                            out_target_angRy = target_angRy;
                        }
                
                    } else if (prm_way == TURN_ANTICLOSE_TO) { //]
                        angle d1_angRz = getFaceAngDistance(AXIS_Z, target_angRz, TURN_ANTICLOSE_TO);
                        angle d1_angRy = getFaceAngDistance(AXIS_Y, target_angRy, TURN_ANTICLOSE_TO);
                        angle d1 = abs(d1_angRz) > abs(d1_angRy) ? abs(d1_angRz) : abs(d1_angRy);
                        GgafDx9Util::anotherRzRy(target_angRz, target_angRy);
                        angle d2_angRz = getFaceAngDistance(AXIS_Z, target_angRz, TURN_ANTICLOSE_TO);
                        angle d2_angRy = getFaceAngDistance(AXIS_Y, target_angRy, TURN_ANTICLOSE_TO);
                        angle d2 = abs(d2_angRz) > abs(d2_angRy) ? abs(d2_angRz) : abs(d2_angRy);
                        if (d1 >= d2) {
                            out_d_angRz = d1_angRz;
                            out_d_angRy = d1_angRy;
                            out_target_angRz = prm_target_angRz;
                            out_target_angRy = prm_target_angRy;
                        } else {
                            out_d_angRz = d2_angRz;
                            out_d_angRy = d2_angRy;
                            out_target_angRz = target_angRz;
                            out_target_angRy = target_angRy;
                        }
                    } else if (prm_way == TURN_COUNTERCLOCKWISE) { //v
                        out_d_angRz = getFaceAngDistance(AXIS_Z, target_angRz, TURN_COUNTERCLOCKWISE);
                        out_d_angRy = getFaceAngDistance(AXIS_Y, target_angRy, TURN_COUNTERCLOCKWISE);
                        out_target_angRz = target_angRz;
                        out_target_angRy = target_angRy;
                    } else if (prm_way == TURN_CLOCKWISE) { //v
                        out_d_angRz = getFaceAngDistance(AXIS_Z, target_angRz, TURN_CLOCKWISE);
                        out_d_angRy = getFaceAngDistance(AXIS_Y, target_angRy, TURN_CLOCKWISE);
                        out_target_angRz = target_angRz;
                        out_target_angRy = target_angRy;
                    } else {
                        //
                        throwGgafCriticalException("GgafDx9Kuroko::getRzRyMvAngDistance() prm_way="<<prm_way<<" zOB_pActor="<<_pActor->getName());
                    }
                }
                
                void GgafDx9Kuroko::setRzRyMvAng(angle prm_angRz, angle prm_angRy) {
                    if (prm_angRz != _angRzMv || prm_angRy !=_angRyMv ) {
                        _angRzMv = GgafDx9Util::simplifyAng(prm_angRz);
                        _angRyMv = GgafDx9Util::simplifyAng(prm_angRy);
                        GgafDx9Util::getNormalizeVectorZY(_angRzMv, _angRyMv, _vX, _vY, _vZ);
                    }
                    if (_relate_RzFaceAng_to_RzMvAng_flg) {
                        setFaceAng(AXIS_Z, _angRzMv);
                    }
                    if (_relate_RyFaceAng_to_RyMvAng_flg) {
                        setFaceAng(AXIS_Y, _angRyMv);
                    }
                }
                
                void GgafDx9Kuroko::setRzRyMvAng_by_RyRz(angle prm_angRyRz_Ry, angle prm_angRyRz_Rz) {
                    angle RyRz_Ry = GgafDx9Util::simplifyAng(prm_angRyRz_Ry);
                    angle RyRz_Rz = GgafDx9Util::simplifyAng(prm_angRyRz_Rz);
                    float out_vY, out_vZ;
                    GgafDx9Util::getNormalizeVectorZY(RyRz_Ry, ANGLE360-RyRz_Rz, _vX, out_vY, out_vZ);
                    _vY = -1.0f*out_vZ;
                    _vZ = out_vY;
                    GgafDx9Util::getRzRyAng(_vX, _vZ, _vY, _angRzMv, _angRyMv);
                    if (_relate_RzFaceAng_to_RzMvAng_flg) {
                        setFaceAng(AXIS_Z, _angRzMv);
                    }
                    if (_relate_RyFaceAng_to_RyMvAng_flg) {
                        setFaceAng(AXIS_Y, _angRyMv);
                    }
                }
                
                void GgafDx9Kuroko::setMvAng(GgafDx9GeometricActor* prm_pActor_Target) {
                    setMvAng(
                        prm_pActor_Target->_X,
                        prm_pActor_Target->_Y,
                        prm_pActor_Target->_Z
                    );
                }
                
                void GgafDx9Kuroko::setMvAng(int prm_tX, int prm_tY, int prm_tZ) {
                    GgafDx9Util::getRzRyAng(
                                   prm_tX - _pActor->_X,
                                   prm_tY - _pActor->_Y,
                                   prm_tZ - _pActor->_Z,
                                   _vX,
                                   _vY,
                                   _vZ,
                                   _angRzMv,
                                   _angRyMv
                                 );
                    if (_relate_RzFaceAng_to_RzMvAng_flg) {
                        setFaceAng(AXIS_Z, _angRzMv);
                    }
                    if (_relate_RyFaceAng_to_RyMvAng_flg) {
                        setFaceAng(AXIS_Y, _angRyMv);
                    }
                }
                
                void GgafDx9Kuroko::setStopTarget_RzRyMvAng(GgafDx9GeometricActor* prm_pActor_Target) {
                    setStopTarget_RzRyMvAng(
                        prm_pActor_Target->_X,
                        prm_pActor_Target->_Y,
                        prm_pActor_Target->_Z
                    );
                }
                
                void GgafDx9Kuroko::setStopTarget_RzRyMvAng(int prm_tX, int prm_tY, int prm_tZ) {
                    angle angRz_Target;
                    angle angRy_Target;
                
                    GgafDx9Util::getRzRyAng(
                                   prm_tX - _pActor->_X,
                                   prm_tY - _pActor->_Y,
                                   prm_tZ - _pActor->_Z,
                                   _dummy1,
                                   _dummy2,
                                   _dummy3,
                                   angRz_Target,
                                   angRy_Target
                                 );
                    setStopTarget_RzMvAng(angRz_Target);
                    setStopTarget_RyMvAng(angRy_Target);
                }
                
                void GgafDx9Kuroko::forceVxMvVeloRange(velo prm_veloVxMv01, velo prm_veloVxMv02) {
                    if (prm_veloVxMv01 < prm_veloVxMv02) {
                        _veloTopVxMv = prm_veloVxMv02;
                        _veloBottomVxMv = prm_veloVxMv01;
                    } else {
                        _veloTopVxMv = prm_veloVxMv01;
                        _veloBottomVxMv = prm_veloVxMv02;
                    }
                    setVxMvVelo(_veloVxMv); //
                }
                
                void GgafDx9Kuroko::setVxMvVelo(velo prm_veloVxMv) {
                    if (prm_veloVxMv > _veloTopVxMv) {
                        _veloVxMv = _veloTopVxMv;
                    } else if (prm_veloVxMv < _veloBottomVxMv) {
                        _veloVxMv = _veloBottomVxMv;
                    } else {
                        _veloVxMv = prm_veloVxMv;
                    }
                }
                
                void GgafDx9Kuroko::addVxMvVelo(velo prm_veloVxMv) {
                    _veloVxMv += prm_veloVxMv;
                    if (_veloVxMv > _veloTopVxMv) {
                        _veloVxMv = _veloTopVxMv;
                    } else if (_veloVxMv < _veloBottomVxMv) {
                        _veloVxMv = _veloBottomVxMv;
                    }
                }
                
                void GgafDx9Kuroko::setVxMvAcce(acce prm_acceVxMv) {
                    if (prm_acceVxMv > _acceTopVxMv) {
                        _acceVxMv = _acceTopVxMv;
                    } else if (prm_acceVxMv < _acceBottomVxMv) {
                        _acceVxMv = _acceBottomVxMv;
                    } else {
                        _acceVxMv = prm_acceVxMv;
                    }
                }
                
                void GgafDx9Kuroko::addVxMvAcce(acce prm_acceVxMv) {
                    setVxMvAcce(_acceVxMv + prm_acceVxMv);
                }
                
                
                void GgafDx9Kuroko::forceVxMvAcceRange(acce prm_acceVxMv01, acce prm_acceVxMv02) {
                    if (prm_acceVxMv01 < prm_acceVxMv02) {
                        _acceTopVxMv = prm_acceVxMv02;
                        _acceBottomVxMv = prm_acceVxMv01;
                    } else {
                        _acceTopVxMv = prm_acceVxMv01;
                        _acceBottomVxMv = prm_acceVxMv02;
                    }
                    setVxMvAcce(_acceVxMv); //
                }
                
                
                void GgafDx9Kuroko::forceVyMvVeloRange(velo prm_veloVyMv01, velo prm_veloVyMv02) {
                    if (prm_veloVyMv01 < prm_veloVyMv02) {
                        _veloTopVyMv = prm_veloVyMv02;
                        _veloBottomVyMv = prm_veloVyMv01;
                    } else {
                        _veloTopVyMv = prm_veloVyMv01;
                        _veloBottomVyMv = prm_veloVyMv02;
                    }
                    setVyMvVelo(_veloVyMv); //
                }
                
                void GgafDx9Kuroko::setVyMvVelo(velo prm_veloVyMv) {
                    if (prm_veloVyMv > _veloTopVyMv) {
                        _veloVyMv = _veloTopVyMv;
                    } else if (prm_veloVyMv < _veloBottomVyMv) {
                        _veloVyMv = _veloBottomVyMv;
                    } else {
                        _veloVyMv = prm_veloVyMv;
                    }
                }
                
                void GgafDx9Kuroko::addVyMvVelo(velo prm_veloVyMv) {
                    _veloVyMv += prm_veloVyMv;
                    if (_veloVyMv > _veloTopVyMv) {
                        _veloVyMv = _veloTopVyMv;
                    } else if (_veloVyMv < _veloBottomVyMv) {
                        _veloVyMv = _veloBottomVyMv;
                    }
                }
                
                void GgafDx9Kuroko::setVyMvAcce(acce prm_acceVyMv) {
                    if (prm_acceVyMv > _acceTopVyMv) {
                        _acceVyMv = _acceTopVyMv;
                    } else if (prm_acceVyMv < _acceBottomVyMv) {
                        _acceVyMv = _acceBottomVyMv;
                    } else {
                        _acceVyMv = prm_acceVyMv;
                    }
                }
                
                void GgafDx9Kuroko::addVyMvAcce(acce prm_acceVyMv) {
                    setVyMvAcce(_acceVyMv + prm_acceVyMv);
                }
                
                
                void GgafDx9Kuroko::forceVyMvAcceRange(acce prm_acceVyMv01, acce prm_acceVyMv02) {
                    if (prm_acceVyMv01 < prm_acceVyMv02) {
                        _acceTopVyMv = prm_acceVyMv02;
                        _acceBottomVyMv = prm_acceVyMv01;
                    } else {
                        _acceTopVyMv = prm_acceVyMv01;
                        _acceBottomVyMv = prm_acceVyMv02;
                    }
                    setVyMvAcce(_acceVyMv); //
                }
                
                void GgafDx9Kuroko::forceVzMvVeloRange(velo prm_veloVzMv01, velo prm_veloVzMv02) {
                    if (prm_veloVzMv01 < prm_veloVzMv02) {
                        _veloTopVzMv = prm_veloVzMv02;
                        _veloBottomVzMv = prm_veloVzMv01;
                    } else {
                        _veloTopVzMv = prm_veloVzMv01;
                        _veloBottomVzMv = prm_veloVzMv02;
                    }
                    setVzMvVelo(_veloVzMv); //
                }
                
                void GgafDx9Kuroko::setVzMvVelo(velo prm_veloVzMv) {
                    if (prm_veloVzMv > _veloTopVzMv) {
                        _veloVzMv = _veloTopVzMv;
                    } else if (prm_veloVzMv < _veloBottomVzMv) {
                        _veloVzMv = _veloBottomVzMv;
                    } else {
                        _veloVzMv = prm_veloVzMv;
                    }
                }
                
                void GgafDx9Kuroko::addVzMvVelo(velo prm_veloVzMv) {
                    _veloVzMv += prm_veloVzMv;
                    if (_veloVzMv > _veloTopVzMv) {
                        _veloVzMv = _veloTopVzMv;
                    } else if (_veloVzMv < _veloBottomVzMv) {
                        _veloVzMv = _veloBottomVzMv;
                    }
                }
                
                void GgafDx9Kuroko::setVzMvAcce(acce prm_acceVzMv) {
                    if (prm_acceVzMv > _acceTopVzMv) {
                        _acceVzMv = _acceTopVzMv;
                    } else if (prm_acceVzMv < _acceBottomVzMv) {
                        _acceVzMv = _acceBottomVzMv;
                    } else {
                        _acceVzMv = prm_acceVzMv;
                    }
                }
                
                void GgafDx9Kuroko::addVzMvAcce(acce prm_acceVzMv) {
                    setVzMvAcce(_acceVzMv + prm_acceVzMv);
                }
                
                
                void GgafDx9Kuroko::forceVzMvAcceRange(acce prm_acceVzMv01, acce prm_acceVzMv02) {
                    if (prm_acceVzMv01 < prm_acceVzMv02) {
                        _acceTopVzMv = prm_acceVzMv02;
                        _acceBottomVzMv = prm_acceVzMv01;
                    } else {
                        _acceTopVzMv = prm_acceVzMv01;
                        _acceBottomVzMv = prm_acceVzMv02;
                    }
                    setVzMvAcce(_acceVzMv); //
                }
                
                
                
                void GgafDx9Kuroko::forceVxyzMvVeloRange(velo prm_veloVxyzMv01, velo prm_veloVxyzMv02) {
                    forceVxMvVeloRange(prm_veloVxyzMv01, prm_veloVxyzMv02);
                    forceVyMvVeloRange(prm_veloVxyzMv01, prm_veloVxyzMv02);
                    forceVzMvVeloRange(prm_veloVxyzMv01, prm_veloVxyzMv02);
                }
                void GgafDx9Kuroko::forceVxyzMvAcceRange(acce prm_acceVxyzMv01, acce prm_acceVxyzMv02) {
                    forceVxMvAcceRange(prm_acceVxyzMv01, prm_acceVxyzMv02);
                    forceVyMvAcceRange(prm_acceVxyzMv01, prm_acceVxyzMv02);
                    forceVzMvAcceRange(prm_acceVxyzMv01, prm_acceVxyzMv02);
                }
                
                
                
                
                void GgafDx9Kuroko::orderTagettingFaceAngSequence(angle prm_angRz_Target, angle prm_angRy_Target,
                                                                        angvelo prm_angVelo, angacce prm_angAcce,
                                                                        int prm_way, bool prm_optimize_ang) {
                    angle out_d_angRz;
                    angle out_d_angRy;
                    if (prm_optimize_ang) {
                        getRzRyFaceAngDistance(prm_way,
                                               prm_angRz_Target, prm_angRy_Target,
                                               out_d_angRz, out_d_angRy,
                                               prm_angRz_Target, prm_angRy_Target);
                    } else {
                        out_d_angRz = getFaceAngDistance(AXIS_Z, prm_angRz_Target, prm_way);
                        out_d_angRy = getFaceAngDistance(AXIS_Y, prm_angRy_Target, prm_way);
                    }
                
                    if (out_d_angRz > 0) {
                        setFaceAngVelo(AXIS_Z, prm_angVelo);
                        setFaceAngAcce(AXIS_Z, prm_angAcce);
                    } else {
                        setFaceAngVelo(AXIS_Z, -prm_angVelo);
                        setFaceAngAcce(AXIS_Z, -prm_angAcce);
                    }
                    if (out_d_angRy > 0) {
                        setFaceAngVelo(AXIS_Y, prm_angVelo);
                        setFaceAngAcce(AXIS_Y, prm_angAcce);
                    } else {
                        setFaceAngVelo(AXIS_Y, -prm_angVelo);
                        setFaceAngAcce(AXIS_Y, -prm_angAcce);
                    }
                
                    setStopTarget_FaceAng(AXIS_Z, prm_angRz_Target);
                    setStopTarget_FaceAng(AXIS_Y, prm_angRy_Target);
                }
                
                void GgafDx9Kuroko::orderTagettingFaceAngSequence(int prm_tX, int prm_tY, int prm_tZ,
                                                                        angvelo prm_angVelo, angacce prm_angAcce,
                                                                        int prm_way, bool prm_optimize_ang) {
                    angle out_angRz_Target;
                    angle out_angRy_Target;
                    GgafDx9Util::getRzRyAng(prm_tX - _pActor->_X,
                                            prm_tY - _pActor->_Y,
                                            prm_tZ - _pActor->_Z,
                                            out_angRz_Target,
                                            out_angRy_Target);
                    orderTagettingFaceAngSequence(out_angRz_Target, out_angRy_Target,
                                                 prm_angVelo, prm_angAcce,
                                                 prm_way, prm_optimize_ang);
                }
                
                void GgafDx9Kuroko::orderTagettingRzFaceAngSequence(angle prm_angRz_Target,
                                                                          angvelo prm_angVelo, angacce prm_angAcce,
                                                                          int prm_way) {
                    if (getFaceAngDistance(AXIS_Z, prm_angRz_Target, prm_way) > 0) {
                        setFaceAngVelo(AXIS_Z, prm_angVelo);
                        setFaceAngAcce(AXIS_Z, prm_angAcce);
                    } else {
                        setFaceAngVelo(AXIS_Z, -prm_angVelo);
                        setFaceAngAcce(AXIS_Z, -prm_angAcce);
                    }
                    setStopTarget_FaceAng(AXIS_Z, prm_angRz_Target);
                
                }
                
                void GgafDx9Kuroko::orderTagettingRyFaceAngSequence(angle prm_angRy_Target,
                                                                          angvelo prm_angVelo, angacce prm_angAcce,
                                                                          int prm_way) {
                    if (getFaceAngDistance(AXIS_Y, prm_angRy_Target, prm_way) > 0) {
                        setFaceAngVelo(AXIS_Y, prm_angVelo);
                        setFaceAngAcce(AXIS_Y, prm_angAcce);
                    } else {
                        setFaceAngVelo(AXIS_Y, -prm_angVelo);
                        setFaceAngAcce(AXIS_Y, -prm_angAcce);
                    }
                    setStopTarget_FaceAng(AXIS_Y, prm_angRy_Target);
                }
                
                void GgafDx9Kuroko::orderTagettingRxSpinAngleSequence(angle prm_angRx_Target,
                                                                            angvelo prm_angVelo, angacce prm_angAcce,
                                                                            int prm_way) {
                    if (getFaceAngDistance(AXIS_X, prm_angRx_Target, prm_way) > 0) {
                        setFaceAngVelo(AXIS_X, prm_angVelo);
                        setFaceAngAcce(AXIS_X, prm_angAcce);
                    } else {
                        setFaceAngVelo(AXIS_X, -prm_angVelo);
                        setFaceAngAcce(AXIS_X, -prm_angAcce);
                    }
                    setStopTarget_FaceAng(AXIS_X, prm_angRx_Target);
                }
                
                void GgafDx9Kuroko::orderTagettingMvAngSequence(angle prm_angRz_Target, angle prm_angRy_Target,
                                                                      angvelo prm_angVelo, angacce prm_angAcce,
                                                                      int prm_way, bool prm_optimize_ang) {
                    angle out_d_angRz;
                    angle out_d_angRy;
                    angle out_target_angRz;
                    angle out_target_angRy;
                    if (prm_optimize_ang) {
                        getRzRyMvAngDistance(prm_way,
                                             prm_angRz_Target, prm_angRy_Target,
                                             out_d_angRz, out_d_angRy,
                                             out_target_angRz, out_target_angRy);
                    } else {
                        out_d_angRz = getRzMvAngDistance(prm_angRz_Target, prm_way);
                        out_d_angRy = getRyMvAngDistance(prm_angRy_Target, prm_way);
                        out_target_angRz = prm_angRz_Target;
                        out_target_angRy = prm_angRy_Target;
                    }
                    if (out_d_angRz > 0) {
                        setRzMvAngVelo(prm_angVelo);
                        setRzMvAngAcce(prm_angAcce);
                    } else {
                        setRzMvAngVelo(-prm_angVelo);
                        setRzMvAngAcce(-prm_angAcce);
                    }
                    if (out_d_angRy > 0) {
                        setRyMvAngVelo(prm_angVelo);
                        setRyMvAngAcce(prm_angAcce);
                    } else {
                        setRyMvAngVelo(-prm_angVelo);
                        setRyMvAngAcce(-prm_angAcce);
                    }
                
                    setStopTarget_RzMvAng(out_target_angRz);
                    setStopTarget_RyMvAng(out_target_angRy);
                
                }
                
                
                void GgafDx9Kuroko::orderTagettingMvAngSequence(int prm_tX, int prm_tY, int prm_tZ,
                                                                      angvelo prm_angVelo, angacce prm_angAcce,
                                                                      int prm_way, bool prm_optimize_ang) {
                    angle out_angRz_Target;
                    angle out_angRy_Target;
                    GgafDx9Util::getRzRyAng(prm_tX - _pActor->_X,
                                            prm_tY - _pActor->_Y,
                                            prm_tZ - _pActor->_Z,
                                            out_angRz_Target,
                                            out_angRy_Target);
                    orderTagettingMvAngSequence(out_angRz_Target, out_angRy_Target,
                                               prm_angVelo, prm_angAcce,
                                               prm_way, prm_optimize_ang);
                }
                
                
                void GgafDx9Kuroko::orderTagettingRzMvAngSequence(angle prm_angRz_Target,
                                                                        angvelo prm_angVelo, angacce prm_angAcce,
                                                                        int prm_way) {
                    if (getRzMvAngDistance(prm_angRz_Target, prm_way) > 0) {
                        setRzMvAngVelo(prm_angVelo);
                        setRzMvAngAcce(prm_angAcce);
                    } else {
                        setRzMvAngVelo(-prm_angVelo);
                        setRzMvAngAcce(-prm_angAcce);
                    }
                    setStopTarget_RzMvAng(prm_angRz_Target);
                
                }
                
                void GgafDx9Kuroko::orderTagettingRyMvAngSequence(angle prm_angRy_Target,
                                                                        angvelo prm_angVelo, angacce prm_angAcce,
                                                                        int prm_way) {
                    if (getRyMvAngDistance(prm_angRy_Target, prm_way) > 0) {
                        setRyMvAngVelo(prm_angVelo);
                        setRyMvAngAcce(prm_angAcce);
                    } else {
                        setRyMvAngVelo(-prm_angVelo);
                        setRyMvAngAcce(-prm_angAcce);
                    }
                    setStopTarget_RyMvAng(prm_angRy_Target);
                }
                
                void GgafDx9Kuroko::orderGravitationVxyzMvSequence(
                        int prm_tX, int prm_tY, int prm_tZ,
                        velo prm_max_velo,
                        acce prm_acce,
                        int prm_stop_renge
                        ) {
                    _gravitation_mv_seq_target_X = prm_tX;
                    _gravitation_mv_seq_target_Y = prm_tY;
                    _gravitation_mv_seq_target_Z = prm_tZ;
                    _gravitation_mv_seq_pActor_target = NULL;
                    _gravitation_mv_seq_max_velo = prm_max_velo;
                    _gravitation_mv_seq_acce = prm_acce;
                    _gravitation_mv_seq_stop_renge = prm_stop_renge;
                    _gravitation_mv_seq_flg = true;
                
                    forceVxMvVeloRange(-prm_max_velo, prm_max_velo);
                    forceVyMvVeloRange(-prm_max_velo, prm_max_velo);
                    forceVzMvVeloRange(-prm_max_velo, prm_max_velo);
                }
                
                void GgafDx9Kuroko::orderGravitationVxyzMvSequence(
                        GgafDx9GeometricActor* prm_pActor_target,
                        velo prm_max_velo,
                        acce prm_acce,
                        int prm_stop_renge
                        ) {
                    _gravitation_mv_seq_target_X = 0;
                    _gravitation_mv_seq_target_Y = 0;
                    _gravitation_mv_seq_target_Z = 0;
                    _gravitation_mv_seq_pActor_target = prm_pActor_target;
                    _gravitation_mv_seq_max_velo = prm_max_velo;
                    _gravitation_mv_seq_acce = prm_acce;
                    _gravitation_mv_seq_stop_renge = prm_stop_renge;
                    _gravitation_mv_seq_flg = true;
                
                    forceVxMvVeloRange(-prm_max_velo, prm_max_velo);
                    forceVyMvVeloRange(-prm_max_velo, prm_max_velo);
                    forceVzMvVeloRange(-prm_max_velo, prm_max_velo);
                }
                
                
                
                void GgafDx9Kuroko::takeoverMvFrom(GgafDx9Kuroko* prm_pKuroko) {
                    // LpPxNg
                    _vX = prm_pKuroko->_vX;
                    _vY = prm_pKuroko->_vY;
                    _vZ = prm_pKuroko->_vZ;
                    // pZ]p
                    _angRzMv = prm_pKuroko->_angRzMv;
                    // pY]p
                    _angRyMv = prm_pKuroko->_angRyMv;
                    // x
                    _veloMv = prm_pKuroko->_veloMv;
                    // x
                    _veloTopMv = prm_pKuroko->_veloTopMv;
                    // x
                    _veloBottomMv = prm_pKuroko->_veloBottomMv;
                    // x
                    _accMv = prm_pKuroko->_accMv;
                    // x
                    _jerkMv = prm_pKuroko->_jerkMv;
                
                    // Xx
                    _veloVxMv = prm_pKuroko->_veloVxMv;
                    // Xx
                    _veloTopVxMv = prm_pKuroko->_veloTopVxMv;
                    // Xx
                    _veloBottomVxMv = prm_pKuroko->_veloBottomVxMv;
                    // Xx
                    _acceVxMv = prm_pKuroko->_acceVxMv;
                    // Xx
                    _acceTopVxMv = prm_pKuroko->_acceTopVxMv;
                    // Xx
                    _acceBottomVxMv = prm_pKuroko->_acceBottomVxMv;
                    // Yx
                    _veloVyMv = prm_pKuroko->_veloVyMv;
                    // Yx
                    _veloTopVyMv = prm_pKuroko->_veloTopVyMv;
                    // Yx
                    _veloBottomVyMv = prm_pKuroko->_veloBottomVyMv;
                    // Yx
                    _acceVyMv = prm_pKuroko->_acceVyMv;
                    // Yx
                    _acceTopVyMv = prm_pKuroko->_acceTopVyMv;
                    // Yx
                    _acceBottomVyMv = prm_pKuroko->_acceBottomVyMv;
                    // Zx
                    _veloVzMv = prm_pKuroko->_veloVzMv;
                    // Zx
                    _veloTopVzMv = prm_pKuroko->_veloTopVzMv;
                    // Zx
                    _veloBottomVzMv = prm_pKuroko->_veloBottomVzMv;
                    // Zx
                    _acceVzMv = prm_pKuroko->_acceVzMv;
                    // Zx
                    _acceTopVzMv = prm_pKuroko->_acceTopVzMv;
                    // Zx
                    _acceBottomVzMv = prm_pKuroko->_acceBottomVzMv;
                
                }
                
                void GgafDx9Kuroko::resetMv() {
                    //LpPxNg
                    _vX = _vY = _vZ = 0.0f;
                    //pZ]
                    _angRzMv = 0;
                    //pY]
                    _angRyMv = 0;
                    //x
                    _veloMv = 0;
                    //x = 256 px/fream
                    _veloTopMv = 256 * LEN_UNIT; //_veloMv  256000(=256px) AIW 256px }B
                    //x = 0   px/fream
                    _veloBottomMv = -256 * LEN_UNIT; //_veloMv  -256000(-256px) AIW -256000px }B
                    //xixj = 0 px/fream^2
                    _accMv = 0; //_veloMv BftHg
                
                    _jerkMv = 0;
                    //piZ]jpx = 0 angle/fream
                    _angveloRzMv = 0; //1t[ZppBftHgppAB
                    //piZ]jpx = +360,000 angle/fream
                    _angveloRzTopMv = ANGLE360; //_angveloRzMv BftHg1t[DXo
                    //piZ]jpx = -360,000 angle/fream
                    _angveloRzBottomMv = ANGLE360 * -1; //_angveloRzMv BftHg1t[DXo
                    //piZ]jpx = 0 angle/fream^2
                    _angacceRzMv = 0; //_angveloRzMv BftHgppx
                
                    _angjerkRzMv = 0;
                
                    //XxiXWj 0 px/fream
                    _veloVxMv = 0;
                    //Xx  256 px/fream
                    _veloTopVxMv = 256 * LEN_UNIT;
                    //Xx  256 px/fream
                    _veloBottomVxMv = -256 * LEN_UNIT;
                    //Xxx  0 px/fream^2  ()
                    _acceVxMv = 0;
                    _acceTopVxMv = 256 * LEN_UNIT;
                    _acceBottomVxMv = -256 * LEN_UNIT;
                    //YxiYWj 0 px/fream
                    _veloVyMv = 0;
                    //Yx  256 px/fream
                    _veloTopVyMv = 256 * LEN_UNIT;
                    //Yx  256 px/fream
                    _veloBottomVyMv = -256 * LEN_UNIT;
                    //Yxx  0 px/fream^2  ()
                    _acceVyMv = 0;
                
                    _acceTopVyMv = 256 * LEN_UNIT;
                    _acceBottomVyMv = -256 * LEN_UNIT;
                
                    //ZxiZWj 0 px/fream
                    _veloVzMv = 0;
                    //Zx  256 px/fream
                    _veloTopVzMv = 256 * LEN_UNIT;
                    //Zx  256 px/fream
                    _veloBottomVzMv = -256 * LEN_UNIT;
                    //Zxx  0 px/fream^2  ()
                    _acceVzMv = 0;
                    _acceTopVzMv = 256 * LEN_UNIT;
                    _acceBottomVzMv = -256 * LEN_UNIT;
                }
                
        9394 -> GgafDx9Kuroko::~GgafDx9Kuroko() {
                }


Top 10 Lines:

     Line      Count

     2134       9394
      123       4695

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

    14089   Total number of line executions
  4696.33   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/GgafDx9BoardActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
           2 -> GgafDx9BoardActor::GgafDx9BoardActor(const char* prm_name,
                                                     const char* prm_model_id,
                                                     const char* prm_effect_id,
                                                     const char* prm_technique) :
                                                         GgafDx9DrawableActor(prm_name,
                                                                              prm_model_id,
                                                                              "B",
                                                                              prm_effect_id,
                                                                              "B",
                                                                              prm_technique,
                                                                              NULL) {
                    _obj_class |= Obj_GgafDx9BoardActor;
                    _class_name = "GgafDx9BoardActor";
                
                    _pBoardModel = (GgafDx9BoardModel*)_pGgafDx9Model;
                    _pBoardEffect = (GgafDx9BoardEffect*)_pGgafDx9Effect;
                    _pUvFlipper = NEW GgafDx9UvFlipper(this);
                    _pUvFlipper->forcePtnNoRange(0, _pBoardModel->_pattno_max);
                    _pUvFlipper->setPtnNo(0);
                    _pUvFlipper->setFlipMethod(NOT_ANIMATED, 1);
                    _fAlpha = 1.0f;
                
                    _isTransformed = true;
                    _pFunc_calcRotMvWorldMatrix = NULL;
                    _sx = 1.0f;
                    _sy = 1.0f;
                }
                
                void GgafDx9BoardActor::processDraw() {
                    ID3DXEffect* pID3DXEffect = _pBoardEffect->_pID3DXEffect;
                    HRESULT hr;
                    hr = pID3DXEffect->SetFloat(_pBoardEffect->_hTransformedX, _x);
                    checkDxException(hr, D3D_OK, "GgafDx9BoardModel::draw SetFloat(_hTransformedX) sB");
                    hr = pID3DXEffect->SetFloat(_pBoardEffect->_hTransformedY, _y);
                    checkDxException(hr, D3D_OK, "GgafDx9BoardModel::draw SetFloat(_hTransformedY) sB");
                    hr = pID3DXEffect->SetFloat(_pBoardEffect->_hDepthZ, _z);
                    checkDxException(hr, D3D_OK, "GgafDx9BoardModel::draw SetFloat(_hDepthZ) sB");
                    hr = pID3DXEffect->SetFloat(_pBoardEffect->_hAlpha, _fAlpha);
                    checkDxException(hr, D3D_OK, "GgafDx9BoardModel::draw SetFloat(_hAlpha) sB");
                    hr = pID3DXEffect->SetFloat(_pBoardEffect->_hSx, _sx);
                    checkDxException(hr, D3D_OK, "GgafDx9BoardModel::draw SetFloat(_sx) sB");
                    hr = pID3DXEffect->SetFloat(_pBoardEffect->_hSy, _sy);
                    checkDxException(hr, D3D_OK, "GgafDx9BoardModel::draw SetFloat(_sy) sB");
                    _pBoardModel->draw(this);
                }
                
           2 -> GgafDx9BoardActor::~GgafDx9BoardActor() {
                    DELETE_IMPOSSIBLE_NULL(_pUvFlipper);
                }


Top 10 Lines:

     Line      Count

        6          2
       52          2

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        4   Total number of line executions
     1.33   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/GgafDx9BoardSetActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
          28 -> GgafDx9BoardSetActor::GgafDx9BoardSetActor(const char* prm_name,
                                                           const char* prm_model_id,
                                                           const char* prm_effect_id,
                                                           const char* prm_technique) :
                                                               GgafDx9DrawableActor(prm_name,
                                                                                    prm_model_id,
                                                                                    "b",
                                                                                    prm_effect_id,
                                                                                    "b",
                                                                                    prm_technique,
                                                                                    NULL) {
                    _obj_class |= Obj_GgafDx9BoardSetActor;
                    _class_name = "GgafDx9BoardSetActor";
                
                    _pBoardSetModel = (GgafDx9BoardSetModel*)_pGgafDx9Model;
                    _pBoardSetEffect = (GgafDx9BoardSetEffect*)_pGgafDx9Effect;
                    _pUvFlipper = NEW GgafDx9UvFlipper(this);
                    _pUvFlipper->forcePtnNoRange(0, _pBoardSetModel->_pattno_max);
                    _pUvFlipper->setPtnNo(0);
                    _pUvFlipper->setFlipMethod(NOT_ANIMATED, 1);
                    _fAlpha = 1.0f;
                
                    _isTransformed = true;
                    _pFunc_calcRotMvWorldMatrix = NULL;
                }
                
                void GgafDx9BoardSetActor::processDraw() {
                    _draw_set_num = 0; //GgafDx9BoardSetActorfeNjbN
                                       //AJEgB`[xx`B
                    ID3DXEffect* pID3DXEffect = _pBoardSetEffect->_pID3DXEffect;
                    HRESULT hr;
                    GgafDx9DrawableActor* pDrawActor = this;
                    GgafDx9BoardSetActor* pBoardSetActor;
                    GgafDx9RectUV* pRectUV_Active;
                    while (true) {
                        if (pDrawActor)  {
                            if (pDrawActor->_pGgafDx9Model == _pBoardSetModel && pDrawActor->_hash_technique == _hash_technique) {
                                pBoardSetActor = (GgafDx9BoardSetActor*)pDrawActor;
                
                                hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahTransformedX[_draw_set_num], pDrawActor->_x);
                                checkDxException(hr, D3D_OK, "GgafDx9BoardSetModel::draw SetFloat(_ahTransformedX) sB");
                                hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahTransformedY[_draw_set_num], pDrawActor->_y);
                                checkDxException(hr, D3D_OK, "GgafDx9BoardSetModel::draw SetFloat(_ahTransformedY) sB");
                                hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahDepthZ[_draw_set_num], pDrawActor->_z);
                                checkDxException(hr, D3D_OK, "GgafDx9BoardSetModel::draw SetFloat(_ahDepthZ) sB");
                                hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahAlpha[_draw_set_num], pDrawActor->_fAlpha);
                                checkDxException(hr, D3D_OK, "GgafDx9BoardSetModel::draw SetFloat(_ahAlpha) sB");
                
                                pRectUV_Active = _pBoardSetModel->_paRectUV + (((GgafDx9BoardSetActor*)(pDrawActor))->_pUvFlipper->_pattno_uvflip_now);
                                hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahOffsetU[_draw_set_num], pRectUV_Active->_aUV[0].tu);
                                checkDxException(hr, D3D_OK, "GgafDx9BoardModel::draw() SetFloat(_hOffsetU) sB");
                                hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahOffsetV[_draw_set_num], pRectUV_Active->_aUV[0].tv);
                                checkDxException(hr, D3D_OK, "GgafDx9BoardModel::draw() SetFloat(_hOffsetV) sB");
                
                                _draw_set_num++;
                                if (_draw_set_num >= _pBoardSetModel->_set_num) {
                                    break;
                                }
                                pDrawActor = pDrawActor->_pNext_TheSameDrawDepthLevel;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    GgafDx9Universe::_pActor_DrawActive = pBoardSetActor; //`ZbgAN^[Zbg
                    _pBoardSetModel->draw(this, _draw_set_num);
                }
                
                
          28 -> GgafDx9BoardSetActor::~GgafDx9BoardSetActor() {
                    DELETE_IMPOSSIBLE_NULL(_pUvFlipper);
                }


Top 10 Lines:

     Line      Count

        6         28
       77         28

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       56   Total number of line executions
    18.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/GgafDx9DrawableActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                unsigned int GgafDx9DrawableActor::_hash_technique_last_draw = 0;
                
       ##### -> GgafDx9DrawableActor::GgafDx9DrawableActor(const char* prm_name,
                                                           const char* prm_model,
                                                           const char* prm_effect,
                                                           const char* prm_technique,
                                                           GgafDx9Checker* prm_pChecker) :
                  GgafDx9GeometricActor(prm_name, prm_pChecker) {
                    _obj_class |= Obj_GgafDx9DrawableActor;
                    _class_name = "GgafDx9DrawableActor";
                
                    //_TRACE_("GgafDx9DrawableActor::GgafDx9DrawableActor(");
                    //_TRACE_("    prm_name="<<prm_name);
                    //_TRACE_("    prm_model="<<prm_model);
                    //_TRACE_("    prm_effect="<<prm_effect);
                    //_TRACE_("    prm_technique="<<prm_technique);
                    //_TRACE_(")");
                
                    _hash_technique = GgafUtil::easy_hash(prm_technique);
                    _technique = NEW char[51];
                    strcpy(_technique, prm_technique);
                    _technique_temp = NEW char[51];
                    _hash_technique = 0;
                    _frame_temp_technique = 0;
                    _is_temp_technique = false;
                
                    _pNext_TheSameDrawDepthLevel = NULL;
                    //f
                    _pGgafDx9ModelCon = (GgafDx9ModelConnection*)GgafDx9God::_pModelManager->getConnection(prm_model);
                    _pGgafDx9Model = (GgafDx9Model*)_pGgafDx9ModelCon->refer();
                    //GtFNg
                    _pGgafDx9EffectCon = (GgafDx9EffectConnection*)GgafDx9God::_pEffectManager->getConnection(prm_effect);
                    _pGgafDx9Effect = (GgafDx9Effect*)_pGgafDx9EffectCon->refer();
                    //}eARs[
                    _paD3DMaterial9 = NEW D3DMATERIAL9[_pGgafDx9Model->_dwNumMaterials];
                    for (DWORD i = 0; i < _pGgafDx9Model->_dwNumMaterials; i++){
                        _paD3DMaterial9[i] = _pGgafDx9Model->_paD3DMaterial9_default[i];
                    }
                    _fAlpha = 1.0f;
                    //_
                    _fBoundingSphereRadius = _pGgafDx9Model->_fBoundingSphereRadius;
                    _now_drawdepth = 0;
                    _specal_drawdepth = -1;
                    _zenable = true;
                    _zwriteenable = true;
                }
                
                
        4678 -> GgafDx9DrawableActor::GgafDx9DrawableActor(const char* prm_name,
                                                           const char* prm_model_id,
                                                           const char* prm_model_type,
                                                           const char* prm_effect_id,
                                                           const char* prm_effect_type,
                                                           const char* prm_technique,
                                                           GgafDx9Checker* prm_pChecker) :
                  GgafDx9GeometricActor(prm_name, prm_pChecker) {
                
                //_TRACE_("GgafDx9DrawableActor::GgafDx9DrawableActor(");
                //_TRACE_("    prm_name="<<prm_name);
                //_TRACE_("    prm_model_id="<<prm_model_id);
                //_TRACE_("    prm_model_type="<<prm_model_type);
                //_TRACE_("    prm_effect_id="<<prm_effect_id);
                //_TRACE_("    prm_effect_type="<<prm_effect_type);
                //_TRACE_("    prm_technique="<<prm_technique);
                //_TRACE_(")");
                
                    _class_name = "GgafDx9DrawableActor";
                    _hash_technique = GgafUtil::easy_hash(prm_technique);
                    _technique = NEW char[51];
                    strcpy(_technique, prm_technique);
                    _technique_temp = NEW char[51];
                    _hash_technique = 0;
                    _frame_temp_technique = 0;
                    _is_temp_technique = false;
                
                    char* model_name = NEW char[51];
                    model_name[0] = '\0';
                    strcat(model_name, prm_model_type);
                    strcat(model_name, "/");
                    strcat(model_name, prm_model_id);
                    // prm_model_id   = "Ceres"
                    // prm_model_type = "X"
                    // Amodel_name 
                    // model_name     = "X/Ceres"
                    // B
                
                    char* effelct_name = NEW char[51];
                    effelct_name[0] = '\0';
                    strcat(effelct_name, prm_effect_type);
                    strcat(effelct_name, "/");
                    strcat(effelct_name, prm_effect_id);
                    // prm_effect_id   = "DefaultMeshEffect"
                    // prm_effect_type = "X"
                    // Aeffelct_name 
                    // effelct_name     = "X/DefaultMeshEffect"
                    // B
                
                    _pNext_TheSameDrawDepthLevel = NULL;
                    //f
                    _pGgafDx9ModelCon = (GgafDx9ModelConnection*)GgafDx9God::_pModelManager->getConnection(model_name);
                    _pGgafDx9Model = (GgafDx9Model*)_pGgafDx9ModelCon->refer();
                    //GtFNg
                    _pGgafDx9EffectCon = (GgafDx9EffectConnection*)GgafDx9God::_pEffectManager->getConnection(effelct_name);
                    _pGgafDx9Effect = (GgafDx9Effect*)_pGgafDx9EffectCon->refer();
                    //}eARs[
                    _paD3DMaterial9 = NEW D3DMATERIAL9[_pGgafDx9Model->_dwNumMaterials];
                    for (DWORD i = 0; i < _pGgafDx9Model->_dwNumMaterials; i++){
                        _paD3DMaterial9[i] = _pGgafDx9Model->_paD3DMaterial9_default[i];
                    }
                    _fAlpha = 1.0f;
                
                    //_
                    _fBoundingSphereRadius = _pGgafDx9Model->_fBoundingSphereRadius;
                
                    DELETEARR_IMPOSSIBLE_NULL(model_name);
                    DELETEARR_IMPOSSIBLE_NULL(effelct_name);
                
                    _now_drawdepth = 0;
                    _specal_drawdepth = -1;
                    _zenable = true;
                    _zwriteenable = true;
                }
                
                
                
                void GgafDx9DrawableActor::processPreDraw() {
                    if (_pGgafDx9Model->_is_init_model == false) {
                        onCreateModel(); //f
                        _pGgafDx9Model->_is_init_model = true;
                    }
                
                    _pNext_TheSameDrawDepthLevel = NULL;
                    //TODO:v
                    if (isActiveActor()) {
                        if (_isTransformed) {
                            _now_drawdepth = GgafDx9Universe::setDrawDepthLevel(
                                                (int)(_z * MAX_DRAW_DEPTH_LEVEL),
                                                this
                                             );
                        } else {
                            if (isOutOfView() || _fAlpha <= 0.0f || ((GgafDx9Scene*)getPlatformScene())->_pAlphaCurtain->_alpha <= 0.0f) {
                                //`o^
                            } else {
                                //
                                //Ju _cameraZ_org = -47.6701A\s  _zf  _dep=20A_zf = -_cameraZ_org*(_dep+1); BB
                                //uQFGgafDx9Camera::GgafDx9Camera()v
                                //\(s:_zf)Ju21{ 1000(1001.0721) i _zf = -_cameraZ_org*20.0 j
                                // MAX_DRAW_DEPTH_LEVEL (1000)
                                //{CuDIRECTXW1_t10pxvZsB
                                //10pxuiK_O
                                //
                                //  GgafDx9Universe::setDrawDepthLevel(-1.0*_fDist_VpPlnFront, this);
                                //   (_fDist_VpPlnFrontOIuWFNg)
                                //
                                //A1000 iK[xB
                                //A
                                //
                                //  GgafDx9Universe::setDrawDepthLevel(-1.0*_fDist_VpPlnFront*10.0, this);
                                //
                                //1pxu 10000 iKB
                                //MAX_DRAW_DEPTH_LEVELA600iKptH[}XIB
                                //600iKiK_OlB
                                //
                                //IuWFNgBiK`lB
                                //JAAoEgiK_OlB
                                //
                                //  <o   |-+-+-+-+-+-+-+-+-+-+-+-+-+--+---+----+-----+------+------+-------+-----
                                //              ------>          ^            ------>                         ^
                                // J                   AoEguJn[x                                 [
                                //
                                //}C[WiKIrI
                                //yQlz
                                //   7975036 <DEBUG> GgafDx9Camera::GgafDx9Camera AXyNgF1.33333
                                //   7975036 <DEBUG> GgafDx9Camera::GgafDx9Camera FovX=1.39626 FovY=1.12341
                                //   7975036 <DEBUG> GgafDx9Camera::GgafDx9Camera Ju(0,0,-47.6701)
                                //   7975036 <DEBUG> GgafDx9Camera::GgafDx9Camera  [0.01 ~ 1001.07]
                                //
                                // 1001.07 10000pxs`
                                if (_specal_drawdepth < 0) { //`[xw
                
                                    float dep = -_fDist_VpPlnFront; //IuWFNg_(DIRECTX)
                                    static float roughly_dep_point1 = (P_CAM->_zf * 0.3); //r|CgP(Js 3/10 n_)( 300 DIRECTX)
                                    static float roughly_dep_point2 = (P_CAM->_zf * 0.6); //r|CgQ(Js 6/10 n_)( 600 DIRECTX)
                
                                    if (dep <= roughly_dep_point1) { //dep ` roughly_dep_point1 IuWFNg
                
                                        _now_drawdepth = GgafDx9Universe::setDrawDepthLevel(dep*0.5, this); //DirectX10.5{ADirectX2[1B20pxu
                                        // MAX_DRAW_DEPTH_LEVEL  0 ` (int)roughly_dep_point1 RR
                                        // L 1001.07 * 0.3 = 300 ADIRECTX 0`300  300*0.5 = 150 
                                        // MAX_DRAW_DEPTH_LEVEL = 0 ` 150 
                                    } else if (dep <= roughly_dep_point2) {
                                        //dep  roughly_dep_point1(300 DIRECTX) ` roughly_dep_point2(600 DIRECTX) IuWFNg
                                        int offset_DRAW_DEPTH_LEVEL = roughly_dep_point1*0.5; //iKxItZbg = 150
                
                                        _now_drawdepth = GgafDx9Universe::setDrawDepthLevel(offset_DRAW_DEPTH_LEVEL + ((dep - roughly_dep_point1) * 0.2), this);  //DirectX10.2{BDirectX5[1B50pxuiK_
                                        // (dep - roughly_dep_point1) * 0.2  dep  roughly_dep_point2 
                                        // (600 - 300) * 0.2 =  60ADIRECTX 300`600  MAX_DRAW_DEPTH_LEVEL  150`210 
                                    } else {
                                        //dep  roughly_dep_point2(600) ` IuWFNg
                                        // offset_DRAW_DEPTH_LEVEL + (dep - roughly_dep_point1) * 0.2)  dep  roughly_dep_point2lItZbg
                                        int offset_DRAW_DEPTH_LEVEL = (roughly_dep_point1*0.5) + ((roughly_dep_point2 - roughly_dep_point1) * 0.2);
                
                                        _now_drawdepth = GgafDx9Universe::setDrawDepthLevel(offset_DRAW_DEPTH_LEVEL  + ((dep - roughly_dep_point2) * 0.01), this); //0.01{BDirectX100[1B1000pxuiK_
                                    }
                //                    if (GgafDx9Input::isBeingPressedKey(DIK_I)) {
                //                        _TRACE_("setDep ["<<_now_drawdepth<<"]:dep="<<dep<<" roughly_dep_point1="<<roughly_dep_point1<<" roughly_dep_point2="<<roughly_dep_point2<<" name="<<this->getName());
                //                    }
                                } else {
                                    //`[xwL
                                    if (GgafDx9Universe::_apAlphaActorList_DrawDepthLevel[_specal_drawdepth] == NULL) {
                                        //prm_draw_depth_levelAN^[
                                        this->_pNext_TheSameDrawDepthLevel = NULL;
                                        GgafDx9Universe:: _apAlphaActorList_DrawDepthLevel[_specal_drawdepth] = this;
                                    } else {
                                        //O
                                        GgafDx9DrawableActor* pActorTmp = GgafDx9Universe::_apAlphaActorList_DrawDepthLevel[_specal_drawdepth];
                                        this->_pNext_TheSameDrawDepthLevel = pActorTmp;
                                        GgafDx9Universe::_apAlphaActorList_DrawDepthLevel[_specal_drawdepth] = this;
                                    }
                                    _now_drawdepth = _specal_drawdepth;
                //                    if (GgafDx9Input::isBeingPressedKey(DIK_I)) {
                //                        _TRACE_("_specal_drawdepth ["<<_now_drawdepth<<"]: name="<<this->getName());
                //                    }
                                }
                
                            }
                        }
                    }
                
                    //eNjbN`FbN
                    if (_is_temp_technique) {
                        if (_frame_temp_technique <= _frame_of_behaving) {
                            //eNjbNB
                            _hash_technique = _hash_technique_temp;
                            strcpy(_technique, _technique_temp);
                            _is_temp_technique = false;
                            //_BzB_technique_temp = "";
                            _hash_technique_temp = 0;
                        }
                    }
                
                }
                
                
                #ifdef MY_DEBUG
                
                void GgafDx9DrawableActor::processAfterDraw() {
                    //\
                    if (GgafDx9God::_d3dfillmode == D3DFILL_WIREFRAME) {
                        GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
                        drawHitArea();
                        GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_FILLMODE, GgafDx9God::_d3dfillmode);
                    }
                }
                
                #else
                
                void GgafDx9DrawableActor::processAfterDraw() {}
                
                #endif
                
                
                
                void GgafDx9DrawableActor::setMaterialColor(float r, float g, float b) {
                    for (DWORD i = 0; i < _pGgafDx9Model->_dwNumMaterials; i++) {
                        _paD3DMaterial9[i].Ambient.r = r;
                        _paD3DMaterial9[i].Diffuse.r = r;
                        _paD3DMaterial9[i].Ambient.g = g;
                        _paD3DMaterial9[i].Diffuse.g = g;
                        _paD3DMaterial9[i].Ambient.b = b;
                        _paD3DMaterial9[i].Diffuse.b = b;
                    }
                }
                
                void GgafDx9DrawableActor::resetMaterialColor() {
                    for (DWORD i = 0; i < _pGgafDx9Model->_dwNumMaterials; i++) {
                        _paD3DMaterial9[i].Ambient.r = _pGgafDx9Model->_paD3DMaterial9_default[i].Ambient.r;
                        _paD3DMaterial9[i].Diffuse.r = _pGgafDx9Model->_paD3DMaterial9_default[i].Diffuse.r;
                        _paD3DMaterial9[i].Ambient.g = _pGgafDx9Model->_paD3DMaterial9_default[i].Ambient.g;
                        _paD3DMaterial9[i].Diffuse.g = _pGgafDx9Model->_paD3DMaterial9_default[i].Diffuse.g;
                        _paD3DMaterial9[i].Ambient.b = _pGgafDx9Model->_paD3DMaterial9_default[i].Ambient.b;
                        _paD3DMaterial9[i].Diffuse.b = _pGgafDx9Model->_paD3DMaterial9_default[i].Diffuse.b;
                    }
                }
                
                
        4679 -> GgafDx9DrawableActor::~GgafDx9DrawableActor() {
                    DELETEARR_IMPOSSIBLE_NULL(_technique);
                    DELETEARR_IMPOSSIBLE_NULL(_technique_temp);
                    DELETEARR_IMPOSSIBLE_NULL(_paD3DMaterial9);
                    _pGgafDx9EffectCon->close();
                    _pGgafDx9ModelCon->close();
                }


Top 10 Lines:

     Line      Count

      292       4679
       54       4678

Execution Summary:

        4   Executable lines in this file
        3   Lines executed
    75.00   Percent of the file executed

     9357   Total number of line executions
  2339.25   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/actor/GgafDx9GeometricActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                
        4696 -> GgafDx9GeometricActor::GgafDx9GeometricActor(const char* prm_name,
                                                             GgafDx9Checker* prm_pChecker) : GgafDx9BaseActor(prm_name) {
                    _obj_class |= Obj_GgafDx9GeometricActor;
                    _class_name = "GgafDx9GeometricActor";
                    _isTransformed = false;
                    _X = _Y = _Z = 0;
                    _RX = _RY = _RZ = 0;
                    _SX = _SY = _SZ = LEN_UNIT;
                    _x = _y = 0.0f;
                    _z = 0.00000001f; //O
                
                    _fBoundingSphereRadius = 0;
                    _fRate_BoundingSphereRadius = 1.0f;
                    _pChecker = prm_pChecker;
                    _pKuroko = NEW GgafDx9Kuroko(this);
                    _pSeTransmitter = NEW GgafDx9SeTransmitter(this);
                
                    _offscreenkind = -1;
                    _pFunc_calcRotMvWorldMatrix = NULL;
                    _pActor_Base = NULL;
                
                
                    _X_local  = 0;
                    _Y_local  = 0;
                    _Z_local  = 0;
                    _RX_local = 0;
                    _RY_local = 0;
                    _RZ_local = 0;
                    _X_final  = 0;
                    _Y_final  = 0;
                    _Z_final  = 0;
                    _RX_final = 0;
                    _RY_final = 0;
                    _RZ_final = 0;
                
                
                    _X_offset  = 0;
                    _Y_offset  = 0;
                    _Z_offset  = 0;
                    _RX_offset = 0;
                    _RY_offset = 0;
                    _RZ_offset = 0;
                    _is_local = false;
                    _wasCalc_matInvWorldRotMv = false;
                }
                
                
                void GgafDx9GeometricActor::processSettlementBehavior() {
                    _wasCalc_matInvWorldRotMv = false;
                
                    if (_pActor_Base) {
                        //y[JWU
                        changeGeoLocal();
                    }
                
                    //DirectXPWiWorldsgpj
                    _fX = (FLOAT)(1.0f * _X / LEN_UNIT / PX_UNIT);
                    _fY = (FLOAT)(1.0f * _Y / LEN_UNIT / PX_UNIT);
                    _fZ = (FLOAT)(1.0f * _Z / LEN_UNIT / PX_UNIT);
                    //Worldsi_matWorldjXV
                    if (_pFunc_calcRotMvWorldMatrix) {
                        (*_pFunc_calcRotMvWorldMatrix)(this, _matWorldRotMv);
                        //XP[l
                        if (_SX != LEN_UNIT || _SY != LEN_UNIT || _SZ != LEN_UNIT) {
                           static float fRateScale = 1.0f * LEN_UNIT;
                           float Sx = _SX / fRateScale;
                           float Sy = _SY / fRateScale;
                           float Sz = _SZ / fRateScale;
                
                           _matWorld._11 = Sx * _matWorldRotMv._11;
                           _matWorld._12 = Sx * _matWorldRotMv._12;
                           _matWorld._13 = Sx * _matWorldRotMv._13;
                           _matWorld._14 = _matWorldRotMv._14;
                
                           _matWorld._21 = Sy * _matWorldRotMv._21;
                           _matWorld._22 = Sy * _matWorldRotMv._22;
                           _matWorld._23 = Sy * _matWorldRotMv._23;
                           _matWorld._24 = _matWorldRotMv._24;
                
                           _matWorld._31 = Sz * _matWorldRotMv._31;
                           _matWorld._32 = Sz * _matWorldRotMv._32;
                           _matWorld._33 = Sz * _matWorldRotMv._33;
                           _matWorld._34 = _matWorldRotMv._34;
                
                           _matWorld._41 = _matWorldRotMv._41;
                           _matWorld._42 = _matWorldRotMv._42;
                           _matWorld._43 = _matWorldRotMv._43;
                           _matWorld._44 = _matWorldRotMv._44;
                        } else {
                           _matWorld = _matWorldRotMv;
                        }
                    }
                
                
                    if (_pActor_Base) {
                        //W
                        D3DXMatrixMultiply(&_matWorld, &_matWorld, &(_pActor_Base->_matWorldRotMv)); //
                        D3DXMatrixMultiply(&_matWorldRotMv, &_matWorldRotMv, &(_pActor_Base->_matWorldRotMv)); //
                        changeGeoFinal();
                        //[hssoIIW
                        _X = _matWorld._41*PX_UNIT*LEN_UNIT;
                        _Y = _matWorld._42*PX_UNIT*LEN_UNIT;
                        _Z = _matWorld._43*PX_UNIT*LEN_UNIT;
                        _fX = _matWorld._41;
                        _fY = _matWorld._42;
                        _fZ = _matWorld._43;
                
                        //TODO:W_RX, _RY, _RZ 
                
                    }
                
                
                    //Wo^
                    if (_pChecker) {
                        _pChecker->_blown_sgn_vX = 0;
                        _pChecker->_blown_sgn_vY = 0;
                        _pChecker->_blown_sgn_vZ = 0;
                        if (_can_hit_out_of_view == false && isOutOfView()) {
                            //Oo^
                        } else {
                            _pChecker->updateHitArea();
                        }
                    }
                
                    //o[XV
                    if (_isTransformed == false) {
                        GgafDx9Camera* pCam = P_CAM;
                        //DirectXPWiWorldsgpj
                //        _fX = (FLOAT)(1.0f * _X / LEN_UNIT / PX_UNIT);
                //        _fY = (FLOAT)(1.0f * _Y / LEN_UNIT / PX_UNIT);
                //        _fZ = (FLOAT)(1.0f * _Z / LEN_UNIT / PX_UNIT);
                        //
                        _fDist_VpPlnTop    = pCam->_plnTop.a*_fX +
                                             pCam->_plnTop.b*_fY +
                                             pCam->_plnTop.c*_fZ +
                                             pCam->_plnTop.d;
                
                        _fDist_VpPlnBottom = pCam->_plnBottom.a*_fX +
                                             pCam->_plnBottom.b*_fY +
                                             pCam->_plnBottom.c*_fZ +
                                             pCam->_plnBottom.d;
                
                        _fDist_VpPlnLeft   = pCam->_plnLeft.a*_fX +
                                             pCam->_plnLeft.b*_fY +
                                             pCam->_plnLeft.c*_fZ +
                                             pCam->_plnLeft.d;
                
                        _fDist_VpPlnRight  = pCam->_plnRight.a*_fX +
                                             pCam->_plnRight.b*_fY +
                                             pCam->_plnRight.c*_fZ +
                                             pCam->_plnRight.d;
                
                        _fDist_VpPlnFront  = pCam->_plnFront.a*_fX +
                                             pCam->_plnFront.b*_fY +
                                             pCam->_plnFront.c*_fZ +
                                             pCam->_plnFront.d;
                
                        _fDist_VpPlnBack   = pCam->_plnBack.a*_fX +
                                             pCam->_plnBack.b*_fY +
                                             pCam->_plnBack.c*_fZ +
                                             pCam->_plnBack.d;
                        _offscreenkind = -1;
                    }
                
                }
                
                
                GgafGroupActor* GgafDx9GeometricActor::addSubBone(actorkind prm_kind,
                                                                  GgafDx9GeometricActor* prm_pGeoActor,
                                                                  int prm_X_init_local,
                                                                  int prm_Y_init_local,
                                                                  int prm_Z_init_local,
                                                                  int prm_RX_init_local,
                                                                  int prm_RZ_init_local,
                                                                  int prm_RY_init_local) {
                    GgafGroupActor* pGroupActor = addSubGroup(prm_kind, prm_pGeoActor);
                    prm_pGeoActor->_pActor_Base = this;
                    prm_pGeoActor->changeGeoLocal();
                    prm_pGeoActor->_X = prm_X_init_local;
                    prm_pGeoActor->_Y = prm_Y_init_local;
                    prm_pGeoActor->_Z = prm_Z_init_local;
                    prm_pGeoActor->_pKuroko->_angFace[AXIS_X]  = prm_RX_init_local;
                    prm_pGeoActor->_pKuroko->_angFace[AXIS_Z]  = prm_RZ_init_local;
                    prm_pGeoActor->_pKuroko->_angFace[AXIS_Y]  = prm_RY_init_local;
                    prm_pGeoActor->_pKuroko->_angRzMv = prm_RZ_init_local;
                    prm_pGeoActor->_pKuroko->_angRyMv = prm_RY_init_local;
                    prm_pGeoActor->_RX = prm_RX_init_local;
                    prm_pGeoActor->_RZ = prm_RZ_init_local;
                    prm_pGeoActor->_RY = prm_RY_init_local;
                    prm_pGeoActor->changeGeoFinal();
                    return pGroupActor;
                }
                GgafGroupActor* GgafDx9GeometricActor::addSubBone(GgafDx9GeometricActor* prm_pGeoActor,
                                                                  int prm_X_init_local,
                                                                  int prm_Y_init_local,
                                                                  int prm_Z_init_local,
                                                                  int prm_RX_init_local,
                                                                  int prm_RZ_init_local,
                                                                  int prm_RY_init_local) {
                    return addSubBone(prm_pGeoActor->_pStatus->get(STAT_DEFAULT_ACTOR_KIND),
                                      prm_pGeoActor,
                                      prm_X_init_local,
                                      prm_Y_init_local,
                                      prm_Z_init_local,
                                      prm_RX_init_local,
                                      prm_RZ_init_local,
                                      prm_RY_init_local);
                }
                
                bool GgafDx9GeometricActor::processHitChkLogic(GgafActor* prm_pOtherActor) {
                    if (_obj_class & Obj_GgafDx9GeometricActor) {
                        if (_pChecker) {
                            return _pChecker->isHit(((GgafDx9GeometricActor*)prm_pOtherActor)->_pChecker);
                        }
                    }
                    return false;
                
                //        GgafDx9GeometricActor* pOtherActor = dynamic_cast<GgafDx9GeometricActor*> (prm_pOtherActor);
                //        if (pOtherActor != NULL && pOtherActor->_pChecker) {
                //            return _pChecker->isHit(pOtherActor->_pChecker);
                //        } else {
                //            _TRACE_("GgafDx9GeometricActor::processHitChkLogic prm_pOtherActor("<<(prm_pOtherActor->getName())<<") is not GgafDx9GeometricActor")
                //            return false;
                //        }
                        //{dynamic_castpISBAxUPidynamic_castjA
                        //GgafDx9GeometricActorLXgBB
                        //WAN^[_can_hit_flg YfalseAGgafDx9GeometricActor
                        //LXg|C^nYB
                }
                
                
                int GgafDx9GeometricActor::isOutOfView() {
                    //_TRACE_("name="<<getName()<<" _fBoundingSphereRadius="<<_fBoundingSphereRadius);
                    float bound = _fBoundingSphereRadius * _fRate_BoundingSphereRadius;
                    if (_offscreenkind == -1) {
                        if (_fDist_VpPlnTop <= bound) {
                            if (_fDist_VpPlnBottom <= bound) {
                                if (_fDist_VpPlnLeft <= bound) {
                                    if (_fDist_VpPlnRight <= bound) {
                                        if (_fDist_VpPlnFront <= bound) {
                                            if (_fDist_VpPlnBack <= bound) {
                                                //Viewport
                                                _offscreenkind = 0;
                                            } else {
                                                //O
                                                _offscreenkind = 6;
                                            }
                                        } else {
                                            //OOO
                                            _offscreenkind = 5;
                                        }
                                    } else {
                                        //EEO
                                        _offscreenkind = 4;
                                    }
                                } else {
                                    //O
                                    _offscreenkind = 3;
                                }
                            } else {
                                //O
                                _offscreenkind = 2;
                            }
                        } else {
                            //O
                            _offscreenkind = 1;
                        }
                    }
                    return _offscreenkind;
                }
                
                bool GgafDx9GeometricActor::isOutOfUniverse() {
                    if (GgafDx9Universe::_X_goneLeft < _X) {
                        if (_X < GgafDx9Universe::_X_goneRight) {
                            if (GgafDx9Universe::_Y_goneBottom < _Y) {
                                if (_Y < GgafDx9Universe::_Y_goneTop) {
                                    if (GgafDx9Universe::_Z_goneNear < _Z) {
                                        if (_Z < GgafDx9Universe::_Z_goneFar) {
                                            return false;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return true;
                }
                
                void GgafDx9GeometricActor::locateAs(GgafDx9GeometricActor* prm_pActor) {
                    _X = prm_pActor->_X;
                    _Y = prm_pActor->_Y;
                    _Z = prm_pActor->_Z;
                }
                
                void GgafDx9GeometricActor::locateAs(GgafDx9GeoElem* prm_pGgafDx9GeoElem) {
                    _X = prm_pGgafDx9GeoElem->_X;
                    _Y = prm_pGgafDx9GeoElem->_Y;
                    _Z = prm_pGgafDx9GeoElem->_Z;
                }
                
                void GgafDx9GeometricActor::rotateWith(GgafDx9GeometricActor* prm_pActor) {
                    _RX = prm_pActor->_RX;
                    _RY = prm_pActor->_RY;
                    _RZ = prm_pActor->_RZ;
                }
                
                
        4697 -> GgafDx9GeometricActor::~GgafDx9GeometricActor() {
                    DELETE_IMPOSSIBLE_NULL(_pKuroko);
                    DELETE_IMPOSSIBLE_NULL(_pSeTransmitter);
                }
                
                
                void GgafDx9GeometricActor::dump() {
                    _TRACE_("\t\t\t\t\t\t\t\t"<<_class_name<<"("<<this<<")["<<getName()<<"]("<<_X<<","<<_Y<<","<<_Z<<")@"<<_frame_of_behaving_since_onActive<<
                                                                                                                          "/"<<
                                                                                                                          _frame_of_behaving<<
                                                                                                                          "/"<<
                                                                                                                          _frame_of_life<<
                                                                                                                          ","<<
                                                                                                                          _was_initialize_flg<<
                                                                                                                          ","<<
                                                                                                                          _can_live_flg<<
                                                                                                                          _is_active_flg<<
                                                                                                                          ","<<
                                                                                                                          _will_activate_after_flg<<
                                                                                                                          "("<<_frame_of_life_when_activation<<")"<<
                                                                                                                          _on_change_to_active_flg<<
                                                                                                                          ","<<
                                                                                                                          _will_inactivate_after_flg<<
                                                                                                                          "("<<_frame_of_life_when_inactivation<<")"<<
                                                                                                                          _on_change_to_inactive_flg<<
                                                                                                                          ","<<
                                                                                                                          _will_end_after_flg<<
                                                                                                                          "("<<_frame_of_life_when_end<<")"<<
                                                                                                                          ","<<
                                                                                                                          _was_paused_flg<<
                                                                                                                          _was_paused_flg_in_next_frame<<
                                                                                                                          _will_mv_first_in_next_frame_flg<<
                                                                                                                          _will_mv_last_in_next_frame_flg
                                                                                                                          );
                
                    GgafActor* pActor_tmp = _pSubFirst;
                    if (_pSubFirst) {
                        while (true) {
                            pActor_tmp->dump("\t\t\t\t\t\t\t\tb");
                            if (pActor_tmp->getNext()) {
                                pActor_tmp = pActor_tmp->getNext();
                            } else {
                                _TRACE_("yxz"<<_class_name<<"("<<this<<")["<<getName()<<"]nextNULL");
                                break;
                            }
                            if (pActor_tmp->isFirst()) {
                                _TRACE_("\t\t\t\t\t\t\t\t");
                                break;
                            }
                        }
                    }
                }
                
                void GgafDx9GeometricActor::dump(string prm_parent) {
                    _TRACE_(prm_parent << _class_name<<"("<<this<<")["<<getName()<<"]("<<_X<<","<<_Y<<","<<_Z<<")@"<<_frame_of_behaving_since_onActive<<
                                                                                                                     "/"<<
                                                                                                                     _frame_of_behaving<<
                                                                                                                     "/"<<
                                                                                                                     _frame_of_life<<
                                                                                                                     ","<<
                                                                                                                     _was_initialize_flg<<
                                                                                                                     ","<<
                                                                                                                     _can_live_flg<<
                                                                                                                     _is_active_flg<<
                                                                                                                     ","<<
                                                                                                                     _will_activate_after_flg<<
                                                                                                                     "("<<_frame_of_life_when_activation<<")"<<
                                                                                                                     _on_change_to_active_flg<<
                                                                                                                     ","<<
                                                                                                                     _will_inactivate_after_flg<<
                                                                                                                     "("<<_frame_of_life_when_inactivation<<")"<<
                                                                                                                     _on_change_to_inactive_flg<<
                                                                                                                     ","<<
                                                                                                                     _will_end_after_flg<<
                                                                                                                     "("<<_frame_of_life_when_end<<")"<<
                                                                                                                     ","<<
                                                                                                                     _was_paused_flg<<
                                                                                                                     _was_paused_flg_in_next_frame<<
                                                                                                                     _will_mv_first_in_next_frame_flg<<
                                                                                                                     _will_mv_last_in_next_frame_flg
                                                                                                                     );
                    GgafActor* pActor_tmp = _pSubFirst;
                    if (_pSubFirst) {
                        while (true) {
                            pActor_tmp->dump(prm_parent + "b");
                            if (pActor_tmp->getNext()) {
                                pActor_tmp = pActor_tmp->getNext();
                            } else {
                                _TRACE_("yxz"<<_class_name<<"("<<this<<")["<<getName()<<"]nextNULL");
                                break;
                            }
                            if (pActor_tmp->isFirst()) {
                                _TRACE_(prm_parent+"");
                                break;
                            }
                        }
                    }
                }
                


Top 10 Lines:

     Line      Count

      314       4697
        7       4696

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

     9393   Total number of line executions
  3131.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/scene/supporter/GgafDx9BgmPerformer.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                int GgafDx9BgmPerformer::_active_bgm_bpm = 120;
                
                
          16 -> GgafDx9BgmPerformer::GgafDx9BgmPerformer() : GgafObject() {
                
                    _bgm_num = 0;
                    _papBgmCon = NULL;
                    _pa_is_fade = NULL;
                    _pa_now_volume = NULL;
                    _pa_target_volume = NULL;
                    _pa_inc_volume = NULL;
                    _pa_is_fadeout_stop = NULL;
                }
                void GgafDx9BgmPerformer::useBgm(int prm_bgm_num) {
                    _bgm_num = prm_bgm_num;
                    _papBgmCon = NEW GgafDx9BgmConnection*[_bgm_num];
                    _pa_is_fade = NEW bool[_bgm_num];
                    _pa_is_fadeout_stop = NEW bool[_bgm_num];
                    _pa_now_volume = NEW double[_bgm_num];
                    _pa_target_volume = NEW double[_bgm_num];
                    _pa_inc_volume = NEW double[_bgm_num];
                    for (int i = 0; i < _bgm_num; i++) {
                        _papBgmCon[i] = NULL;
                        _pa_is_fade[i] = false;
                        _pa_is_fadeout_stop[i] = true;
                        _pa_now_volume[i] = GGAF_MAX_VOLUME;
                        _pa_target_volume[i] = GGAF_MAX_VOLUME;
                        _pa_inc_volume[i] = 0;
                    }
                }
                void GgafDx9BgmPerformer::fade(int prm_id, frame prm_frame, int prm_target_volume) {
                    _pa_is_fade[prm_id] = true;
                    _pa_target_volume[prm_id] = (double)prm_target_volume;
                    _pa_inc_volume[prm_id] = (prm_target_volume - _pa_now_volume[prm_id]) / (double)prm_frame;
                }
                
                void GgafDx9BgmPerformer::set(int prm_id, const char* prm_bgm_name) {
                    if (prm_id < 0 || prm_id >= _bgm_num) {
                        throwGgafCriticalException("GgafDx9BgmPerformer::seteBGM() IDOB0~"<<(_bgm_num-1)<<"Bprm_id="<<prm_id);
                    }
                    _papBgmCon[prm_id] = (GgafDx9BgmConnection*)GgafDx9Sound::_pBgmManager->getConnection(prm_bgm_name);
                }
                
                void GgafDx9BgmPerformer::play(int prm_id, int prm_volume, bool prm_is_loop) {
                    if (prm_id < 0 || prm_id >= _bgm_num) {
                        throwGgafCriticalException("GgafDx9BgmPerformer::play() IDOB0~"<<(_bgm_num-1)<<"Bprm_id="<<prm_id);
                    }
                    _pa_now_volume[prm_id] = (double)prm_volume;
                    _pa_is_fade[prm_id] = false;
                    _papBgmCon[prm_id]->refer()->play(prm_volume, 0.0f, prm_is_loop);
                    GgafDx9BgmPerformer::_active_bgm_bpm = _papBgmCon[prm_id]->refer()->_bpm; //VBGMBPMY
                }
                
                void GgafDx9BgmPerformer::stop(int prm_id) {
                    if (prm_id < 0 || prm_id >= _bgm_num) {
                        throwGgafCriticalException("GgafDx9BgmPerformer::stop() IDOB0~"<<(_bgm_num-1)<<"Bprm_id="<<prm_id);
                    }
                    _papBgmCon[prm_id]->refer()->stop();
                }
                
                void GgafDx9BgmPerformer::pause(int prm_id) {
                    if (prm_id < 0 || prm_id >= _bgm_num) {
                        throwGgafCriticalException("GgafDx9BgmPerformer::pause() IDOB0~"<<(_bgm_num-1)<<"Bprm_id="<<prm_id);
                    }
                    _papBgmCon[prm_id]->refer()->pause();
                }
                
                void GgafDx9BgmPerformer::behave() {
                    for (int id = 0; id < _bgm_num; id++) {
                
                        if (_pa_is_fade[id]) {
                            _pa_now_volume[id] += _pa_inc_volume[id];
                            _papBgmCon[id]->refer()->setVolume(_pa_now_volume[id]);
                            if (_pa_inc_volume[id] > 0 && _pa_now_volume[id] >= _pa_target_volume[id]) {
                                //
                                setVolume(id, (int)_pa_target_volume[id]);
                                _pa_is_fade[id] = false;
                            } else if (_pa_inc_volume[id] < 0 && _pa_now_volume[id] <= _pa_target_volume[id]) {
                                //
                                setVolume(id, (int)_pa_target_volume[id]);
                                _pa_is_fade[id] = false;
                                if (_pa_is_fadeout_stop[id]) {
                                    stop(id);
                                }
                            }
                        }
                
                    }
                
                }
                
                void GgafDx9BgmPerformer::setVolume(int prm_id, int prm_volume) {
                    _pa_now_volume[prm_id] = (double)prm_volume;
                    _papBgmCon[prm_id]->refer()->setVolume(prm_volume);
                }
          32 -> GgafDx9BgmPerformer::~GgafDx9BgmPerformer() {
                    if (_papBgmCon) {
                        for (int i = 0; i < _bgm_num; i++) {
                            if (_papBgmCon[i]) {
                                _papBgmCon[i]->close();
                            }
                
                        }
                    }
                    DELETEARR_POSSIBLE_NULL(_papBgmCon);
                    DELETEARR_POSSIBLE_NULL(_pa_is_fade);
                    DELETEARR_POSSIBLE_NULL(_pa_is_fadeout_stop);
                    DELETEARR_POSSIBLE_NULL(_pa_now_volume);
                    DELETEARR_POSSIBLE_NULL(_pa_target_volume);
                    DELETEARR_POSSIBLE_NULL(_pa_inc_volume);
                }


Top 10 Lines:

     Line      Count

      101         32
        9         16

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       48   Total number of line executions
    16.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/scene/GgafDx9Scene.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
          16 -> GgafDx9Scene::GgafDx9Scene(const char* prm_name) : GgafMainScene(prm_name) {
                    _obj_class |= Obj_GgafDx9Scene;
                    _class_name = "GgafDx9Scene";
                    _pAlphaCurtain = NEW GgafDx9AlphaCurtain(this);
                    _pBgmPerformer = NEW GgafDx9BgmPerformer();
                }
                
                void GgafDx9Scene::processSettlementBehavior() {
                    if (_is_active_flg && !_was_paused_flg && _can_live_flg) {
                        _pAlphaCurtain->behave();
                        _pBgmPerformer->behave();
                    }
                }
                
                void GgafDx9Scene::fadeinSceneTree(int prm_frame_fade) {
                    if (_is_active_flg && !_was_paused_flg && _can_live_flg) {
                        if (prm_frame_fade == 0) {
                            _pAlphaCurtain->open(1.0);
                        } else {
                            _pAlphaCurtain->open(1.0 / prm_frame_fade);
                        }
                        if (getSubFirst()) {
                #ifdef MY_DEBUG
                            if (getSubFirst()->_obj_class & Obj_GgafDx9Scene) {
                                //OK
                            } else {
                                throwGgafCriticalException("GgafDx9Scene::fadeinSceneTree() TuV[AGgafDx9Scene sBthis="<<getName()<<" getSubFirst()="<<(getSubFirst()->getName()) );
                            }
                #endif
                            GgafDx9Scene* pScene = (GgafDx9Scene*)getSubFirst();
                            while(true) {
                                pScene->fadeinSceneTree(prm_frame_fade);
                                if (pScene->isLast()) {
                                    break;
                                } else {
                #ifdef MY_DEBUG
                                    if (pScene->getNext()->_obj_class & Obj_GgafDx9Scene) {
                                        //OK
                                    } else {
                                        throwGgafCriticalException("GgafDx9Scene::fadeinSceneTree() pScene["<<(pScene->getName())<<"->getNext()["<<(pScene->getNext()->getName())<<"]AGgafDx9Scene sBthis="<<getName());
                                    }
                #endif
                                    pScene = (GgafDx9Scene*)(pScene->getNext());
                                }
                            }
                        }
                    }
                }
                
                void GgafDx9Scene::fadeinScene(int prm_frame_fade) {
                    if (_is_active_flg && !_was_paused_flg && _can_live_flg) {
                        if (prm_frame_fade == 0) {
                            _pAlphaCurtain->open(1.0);
                        } else {
                            _pAlphaCurtain->open(1.0 / prm_frame_fade);
                        }
                    }
                }
                
                
                
                
                void GgafDx9Scene::fadeoutSceneTree(int prm_frame_fade) {
                    if (_is_active_flg && !_was_paused_flg && _can_live_flg) {
                        if (prm_frame_fade == 0) {
                            _pAlphaCurtain->close(1.0);
                        } else {
                            _pAlphaCurtain->close(1.0 / prm_frame_fade);
                        }
                        if (getSubFirst()) {
                #ifdef MY_DEBUG
                            if (getSubFirst()->_obj_class & Obj_GgafDx9Scene) {
                                //OK
                            } else {
                                _TRACE_("GgafDx9Scene::fadeoutSceneTree() TuV[AGgafDx9Scene sBthis="<<getName()<<" getSubFirst()="<<(getSubFirst()->getName())<<" class="<<(getSubFirst()->_obj_class));
                                throwGgafCriticalException("GgafDx9Scene::fadeoutSceneTree() TuV[AGgafDx9Scene sBthis="<<getName()<<" getSubFirst()="<<(getSubFirst()->getName()) );
                            }
                #endif
                            GgafDx9Scene* pScene = (GgafDx9Scene*)getSubFirst();
                            while(true) {
                                pScene->fadeoutSceneTree(prm_frame_fade);
                                if (pScene->isLast()) {
                                    break;
                                } else {
                #ifdef MY_DEBUG
                                    if (pScene->getNext()->_obj_class & Obj_GgafDx9Scene) {
                                        //OK
                                    } else {
                                        throwGgafCriticalException("GgafDx9Scene::fadeinSceneTree() pScene["<<(pScene->getName())<<"->getNext()["<<(pScene->getNext()->getName())<<"]AGgafDx9Scene sBthis="<<getName());
                                    }
                #endif
                                    pScene = (GgafDx9Scene*)(pScene->getNext());
                                }
                            }
                        }
                    }
                }
                
                void GgafDx9Scene::fadeoutScene(int prm_frame_fade){
                    if (_is_active_flg && !_was_paused_flg && _can_live_flg) {
                        if (prm_frame_fade == 0) {
                            _pAlphaCurtain->close(1.0);
                        } else {
                            _pAlphaCurtain->close(1.0 / prm_frame_fade);
                        }
                    }
                }
                
                
                void GgafDx9Scene::unblindScene() {
                    _pAlphaCurtain->open();
                }
                void GgafDx9Scene::unblindSceneTree() {
                    _pAlphaCurtain->open();
                    if (getSubFirst()) {
                #ifdef MY_DEBUG
                        if (getSubFirst()->_obj_class & Obj_GgafDx9Scene) {
                            //OK
                        } else {
                            _TRACE_("GgafDx9Scene::unblindSceneTree() TuV[AGgafDx9Scene sBthis="<<getName()<<" getSubFirst()="<<(getSubFirst()->getName())<<" class="<<(getSubFirst()->_obj_class));
                            throwGgafCriticalException("GgafDx9Scene::fadeoutSceneTree() TuV[AGgafDx9Scene sBthis="<<getName()<<" getSubFirst()="<<(getSubFirst()->getName()) );
                        }
                #endif
                        GgafDx9Scene* pScene = (GgafDx9Scene*)getSubFirst();
                        while(true) {
                            pScene->unblindSceneTree();
                            if (pScene->isLast()) {
                                break;
                            } else {
                #ifdef MY_DEBUG
                                if (pScene->getNext()->_obj_class & Obj_GgafDx9Scene) {
                                    //OK
                                } else {
                                    throwGgafCriticalException("GgafDx9Scene::unblindSceneTree() pScene["<<(pScene->getName())<<"->getNext()["<<(pScene->getNext()->getName())<<"]AGgafDx9Scene sBthis="<<getName());
                                }
                #endif
                                pScene = (GgafDx9Scene*)(pScene->getNext());
                            }
                        }
                    }
                }
                void GgafDx9Scene::blindScene() {
                    _pAlphaCurtain->close();
                }
                void GgafDx9Scene::blindSceneTree() {
                    _pAlphaCurtain->close();
                    if (getSubFirst()) {
                #ifdef MY_DEBUG
                        if (getSubFirst()->_obj_class & Obj_GgafDx9Scene) {
                            //OK
                        } else {
                            _TRACE_("GgafDx9Scene::blindSceneTree() TuV[AGgafDx9Scene sBthis="<<getName()<<" getSubFirst()="<<(getSubFirst()->getName())<<" class="<<(getSubFirst()->_obj_class));
                            throwGgafCriticalException("GgafDx9Scene::fadeoutSceneTree() TuV[AGgafDx9Scene sBthis="<<getName()<<" getSubFirst()="<<(getSubFirst()->getName()) );
                        }
                #endif
                        GgafDx9Scene* pScene = (GgafDx9Scene*)getSubFirst();
                        while(true) {
                            pScene->blindSceneTree();
                            if (pScene->isLast()) {
                                break;
                            } else {
                #ifdef MY_DEBUG
                                if (pScene->getNext()->_obj_class & Obj_GgafDx9Scene) {
                                    //OK
                                } else {
                                    throwGgafCriticalException("GgafDx9Scene::blindSceneTree() pScene["<<(pScene->getName())<<"->getNext()["<<(pScene->getNext()->getName())<<"]AGgafDx9Scene sBthis="<<getName());
                                }
                #endif
                                pScene = (GgafDx9Scene*)(pScene->getNext());
                            }
                        }
                    }
                }
                
                
                
                
          16 -> GgafDx9Scene::~GgafDx9Scene() {
                    DELETE_IMPOSSIBLE_NULL(_pAlphaCurtain);
                    DELETE_IMPOSSIBLE_NULL(_pBgmPerformer);
                }


Top 10 Lines:

     Line      Count

        6         16
      183         16

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       32   Total number of line executions
    10.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/scene/GgafDx9Universe.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                GgafDx9DrawableActor* GgafDx9Universe::_apAlphaActorList_DrawDepthLevel[MAX_DRAW_DEPTH_LEVEL+1];
                GgafDx9DrawableActor* GgafDx9Universe::_pActors_DrawMaxDrawDepth = NULL;
                GgafDx9DrawableActor* GgafDx9Universe::_pActor_DrawActive = NULL;
                
                int GgafDx9Universe::_X_goneLeft   = 0;
                int GgafDx9Universe::_X_goneRight  = 0;
                int GgafDx9Universe::_Y_goneTop    = 0;
                int GgafDx9Universe::_Y_goneBottom = 0;
                int GgafDx9Universe::_Z_goneFar   = 0;
                int GgafDx9Universe::_Z_goneNear  = 0;
                
                
         240 -> GgafDx9Universe::SeArray::SeArray() {
                    _p = 0;
                    for (int i = 0; i < MAX_SE_AT_ONCE; i++) {
                        _apSe[i] = NULL;
                    }
                }
                
                void GgafDx9Universe::SeArray::add(GgafDx9Se* prm_pSe, LONG prm_volume, float prm_pan, float prm_rate_frequency) {
                    if (_p < MAX_SE_AT_ONCE) {
                        _apSe[_p] = prm_pSe;
                        _rate_frequency[_p] = prm_rate_frequency;
                        _volume[_p] = prm_volume;
                        _pan[_p] = prm_pan;
                        _p++;
                    }
                }
                
                void GgafDx9Universe::SeArray::play(int index) {
                    _apSe[index]->play(_volume[index], _pan[index], _rate_frequency[index]);
                    _apSe[index] = NULL;
                }
                
           1 -> GgafDx9Universe::GgafDx9Universe(const char* prm_name, GgafDx9Camera* prm_pCamera) : GgafUniverse(prm_name) {
                    _obj_class |= Obj_GgafDx9Universe;
                    _class_name = "GgafDx9Universe";
                    for (int i = 0; i < MAX_DRAW_DEPTH_LEVEL; i++) {
                        _apAlphaActorList_DrawDepthLevel[i] = NULL;
                    }
                    //JNEWB
                    _pCamera = prm_pCamera;
                
                
                    getLordActor()->addSubGroup(_pCamera);
                    _pActor_DrawActive = NULL;
                
                    //JB
                    _X_goneRight  = +_pCamera->_zf*PX_UNIT*LEN_UNIT;// + (abs(_pCamera->_cameraZ)*PX_UNIT*LEN_UNIT);
                    _X_goneLeft   = -_pCamera->_zf*PX_UNIT*LEN_UNIT;// - (abs(_pCamera->_cameraZ)*PX_UNIT*LEN_UNIT);
                    _Y_goneTop    = +_pCamera->_zf*PX_UNIT*LEN_UNIT;// + (abs(_pCamera->_cameraZ)*PX_UNIT*LEN_UNIT);
                    _Y_goneBottom = -_pCamera->_zf*PX_UNIT*LEN_UNIT;// - (abs(_pCamera->_cameraZ)*PX_UNIT*LEN_UNIT);
                    _Z_goneFar    = +_pCamera->_zf*PX_UNIT*LEN_UNIT;// + (abs(_pCamera->_cameraZ)*PX_UNIT*LEN_UNIT);
                    _Z_goneNear   = -_pCamera->_zf*PX_UNIT*LEN_UNIT;// - (abs(_pCamera->_cameraZ)*PX_UNIT*LEN_UNIT);
                    _TRACE_("Gone=X ("<<_X_goneLeft<<" ~ "<<_X_goneRight<<") Y("<<_Y_goneBottom<<" ~ "<<_Y_goneTop<<") Z("<<_Z_goneFar<<" ~ "<<_Z_goneNear<<")");
                
                    _pRing_pSeArray = NEW GgafLinkedListRing<SeArray>();
                    for (int i = 0; i < MAX_SE_DELAY; i++) { //GGAF_SAYONARA_DELAYxt[ASExt[g
                        _pRing_pSeArray->addLast(NEW SeArray(), true);
                    }
                    GgafRepeatSeq::create("_SE_D_", 0, 8); //YSEt[
                }
                
                void GgafDx9Universe::registSe(GgafDx9Se* prm_pSe, LONG prm_volume, float prm_pan, float prm_rate_frequency, int prm_delay ) {
                    int bpm = GgafDx9BgmPerformer::_active_bgm_bpm;
                    //Yt[vZ
                    //160*60=3600t[
                    //4^C~O 3600/_bpm
                    //8^C~O 3600/(_bpm*2) = 1800/_bpm
                    //16^C~O 3600/(_bpm*4) = 900/_bpm
                    //0t[BGMAt[fA16^C~O
                    //F = f%(900/_bpm)
                    //F = 0A f
                    //F != 0  {f/(900/_bpm) * (900/_bpm)} + (900/_bpm) 16^C~O
                    //TODO:Cx[_[GNXg[II{Vvf~BII
                
                
                
                
                    //SE^C~O 0`8t[o
                    _pRing_pSeArray->getNext(prm_delay+1+(GgafRepeatSeq::nextVal("_SE_D_")))->add(prm_pSe, prm_volume, prm_pan, prm_rate_frequency);
                    //_pRing_pSeArray->getNext(prm_delay+1)->add(prm_pSe, prm_volume, prm_pan, prm_rate_frequency);
                }
                
                void GgafDx9Universe::processSettlementBehavior() {
                
                    GgafUniverse::processSettlementBehavior();
                    //SE
                    SeArray* pSeArray = _pRing_pSeArray->next(); //iSEz
                    if (pSeArray->_p > 0) {
                        for (int p = 0; p < pSeArray->_p; p++) {
                            pSeArray->play(p);
                        }
                        pSeArray->_p = 0; //Zbg
                    }
                
                }
                
                void GgafDx9Universe::draw() {
                    GgafDx9ModelConnection* pModelCon = GgafDx9God::_pModelManager->getFirstConnection();
                    while (pModelCon) {
                        pModelCon->refer()->_pTextureBlinker->behave();
                        pModelCon = (GgafDx9ModelConnection*)(pModelCon->getNext());
                    }
                
                    //EffectManagerVew
                    GgafDx9God::_pEffectManager->setParamPerFrameAll();
                
                    //iK_Osvi[Awij`B
                    //TODO:{O`BAK
                    _pActor_DrawActive = _pActors_DrawMaxDrawDepth;
                    GgafDx9Scene* pScene;
                    while (_pActor_DrawActive) {
                        //}X^[B
                #ifdef MY_DEBUG
                            if (_pActor_DrawActive->getPlatformScene()->_obj_class & Obj_GgafDx9Scene) {
                                //OK
                            } else {
                                throwGgafCriticalException("GgafDx9Universe::draw() err1. _pActor_DrawActive["<<(_pActor_DrawActive->getName())<<"->getPlatformScene()["<<(_pActor_DrawActive->getPlatformScene()->getName())<<"]AGgafDx9Scene sBthis="<<getName());
                            }
                #endif
                        pScene = (GgafDx9Scene*)_pActor_DrawActive->getPlatformScene();
                        _pActor_DrawActive->_pGgafDx9Effect->_pID3DXEffect->SetFloat(
                                _pActor_DrawActive->_pGgafDx9Effect->_h_alpha_master, pScene->_pAlphaCurtain->_alpha
                        );
                
                        if (_pActor_DrawActive->_fAlpha < 1.0f) {
                            GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE); //vfJOOFF
                            //AAiK_OsvA\AO\B
                        }
                
                        //`
                        _pActor_DrawActive->processDraw();
                
                        if (_pActor_DrawActive->_fAlpha < 1.0f) {
                            GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);  //JOL
                        }
                        _pActor_DrawActive = _pActor_DrawActive->_pNext_TheSameDrawDepthLevel;
                    }
                    _pActors_DrawMaxDrawDepth = NULL; //Zbg
                
                    //iK_OKvIuWFNg`
                    //float tmpAlpah;
                    //int alphapoint = MAX_DRAW_DEPTH_LEVEL/4*3;
                    for (int i = MAX_DRAW_DEPTH_LEVEL; i >= 0; i--) {
                        _pActor_DrawActive = _apAlphaActorList_DrawDepthLevel[i];
                        while (_pActor_DrawActive) {
                #ifdef MY_DEBUG
                            if (_pActor_DrawActive->getPlatformScene()->_obj_class & Obj_GgafDx9Scene) {
                                //OK
                            } else {
                                throwGgafCriticalException("GgafDx9Universe::draw() err2. _pActor_DrawActive["<<(_pActor_DrawActive->getName())<<"->getPlatformScene()["<<(_pActor_DrawActive->getPlatformScene()->getName())<<"]AGgafDx9Scene sBthis="<<getName());
                            }
                #endif
                            //eV[J[eB
                            pScene = (GgafDx9Scene*)_pActor_DrawActive->getPlatformScene();
                            _pActor_DrawActive->_pGgafDx9Effect->_pID3DXEffect->SetFloat(
                                    _pActor_DrawActive->_pGgafDx9Effect->_h_alpha_master, pScene->_pAlphaCurtain->_alpha);
                
                            //vfJOOFF
                            if (_pActor_DrawActive->_fAlpha < 1.0f) {
                                GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
                            }
                            //Zobt@l
                            if (!_pActor_DrawActive->_zenable) {
                                GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
                            }
                            // Zobt@s
                            if (!_pActor_DrawActive->_zwriteenable) {
                                GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_ZWRITEENABLE, FALSE );
                            }
                
                            _pActor_DrawActive->processDraw();
                
                            //JOL
                            if (_pActor_DrawActive->_fAlpha < 1.0f) {
                                GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
                            }
                            //Zobt@l
                            if (!_pActor_DrawActive->_zenable) {
                                GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
                            }
                            // Zobt@s
                            if (!_pActor_DrawActive->_zwriteenable) {
                                GgafDx9God::_pID3DDevice9->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
                            }
                
                
                
                            _pActor_DrawActive = _pActor_DrawActive->_pNext_TheSameDrawDepthLevel;
                        }
                        _apAlphaActorList_DrawDepthLevel[i] = NULL; //Zbg
                    }
                
                    //EndPass
                    HRESULT hr;
                    if (GgafDx9EffectManager::_pEffect_Active) {
                
                        TRACE4("EndPass("<<GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect<<"): /_pEffect_Active="<<GgafDx9EffectManager::_pEffect_Active->_effect_name<<"("<<GgafDx9EffectManager::_pEffect_Active<<")");
                        hr = GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect->EndPass();
                        checkDxException(hr, D3D_OK, "GgafDx9Universe::processDraw() EndPass() sB");
                        hr = GgafDx9EffectManager::_pEffect_Active->_pID3DXEffect->End();
                        checkDxException(hr, D3D_OK, "GgafDx9Universe::processDraw() End() sB");
                #ifdef MY_DEBUG
                        if (GgafDx9EffectManager::_pEffect_Active->_begin == false) {
                            throwGgafCriticalException("begin  "<<(GgafDx9EffectManager::_pEffect_Active==NULL?"NULL":GgafDx9EffectManager::_pEffect_Active->_effect_name)<<"");
                        } else {
                            GgafDx9EffectManager::_pEffect_Active->_begin = false;
                        }
                #endif
                        GgafDx9EffectManager::_pEffect_Active = NULL;
                        GgafDx9ModelManager::_pModelLastDraw = NULL;
                        GgafDx9DrawableActor::_hash_technique_last_draw = 0;
                
                
                    }
                
                }
                
                //void GgafDx9Universe::setDrawDepthMaxLevel(GgafDx9DrawableActor* prm_pActor) {
                //    static GgafDx9DrawableActor* pActorTmp;
                //    if (_pActors_DrawMaxDrawDepth == NULL) {
                //        //AN^[
                //        prm_pActor->_pNext_TheSameDrawDepthLevel = NULL;
                //        _pActors_DrawMaxDrawDepth = prm_pActor;
                //        return;
                //    } else {
                //        //AN^[o^
                //        pActorTmp = _pActors_DrawMaxDrawDepth;
                //        prm_pActor->_pNext_TheSameDrawDepthLevel = pActorTmp;
                //        _pActors_DrawMaxDrawDepth = prm_pActor;
                //        return;
                //    }
                //}
                int GgafDx9Universe::setDrawDepthLevel(int prm_draw_depth_level, GgafDx9DrawableActor* prm_pActor) {
                    int draw_depth_level;
                    GgafDx9DrawableActor* pActorTmp;
                    //Jbg
                    if (prm_draw_depth_level > MAX_DRAW_DEPTH_LEVEL - 2) {
                        draw_depth_level = MAX_DRAW_DEPTH_LEVEL - 2;
                    } else if (prm_draw_depth_level < 0) {
                        draw_depth_level = 0;
                    } else {
                        draw_depth_level = prm_draw_depth_level;
                    }
                
                    if (_apAlphaActorList_DrawDepthLevel[draw_depth_level] == NULL) {
                        //prm_draw_depth_levelAN^[
                        prm_pActor->_pNext_TheSameDrawDepthLevel = NULL;
                        _apAlphaActorList_DrawDepthLevel[draw_depth_level] = prm_pActor;
                    } else {
                        //prm_draw_depth_levelAN^[o^
                        //\AK(L[)AAO(X^bN)At[sB
                        //AZobt@LeNX`IuWFNgAIuWFNgA
                        //[xAvCIeBi`jB
                        //`t[A\sB
                        //TODO:()QARIuWFNgeA{``B
                        if ((GgafGod::_pGod->_pUniverse->_frame_of_behaving & 1) == 1) {
                
                            //O
                            pActorTmp = _apAlphaActorList_DrawDepthLevel[draw_depth_level];
                            prm_pActor->_pNext_TheSameDrawDepthLevel = pActorTmp;
                            _apAlphaActorList_DrawDepthLevel[draw_depth_level] = prm_pActor;
                        } else {
                            //K
                            pActorTmp = _apAlphaActorList_DrawDepthLevel[draw_depth_level];
                            while(pActorTmp->_pNext_TheSameDrawDepthLevel) {
                                pActorTmp = pActorTmp->_pNext_TheSameDrawDepthLevel;
                            }
                            pActorTmp->_pNext_TheSameDrawDepthLevel = prm_pActor;
                            prm_pActor->_pNext_TheSameDrawDepthLevel = NULL;
                        }
                    }
                    return draw_depth_level;
                
                }
                
                
           1 -> GgafDx9Universe::~GgafDx9Universe() {
                
                    DELETE_IMPOSSIBLE_NULL(_pRing_pSeArray);
                }


Top 10 Lines:

     Line      Count

       18        240
       40          1
      284          1

Execution Summary:

        4   Executable lines in this file
        3   Lines executed
    75.00   Percent of the file executed

      242   Total number of line executions
    60.50   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/util/spline/GgafDx9FixedFrameSplineProgram.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
       ##### -> GgafDx9FixedFrameSplineProgram::GgafDx9FixedFrameSplineProgram(GgafDx9GeometricActor* prm_pActor)
                 : GgafDx9SplineProgram(prm_pActor) {
                    _SPframe_segment = 0;
                    _paDistace_to = NULL;
                    _paSPMvVeloTo = NULL;
                    _is_executing = false;
                    _option = 0;
                    _SIN_RzMv_begin = 0;
                    _COS_RzMv_begin = 0;
                    _SIN_RyMv_begin = 0;
                    _COS_RyMv_begin = 0;
                    _angveloRzRyMv = ANGLE360;
                }
                
       ##### -> GgafDx9FixedFrameSplineProgram::GgafDx9FixedFrameSplineProgram(GgafDx9GeometricActor* prm_pActor,
                                                                               double prm_paaCriteriaPoints[][3],
                                                                               int prm_point_num,
                                                                               double prm_accuracy,
                                                                               frame prm_spent_frame,
                                                                               angvelo prm_angveloRzRyMv )
                
                                                        : GgafDx9SplineProgram(prm_pActor,
                                                                               prm_paaCriteriaPoints,
                                                                               prm_point_num,
                                                                               prm_accuracy)      {
                    _spent_frame = prm_spent_frame;
                    _angveloRzRyMv = prm_angveloRzRyMv;
                    init();
                }
                
         884 -> GgafDx9FixedFrameSplineProgram::GgafDx9FixedFrameSplineProgram(GgafDx9GeometricActor* prm_pActor,
                                                                               GgafDx9Spline3D* prm_sp,
                                                                               frame prm_spent_frame,
                                                                               angvelo prm_angveloRzRyMv)
                
                                                         : GgafDx9SplineProgram(prm_pActor,
                                                                                prm_sp) {
                    _spent_frame = prm_spent_frame;
                    _angveloRzRyMv = prm_angveloRzRyMv;
                    init();
                }
                
                
                void GgafDx9FixedFrameSplineProgram::init() {
                    //e__Ax\S
                
                    // prm_paaCriteriaPoints[2][3] = { {1000,2000,3000}, {2000,1000,0}, {3900, 0, 1000} }
                    // prm_point_num = 3          //_
                    // prm_accuracy = 0.25(=1/4)  //_x
                    // prm_spent_frame = 120      //t[
                    // A}B
                    //
                    // X:_
                    // o:__iXvC_j
                    // X--o: \W
                    // _paDistace_to[] : _
                    // paSPMvVeloTo[] : _BKvx
                    //
                    // sp._rnum v_B sp._rnum = 9 B
                    // prm_accuracy YA__JASRAsp._rnumKgp
                    // }Yd}B
                    //
                    //      v = paSPMvVeloTo[1]                              v = paSPMvVeloTo[8]
                    //               paSPDistaceTo[1]     paSPDistaceTo[5]          paSPDistaceTo[8]
                    //                    ||                     ||                         ||
                    //                   <-->                 <------>                    <----->
                    //                  X----o----o----o-----X--------o---------o--------o-------X
                    //                  ^                    ^        ^                          ^
                    //                  |                    |        |                          |
                    //            (sp._X_compute[0],         | (sp._X_compute[5],        sp._X_compute[8]
                    //             sp._Y_compute[0],         |  sp._Y_compute[5],        sp._Y_compute[8]
                    //             sp._Z_compute[0])         |  sp._Z_compute[5])        sp._Z_compute[8]
                    //                  |                    |                                   |
                    // (prm_paaCriteriaPoints[0][0],   (prm_paaCriteriaPoints[1][0],    (prm_paaCriteriaPoints[2][0],
                    //  prm_paaCriteriaPoints[0][1],    prm_paaCriteriaPoints[1][1],     prm_paaCriteriaPoints[2][1],
                    //  prm_paaCriteriaPoints[0][2])    prm_paaCriteriaPoints[1][2])     prm_paaCriteriaPoints[2][2])
                    //   = (1000,2000,3000)             = (2000,1000,0)                    = (3900, 0, 1000)
                    //
                    //                 <--------------------------------------------------------->
                    //                                 120Frame(=prm_spent_frame)
                    //                  <-->
                    //                  frm_segment = P 120/8 Frame = prm_spent_frame / (sp._rnum-1);
                
                    //Pgp\t[
                    _SPframe_segment = 1.0*_spent_frame / (_sp->_rnum-1);
                    if (_SPframe_segment < 1) {
                        _SPframe_segment = 1;
                    }
                    _paDistace_to = NEW int[_sp->_rnum];
                    _paSPMvVeloTo = NEW velo[_sp->_rnum];
                    int x_from, y_from, z_from;
                    int x_to, y_to, z_to;
                
                    x_to = _sp->_X_compute[0];
                    y_to = _sp->_Y_compute[0];
                    z_to = _sp->_Z_compute[0];
                    for (int t = 1; t < _sp->_rnum; t ++) {
                        x_from = x_to;
                        y_from = y_to;
                        z_from = z_to;
                        x_to = _sp->_X_compute[t];
                        y_to = _sp->_Y_compute[t];
                        z_to = _sp->_Z_compute[t];
                        _paDistace_to[t] = GgafDx9Util::getDistance(
                                                    x_from,
                                                    y_from,
                                                    z_from,
                                                    x_to,
                                                    y_to,
                                                    z_to
                                                 );
                
                        // paDistaceTo[t] Afrm_segment KvxB
                        //
                        _paSPMvVeloTo[t] = (velo)(_paDistace_to[t] / _SPframe_segment);
                    }
                
                //
                //    for (int t = 0; t < _sp->_rnum; t ++) {
                //        _TRACE_((float)_sp->_X_compute[t]<<"  "<< (float)_sp->_Y_compute[t]<<"  "<< (float)_sp->_Z_compute[t]);
                //    }
                
                }
                
                void GgafDx9FixedFrameSplineProgram::begin(int prm_option) {
                    if (_sp) {
                        _is_executing = true;
                        _option = prm_option;
                        _SPframe = 0;
                        velo v = _pActor_target->_pKuroko->_veloMv;
                        if (v == 0) {
                            _paSPMvVeloTo[0] = 1000;
                        } else {
                            _paSPMvVeloTo[0] = v;
                        }
                
                        if (_option == 2) {
                            _X_begin = _sp->_X_compute[0]*_rate_X + _offset_X - _pActor_target->_X ;
                            _Y_begin = _sp->_Y_compute[0]*_rate_Y + _offset_Y - _pActor_target->_Y;
                            _Z_begin = _sp->_Z_compute[0]*_rate_Z + _offset_Z - _pActor_target->_Z;
                            _SIN_RzMv_begin = GgafDx9Util::SIN[_pActor_target->_pKuroko->_angRzMv/ANGLE_RATE];
                            _COS_RzMv_begin = GgafDx9Util::COS[_pActor_target->_pKuroko->_angRzMv/ANGLE_RATE];
                            _SIN_RyMv_begin = GgafDx9Util::SIN[_pActor_target->_pKuroko->_angRyMv/ANGLE_RATE];
                            _COS_RyMv_begin = GgafDx9Util::COS[_pActor_target->_pKuroko->_angRyMv/ANGLE_RATE];
                        } else if (_option == 1) {
                            _X_begin = _sp->_X_compute[0]*_rate_X + _offset_X - _pActor_target->_X;
                            _Y_begin = _sp->_Y_compute[0]*_rate_Y + _offset_Y - _pActor_target->_Y;
                            _Z_begin = _sp->_Z_compute[0]*_rate_Z + _offset_Z - _pActor_target->_Z;
                        } else {
                            _X_begin = _sp->_X_compute[0]*_rate_X + _offset_X;
                            _Y_begin = _sp->_Y_compute[0]*_rate_Y + _offset_Y;
                            _Z_begin = _sp->_Z_compute[0]*_rate_Z + _offset_Z;
                
                        }
                    }
                }
                
                
                void GgafDx9FixedFrameSplineProgram::behave() {
                    if (_is_executing) {
                        GgafDx9Kuroko* _pKuroko = _pActor_target->_pKuroko;
                
                        //_INDEX
                        int SPPointIndex = _SPframe/_SPframe_segment;
                        if ( SPPointIndex == _sp->_rnum) {
                            //I
                            _is_executing = false;
                            return;
                        }
                
                        //
                        if (_SPframe % _SPframe_segment == 0) {
                            double dx = _sp->_X_compute[SPPointIndex]*_rate_X + _offset_X;
                            double dy = _sp->_Y_compute[SPPointIndex]*_rate_Y + _offset_Y;
                            double dz = _sp->_Z_compute[SPPointIndex]*_rate_Z + _offset_Z;
                
                
                            //_ior_)p
                            if (_option == 2) {
                                //    s  Z]  Y]
                                //    | cosRz*cosRy                            , sinRz                , cosRz*-sinRy                            , 0 |
                                //    | -sinRz*cosRy                           , cosRz                , -sinRz*-sinRy                           , 0 |
                                //    | sinRy                                  , 0                    , cosRy                                   , 0 |
                                //    | (dx*cosRz + dy*-sinRz)*cosRy + dz*sinRy, (dx*sinRz + dy*cosRz), (dx*cosRz + dy*-sinRz)*-sinRy + dz*cosRy, 1 |
                                _pKuroko->orderTagettingMvAngSequence(
                                                ((dx * _COS_RzMv_begin + dy * -_SIN_RzMv_begin) * _COS_RyMv_begin + dz * _SIN_RyMv_begin) - _X_begin,
                                                (dx * _SIN_RzMv_begin + dy * _COS_RzMv_begin) - _Y_begin,
                                                ((dx * _COS_RzMv_begin + dy * -_SIN_RzMv_begin) * -_SIN_RyMv_begin + dz * _COS_RyMv_begin) - _Z_begin,
                                                _angveloRzRyMv, 0,
                                                TURN_CLOSE_TO, true
                                              );
                            } else if (_option == 1) {
                                //W^[Qbg
                                _pKuroko->orderTagettingMvAngSequence(
                                                dx - _X_begin, dy - _Y_begin, dz - _Z_begin,
                                                _angveloRzRyMv, 0,
                                                TURN_CLOSE_TO, true
                                              );
                            } else {
                                //W^[Qbg
                                _pKuroko->orderTagettingMvAngSequence(
                                                dx, dy, dz,
                                                _angveloRzRyMv, 0,
                                                TURN_CLOSE_TO, true
                                              );
                            }
                            _pActor_target->_pKuroko->setMvVelo(_paSPMvVeloTo[SPPointIndex]);
                        }
                        _SPframe++;
                    }
                
                }
        1768 -> GgafDx9FixedFrameSplineProgram::~GgafDx9FixedFrameSplineProgram() {
                    //CjVCYO
                    DELETEARR_POSSIBLE_NULL(_paDistace_to);
                    //CjVCYO
                    DELETEARR_POSSIBLE_NULL(_paSPMvVeloTo);
                }


Top 10 Lines:

     Line      Count

      218       1768
       36        884

Execution Summary:

        5   Executable lines in this file
        4   Lines executed
    80.00   Percent of the file executed

     2652   Total number of line executions
   530.40   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9Core\GprofCdt/../src/jp/ggaf/dx9core/util/spline/GgafDx9Spline3D.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                
                
       ##### -> GgafDx9Spline3D::GgafDx9Spline3D() {
                    _X_basepoint = NULL;
                    _Y_basepoint = NULL;
                    _Z_basepoint = NULL;
                    _num_basepoint = 0;
                    _X_compute = NULL;
                    _Y_compute = NULL;
                    _Z_compute = NULL;
                    _rnum = 0;
                
                }
                
                
           6 -> GgafDx9Spline3D::GgafDx9Spline3D(double prm_paaEstablish[][3], int prm_num, double prm_accuracy) {
                    init(prm_paaEstablish, prm_num, prm_accuracy);
                }
                
                
                void GgafDx9Spline3D::init(double prm_paaEstablish[][3], int prm_num, double prm_accuracy) {
                    _num_basepoint = prm_num;
                    _X_basepoint = NEW double[prm_num];
                    _Y_basepoint = NEW double[prm_num];
                    _Z_basepoint = NEW double[prm_num];
                    for (int i = 0; i < prm_num; i++) {
                        _X_basepoint[i] = prm_paaEstablish[i][0];
                        _Y_basepoint[i] = prm_paaEstablish[i][1];
                        _Z_basepoint[i] = prm_paaEstablish[i][2];
                    }
                    _xs.init(_X_basepoint, prm_num);
                    _ys.init(_Y_basepoint, prm_num);
                    _zs.init(_Z_basepoint, prm_num);
                    _X_compute = NULL;
                    _Y_compute = NULL;
                    _Z_compute = NULL;
                    compute(prm_accuracy);
                }
                
                void GgafDx9Spline3D::compute(double prm_accuracy) {
                    _rnum = _num_basepoint/prm_accuracy;
                    if (_X_compute) {
                        DELETEARR_IMPOSSIBLE_NULL(_X_compute);
                        DELETEARR_IMPOSSIBLE_NULL(_Y_compute);
                        DELETEARR_IMPOSSIBLE_NULL(_Z_compute);
                    }
                    _X_compute = NEW double[_rnum];
                    _Y_compute = NEW double[_rnum];
                    _Z_compute = NEW double[_rnum];
                
                    int index = 0;
                    for (double t = 0.0; t <= _num_basepoint-1.0; t += prm_accuracy) {
                        _X_compute[index] = _xs.compute(t);
                        _Y_compute[index] = _ys.compute(t);
                        _Z_compute[index] = _zs.compute(t);
                        index++;
                    }
                    _rnum = index;
                }
                
          12 -> GgafDx9Spline3D::~GgafDx9Spline3D() {
                    _TRACE_("GgafDx9Spline3D::~GgafDx9Spline3D() !!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                    DELETEARR_IMPOSSIBLE_NULL(_X_basepoint);
                    DELETEARR_IMPOSSIBLE_NULL(_Y_basepoint);
                    DELETEARR_IMPOSSIBLE_NULL(_Z_basepoint);
                    //CjVCYO
                    DELETEARR_POSSIBLE_NULL(_X_compute);
                    DELETEARR_POSSIBLE_NULL(_Y_compute);
                    DELETEARR_POSSIBLE_NULL(_Z_compute);
                }


Top 10 Lines:

     Line      Count

       65         12
       20          6

Execution Summary:

        4   Executable lines in this file
        3   Lines executed
    75.00   Percent of the file executed

       18   Total number of line executions
     4.50   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9Core/include/jp/ggaf/dx9core/util/spline/GgafDx9Spline3D.h:
                #ifndef GGAFDX9SPLINE3D_H_
                #define GGAFDX9SPLINE3D_H_
                
                #define MaxSplineSize 100
                
                namespace GgafDx9Core {
                
                //{NXIshida So TvQlB
                //@\ITvIshida SoB
                //QlTCg
                //uSamayou Oharikuiv
                //http://www5d.biglobe.ne.jp/~stssk/
                //Rec
                //uRXvC@v
                //http://www5d.biglobe.ne.jp/~stssk/maze/spline.html
                //
                //                                2009/10/16 Masatoshi Tsuge
                
                /**
                 * 3XvCNX .
                 * @version 1.00
                 * @since 2009/10/16
                 * @author Masatoshi Tsuge
                 */
                class GgafDx9Spline3D {
                
                public:
                
                    /**
                     * PXvC
                     */
                    class GgafDx9Spline {
                    public:
                        int num;
                        double a[MaxSplineSize + 1], b[MaxSplineSize + 1], c[MaxSplineSize + 1], d[MaxSplineSize + 1];
          18 ->         GgafDx9Spline() {
                            num = 0;
                        }
                        void init(double *sp, int spnum) {
                            double tmp, w[MaxSplineSize + 1];
                            int i;
                            num = spnum - 1;
                            // R0W(a)
                            for (i = 0; i <= num; i++) {
                                a[i] = sp[i];
                            }
                            // R2W(c)vZ
                            // AB
                            // AA@XvCvZ`[jO@
                            c[0] = c[num] = 0.0;
                            for (i = 1; i < num; i++) {
                                c[i] = 3.0 * (a[i - 1] - 2.0 * a[i] + a[i + 1]);
                            }
                            // 
                            w[0] = 0.0;
                            for (i = 1; i < num; i++) {
                                tmp = 4.0 - w[i - 1];
                                c[i] = (c[i] - c[i - 1]) / tmp;
                                w[i] = 1.0 / tmp;
                            }
                            // E
                            for (i = num - 1; i > 0; i--) {
                                c[i] = c[i] - c[i + 1] * w[i];
                            }
                            // R1W(b)3W(b)vZ
                            b[num] = d[num] = 0.0;
                            for (i = 0; i < num; i++) {
                                d[i] = (c[i + 1] - c[i]) / 3.0;
                                b[i] = a[i + 1] - a[i] - c[i] - d[i];
                            }
                        }
                        double compute(double t) {
                            int j;
                            double dt;
                            j = (int)floor(t); // _
                            if (j < 0) j = 0;
                            else if (j >= num) j = num - 1; // l
                
                            dt = t - (double)j;
                            return a[j] + (b[j] + (c[j] + d[j] * dt) * dt) * dt;
                        }
                    };
                
                    /**
                     * RXgN^ .
                     *  init() oB
                     */
                    GgafDx9Spline3D();
                
                    /**
                     * RXgN^ .
                     *  init() oB
                     * @param prm_paaBase _Wz
                     *                    [][0] XW
                     *                    [][1] YW
                     *                    [][2] ZW
                     * @param num         _Wz
                     * @param prm_accuracy _}xB
                     *                     1.0_B
                     *                     0.5__B
                     *                     0.11_10_A
                     * @return
                     */
                    GgafDx9Spline3D(double prm_paaBase[][3], int num, double prm_accuracy);
                
                    /**
                     * _Agp .
                     * @param prm_paaBase _Wz
                     *                    [][0] XW
                     *                    [][1] YW
                     *                    [][2] ZW
                     * @param num         _Wz
                     * @param prm_accuracy _}xB
                     *                     1.0_B
                     *                     0.5__1B
                     *                     0.11_9_A
                     */
                    void init(double prm_paaBase[][3], int num, double prm_accuracy);
                
                    /**
                     * _vZ
                     * @param prm_accuracy _}xB
                     *                     1.0_B
                     *                     0.5__1B
                     *                     0.1_9_A
                     */
                    void compute(double prm_accuracy);
                
                    double* _X_basepoint;
                    double* _Y_basepoint;
                    double* _Z_basepoint;
                    int _num_basepoint;
                
                    GgafDx9Spline _xs;
                    GgafDx9Spline _ys;
                    GgafDx9Spline _zs;
                
                    double* _X_compute;
                    double* _Y_compute;
                    double* _Z_compute;
                    int _rnum;
                
                    virtual ~GgafDx9Spline3D();
                
                };
                
                }
                #endif /*GGAFDX9SPLINE3D_H_*/
                


Top 10 Lines:

     Line      Count

       36         18

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       18   Total number of line executions
    18.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/util/ColliAAB.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
        3398 -> ColliAAB::ColliAAB() : GgafDx9CollisionPart() {
                    _x1 = 0;
                    _y1 = 0;
                    _z1 = 0;
                    _x2 = 0;
                    _y2 = 0;
                    _z2 = 0;
                    _shape_kind = COLLI_AAB;
                }
                
                void ColliAAB::set(int x1, int y1, int z1, int x2, int y2, int z2, bool rotX, bool rotY, bool rotZ) {
                    if (x1 < x2) {
                        _x1 = x1;
                        _x2 = x2;
                    } else {
                        _x1 = x2;
                        _x2 = x1;
                    }
                    if (y1 < y2) {
                        _y1 = y1;
                        _y2 = y2;
                    } else {
                        _y1 = y2;
                        _y2 = y1;
                    }
                    if (z1 < z2) {
                        _z1 = z1;
                        _z2 = z2;
                    } else {
                        _z1 = z2;
                        _z2 = z1;
                    }
                
                    //NXoXV
                    _dx = (_x2 - _x1);
                    _dy = (_y2 - _y1);
                    _dz = (_z2 - _z1);
                    _hdx = _dx / 2;
                    _hdy = _dy / 2;
                    _hdz = _dz / 2;
                    _base_cx = _x1 + _hdx;
                    _base_cy = _y1 + _hdy;
                    _base_cz = _z1 + _hdz;
                    _cx = _base_cx;
                    _cy = _base_cy;
                    _cz = _base_cz;
                    _rotX = rotX;
                    _rotY = rotY;
                    _rotZ = rotZ;
                    //ES
                    _aab_x1 = _x1;
                    _aab_y1 = _y1;
                    _aab_z1 = _z1;
                    _aab_x2 = _x2;
                    _aab_y2 = _y2;
                    _aab_z2 = _z2;
                
                    _is_valid_flg = true;
                }
                
                void ColliAAB::rotateRxRzRy(angle rX, angle rY, angle rZ) {
                    s_ang s_RX, s_RY, s_RZ;
                    int wk_cx, wk_cy, wk_cz;
                    //]
                    s_RX = rX / ANGLE_RATE;
                    s_RY = rY / ANGLE_RATE;
                    s_RZ = rZ / ANGLE_RATE;
                    wk_cx = _base_cx;
                    wk_cy = _base_cy;
                    wk_cz = _base_cz;
                
                    if (_rotX) {
                        _cy = (wk_cy * GgafDx9Util::COS[s_RX]) - (wk_cz * GgafDx9Util::SIN[s_RX]);
                        _cz = (wk_cy * GgafDx9Util::SIN[s_RX]) + (wk_cz * GgafDx9Util::COS[s_RX]);
                        wk_cy = _cy;
                        wk_cz = _cz;
                    }
                
                    //
                    if (_rotZ) {
                        _cx = (wk_cx * GgafDx9Util::COS[s_RZ]) - (wk_cy * GgafDx9Util::SIN[s_RZ]);
                        _cy = (wk_cx * GgafDx9Util::SIN[s_RZ]) + (wk_cy * GgafDx9Util::COS[s_RZ]);
                        wk_cx = _cx;
                        wk_cy = _cy;
                    }
                
                    if (_rotY) {
                //            _cz = (wk_cz * GgafDx9Util::COS[s_RY]) - (wk_cx * GgafDx9Util::SIN[s_RY]);
                //            _cx = (wk_cz * GgafDx9Util::SIN[s_RY]) + (wk_cx * GgafDx9Util::COS[s_RY]);
                        //l
                        //RYA(1,0,0)OxAYv
                        _cx = (wk_cx * GgafDx9Util::COS[S_ANG360-s_RY]) - (wk_cz * GgafDx9Util::SIN[S_ANG360-s_RY]);
                        _cz = (wk_cx * GgafDx9Util::SIN[S_ANG360-s_RY]) + (wk_cz * GgafDx9Util::COS[S_ANG360-s_RY]);
                        wk_cz = _cz;
                        wk_cx = _cx;
                    }
                
                    _x1 = wk_cx - _hdx;
                    _y1 = wk_cy - _hdy;
                    _z1 = wk_cz - _hdz;
                    _x2 = wk_cx + _hdx;
                    _y2 = wk_cy + _hdy;
                    _z2 = wk_cz + _hdz;
                    //EXV
                    _aab_x1 = _x1;
                    _aab_y1 = _y1;
                    _aab_z1 = _z1;
                    _aab_x2 = _x2;
                    _aab_y2 = _y2;
                    _aab_z2 = _z2;
                }
                
                
        6796 -> ColliAAB::~ColliAAB() {
                    TRACE("ColliAAB::~ColliAAB()");
                }


Top 10 Lines:

     Line      Count

      120       6796
        7       3398

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

    10194   Total number of line executions
  3398.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/util/ColliSphere.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
         144 -> ColliSphere::ColliSphere() : GgafDx9CollisionPart() {
                    _x = 0;
                    _y = 0;
                    _z = 0;
                    _r = 0;
                    _rr = 0.0;
                    _shape_kind = COLLI_SPHERE;
                }
                
                void ColliSphere::set(int x, int y, int z, int r, bool rotX, bool rotY, bool rotZ) {
                    _x = x;
                    _y = y;
                    _z = z;
                    _r = r;
                    _rr = 1.0*r*r;
                    //NXoXV
                    _dx = _r*2;
                    _dy = _r*2;
                    _dz = _r*2;
                    _hdx = _dx / 2;
                    _hdy = _dy / 2;
                    _hdz = _dz / 2;
                    _base_cx = _x;
                    _base_cy = _y;
                    _base_cz = _z;
                    _cx = _base_cx;
                    _cy = _base_cy;
                    _cz = _base_cz;
                    _rotX = rotX;
                    _rotY = rotY;
                    _rotZ = rotZ;
                    //E
                    _aab_x1 = _x - _r;
                    _aab_y1 = _y - _r;
                    _aab_z1 = _z - _r;
                    _aab_x2 = _x + _r;
                    _aab_y2 = _y + _r;
                    _aab_z2 = _z + _r;
                
                    _is_valid_flg = true;
                }
                
                void ColliSphere::rotateRxRzRy(angle rX, angle rY, angle rZ) {
                    s_ang s_RX, s_RY, s_RZ;
                    int wk_cx, wk_cy, wk_cz;
                    //]
                    s_RX = rX / ANGLE_RATE;
                    s_RY = rY / ANGLE_RATE;
                    s_RZ = rZ / ANGLE_RATE;
                    wk_cx = _base_cx;
                    wk_cy = _base_cy;
                    wk_cz = _base_cz;
                
                    if (_rotX) {
                        _cy = (wk_cy * GgafDx9Util::COS[s_RX]) - (wk_cz * GgafDx9Util::SIN[s_RX]);
                        _cz = (wk_cy * GgafDx9Util::SIN[s_RX]) + (wk_cz * GgafDx9Util::COS[s_RX]);
                        wk_cy = _cy;
                        wk_cz = _cz;
                    }
                
                    //
                    if (_rotZ) {
                        _cx = (wk_cx * GgafDx9Util::COS[s_RZ]) - (wk_cy * GgafDx9Util::SIN[s_RZ]);
                        _cy = (wk_cx * GgafDx9Util::SIN[s_RZ]) + (wk_cy * GgafDx9Util::COS[s_RZ]);
                        wk_cx = _cx;
                        wk_cy = _cy;
                    }
                
                    if (_rotY) {
                //            _cz = (wk_cz * GgafDx9Util::COS[s_RY]) - (wk_cx * GgafDx9Util::SIN[s_RY]);
                //            _cx = (wk_cz * GgafDx9Util::SIN[s_RY]) + (wk_cx * GgafDx9Util::COS[s_RY]);
                        //l
                        //RYA(1,0,0)OxAYv
                        _cx = (wk_cx * GgafDx9Util::COS[S_ANG360-s_RY]) - (wk_cz * GgafDx9Util::SIN[S_ANG360-s_RY]);
                        _cz = (wk_cx * GgafDx9Util::SIN[S_ANG360-s_RY]) + (wk_cz * GgafDx9Util::COS[S_ANG360-s_RY]);
                        wk_cz = _cz;
                        wk_cx = _cx;
                    }
                
                
                
                    _x = wk_cx;
                    _y = wk_cy;
                    _z = wk_cz;
                    //_r = r;
                    //EXV
                    _aab_x1 = _x - _r;
                    _aab_y1 = _y - _r;
                    _aab_z1 = _z - _r;
                    _aab_x2 = _x + _r;
                    _aab_y2 = _y + _r;
                    _aab_z2 = _z + _r;
                }
                
                
         288 -> ColliSphere::~ColliSphere() {
                    TRACE("ColliSphere::~ColliSphere()");
                }


Top 10 Lines:

     Line      Count

      102        288
        7        144

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      432   Total number of line executions
   144.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/DefaultGod.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
           1 -> DefaultGod::DefaultGod(HINSTANCE prm_hInstance, HWND _hWnd) : GgafDx9God(prm_hInstance, _hWnd) {
                
                }
                
                void DefaultGod::clean() {
                    if (!_was_cleaned) {
                        _TRACE_("DefaultGod::clean() begin");
                        GgafDx9God::clean();
                        _TRACE_("DefaultGod::clean() end");
                    }
                }
                
           1 -> DefaultGod::~DefaultGod() {
                    clean();
                    _was_cleaned = true;
                }


Top 10 Lines:

     Line      Count

        7          1
       19          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        2   Total number of line executions
     0.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/actor/DefaultCamera.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
           1 -> DefaultCamera::DefaultCamera(const char* prm_name, float prm_rad_fovX, float prm_dep) : GgafDx9Camera(prm_name, prm_rad_fovX, prm_dep) {
                    _class_name = "DefaultCamera";
                }
                
           1 -> DefaultCamera::~DefaultCamera() {
                }


Top 10 Lines:

     Line      Count

        7          1
       11          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        2   Total number of line executions
     0.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/actor/WorldBoundActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
           1 -> WorldBoundActor::WorldBoundActor(const char* prm_name, const char* prm_model) :
                        GgafDx9SpriteMeshActor(prm_name,
                                               prm_model,
                                               NULL) {
                
                    _class_name = "WorldBoundActor";
                    _frame_offset = 0;
                    _pScaler = NEW GgafDx9Scaler(this);
                    changeEffectTechnique("NoLight"); //NoLightx^heNjbN
                    defineRotMvWorldMatrix(GgafDx9Util::setWorldMatrix_ScMv); //g~s
                    setSpecialDrawDepth(MAX_DRAW_DEPTH_LEVEL);
                }
                
                void WorldBoundActor::processSettlementBehavior() {
                    //OB
                    //
                    //Eg{[l
                    //EWo^
                    //EvZ
                    //GgafDx9GeometricActor::processSettlementBehavior() I
                    locateAs(P_CAM);
                    _fX = (FLOAT)(1.0f * _X / LEN_UNIT / PX_UNIT);
                    _fY = (FLOAT)(1.0f * _Y / LEN_UNIT / PX_UNIT);
                    _fZ = (FLOAT)(1.0f * _Z / LEN_UNIT / PX_UNIT);
                    (*_pFunc_calcRotMvWorldMatrix)(this, _matWorld); //[h
                }
                //void WorldBoundActor::processPreDraw() {
                //    //O
                //    //
                //    //EiK_O[xvZ
                //    //EeNjbNl
                //    //GgafDx9DrawableActor::processPreDraw() I
                //    if (_pGgafDx9Model->_is_init_model == false) {
                //        onCreateModel(); //f
                //        _pGgafDx9Model->_is_init_model = true;
                //    }
                //    GgafDx9Universe::setDrawDepthLevel(MAX_DRAW_DEPTH_LEVEL,this); //[
                //}
                
           1 -> WorldBoundActor::~WorldBoundActor() {
                    DELETE_IMPOSSIBLE_NULL(_pScaler);
                }


Top 10 Lines:

     Line      Count

        7          1
       46          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        2   Total number of line executions
     0.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/actor/DefaultSpriteActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
          11 -> DefaultSpriteActor::DefaultSpriteActor(const char* prm_name, const char* prm_model_id) :
                    GgafDx9SpriteActor(prm_name,
                                       prm_model_id,
                                       "DefaultSpriteEffect",
                                       "DefaultSpriteTechnique",
                                       NEW CollisionChecker(this) ) {
                    _class_name = "DefaultSpriteActor";
                    _frame_offset = 0;
                    _pCollisionChecker = (CollisionChecker*)_pChecker;
                    _pScaler = NEW GgafDx9Scaler(this);
                    setZWriteEnable(false);
                }
                
                void DefaultSpriteActor::drawHitArea() {
                    ColliAABActor::get()->drawHitarea(_pCollisionChecker); ColliAAPrismActor::get()->drawHitarea(_pCollisionChecker); ColliSphereActor::get()->drawHitarea(_pCollisionChecker);
                }
                
          11 -> DefaultSpriteActor::~DefaultSpriteActor() {
                    DELETE_IMPOSSIBLE_NULL(_pCollisionChecker);
                    DELETE_IMPOSSIBLE_NULL(_pScaler);
                }


Top 10 Lines:

     Line      Count

        7         11
       24         11

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       22   Total number of line executions
     7.33   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/actor/StringBoardActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
          25 -> StringBoardActor::StringBoardActor(const char* prm_name, const char* prm_model) :
                        GgafDx9StringBoardActor(prm_name, prm_model)
                {
                    _class_name = "StringBoardActor";
                }
                
          25 -> StringBoardActor::~StringBoardActor() {
                }
                


Top 10 Lines:

     Line      Count

        7         25
       13         25

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       50   Total number of line executions
    16.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/actor/DefaultD3DXMeshActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
           1 -> DefaultD3DXMeshActor::DefaultD3DXMeshActor(const char* prm_name, const char* prm_model) :
                    GgafDx9D3DXMeshActor(prm_name,
                                         prm_model,
                                         "DefaultMeshEffect",
                                         "DefaultMeshTechnique",
                                         NEW CollisionChecker(this) ) {
                    _class_name = "DefaultD3DXMeshActor";
                    _frame_offset = 0;
                    _pCollisionChecker = (CollisionChecker*)_pChecker;
                    _pScaler = NEW GgafDx9Scaler(this);
                
                }
                
                void DefaultD3DXMeshActor::drawHitArea() {
                    ColliAABActor::get()->drawHitarea(_pCollisionChecker); ColliAAPrismActor::get()->drawHitarea(_pCollisionChecker); ColliSphereActor::get()->drawHitarea(_pCollisionChecker);
                }
                
           1 -> DefaultD3DXMeshActor::~DefaultD3DXMeshActor() {
                    DELETE_IMPOSSIBLE_NULL(_pCollisionChecker);
                    DELETE_IMPOSSIBLE_NULL(_pScaler);
                }


Top 10 Lines:

     Line      Count

        7          1
       24          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        2   Total number of line executions
     0.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/actor/laserchip/SingleLaser.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
                
         225 -> SingleLaser::SingleLaser(const char* prm_name, const char* prm_model_id) :
                             GgafDx9MeshSetActor(prm_name,
                                                 string("27/" + string(prm_model_id)).c_str(),
                                                 "SingleLaserEffect",
                                                 "SingleLaserTechnique",
                                                 NEW CollisionChecker(this) ) {
                
                    _pMeshSetModel->_set_num = 27; //VO[U[Zbg27B
                
                    _class_name = "SingleLaser";
                    _pCollisionChecker = (CollisionChecker*)_pChecker;
                    _ah_matWorld[0]   = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld001" );
                    _ah_matWorld[1]   = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld002" );
                    _ah_matWorld[2]   = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld003" );
                    _ah_matWorld[3]   = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld004" );
                    _ah_matWorld[4]   = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld005" );
                    _ah_matWorld[5]   = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld006" );
                    _ah_matWorld[6]   = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld007" );
                    _ah_matWorld[7]   = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld008" );
                    _ah_matWorld[8]   = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld009" );
                    _ah_matWorld[9]   = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld010" );
                    _ah_matWorld[10]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld011" );
                    _ah_matWorld[11]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld012" );
                    _ah_matWorld[12]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld013" );
                    _ah_matWorld[13]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld014" );
                    _ah_matWorld[14]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld015" );
                    _ah_matWorld[15]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld016" );
                    _ah_matWorld[16]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld017" );
                    _ah_matWorld[17]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld018" );
                    _ah_matWorld[18]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld019" );
                    _ah_matWorld[19]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld020" );
                    _ah_matWorld[20]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld021" );
                    _ah_matWorld[21]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld022" );
                    _ah_matWorld[22]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld023" );
                    _ah_matWorld[23]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld024" );
                    _ah_matWorld[24]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld025" );
                    _ah_matWorld[25]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld026" );
                    _ah_matWorld[26]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld027" );
                //    _ah_matWorld[27]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld028" );
                //    _ah_matWorld[28]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld029" );
                //    _ah_matWorld[29]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld030" );
                
                
                    setZEnable(true);        //Zobt@lL
                    setZWriteEnable(false);  //Zobt@
                
                }
                
                //void SingleLaser::onCreateModel() {
                //    _pMeshSetModel->_set_num = 27; //Single[U[Zbg27B
                //    _TRACE_("SingleLaser::onCreateModel() "<<_pMeshSetModel->getName()<<" Zbg "<< _pMeshSetModel->_set_num<<" B");
                //}
                
                void SingleLaser::processDraw() {
                    _draw_set_num = 0; //GgafDx9MeshSetActorfeNjbN
                                       //AJEgB`[xx`B
                    ID3DXEffect* pID3DXEffect = _pMeshSetEffect->_pID3DXEffect;
                    HRESULT hr;
                    //{f_
                    GgafDx9DrawableActor* pDrawActor = this;
                    SingleLaser* pSingleLaserChip;
                    while (true) {
                        if (pDrawActor)  {
                            if (pDrawActor->_pGgafDx9Model == _pMeshSetModel && pDrawActor->_hash_technique == _hash_technique) {
                                pSingleLaserChip = (SingleLaser*)pDrawActor;
                
                                hr = pID3DXEffect->SetMatrix(this->_ah_matWorld[_draw_set_num], &(pSingleLaserChip->_matWorld));
                                checkDxException(hr, D3D_OK, "GgafDx9MeshSetActor::processDraw() SetMatrix(g_matWorld) _pMeshSetEffect="<<_pMeshSetEffect->getName() << " pDrawActor->_matWorld="<<pDrawActor->_matWorld<<" pDrawActor="<<pDrawActor->getName()<<" _draw_set_num="<<_draw_set_num<<" sB");
                
                                _draw_set_num++;
                                if (_draw_set_num >= _pMeshSetModel->_set_num) {
                                    break;
                                }
                                pDrawActor = pDrawActor->_pNext_TheSameDrawDepthLevel;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    GgafDx9Universe::_pActor_DrawActive = pSingleLaserChip; //`ZbgAN^[Zbg
                    _pMeshSetModel->draw(this, _draw_set_num);
                }
                
                void SingleLaser::drawHitArea() {
                    ColliAABActor::get()->drawHitarea(_pCollisionChecker); ColliAAPrismActor::get()->drawHitarea(_pCollisionChecker); ColliSphereActor::get()->drawHitarea(_pCollisionChecker);
                }
                
         225 -> SingleLaser::~SingleLaser() {
                    DELETE_IMPOSSIBLE_NULL(_pCollisionChecker);
                }


Top 10 Lines:

     Line      Count

        8        225
       97        225

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      450   Total number of line executions
   150.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/actor/laserchip/StraightLaserChip.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
                
          60 -> StraightLaserChip::StraightLaserChip(const char* prm_name, const char* prm_model) :
                    LaserChip(prm_name, prm_model) {
                //    _pPosSourceActor = NULL;
                //    _pAngleSourceActor = NULL;
                
                    _pSource_X = &_X;
                    _pSource_Y = &_Y;
                    _pSource_Z = &_Z;
                    _pSource_RX = &_RX;
                    _pSource_RY = &_RY;
                    _pSource_RZ = &_RZ;
                    _pSource_vX = &_pKuroko->_vX;
                    _pSource_vY = &_pKuroko->_vY;
                    _pSource_vZ = &_pKuroko->_vZ;
                    _veloMv = 100000;
                
                }
                
                void StraightLaserChip::initialize() {
                    //[U[`bvI[o[Cg\
                    _fAlpha = 0.99;
                }
                
                void StraightLaserChip::onActive() {
                    LaserChip::onActive();
                }
                
                void StraightLaserChip::onInactive() {
                    LaserChip::onInactive();
                }
                
                void StraightLaserChip::processBehavior() {
                    LaserChip::processBehavior();
                
                    _RX = (*_pSource_RX);
                    _RY = (*_pSource_RY);
                    _RZ = (*_pSource_RZ);
                    _X = (*_pSource_X) + ((*_pSource_vX) * _veloMv * (int)getActivePartFrame());
                    //_TRACE_("(*_pSource_X)="<<(*_pSource_X)<<" (*_pSource_vX)="<<(*_pSource_vX)<<" _veloMv="<<_veloMv<<" getActivePartFrame()="<<getActivePartFrame()<<" _X="<<_X);
                    _Y = (*_pSource_Y) + ((*_pSource_vY) * _veloMv * (int)getActivePartFrame());
                    _Z = (*_pSource_Z) + ((*_pSource_vZ) * _veloMv * (int)getActivePartFrame());
                
                    //Wf
                    //_pKuroko->behave();
                /*
                    //n_
                    static int centerX, centerY, centerZ;
                    if (_pChip_front) {
                      centerX = (_X - _pChip_front->_X) / 2;
                      centerY = (_Y - _pChip_front->_Y) / 2;
                      centerZ = (_Z - _pChip_front->_Z) / 2;
                      _pCollisionChecker->setColliAAB(
                                      1,
                                      centerX - 30000,
                                      centerY - 30000,
                                      centerZ - 30000,
                                      centerX + 30000,
                                      centerY + 30000,
                                      centerZ + 30000
                                 ); //
                      _pCollisionChecker->getHitAreaBoxs()->enable(1);
                    } else {
                      _pCollisionChecker->getHitAreaBoxs()->disable(1);
                
                    }
                */
                
                }
                
                void StraightLaserChip::processSettlementBehavior() {
                    if (_was_paused_flg) {
                        GgafDx9GeometricActor::processSettlementBehavior();
                    } else {
                        LaserChip::processSettlementBehavior();
                    }
                }
                
                void StraightLaserChip::processJudgement() {
                    LaserChip::processJudgement();
                
                }
                
                
          60 -> StraightLaserChip::~StraightLaserChip() {
                
                }
                


Top 10 Lines:

     Line      Count

        8         60
       91         60

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      120   Total number of line executions
    40.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/actor/DefaultMeshActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
           3 -> DefaultMeshActor::DefaultMeshActor(const char* prm_name, const char* prm_model) :
                    GgafDx9MeshActor(prm_name,
                                     prm_model,
                                     "DefaultMeshEffect",
                                     "DefaultMeshTechnique",
                                     NEW CollisionChecker(this) ) {
                
                    _class_name = "DefaultMeshActor";
                    _frame_offset = 0;
                    _pCollisionChecker = (CollisionChecker*)_pChecker;
                    _pScaler = NEW GgafDx9Scaler(this);
                }
                
                void DefaultMeshActor::drawHitArea() {
                    ColliAABActor::get()->drawHitarea(_pCollisionChecker); ColliAAPrismActor::get()->drawHitarea(_pCollisionChecker); ColliSphereActor::get()->drawHitarea(_pCollisionChecker);
                }
                
           3 -> DefaultMeshActor::~DefaultMeshActor() {
                    DELETE_IMPOSSIBLE_NULL(_pCollisionChecker);
                    DELETE_IMPOSSIBLE_NULL(_pScaler);
                }


Top 10 Lines:

     Line      Count

        7          3
       24          3

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        6   Total number of line executions
     2.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/actor/DefaultSpriteSetActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
         173 -> DefaultSpriteSetActor::DefaultSpriteSetActor(const char* prm_name, const char* prm_model_id) :
                    GgafDx9SpriteSetActor(prm_name,
                                          prm_model_id,
                                          "DefaultSpriteSetEffect",
                                          "DefaultSpriteSetTechnique",
                                          NEW CollisionChecker(this) ) {
                    _class_name = "DefaultSpriteSetActor";
                    _frame_offset = 0;
                    _pCollisionChecker = (CollisionChecker*)_pChecker;
                    _pScaler = NEW GgafDx9Scaler(this);
                    setZWriteEnable(false);
                }
                
                void DefaultSpriteSetActor::drawHitArea() {
                    ColliAABActor::get()->drawHitarea(_pCollisionChecker); ColliAAPrismActor::get()->drawHitarea(_pCollisionChecker); ColliSphereActor::get()->drawHitarea(_pCollisionChecker);
                }
                
                
         173 -> DefaultSpriteSetActor::~DefaultSpriteSetActor() {
                    DELETE_IMPOSSIBLE_NULL(_pCollisionChecker);
                    DELETE_IMPOSSIBLE_NULL(_pScaler);
                }


Top 10 Lines:

     Line      Count

        7        173
       25        173

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      346   Total number of line executions
   115.33   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/actor/laserchip/CurveLaserChip.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
                
         720 -> CurveLaserChip::CurveLaserChip(const char* prm_name, const char* prm_model) :
                    LaserChip(prm_name, prm_model) {
                    _class_name = "CurveLaserChip";
                    _tmpX = 0;
                    _tmpY = 0;
                    _tmpZ = 0;
                }
                
                void CurveLaserChip::initialize() {
                    //B
                    //30px/frame x
                    //B
                    //0.99
                    //ApNXAI[o[ChB
                    _pKuroko->setMvVelo(30000);
                    _fAlpha = 0.99;
                }
                
                
                void CurveLaserChip::onActive() {
                    //[U[`bvo
                    //ApNXAI[o[ChB
                    // A{NX onActive() \bhoB
                    LaserChip::onActive();
                    _tmpX = _X;
                    _tmpY = _Y;
                    _tmpZ = _Z;
                }
                
                void CurveLaserChip::onInactive() {
                    //[U[`bv
                    //ApNXAI[o[ChB
                    // A{NX onInactive() \bhoB
                    LaserChip::onInactive();
                }
                
                void CurveLaserChip::processBehavior() {
                    LaserChip::processBehavior();
                    _pKuroko->behave();
                    //WRs[
                    _tmpX = _X;
                    _tmpY = _Y;
                    _tmpZ = _Z;
                }
                void CurveLaserChip::processSettlementBehavior() {
                    //WB([U[m[}CYj
                    //processSettlementBehavior() \bh`WB
                    //{ processBehaviorAfter() IAS[U[`bv
                    //dprocessSettlementBehavior()HB
                    //{NXpApNXprocessSettlementBehavior()AoB
                    if (_was_paused_flg) {
                        GgafDx9GeometricActor::processSettlementBehavior();
                    } else {
                        if (_pChip_front == NULL) {
                            //[
                            if (_pChip_behind != NULL && _pChip_behind->isActiveActor()) {
                                //[
                            } else {
                                //[[
                                //
                            }
                        } else if (_pChip_behind == NULL) {
                            //[
                            if (_pChip_front != NULL && _pChip_front->isActiveActor()) {
                                //[
                
                            } else {
                                //[[
                                //
                            }
                        } else if (_pChip_front->isActiveActor() && _pChip_behind->isActiveActor()) {
                            //_pChip_behind == NULL B_pChip_behind->isActiveActor()
                            //employu_pChip_behind != NULL Aactive()Lt[
                            //_X,_Y,_Z lB
                            CurveLaserChip* pF = (CurveLaserChip*)_pChip_front;
                            CurveLaserChip* pB = (CurveLaserChip*)_pChip_behind;
                            //W
                            _X = (pF->_tmpX + _tmpX + pB->_tmpX) / 3;
                            _Y = (pF->_tmpY + _tmpY + pB->_tmpY) / 3;
                            _Z = (pF->_tmpZ + _tmpZ + pB->_tmpZ) / 3;
                            _pKuroko->_veloVxMv = (pF->_pKuroko->_veloVxMv + _pKuroko->_veloVxMv + pB->_pKuroko->_veloVxMv) / 3;
                            _pKuroko->_veloVyMv = (pF->_pKuroko->_veloVyMv + _pKuroko->_veloVyMv + pB->_pKuroko->_veloVyMv) / 3;
                            _pKuroko->_veloVzMv = (pF->_pKuroko->_veloVzMv + _pKuroko->_veloVzMv + pB->_pKuroko->_veloVzMv) / 3;
                        }
                        LaserChip::processSettlementBehavior();
                    }
                }
                
                void CurveLaserChip::processJudgement() {
                    LaserChip::processJudgement();
                    //GgafDx9Util::setWorldMatrix_RxRzRyScMv(this, _matWorld);
                }
                
         720 -> CurveLaserChip::~CurveLaserChip() {
                }
                


Top 10 Lines:

     Line      Count

        8        720
      101        720

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

     1440   Total number of line executions
   480.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/actor/laserchip/LaserChip.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
                
        2418 -> LaserChip::LaserChip(const char* prm_name, const char* prm_model) :
                     GgafDx9MeshSetActor(prm_name,
                                         string("11/" + string(prm_model)).c_str(),
                                         "LaserChipEffect",
                                         "LaserChipTechnique",
                                         NEW CollisionChecker(this) ) {
                    _pMeshSetModel->_set_num = 11; //[U[Zbg11B
                    _obj_class |= Obj_LaserChip;
                    _pCollisionChecker = (CollisionChecker*)_pChecker;
                    _class_name = "LaserChip";
                    _pChip_front = NULL;
                    _pChip_behind = NULL;
                    _pDispatcher = NULL; //LaserChipDispatcher new B
                    _chip_kind = 1;
                    _is_regist_hitarea = false;
                    _hitarea_edge_length = 0;
                    _harf_hitarea_edge_length = 0;
                    _can_chikei_hit = false;
                    _ahKind[0]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_kind001" );
                    _ahKind[1]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_kind002" );
                    _ahKind[2]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_kind003" );
                    _ahKind[3]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_kind004" );
                    _ahKind[4]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_kind005" );
                    _ahKind[5]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_kind006" );
                    _ahKind[6]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_kind007" );
                    _ahKind[7]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_kind008" );
                    _ahKind[8]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_kind009" );
                    _ahKind[9]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_kind010" );
                    _ahKind[10] = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_kind011" );
                //    _ahKind[11] = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_kind012" );
                //    _ahKind[12] = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_kind013" );
                //    _ahKind[13] = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_kind014" );
                //    _ahKind[14] = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_kind015" );
                //    _ahKind[15] = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_kind016" );
                
                    _ah_matWorld_front[0]   = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld_front001" );
                    _ah_matWorld_front[1]   = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld_front002" );
                    _ah_matWorld_front[2]   = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld_front003" );
                    _ah_matWorld_front[3]   = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld_front004" );
                    _ah_matWorld_front[4]   = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld_front005" );
                    _ah_matWorld_front[5]   = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld_front006" );
                    _ah_matWorld_front[6]   = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld_front007" );
                    _ah_matWorld_front[7]   = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld_front008" );
                    _ah_matWorld_front[8]   = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld_front009" );
                    _ah_matWorld_front[9]   = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld_front010" );
                    _ah_matWorld_front[10]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld_front011" );
                //    _ah_matWorld_front[11]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld_front012" );
                //    _ah_matWorld_front[12]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld_front013" );
                //    _ah_matWorld_front[13]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld_front014" );
                //    _ah_matWorld_front[14]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld_front015" );
                //    _ah_matWorld_front[15]  = _pMeshSetEffect->_pID3DXEffect->GetParameterByName( NULL, "g_matWorld_front016" );
                
                    setZEnable(true);        //Zobt@lL
                    setZWriteEnable(false);  //Zobt@
                }
                
                void LaserChip::executeHitChk_MeAnd(GgafActor* prm_pOtherActor) {
                    if (prm_pOtherActor->_obj_class & Obj_WallActor) {
                        if (_chip_kind != 2 || _can_chikei_hit) {
                            GgafDx9DrawableActor::executeHitChk_MeAnd(prm_pOtherActor);
                        } else {
                            return;
                        }
                    } else {
                        GgafDx9DrawableActor::executeHitChk_MeAnd(prm_pOtherActor);
                    }
                }
                
                
                //void LaserChip::onCreateModel() {
                //    _pMeshSetModel->_set_num = 11; //[U[Zbg11B
                //    _TRACE_("LaserChip::onCreateModel() "<<_pMeshSetModel->getName()<<" Zbg "<< _pMeshSetModel->_set_num<<" B");
                //}
                
                void LaserChip::initialize() {
                    //_TRACE_("LaserChip::initialize() "<<getName()<<" bump="<<canHit());
                    _pKuroko->setMvVelo(40000);
                    _fAlpha = 0.99;
                }
                
                
                void LaserChip::onActive() {
                    //_TRACE_("LaserChip::onActive()st "<<getName()<<" bump="<<canHit());
                //    _TRACE_("LaserChip::onActive() !!"<<getName()<<"/_is_active_flg_in_next_frame="<<_is_active_flg_in_next_frame<<
                //            "/_on_change_to_active_flg="<<_on_change_to_active_flg<<
                //            "/_on_change_to_inactive_flg="<<_on_change_to_inactive_flg<<
                //            "/_is_active_flg="<<_is_active_flg);
                //    _TRACE_("LaserChip::onActive() _frame_of_behaving_from_onActive = 0;!!!"<<getName()<<"");
                    //o
                    _chip_kind = 1;
                    if (_pChip_front == NULL) {
                //        if (_pDispatcher->_pSeConnection) {
                //            _pDispatcher->_pSeConnection->refer()->play();
                //            //_TRACE_("LaserChip::onActive() _pChip_front == NULL!!");
                //        }
                    } else {
                        //_TRACE_("LaserChip::onActive() _pChip_front == "<<(_pChip_front->getName())<<"");
                    }
                
                    _pDispatcher->_num_chip_active++;
                
                
                    //_TRACE_("LaserChip::onActive()ed "<<getName()<<" bump="<<canHit());
                }
                
                void LaserChip::processBehavior() {
                    //_TRACE_("LaserChip::processBehavior()ed "<<getName()<<" bump="<<canHit());
                }
                
                
                
                
                void LaserChip::processSettlementBehavior() {
                    //O`bvAIL
                    //processBehavior()sBA_pChip_front WB
                
                    int dX, dY, dZ,cX, cY, cZ,h;
                    //_TRACE_("LaserChip::processBehavior()st "<<getName()<<" bump="<<canHit());
                    if (_is_regist_hitarea) { //registHitAreaCube\bho^B
                        if (_pChip_front != NULL) {
                            dX = _pChip_front->_X - _X;
                            dY = _pChip_front->_Y - _Y;
                            dZ = _pChip_front->_Z - _Z;
                            if (GgafUtil::abs(dX) >= _hitarea_edge_length*3 || GgafUtil::abs(dY) >= _hitarea_edge_length*3 || GgafUtil::abs(dZ) >= _hitarea_edge_length*3) {
                                //gO`bvo
                                cX = dX / 2;
                                cY = dY / 2;
                                cZ = dZ / 2;
                                h = _hitarea_edge_length / 2;
                                _pCollisionChecker->setColliAAB(
                                              1,
                                              cX - _harf_hitarea_edge_length,
                                              cY - _harf_hitarea_edge_length,
                                              cZ - _harf_hitarea_edge_length,
                                              cX + _harf_hitarea_edge_length,
                                              cY + _harf_hitarea_edge_length,
                                              cZ + _harf_hitarea_edge_length
                                              );
                                _pCollisionChecker->enable(1);
                            } else {
                                _pCollisionChecker->disable(1);
                            }
                //            //L
                //            if (abs(dX) >= _hitarea_edge_length*5 || abs(dY) >= _hitarea_edge_length*5 || abs(dZ) >= _hitarea_edge_length*5) {
                //                sayonara();
                //            }
                        } else {
                            _pCollisionChecker->disable(1);
                        }
                    }
                
                
                    //[U[`bv B
                    //VF[_[p[^B
                    //
                    //      -==========<>            [U[
                    //
                    //      -= === === === <>        fB
                    //
                    //    | -=|===|===|===|<> |     }[U[IuWFNg}
                    //
                    //    <--><--><--><--><-->^
                    //    ^   ^   ^   ^   ^   |
                    //    |   |   |   |   |   |
                    //    |   |   |   |   |    `----- 4:[`bv(\A`bv\)
                    //    |   |   |   |    `----- 3:`bv(\)
                    //    |   |   |    `----- 2:`bv
                    //    |   |    `----- 2:`bv
                    //    |    `----- 2:`bv
                    //     `----- 1:`bv
                    //
                    //[tB
                    setHitAble(true);
                    if (_pChip_front) {
                        if (_pChip_behind) {
                            if (_pChip_behind->isActiveActor()) {
                                if (_pChip_front->_pChip_front) {
                                    _chip_kind = 2; //eNX``bv
                                } else {
                                    _chip_kind = 3; //eNX``bv
                                }
                            } else {
                                _chip_kind = 1; //[eNX``bv
                            }
                        } else {
                            _chip_kind = 1; //[eNX`
                        }
                    } else {
                        _chip_kind = 4; //[`bvB`
                        setHitAble(false);
                    }
                
                    GgafDx9MeshSetActor::processSettlementBehavior(); //Wo^
                    //TODO:Wo^processSettlementBehavior()oB
                    //XVprocessSettlementBehaviorWo^B
                
                }
                
                void LaserChip::processJudgement() {
                    if (_chip_kind == 4 && _pChip_behind == NULL) {
                        sayonara();
                    }
                    //_TRACE_("LaserChip::processJudgement()st "<<getName()<<" bump="<<canHit());
                    if (isOutOfUniverse()) {
                        sayonara();
                    }
                }
                
                void LaserChip::processPreDraw() {
                    if (_chip_kind < 4) {
                        //4O\
                        GgafDx9DrawableActor::processPreDraw();
                    }
                }
                
                void LaserChip::processDraw() {
                    _draw_set_num = 0; //GgafDx9MeshSetActorfeNjbN
                                       //AJEgB`[xx`B
                    ID3DXEffect* pID3DXEffect = _pMeshSetEffect->_pID3DXEffect;
                    HRESULT hr;
                    //{f_
                    GgafDx9DrawableActor* pDrawActor = this;
                    LaserChip* pLaserChip;
                    while (true) {
                        if (pDrawActor)  {
                            if (pDrawActor->_pGgafDx9Model == _pMeshSetModel && pDrawActor->_hash_technique == _hash_technique) {
                                pLaserChip = (LaserChip*)pDrawActor;
                
                                //sG[A
                                //GgafDx9SpriteLaserChipActor[MEMO]I
                                if (pLaserChip->_pChip_front) {
                                    //g[hs
                                    hr = pID3DXEffect->SetMatrix(_pMeshSetEffect->_ah_matWorld[_draw_set_num], &(pLaserChip->_matWorld));
                                    checkDxException(hr, D3D_OK, "LaserChip::processDraw() SetMatrix(g_matWorld) sB");
                                    //O[hs
                                    hr = pID3DXEffect->SetMatrix(this->_ah_matWorld_front[_draw_set_num], &(pLaserChip->_pChip_front->_matWorld));
                                    checkDxException(hr, D3D_OK, "LaserChip::processDraw() SetMatrix(_h_matWorld_front) sB1");
                                    //`bv
                                    hr = pID3DXEffect->SetInt(this->_ahKind[_draw_set_num], pLaserChip->_chip_kind);
                                    checkDxException(hr, D3D_OK, "LaserChip::processDraw() SetInt(_hKind) sB2");
                                } else {
                                    //[`bv`sv
                                    pDrawActor = pDrawActor->_pNext_TheSameDrawDepthLevel;
                                    continue;
                                }
                
                                _draw_set_num++;
                                if (_draw_set_num >= _pMeshSetModel->_set_num) {
                                    break;
                                }
                                pDrawActor = pDrawActor->_pNext_TheSameDrawDepthLevel;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    GgafDx9Universe::_pActor_DrawActive = pLaserChip; //`ZbgAN^[Zbg
                    if (_draw_set_num > 0) { //`\Kv
                        _pMeshSetModel->draw(this, _draw_set_num);
                    }
                }
                
                void LaserChip::drawHitArea() {
                    //_TRACE_("LaserChip::drawHitArea()st "<<getName()<<" bump="<<canHit());
                    ColliAABActor::get()->drawHitarea(_pCollisionChecker); ColliAAPrismActor::get()->drawHitarea(_pCollisionChecker); ColliSphereActor::get()->drawHitarea(_pCollisionChecker);
                    //_TRACE_("LaserChip::drawHitArea()ed "<<getName()<<" bump="<<canHit());
                }
                
                void LaserChip::onHit(GgafActor* prm_pOtherActor) {
                }
                
                void LaserChip::onInactive() {
                
                    //
                    _pDispatcher->_num_chip_active--;
                    //Oqf
                    if (_pChip_front) {
                        _pChip_front->_pChip_behind = NULL;
                    }
                    _pChip_front = NULL;
                    if (_pChip_behind) {
                        _pChip_behind->_pChip_front = NULL;
                    }
                    _pChip_behind = NULL;
                
                
                
                
                
                
                
                
                
                
                
                    //_TRACE_("LaserChip::onInactive()st "<<getName()<<" bump="<<canHit());
                //    _TRACE_("LaserChip::onInactive() !!"<<getName()<<"/_is_active_flg_in_next_frame="<<_is_active_flg_in_next_frame<<
                //            "/_on_change_to_active_flg="<<_on_change_to_active_flg<<
                //            "/_on_change_to_inactive_flg="<<_on_change_to_inactive_flg<<
                //            "/_is_active_flg="<<_is_active_flg);
                    //
                
                    //[U[`bv B
                    //VF[_[p[^B
                    //
                    //      -==========<>            [U[
                    //
                    //      -= === === === <>        fB
                    //
                    //    | -=|===|===|===|<> |     }[U[IuWFNg}
                    //
                    //    <--><--><--><--><-->^
                    //     ^   ^   ^   ^   ^  |
                    //     |   |   |   |   |  |
                    //     |   |   |   |   |   `----- 4:[`bv(\A`bv\)
                    //     |   |   |   |    `----- 3:`bv(\)
                    //     |   |   |    `----- 2:`bv
                    //     |   |    `----- 2:`bv
                    //     |    `----- 2:`bv
                    //      `----- 1:`bv
                
                    //WI}OAN
                
                    //p^[A
                    //
                    //    | -=|<> |
                    //
                    //    <--><-->^
                    //     ^   ^  |
                    //     |   |  |
                    //     |   |   `----- 4:[`bv
                    //     |    `----- 3:`bv
                    //      `----- 1:`bv
                
                    //p^[B
                    //
                    //    | -=|
                    //
                    //    <-->^
                    //     ^  |
                    //     |  |
                    //     |   `----- 4:[`bv
                    //      `----- 1:`bv(2:`bv)
                
                
                    //p^[C
                    //
                    //    |     }[[U[IuWFNg(A\B)
                    //
                    //    ^
                    //    |
                    //     `----- 4:[`bv(1:`bv)
                
                
                //    if (_pChip_front) {
                //        if (_pChip_behind) {
                //            if (_pChip_behind->isActiveActor()) {
                //                if (_pChip_front->_pChip_front) {
                //                    _chip_kind = 2; //eNX``bv
                //                } else {
                //                    _chip_kind = 3; //eNX``bv
                //                }
                //            } else {
                //                _chip_kind = 1; //[eNX``bv
                //            }
                //        } else {
                //            _chip_kind = 1; //[eNX`
                //        }
                //    } else {
                //        _chip_kind = 4; //[`bv
                //    }
                ////_TRACE_("_chip_kind="<<_chip_kind<<" _pChip_behind="<<_pChip_behind<<"/_pChip_front="<<_pChip_front);
                //    if (_chip_kind == 4) {
                //        //[
                //        if (_pChip_behind) {
                //            //p^[CO
                //            _pChip_behind->_pChip_front = NULL;
                //            _pChip_front = NULL;
                //            _pChip_behind = NULL;
                //        } else {
                //            //p^[C
                //            _pChip_front = NULL;
                //            _pChip_behind = NULL;
                //        }
                //
                //        _pDispatcher->_num_chip_active--;
                //    } else if (_chip_kind == 3) {
                //        //[A[
                //        if (_pChip_front) {
                //            _pChip_front->inactivateImmediately();
                //            _pChip_front->_pChip_front = NULL;
                //            _pChip_front->_pChip_behind = NULL;
                //            _pChip_front = NULL;
                //        }
                //        activateImmediately();
                //        _pDispatcher->_num_chip_active--;
                //    } else if (_chip_kind == 2) {
                //        //
                //        activateImmediately(); //active
                //        if (_pChip_front) {
                //            _pChip_front->_pChip_behind = NULL;
                //        }
                //        if (_pChip_behind) {
                //            _pChip_behind->_pChip_front = NULL;
                //        }
                //        _pChip_front = NULL;
                //        _pChip_behind = NULL;
                //        //_pDispatcher->_num_chip_active 
                //    } else if (_chip_kind == 1) {
                //        if (_pChip_front) {
                //            _pChip_front->_pChip_behind = NULL;
                //        }
                //        _pChip_front = NULL;
                //        _pChip_behind = NULL;
                //        _pDispatcher->_num_chip_active--;
                //    }
                }
                
                void LaserChip::registHitAreaCube(int prm_edge_length) {
                    //_TRACE_("LaserChip::registHitAreaCube()st "<<getName()<<" bump="<<canHit());
                    //[U[`bvI[o[Cg\
                    _is_regist_hitarea = true;
                    _hitarea_edge_length = prm_edge_length;
                    _harf_hitarea_edge_length = _hitarea_edge_length / 2;
                    _pCollisionChecker->makeCollision(2);
                    _pCollisionChecker->setColliAAB_Cube(0, prm_edge_length);
                    _pCollisionChecker->setColliAAB_Cube(1, prm_edge_length);
                    _pCollisionChecker->disable(1);
                    setHitAble(true);
                    //_TRACE_("LaserChip::registHitAreaCube()ed "<<getName()<<" bump="<<canHit());
                
                }
                
        2418 -> LaserChip::~LaserChip() {
                    DELETE_IMPOSSIBLE_NULL(_pCollisionChecker);
                
                }
                


Top 10 Lines:

     Line      Count

        8       2418
      443       2418

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

     4836   Total number of line executions
  1612.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/actor/laserchip/HomingLaserChip.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
                
        1638 -> HomingLaserChip::HomingLaserChip(const char* prm_name, const char* prm_model) :
                    LaserChip(prm_name, prm_model) {
                    _class_name = "HomingLaserChip";
                    _is_leader = false;
                }
                
                void HomingLaserChip::initialize() {
                    //B
                    //30px/frame x
                    //B
                    //0.99
                    //ApNXAI[o[ChB
                    _pKuroko->setMvVelo(30000);
                    _fAlpha = 0.99;
                }
                
                
                void HomingLaserChip::onActive() {
                    //ApNXAI[o[ChB
                    // A{NX onActive() \bhoB
                    LaserChip::onActive();
                    HomingLaserChip* pChip_front =  (HomingLaserChip*)_pChip_front;
                
                    //[U[`bvo
                    if (pChip_front == NULL) {
                        //_TRACE_("HomingLaserChip::onActive() "<<getName()<<" pChip_front == NULL");
                        _is_leader = true;
                        //g
                        _begining_X = _X;
                        _begining_Y = _Y;
                        _begining_Z = _Z;
                        _begining_RX = _RX;
                        _begining_RY = _RY;
                        _begining_RZ = _RZ;
                    } else {
                        _is_leader = false;
                        //_TRACE_("HomingLaserChip::onActive() "<<getName()<<" pChip_front =="<<(pChip_front->getName()));
                        _begining_X = pChip_front->_begining_X;
                        _begining_Y = pChip_front->_begining_Y;
                        _begining_Z = pChip_front->_begining_Z;
                        _begining_RX = pChip_front->_begining_RX;
                        _begining_RY = pChip_front->_begining_RY;
                        _begining_RZ = pChip_front->_begining_RZ;
                
                        _X = _begining_X;
                        _Y = _begining_Y;
                        _Z = _begining_Z;
                        _RX = _begining_RX;
                        _RY = _begining_RY;
                        _RZ = _begining_RZ;
                    }
                
                
                
                
                }
                
                void HomingLaserChip::onInactive() {
                
                
                
                    //[U[`bv
                    //      -==========<>            [U[
                    //
                    //      -= === === === <>        fB
                    //
                    //    | -=|===|===|===|<> |      }[U[IuWFNg}
                    //
                    //    <--><--><--><--><-->^
                    //    ^   ^   ^   ^   ^   |
                    //    |   |   |   |   |   |
                    //    |   |   |   |   |    `----- 4:[`bv(\A`bv\)
                    //    |   |   |   |    `----- 3:`bv(\)
                    //    |   |   |    `----- 2:`bv
                    //    |   |    `----- 2:`bv
                    //    |    `----- 2:`bv
                    //     `----- 1:`bv
                    //
                
                    //_TRACE_("A HomingLaserChip::onInactive() _chip_kind ="<<_chip_kind <<")");
                    if (_chip_kind == 1) {
                
                    } else if (_chip_kind == 2) {
                        //`bv
                        //g`bvA[U[\QB
                        //OO`bvAO]A`bv Mover p[^sB
                        //`bvV`bv[U[\O[v _pKuroko->behave() pA
                        //V`bvx`BKvB
                        if (_pChip_behind) {
                            int D = (int)(GgafUtil::sqrt_fast(
                                              (
                                                ((double)(_pChip_behind->_X - _X)) * ((double)(_pChip_behind->_X - _X))
                                              ) + (
                                                ((double)(_pChip_behind->_Y - _Y)) * ((double)(_pChip_behind->_Y - _Y))
                                              ) + (
                                                ((double)(_pChip_behind->_Z - _Z)) * ((double)(_pChip_behind->_Z - _Z))
                                              )
                                            )
                                         );
                            _pChip_behind->_pKuroko->setMvVelo(D); //x
                            _pChip_behind->_pKuroko->setMvAng(this);
                        } else {
                            //throwGgafCriticalException("HomingLaserChip::onInactive() _chip_kind == 2 A_pChip_behind");
                        }
                    } else if (_chip_kind == 3) {
                        //`bv
                        //wAB
                        //s`bvA`bv`BKvB
                        //[`bv Mover p[^xRs[OK
                        //vZx
                        if (_pChip_behind && _pChip_front) {
                            _pChip_behind->_pKuroko->_vX = _pChip_front->_pKuroko->_vX;
                            _pChip_behind->_pKuroko->_vY = _pChip_front->_pKuroko->_vY;
                            _pChip_behind->_pKuroko->_vZ = _pChip_front->_pKuroko->_vZ;
                            _pChip_behind->_pKuroko->_angRzMv = _pChip_front->_pKuroko->_angRzMv;
                            _pChip_behind->_pKuroko->_angRyMv = _pChip_front->_pKuroko->_angRyMv;
                            _pChip_behind->_pKuroko->_veloMv = _pChip_front->_pKuroko->_veloMv;
                        } else {
                            //throwGgafCriticalException("HomingLaserChip::onInactive() _chip_kind == 2 A_pChip_front  _pChip_behind ");
                        }
                    } else if (_chip_kind == 4) {
                        if (_pChip_behind) {
                            _pChip_behind->_pKuroko->_vX = _pKuroko->_vX;
                            _pChip_behind->_pKuroko->_vY = _pKuroko->_vY;
                            _pChip_behind->_pKuroko->_vZ = _pKuroko->_vZ;
                            _pChip_behind->_pKuroko->_angRzMv = _pKuroko->_angRzMv;
                            _pChip_behind->_pKuroko->_angRyMv = _pKuroko->_angRyMv;
                            _pChip_behind->_pKuroko->_veloMv = _pKuroko->_veloMv;
                        } else {
                            //throwGgafCriticalException("HomingLaserChip::onInactive() _chip_kind == 4 A_pChip_behind ");
                        }
                    }
                    LaserChip::onInactive(); //f
                }
                
                void HomingLaserChip::processBehavior() {
                    LaserChip::processBehavior();
                
                    //ApNXAI[o[ChB
                    // A{NX processBehavior() \bhoB
                    //Wf
                    HomingLaserChip* pChip_front =  (HomingLaserChip*)_pChip_front;
                    if (getActivePartFrame() > 1) {
                        //GgafActorDispatcher::employ() 
                        //A|C^AAN^[AN^[TuB
                        //A[U[processBehavior() A
                        //qB
                        if (pChip_front == NULL) {
                            //{`bvA`bv
                            _prev_X  = _X;
                            _prev_Y  = _Y;
                            _prev_Z  = _Z;
                            _prev_RX = _RX;
                            _prev_RY = _RY;
                            _prev_RZ = _RZ;
                
                            processBehaviorHeadChip(); //`bv
                        } else {
                
                            _prev_X  = _X;
                            _prev_Y  = _Y;
                            _prev_Z  = _Z;
                            _prev_RX = _RX;
                            _prev_RY = _RY;
                            _prev_RZ = _RZ;
                
                            _X  = pChip_front->_prev_X;
                            _Y  = pChip_front->_prev_Y;
                            _Z  = pChip_front->_prev_Z;
                            _RX = pChip_front->_prev_RX;
                            _RY = pChip_front->_prev_RY;
                            _RZ = pChip_front->_prev_RZ;
                        }
                    }
                }
                
                void HomingLaserChip::processSettlementBehavior() {
                    if (_was_paused_flg) {
                        GgafDx9GeometricActor::processSettlementBehavior();
                    } else {
                        LaserChip::processSettlementBehavior();
                    }
                }
                
                void HomingLaserChip::processJudgement() {
                    LaserChip::processJudgement();
                    //GgafDx9Util::setWorldMatrix_RxRzRyScMv(this, _matWorld);
                }
                
        1638 -> HomingLaserChip::~HomingLaserChip() {
                }
                


Top 10 Lines:

     Line      Count

        8       1638
      197       1638

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

     3276   Total number of line executions
  1092.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/actor/DefaultMeshSetActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
        1815 -> DefaultMeshSetActor::DefaultMeshSetActor(const char* prm_name, const char* prm_model) :
                    GgafDx9MeshSetActor(prm_name,
                                        prm_model,
                                        "DefaultMeshSetEffect",
                                        "DefaultMeshSetTechnique",
                                        NEW CollisionChecker(this) ) {
                
                    _class_name = "DefaultMeshSetActor";
                    _frame_offset = 0;
                    _pCollisionChecker = (CollisionChecker*)_pChecker;
                    _pScaler = NEW GgafDx9Scaler(this);
                }
                
                void DefaultMeshSetActor::drawHitArea() {
                    ColliAABActor::get()->drawHitarea(_pCollisionChecker); ColliAAPrismActor::get()->drawHitarea(_pCollisionChecker); ColliSphereActor::get()->drawHitarea(_pCollisionChecker);
                }
                
        1816 -> DefaultMeshSetActor::~DefaultMeshSetActor() {
                    DELETE_IMPOSSIBLE_NULL(_pCollisionChecker);
                    DELETE_IMPOSSIBLE_NULL(_pScaler);
                }


Top 10 Lines:

     Line      Count

       24       1816
        7       1815

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

     3631   Total number of line executions
  1210.33   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/actor/DefaultBoardActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
           2 -> DefaultBoardActor::DefaultBoardActor(const char* prm_name, const char* prm_model) :
                    GgafDx9BoardActor(prm_name, prm_model, "DefaultBoardEffect", "DefaultBoardTechnique")
                {
                    _class_name = "DefaultBoardActor";
                }
                
           2 -> DefaultBoardActor::~DefaultBoardActor() {
                }
                


Top 10 Lines:

     Line      Count

        7          2
       13          2

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        4   Total number of line executions
     1.33   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/actor/DefaultBoardSetActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
           3 -> DefaultBoardSetActor::DefaultBoardSetActor(const char* prm_name, const char* prm_model) :
                    GgafDx9BoardSetActor(prm_name, prm_model, "DefaultBoardSetEffect", "DefaultBoardSetTechnique")
                {
                    _class_name = "DefaultBoardSetActor";
                }
                
           3 -> DefaultBoardSetActor::~DefaultBoardSetActor() {
                }
                


Top 10 Lines:

     Line      Count

        7          3
       13          3

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        6   Total number of line executions
     2.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/actor/laserchip/LaserChipDispatcher.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
         108 -> LaserChipDispatcher::LaserChipDispatcher(const char* prm_name) : GgafActorDispatcher(prm_name) {
                    _class_name = "LaserChipDispatcher";
                    _num_continual_employ_count = 0;
                    _num_chip_active = 0;
                    _is_tear_laser = true;
                    _num_chip_max = 0;
                    _num_chip_interval = 1;
                    _pChip_prev_employ = NULL;
                    _frame_of_behaving_prev_employ = 0;
                
                    _num_interval_frame_count = _num_chip_interval; //C^[o
                    _num_continual_employ_max = _num_chip_max;
                    _pEffectActor_Irradiate = NULL;
                }
                
                void LaserChipDispatcher::config(int prm_num_continual_employ_max,
                                                 UINT32 prm_num_chip_interval,
                                                 GgafDx9Core::GgafDx9DrawableActor* prm_pEffectActor_Irradiate) {
                    _num_continual_employ_max = prm_num_continual_employ_max;
                    _num_chip_interval = prm_num_chip_interval;
                    _pEffectActor_Irradiate = prm_pEffectActor_Irradiate;
                    if (_pEffectActor_Irradiate) {
                        _pEffectActor_Irradiate->inactivateImmediately();
                    }
                }
                
                
                LaserChip* LaserChipDispatcher::employ() {
                    if (_num_continual_employ_count > _num_continual_employ_max) { //_num_continual_employ_maxAAe(_num_interval_frame_countZbg)B
                        _is_tear_laser = true;
                        _pChip_prev_employ = NULL;
                        _frame_of_behaving_prev_employ = 0;
                        _num_continual_employ_count = 0;
                        _num_interval_frame_count = 0;
                        return NULL;
                    } else if (_num_interval_frame_count < _num_chip_interval) { //_num_chip_intervalt[eB
                        _is_tear_laser = true;
                        _num_interval_frame_count++;
                        return NULL;
                    } else if (_is_tear_laser && _num_chip_max - _num_chip_active < _num_chip_max/4) { //e _num_chip_max/4 
                        _is_tear_laser = true;
                        _pChip_prev_employ = NULL;
                        _frame_of_behaving_prev_employ = 0;
                        _num_continual_employ_count = 0;
                        _num_interval_frame_count++;
                        return NULL;
                    } else {
                        LaserChip* pChip = (LaserChip*)GgafActorDispatcher::employ();
                        if (pChip) {
                //            pChip->activate();
                            if (_pChip_prev_employ) {
                                //Oemploy()`bv
                                if (_frame_of_behaving_prev_employ+1 == _pChip_prev_employ->getBehaveingFrame()) {
                                    //2t[AemployA
                                    _num_continual_employ_count++;
                                    pChip->_pChip_front = _pChip_prev_employ;
                                    _pChip_prev_employ->_pChip_behind = pChip;
                                    pChip->_pChip_behind = NULL;
                                    _is_tear_laser = false;
                                } else {
                                    //2t[AemployoA
                                    _num_continual_employ_count = 0;
                                    pChip->_pChip_front = NULL;
                                    pChip->_pChip_behind = NULL;
                                    //_pChip_prev_employ->_pChip_behind = NULL;
                                    _is_tear_laser = true;
                                }
                            } else {
                                //employ()
                                pChip->_pChip_front = NULL;
                                pChip->_pChip_behind = NULL;
                                _is_tear_laser = false;
                            }
                            _pChip_prev_employ = pChip;
                            _frame_of_behaving_prev_employ = pChip->getBehaveingFrame();
                            //20n`qbg`bv
                            if (_num_continual_employ_count % 20 == 0) {
                                pChip->_can_chikei_hit = true;
                            } else {
                                pChip->_can_chikei_hit = false;
                            }
                            return pChip;
                
                        } else {
                            //employ()^C~Oemploy()o
                            _num_continual_employ_count = 0;
                            _is_tear_laser = true;
                            _pChip_prev_employ = NULL;
                            _frame_of_behaving_prev_employ = 0;
                            _num_interval_frame_count++;
                            return NULL;
                        }
                    }
                }
                
                void LaserChipDispatcher::processFinal() {
                    //GtFNg\
                    if (_pEffectActor_Irradiate) {
                        if (_pChip_prev_employ && _frame_of_behaving_prev_employ == _pChip_prev_employ->getBehaveingFrame()) {
                            if (_pEffectActor_Irradiate->_is_active_flg == false) {
                                _pEffectActor_Irradiate->activate();
                            }
                        } else {
                            if (_pEffectActor_Irradiate->_is_active_flg) {
                                _pEffectActor_Irradiate->inactivate();
                            }
                        }
                    }
                }
                
                void LaserChipDispatcher::addSubLast(LaserChip* prm_pLaserChip) {
                    _num_chip_max ++;
                    _num_continual_employ_max++;
                    prm_pLaserChip->_pDispatcher = this;
                    GgafActorDispatcher::addSubLast(prm_pLaserChip);
                }
                
                void LaserChipDispatcher::onReset() {
                    _is_tear_laser = true;
                    _num_continual_employ_count = 0;
                    _num_chip_active = 0;
                    _frame_of_behaving_prev_employ = 0;
                    GgafActorDispatcher::onReset();
                }
                
         216 -> LaserChipDispatcher::~LaserChipDispatcher() {
                }


Top 10 Lines:

     Line      Count

      132        216
        7        108

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      324   Total number of line executions
   108.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/util/LinearOctreeForActor.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
                
           1 -> LinearOctreeForActor::LinearOctreeForActor(int prm_level) : GgafLinearOctree(prm_level) {
                }
                
                
                void LinearOctreeForActor::executeAllHitChk(actorkind prm_groupA, actorkind prm_groupB) {
                    _kind_groupA = prm_groupA;
                    _kind_groupB = prm_groupB;
                    TRACE5("_kind_groupA="<<_kind_groupA);
                    TRACE5("_kind_groupB="<<_kind_groupB);
                    if (((_paSpace[0]._kindinfobit & _kind_groupA) > 0) && ((_paSpace[0]._kindinfobit & _kind_groupB) > 0)) {
                        //s
                        executeHitChk(0); //
                        //AB
                        _stackParentSpaceActor_GroupA.clear();
                        _stackParentSpaceActor_GroupB.clear();
                    }
                }
                
                
                void LinearOctreeForActor::executeHitChk(UINT32 prm_index) {
                    TRACE5("InSpaceNo="<<prm_index);
                    LinearOctreeActorElem* pElem = ((LinearOctreeActorElem*)(_paSpace[prm_index]._pElemFirst));
                    if (pElem) {
                        GgafActor* pActor_ElemValue = pElem->_pActor;
                        TRACE5("pActor_ElemValue="<<pActor_ElemValue->getName());
                        while(true) {
                            if ((pElem->_kindbit & _kind_groupA) > 0) {
                                _stackCurrentSpaceActor_GroupA.push(pActor_ElemValue);
                            }
                            if ((pElem->_kindbit & _kind_groupB) > 0) {
                                _stackCurrentSpaceActor_GroupB.push(pActor_ElemValue);
                            }
                            if (pElem == _paSpace[prm_index]._pElemLast) {
                                break;
                            }
                            pElem = (LinearOctreeActorElem*)(pElem -> _pNext);
                            pActor_ElemValue = pElem->_pActor;
                        }
                        //O[vAO[vB
                        executeHitChk_RoundRobin(&_stackCurrentSpaceActor_GroupA, &_stackCurrentSpaceActor_GroupB);
                
                        //O[vAeO[vB
                        executeHitChk_RoundRobin(&_stackCurrentSpaceActor_GroupA, &_stackParentSpaceActor_GroupB );
                
                        //eO[vAO[vB
                        executeHitChk_RoundRobin(&_stackParentSpaceActor_GroupA , &_stackCurrentSpaceActor_GroupB);
                    }
                
                    UINT32 next_level_index = prm_index*8 + 1; //_papSpace[prm_index] q[gu0zvf
                    TRACE5("next_level_index="<<next_level_index);
                    if ( next_level_index > _num_space-1) {
                        //vfI[o[A[t
                        TRACE5("[Space");
                        _stackCurrentSpaceActor_GroupA.clear();
                        _stackCurrentSpaceActor_GroupB.clear();
                        return; //e
                    } else {
                        //BAOeAN^[X^bN(X^bNJ)
                        int add_num_GroupA, add_num_GroupB;
                        add_num_GroupA = add_num_GroupB = 0;
                        GgafActor* pActor;
                        while (true) {
                            pActor = _stackCurrentSpaceActor_GroupA.pop();
                            if (pActor == NULL) {
                                break;
                            } else {
                                _stackParentSpaceActor_GroupA.push(pActor);
                                add_num_GroupA++;
                            }
                        }
                        while (true) {
                            pActor = _stackCurrentSpaceActor_GroupB.pop();
                            if (pActor == NULL) {
                                break;
                            } else {
                                _stackParentSpaceActor_GroupB.push(pActor);
                                add_num_GroupB++;
                            }
                        }
                
                        //q
                        for(UINT32 i = next_level_index; i < next_level_index+8; i++) {
                            if (((_paSpace[i]._kindinfobit & _kind_groupA) > 0) || ((_paSpace[i]._kindinfobit & _kind_groupB) > 0)) {
                                executeHitChk(i);
                            }
                        }
                
                        //A
                        for (int i = 0; i < add_num_GroupA; i ++) {
                            _stackParentSpaceActor_GroupA.pop();
                        }
                        for (int i = 0; i < add_num_GroupB; i ++) {
                            _stackParentSpaceActor_GroupB.pop();
                        }
                        return; //e
                    }
                
                
                }
                
                void LinearOctreeForActor::executeHitChk_RoundRobin(CollisionStack* prm_pStackA, CollisionStack* prm_pStackB) {
                    //TEXT5("prm_pStackA:"); prm_pStackA->dump(); TEXT5("\n");
                    //TEXT5("prm_pStackB:"); prm_pStackB->dump(); TEXT5("\n");
                    //I
                    if (prm_pStackA->_p == 0 || prm_pStackB->_p == 0) {
                        return;
                    }
                    GgafActor* pActor_A;
                    GgafActor* pActor_B;
                    for (UINT32 i = 0; i < prm_pStackA->_p; i++) {
                        pActor_A = prm_pStackA->_apActor[i];
                        for (UINT32 j = 0; j < prm_pStackB->_p; j++) {
                            pActor_B = prm_pStackB->_apActor[j];
                //            if (GgafDx9Input::isBeingPressedKey(DIK_I)) {
                //                _TRACE_("HitChk("<<pActor_A->getName()<<" x "<<pActor_B->getName()<<")");
                //            }
                            pActor_A->executeHitChk_MeAnd(pActor_B);
                        }
                    }
                }
                
                
           2 -> LinearOctreeForActor::~LinearOctreeForActor() {
                }
                
                
                


Top 10 Lines:

     Line      Count

      130          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9LibStg/include/jp/ggaf/dx9libstg/util/LinearOctreeForActor.h:
                #ifndef LINEAROCTREEFORACTOR_H_
                #define LINEAROCTREEFORACTOR_H_
                namespace GgafDx9LibStg {
                
                /**
                 * GgafActorvf@\`zNX .
                 * AO[v  BO[v2O[vs
                 * @version 1.00
                 * @since 2009/11/23
                 * @author Masatoshi Tsuge
                 */
                class LinearOctreeForActor : public GgafCore::GgafLinearOctree {
                
                public:
                
                    /**
                     * AN^[X^bN .
                     * lX^bN
                     */
                    class CollisionStack {
                    public:
                        /**  3000 LW */
                        GgafCore::GgafActor* _apActor[3000];
                        /** J[\|C^  */
                        UINT32 _p;
                        /**
                         * RXgN^
                         * @return
                         */
           4 ->         CollisionStack() {
                            _p = 0;
                        }
                        /**
                         * X^bN .
                         * @param prm_pActor AN^[
                         */
                        inline void push(GgafCore::GgafActor* prm_pActor) {
                            if (_p > 3000-1) {
                                throwGgafCriticalException("LinearOctreeForActor::push("<<prm_pActor->getName()<<") X^bNgAB");
                            }
                            _apActor[_p] = prm_pActor;
                            _p++;
                        }
                        /**
                         * X^bNo .
                         * @return oAN^[
                         */
                        inline GgafCore::GgafActor* pop() {
                            if (_p == 0) {
                                return NULL;
                            } else {
                                _p--;
                                return _apActor[_p];
                            }
                        }
                        /**
                         * X^bNB .
                         */
                        inline void clear() {
                            _p = 0;
                        }
           4 ->         ~CollisionStack() {
                            clear();
                        }
                        void dump() {
                            TEXT5("CollisionStack.dump=");
                            for (UINT32 i = 0; i < _p; i++) {
                                TEXT5((_apActor[i]->getName())<<"->");
                            }
                            TEXT5("END");
                        }
                    };
                
                    /** SAAN^[AO[vX^bN */
                    CollisionStack _stackCurrentSpaceActor_GroupA;
                    /** SAAN^[BO[vX^bN */
                    CollisionStack _stackCurrentSpaceActor_GroupB;
                
                    /** AeSAN^[AO[vX^bN */
                    CollisionStack _stackParentSpaceActor_GroupA;
                    /** AeSAN^[BO[vX^bN */
                    CollisionStack _stackParentSpaceActor_GroupB;
                
                    /** sAN^[A */
                    actorkind _kind_groupA;
                    /** sAN^[B */
                    actorkind _kind_groupB;
                
                
                    /**
                     * RXgN^
                     * @param prm_level x
                     */
                    LinearOctreeForActor(int prm_level);
                
                    /**
                     * uAN^[AO[v  AN^[BO[vvs  .
                     * Av{\bhB
                     * @param prm_groupA AN^[AO[v
                     * @param prm_groupB AN^[BO[v
                     */
                    void executeAllHitChk(actorkind prm_groupA, actorkind prm_groupB);
                
                    /**
                     * s  .
                     * executeAllHitChk gpB
                     * @param prm_index `zzvf
                     */
                    void executeHitChk(UINT32 prm_index);
                
                    /**
                     * AN^[AO[vX^bNAAN^[BO[vX^bNs  .
                     * executeHitChk gpB
                     * @param prm_pStackA AN^[AO[vX^bN
                     * @param prm_pStackB AN^[BO[vX^bN
                     */
                    void executeHitChk_RoundRobin(CollisionStack* prm_pStackA, CollisionStack* prm_pStackB);
                
                
                    virtual ~LinearOctreeForActor();
                };
                
                
                }
                #endif /*LINEAROCTREEFORACTOR_H_*/
                


Top 10 Lines:

     Line      Count

       30          4
       62          4

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        8   Total number of line executions
     4.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/util/CollisionChecker.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
                int CollisionChecker::_num_check = 0;
                LinearOctreeForActor* CollisionChecker::_pLinearOctree = NULL;
        4645 -> CollisionChecker::CollisionChecker(GgafDx9GeometricActor* prm_pActor) : GgafDx9Checker(prm_pActor) {
                    if (CollisionChecker::_pLinearOctree == NULL) {
                        CollisionChecker::_pLinearOctree  = ((DefaultUniverse*)(GgafGod::_pGod->_pUniverse))->_pLinearOctree;
                    }
                    _pElem = NEW LinearOctreeActorElem(prm_pActor, 0);
                    _need_update_aabb = true;
                }
                
                void CollisionChecker::makeCollision(int prm_nColliPart) {
                    if (_pCollisionArea == NULL) {
                        _pCollisionArea = NEW GgafDx9CollisionArea(prm_nColliPart);
                    } else {
                        throwGgafCriticalException("CollisionChecker::makeCollision  makeCollision B");
                    }
                }
                
                void CollisionChecker::setColliSphere(int prm_index, int x, int y, int z, int r, bool rotX, bool rotY, bool rotZ) {
                #ifdef MY_DEBUG
                    if (_pCollisionArea == NULL) {
                        throwGgafCriticalException("CollisionChecker::setColli_AABB()["<<getTargetActor()->getName()<<"]   makeCollision sAvfB");
                    }
                    if (prm_index > _pCollisionArea->_nColliPart) {
                        throwGgafCriticalException("CollisionChecker::setColli_AABB()["<<getTargetActor()->getName()<<"]  vfCfbNX"<<prm_index<<"OB");
                    }
                #endif
                    if (_pCollisionArea->_papColliPart[prm_index] == NULL) {
                        _pCollisionArea->_papColliPart[prm_index] = NEW ColliSphere();
                    }
                #ifdef MY_DEBUG
                    if (_pCollisionArea->_papColliPart[prm_index]->_shape_kind != COLLI_SPHERE) {
                        throwGgafCriticalException("CollisionChecker::setColliSphere()["<<getTargetActor()->getName()<<"]  vfCfbNX"<<prm_index<<"SPHEREAXVB");
                    }
                #endif
                    ColliSphere* pSphere = (ColliSphere*)_pCollisionArea->_papColliPart[prm_index];
                    pSphere->_shape_kind = COLLI_SPHERE;
                    pSphere->_is_valid_flg = true;
                    pSphere->set(x, y, z, r, rotX, rotY, rotZ);
                    _need_update_aabb = true;
                }
                
                
                void CollisionChecker::setColliAAB(int prm_index,
                                                   int x1,
                                                   int y1,
                                                   int z1,
                                                   int x2,
                                                   int y2,
                                                   int z2,
                                                   bool rotX,
                                                   bool rotY,
                                                   bool rotZ) {
                #ifdef MY_DEBUG
                    if (_pCollisionArea == NULL) {
                        throwGgafCriticalException("CollisionChecker::setColliAAB()["<<getTargetActor()->getName()<<"]   makeCollision sAvfB");
                    }
                    if (prm_index > _pCollisionArea->_nColliPart) {
                        throwGgafCriticalException("CollisionChecker::setColliAAB()["<<getTargetActor()->getName()<<"]  vfCfbNX"<<prm_index<<"OB");
                    }
                #endif
                    if (_pCollisionArea->_papColliPart[prm_index] == NULL) {
                        _pCollisionArea->_papColliPart[prm_index] = NEW ColliAAB();
                    }
                #ifdef MY_DEBUG
                    if (_pCollisionArea->_papColliPart[prm_index]->_shape_kind != COLLI_AAB) {
                        throwGgafCriticalException("CollisionChecker::setColliAAB()["<<getTargetActor()->getName()<<"]  vfCfbNX"<<prm_index<<"AABBAXVB");
                    }
                #endif
                    ColliAAB* pAAB = (ColliAAB*)_pCollisionArea->_papColliPart[prm_index];
                    pAAB->_shape_kind = COLLI_AAB;
                    pAAB->_is_valid_flg = true;
                    pAAB->set(x1, y1, z1, x2, y2, z2, rotX, rotY, rotZ);
                    _need_update_aabb = true;
                }
                
                void CollisionChecker::setColliAAPrism(int prm_index,
                                                       int x1,
                                                       int y1,
                                                       int z1,
                                                       int x2,
                                                       int y2,
                                                       int z2,
                                                       int pos_prism,
                                                       bool rotX,
                                                       bool rotY,
                                                       bool rotZ) {
                #ifdef MY_DEBUG
                    if (_pCollisionArea == NULL) {
                        throwGgafCriticalException("CollisionChecker::setColliAAPrism()["<<getTargetActor()->getName()<<"]   makeCollision sAvfB");
                    }
                    if (prm_index > _pCollisionArea->_nColliPart) {
                        throwGgafCriticalException("CollisionChecker::setColliAAPrism()["<<getTargetActor()->getName()<<"]  vfCfbNX"<<prm_index<<"OB");
                    }
                #endif
                    if (_pCollisionArea->_papColliPart[prm_index] == NULL) {
                        _pCollisionArea->_papColliPart[prm_index] = NEW ColliAAPrism();
                    }
                #ifdef MY_DEBUG
                    if (_pCollisionArea->_papColliPart[prm_index]->_shape_kind != COLLI_AAPRISM) {
                        throwGgafCriticalException("CollisionChecker::setColliAAPrism()["<<getTargetActor()->getName()<<"]  vfCfbNX"<<prm_index<<"AAPRISMAXVB");
                    }
                #endif
                    ColliAAPrism* pAAPrism = (ColliAAPrism*)_pCollisionArea->_papColliPart[prm_index];
                    pAAPrism->_shape_kind = COLLI_AAPRISM;
                    pAAPrism->_is_valid_flg = true;
                    pAAPrism->set(x1, y1, z1, x2, y2, z2, pos_prism, rotX, rotY, rotZ);
                    _need_update_aabb = true;
                }
                
                
                void CollisionChecker::updateHitArea() {
                    if (_pActor == NULL || _pCollisionArea == NULL) {
                        return;
                    }
                    //if (_pActor->_can_hit_flg && _pActor->isActiveActor() && _pActor->isOutOfView() == 0 ) {  //Oo^
                    if (_pActor->_can_hit_flg && _pActor->isActiveActor() ) {
                        GgafDx9CollisionPart* pColliPart;
                        for (int i = 0; i < _pCollisionArea->_nColliPart; i++) {
                #ifdef MY_DEBUG
                            if (_pCollisionArea->_papColliPart[i] == NULL) {
                                throwGgafCriticalException("CollisionChecker::updateHitArea()["<<getTargetActor()->getName()<<"]  _papColliPart["<<i<<"]NULLB");
                            }
                #endif
                            pColliPart = _pCollisionArea->_papColliPart[i];
                
                            if (pColliPart->_rotX || pColliPart->_rotY || pColliPart->_rotZ) {
                                pColliPart->rotateRxRzRy(_pActor->_RX, _pActor->_RY, _pActor->_RZ);
                                _need_update_aabb = true;
                            }
                        }
                        if (_need_update_aabb) {
                            //OAABBXV
                            _pCollisionArea->updateAABB();
                            _need_update_aabb = false;
                        }
                
                        //Wo^I
                        _pElem->_kindbit = _pActor->getGroupActor()->_kind;
                        _pLinearOctree->registElem(_pElem, _pActor->_X + _pCollisionArea->_AABB_X1,
                                                           _pActor->_Y + _pCollisionArea->_AABB_Y1,
                                                           _pActor->_Z + _pCollisionArea->_AABB_Z1,
                                                           _pActor->_X + _pCollisionArea->_AABB_X2,
                                                           _pActor->_Y + _pCollisionArea->_AABB_Y2,
                                                           _pActor->_Z + _pCollisionArea->_AABB_Z2);
                
                #ifdef MY_DEBUG
                //        if (GgafDx9Input::isBeingPressedKey(DIK_I)) {
                //            _TRACE_("  CollisionChecker::updateHitArea()  registElem("<<(_pActor->getName())<<")=("<<
                //                                             (_pActor->_X + _pCollisionArea->_AABB_X1)<<","<<
                //                                             (_pActor->_Y + _pCollisionArea->_AABB_Y1)<<","<<
                //                                             (_pActor->_Z + _pCollisionArea->_AABB_Z1)<<","<<
                //                                             (_pActor->_X + _pCollisionArea->_AABB_X2)<<","<<
                //                                             (_pActor->_Y + _pCollisionArea->_AABB_Y2)<<","<<
                //                                             (_pActor->_Z + _pCollisionArea->_AABB_Z2)<<")");
                //            //_pLinearOctree->putTree();
                //
                //        }
                #endif
                    }
                }
                
                
                bool CollisionChecker::isHit(GgafDx9Core::GgafDx9Checker* prm_pOppChecker) {
                    CollisionChecker* pOppCChecker = (CollisionChecker*)prm_pOppChecker;
                    //TODO: 
                    //sAN^[
                    GgafDx9GeometricActor* pOppActor = pOppCChecker->getTargetActor();
                    //
                    GgafDx9CollisionArea* pOppCollisionArea = pOppCChecker->_pCollisionArea;
                
                //    if (_pCollisionArea == NULL || pOppCollisionArea == NULL ||
                //        _pActor->isOutOfView() > 0 || pOppActor->isOutOfView() > 0 ) {  //O
                
                    if (_pCollisionArea == NULL || pOppCollisionArea == NULL) {
                        return false;
                    }
                
                    GgafDx9CollisionPart* pColliPart;     //gvf
                    GgafDx9CollisionPart* pOppColliPart;  //vf
                
                    for (int i = 0; i < _pCollisionArea->_nColliPart; i++) {
                        pColliPart = _pCollisionArea->_papColliPart[i];
                        if (!pColliPart->_is_valid_flg) { continue; }
                
                        for (int j = 0; j < pOppCollisionArea->_nColliPart; j++) {
                            pOppColliPart = pOppCollisionArea->_papColliPart[j];
                            if (!pOppColliPart->_is_valid_flg) { continue; }
                #ifdef MY_DEBUG
                            CollisionChecker::_num_check++;
                #endif
                            if (pColliPart->_shape_kind == COLLI_AAB) {
                                if (pOppColliPart->_shape_kind == COLLI_AAB) {
                                    //AAB  AAB
                                    if (StgUtil::isHit(this        , _pActor  , (ColliAAB*)pColliPart,
                                                       pOppCChecker, pOppActor, (ColliAAB*)pOppColliPart)) {
                                        pOppCChecker->_blown_sgn_vX += -(this->_blown_sgn_vX);
                                        pOppCChecker->_blown_sgn_vY += -(this->_blown_sgn_vY);
                                        pOppCChecker->_blown_sgn_vZ += -(this->_blown_sgn_vZ);
                                        return true;
                                    }
                                 } else if (pOppColliPart->_shape_kind == COLLI_SPHERE) {
                                     //AAB  
                                     if (StgUtil::isHit(this        , _pActor  , (ColliAAB*)pColliPart,
                                                        pOppCChecker, pOppActor, (ColliSphere*)pOppColliPart)) {
                                         pOppCChecker->_blown_sgn_vX += -(this->_blown_sgn_vX);
                                         pOppCChecker->_blown_sgn_vY += -(this->_blown_sgn_vY);
                                         pOppCChecker->_blown_sgn_vZ += -(this->_blown_sgn_vZ);
                                         return true;
                                     }
                                 } else if (pOppColliPart->_shape_kind == COLLI_AAPRISM) {
                                     //AAB  AAPrism
                                     if (StgUtil::isHit(pOppCChecker, pOppActor, (ColliAAPrism*)pOppColliPart,
                                                        this        , _pActor  , (ColliAAB*)pColliPart)) {
                                         this->_blown_sgn_vX += -(pOppCChecker->_blown_sgn_vX);
                                         this->_blown_sgn_vY += -(pOppCChecker->_blown_sgn_vY);
                                         this->_blown_sgn_vZ += -(pOppCChecker->_blown_sgn_vZ);
                                         return true;
                                     }
                                 }
                
                            } else if (pColliPart->_shape_kind == COLLI_SPHERE) {
                                if (pOppColliPart->_shape_kind == COLLI_AAB) {
                                    //  AAB
                                    if (StgUtil::isHit(pOppCChecker, pOppActor, (ColliAAB*)pOppColliPart,
                                                       this        , _pActor  , (ColliSphere*)pColliPart)) {
                                        this->_blown_sgn_vX += -(pOppCChecker->_blown_sgn_vX);
                                        this->_blown_sgn_vY += -(pOppCChecker->_blown_sgn_vY);
                                        this->_blown_sgn_vZ += -(pOppCChecker->_blown_sgn_vZ);
                                        return true;
                                    }
                                } else if (pOppColliPart->_shape_kind == COLLI_SPHERE) {
                                    //  
                                    if (StgUtil::isHit(this        , _pActor  , (ColliSphere*)pColliPart,
                                                       pOppCChecker, pOppActor, (ColliSphere*)pOppColliPart)) {
                                        pOppCChecker->_blown_sgn_vX += -(this->_blown_sgn_vX);
                                        pOppCChecker->_blown_sgn_vY += -(this->_blown_sgn_vY);
                                        pOppCChecker->_blown_sgn_vZ += -(this->_blown_sgn_vZ);
                                        return true;
                                    }
                                } else if (pOppColliPart->_shape_kind == COLLI_AAPRISM) {
                                    //  AAPrism
                                    if (StgUtil::isHit(pOppCChecker, pOppActor, (ColliAAPrism*)pOppColliPart,
                                                       this        , _pActor  , (ColliSphere*)pColliPart)) {
                                        this->_blown_sgn_vX += -(pOppCChecker->_blown_sgn_vX);
                                        this->_blown_sgn_vY += -(pOppCChecker->_blown_sgn_vY);
                                        this->_blown_sgn_vZ += -(pOppCChecker->_blown_sgn_vZ);
                                        return true;
                                    }
                                }
                
                            } else if (pColliPart->_shape_kind == COLLI_AAPRISM) {
                                if (pOppColliPart->_shape_kind == COLLI_AAB) {
                                    //AAPrism  AAB
                                    if (StgUtil::isHit(this        , _pActor  , (ColliAAPrism*)pColliPart,
                                                       pOppCChecker, pOppActor, (ColliAAB*)pOppColliPart)) {
                                        pOppCChecker->_blown_sgn_vX += -(this->_blown_sgn_vX);
                                        pOppCChecker->_blown_sgn_vY += -(this->_blown_sgn_vY);
                                        pOppCChecker->_blown_sgn_vZ += -(this->_blown_sgn_vZ);
                                        return true;
                                    }
                                } else if (pOppColliPart->_shape_kind == COLLI_SPHERE) {
                                    //AAPrism  
                                    if (StgUtil::isHit(this        , _pActor  , (ColliAAPrism*)pColliPart,
                                                       pOppCChecker, pOppActor, (ColliSphere*)pOppColliPart)) {
                                        pOppCChecker->_blown_sgn_vX += -(this->_blown_sgn_vX);
                                        pOppCChecker->_blown_sgn_vY += -(this->_blown_sgn_vY);
                                        pOppCChecker->_blown_sgn_vZ += -(this->_blown_sgn_vZ);
                                        return true;
                                    }
                                }  else if (pOppColliPart->_shape_kind == COLLI_AAPRISM) {
                                   //AAPrism  AAPrism
                                   //TODO: dAlGB
                                   //lEEEBB
                                   return false;
                                }
                            }
                
                        } //for (int j = 0; j < pOppCollisionArea->_nColliPart; j++)
                
                    } //for (int i = 0; i < _pCollisionArea->_nColliPart; i++)
                    return false;
                }
                
                
                
        9294 -> CollisionChecker::~CollisionChecker() {
                    TRACE("CollisionChecker::~CollisionChecker() _pActor="<<_pActor->getName());
                    DELETE_IMPOSSIBLE_NULL(_pElem);
                    DELETE_POSSIBLE_NULL(_pCollisionArea);
                    //B_pElemBB
                }


Top 10 Lines:

     Line      Count

      293       9294
        9       4645

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

    13939   Total number of line executions
  4646.33   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9LibStg/include/jp/ggaf/dx9libstg/util/LinearOctreeActorElem.h:
                #ifndef LINEAROCTREEACTORELEM_H_
                #define LINEAROCTREEACTORELEM_H_
                namespace GgafDx9LibStg {
                
                /**
                 * GgafLinearOctreeElempvfNX .
                 * GgafActorvf
                 * @version 1.00
                 * @since 2009/11/23
                 * @author Masatoshi Tsuge
                 */
        9294 -> class LinearOctreeActorElem : public GgafCore::GgafLinearOctreeElem {
                public:
                    GgafCore::GgafActor* _pActor;
        4646 ->     LinearOctreeActorElem(GgafCore::GgafObject* prm_pObject, UINT32 prm_kindbit) : GgafCore::GgafLinearOctreeElem(prm_pObject,prm_kindbit) {
                        _pActor = (GgafCore::GgafActor*)prm_pObject;
                    }
                };
                
                
                }
                #endif /*LINEAROCTREEACTORELEM_H_*/
                


Top 10 Lines:

     Line      Count

       12       9294
       15       4646

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

    13940   Total number of line executions
  6970.00   Average executions per line


*** File c:/cygwin/mingw/bin/../lib/gcc/mingw32/4.5.2/include/c++/bits/hashtable.h:
                // hashtable.h header -*- C++ -*-
                
                // Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/hashtable.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                #ifndef _HASHTABLE_H
                #define _HASHTABLE_H 1
                
                #pragma GCC system_header
                
                #include <bits/hashtable_policy.h>
                
                namespace std
                {
                  // Class template _Hashtable, class definition.
                  
                  // Meaning of class template _Hashtable's template parameters
                  
                  // _Key and _Value: arbitrary CopyConstructible types.
                  
                  // _Allocator: an allocator type ([lib.allocator.requirements]) whose
                  // value type is Value.  As a conforming extension, we allow for
                  // value type != Value.
                
                  // _ExtractKey: function object that takes a object of type Value
                  // and returns a value of type _Key.
                  
                  // _Equal: function object that takes two objects of type k and returns
                  // a bool-like value that is true if the two objects are considered equal.
                  
                  // _H1: the hash function.  A unary function object with argument type
                  // Key and result type size_t.  Return values should be distributed
                  // over the entire range [0, numeric_limits<size_t>:::max()].
                  
                  // _H2: the range-hashing function (in the terminology of Tavori and
                  // Dreizin).  A binary function object whose argument types and result
                  // type are all size_t.  Given arguments r and N, the return value is
                  // in the range [0, N).
                  
                  // _Hash: the ranged hash function (Tavori and Dreizin). A binary function
                  // whose argument types are _Key and size_t and whose result type is
                  // size_t.  Given arguments k and N, the return value is in the range
                  // [0, N).  Default: hash(k, N) = h2(h1(k), N).  If _Hash is anything other
                  // than the default, _H1 and _H2 are ignored.
                  
                  // _RehashPolicy: Policy class with three members, all of which govern
                  // the bucket count. _M_next_bkt(n) returns a bucket count no smaller
                  // than n.  _M_bkt_for_elements(n) returns a bucket count appropriate
                  // for an element count of n.  _M_need_rehash(n_bkt, n_elt, n_ins)
                  // determines whether, if the current bucket count is n_bkt and the
                  // current element count is n_elt, we need to increase the bucket
                  // count.  If so, returns make_pair(true, n), where n is the new
                  // bucket count.  If not, returns make_pair(false, <anything>).
                  
                  // ??? Right now it is hard-wired that the number of buckets never
                  // shrinks.  Should we allow _RehashPolicy to change that?
                  
                  // __cache_hash_code: bool.  true if we store the value of the hash
                  // function along with the value.  This is a time-space tradeoff.
                  // Storing it may improve lookup speed by reducing the number of times
                  // we need to call the Equal function.
                  
                  // __constant_iterators: bool.  true if iterator and const_iterator are
                  // both constant iterator types.  This is true for unordered_set and
                  // unordered_multiset, false for unordered_map and unordered_multimap.
                  
                  // __unique_keys: bool.  true if the return value of _Hashtable::count(k)
                  // is always at most one, false if it may be an arbitrary number.  This
                  // true for unordered_set and unordered_map, false for unordered_multiset
                  // and unordered_multimap.
                  
                  template<typename _Key, typename _Value, typename _Allocator,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, 
                	   typename _RehashPolicy,
                	   bool __cache_hash_code,
                	   bool __constant_iterators,
                	   bool __unique_keys>
                    class _Hashtable
                    : public __detail::_Rehash_base<_RehashPolicy,
                				    _Hashtable<_Key, _Value, _Allocator,
                					       _ExtractKey,
                					       _Equal, _H1, _H2, _Hash,
                					       _RehashPolicy,
                					       __cache_hash_code,
                					       __constant_iterators,
                					       __unique_keys> >,
                      public __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,
                				       _H1, _H2, _Hash, __cache_hash_code>,
                      public __detail::_Map_base<_Key, _Value, _ExtractKey, __unique_keys,
                				 _Hashtable<_Key, _Value, _Allocator,
                					    _ExtractKey,
                					    _Equal, _H1, _H2, _Hash,
                					    _RehashPolicy,
                					    __cache_hash_code,
                					    __constant_iterators,
                					    __unique_keys> >,
                      public __detail::_Equality_base<_ExtractKey, __unique_keys,
                				      _Hashtable<_Key, _Value, _Allocator,
                						 _ExtractKey,
                						 _Equal, _H1, _H2, _Hash,
                						 _RehashPolicy,
                						 __cache_hash_code,
                						 __constant_iterators,
                						 __unique_keys> >
                    {
                    public:
                      typedef _Allocator                                  allocator_type;
                      typedef _Value                                      value_type;
                      typedef _Key                                        key_type;
                      typedef _Equal                                      key_equal;
                      // mapped_type, if present, comes from _Map_base.
                      // hasher, if present, comes from _Hash_code_base.
                      typedef typename _Allocator::pointer                pointer;
                      typedef typename _Allocator::const_pointer          const_pointer;
                      typedef typename _Allocator::reference              reference;
                      typedef typename _Allocator::const_reference        const_reference;
                
                      typedef std::size_t                                 size_type;
                      typedef std::ptrdiff_t                              difference_type;
                      typedef __detail::_Node_iterator<value_type, __constant_iterators,
                				       __cache_hash_code>
                                                                          local_iterator;
                      typedef __detail::_Node_const_iterator<value_type,
                					     __constant_iterators,
                					     __cache_hash_code>
                                                                          const_local_iterator;
                
                      typedef __detail::_Hashtable_iterator<value_type, __constant_iterators,
                					    __cache_hash_code>
                                                                          iterator;
                      typedef __detail::_Hashtable_const_iterator<value_type,
                						  __constant_iterators,
                						  __cache_hash_code>
                                                                          const_iterator;
                
                      template<typename _Key2, typename _Value2, typename _Ex2, bool __unique2,
                	       typename _Hashtable2>
                        friend struct __detail::_Map_base;
                
                    private:
                      typedef __detail::_Hash_node<_Value, __cache_hash_code> _Node;
                      typedef typename _Allocator::template rebind<_Node>::other
                                                                        _Node_allocator_type;
                      typedef typename _Allocator::template rebind<_Node*>::other
                                                                        _Bucket_allocator_type;
                
                      typedef typename _Allocator::template rebind<_Value>::other
                                                                        _Value_allocator_type;
                
                      _Node_allocator_type   _M_node_allocator;
                      _Node**                _M_buckets;
                      size_type              _M_bucket_count;
                      size_type              _M_element_count;
                      _RehashPolicy          _M_rehash_policy;
                      
                      _Node*
                      _M_allocate_node(const value_type& __v);
                  
                      void
                      _M_deallocate_node(_Node* __n);
                  
                      void
                      _M_deallocate_nodes(_Node**, size_type);
                
                      _Node**
                      _M_allocate_buckets(size_type __n);
                  
                      void
                      _M_deallocate_buckets(_Node**, size_type __n);
                
                    public:			    
                      // Constructor, destructor, assignment, swap
                      _Hashtable(size_type __bucket_hint,
                		 const _H1&, const _H2&, const _Hash&,
                		 const _Equal&, const _ExtractKey&,
                		 const allocator_type&);
                  
                      template<typename _InputIterator>
                        _Hashtable(_InputIterator __first, _InputIterator __last,
                		   size_type __bucket_hint,
                		   const _H1&, const _H2&, const _Hash&, 
                		   const _Equal&, const _ExtractKey&,
                		   const allocator_type&);
                  
                      _Hashtable(const _Hashtable&);
                
                      _Hashtable(_Hashtable&&);
                      
                      _Hashtable&
                      operator=(const _Hashtable&);
                
                      ~_Hashtable();
                
                      void swap(_Hashtable&);
                
                      // Basic container operations
                      iterator
                      begin()
                      {
                	iterator __i(_M_buckets);
                	if (!__i._M_cur_node)
                	  __i._M_incr_bucket();
                	return __i;
                      }
                
                      const_iterator
                      begin() const
                      {
                	const_iterator __i(_M_buckets);
                	if (!__i._M_cur_node)
                	  __i._M_incr_bucket();
                	return __i;
                      }
                
                      iterator
                      end()
                      { return iterator(_M_buckets + _M_bucket_count); }
                
                      const_iterator
                      end() const
                      { return const_iterator(_M_buckets + _M_bucket_count); }
                
                      const_iterator
                      cbegin() const
                      {
                	const_iterator __i(_M_buckets);
                	if (!__i._M_cur_node)
                	  __i._M_incr_bucket();
                	return __i;
                      }
                
                      const_iterator
                      cend() const
                      { return const_iterator(_M_buckets + _M_bucket_count); }
                
                      size_type
                      size() const
                      { return _M_element_count; }
                  
                      bool
                      empty() const
                      { return size() == 0; }
                
                      allocator_type
                      get_allocator() const
                      { return allocator_type(_M_node_allocator); }
                
                      _Value_allocator_type
                      _M_get_Value_allocator() const
                      { return _Value_allocator_type(_M_node_allocator); }
                
                      size_type
                      max_size() const
                      { return _M_node_allocator.max_size(); }
                
                      // Observers
                      key_equal
                      key_eq() const
                      { return this->_M_eq; }
                
                      // hash_function, if present, comes from _Hash_code_base.
                
                      // Bucket operations
                      size_type
                      bucket_count() const
                      { return _M_bucket_count; }
                  
                      size_type
                      max_bucket_count() const
                      { return max_size(); }
                  
                      size_type
                      bucket_size(size_type __n) const
                      { return std::distance(begin(__n), end(__n)); }
                  
                      size_type
                      bucket(const key_type& __k) const
                      { 
                	return this->_M_bucket_index(__k, this->_M_hash_code(__k),
                				     bucket_count());
                      }
                
                      local_iterator
                      begin(size_type __n)
                      { return local_iterator(_M_buckets[__n]); }
                
                      local_iterator
                      end(size_type)
                      { return local_iterator(0); }
                
                      const_local_iterator
                      begin(size_type __n) const
                      { return const_local_iterator(_M_buckets[__n]); }
                
                      const_local_iterator
                      end(size_type) const
                      { return const_local_iterator(0); }
                
                      // DR 691.
                      const_local_iterator
                      cbegin(size_type __n) const
                      { return const_local_iterator(_M_buckets[__n]); }
                
                      const_local_iterator
                      cend(size_type) const
                      { return const_local_iterator(0); }
                
                      float
                      load_factor() const
                      { 
                	return static_cast<float>(size()) / static_cast<float>(bucket_count());
                      }
                
                      // max_load_factor, if present, comes from _Rehash_base.
                
                      // Generalization of max_load_factor.  Extension, not found in TR1.  Only
                      // useful if _RehashPolicy is something other than the default.
                      const _RehashPolicy&
                      __rehash_policy() const
                      { return _M_rehash_policy; }
                      
                      void 
                      __rehash_policy(const _RehashPolicy&);
                
                      // Lookup.
                      iterator
                      find(const key_type& __k);
                
                      const_iterator
                      find(const key_type& __k) const;
                
                      size_type
                      count(const key_type& __k) const;
                
                      std::pair<iterator, iterator>
                      equal_range(const key_type& __k);
                
                      std::pair<const_iterator, const_iterator>
                      equal_range(const key_type& __k) const;
                
                    private:			// Find, insert and erase helper functions
                      // ??? This dispatching is a workaround for the fact that we don't
                      // have partial specialization of member templates; it would be
                      // better to just specialize insert on __unique_keys.  There may be a
                      // cleaner workaround.
                      typedef typename std::conditional<__unique_keys,
                					std::pair<iterator, bool>,
                					iterator>::type
                        _Insert_Return_Type;
                
                      typedef typename std::conditional<__unique_keys,
                					std::_Select1st<_Insert_Return_Type>,
                					std::_Identity<_Insert_Return_Type>
                                                   >::type
                        _Insert_Conv_Type;
                
                      _Node*
                      _M_find_node(_Node*, const key_type&,
                		   typename _Hashtable::_Hash_code_type) const;
                
                      iterator
                      _M_insert_bucket(const value_type&, size_type,
                		       typename _Hashtable::_Hash_code_type);
                
                      std::pair<iterator, bool>
                      _M_insert(const value_type&, std::true_type);
                
                      iterator
                      _M_insert(const value_type&, std::false_type);
                
                      void
                      _M_erase_node(_Node*, _Node**);
                
                    public:				
                      // Insert and erase
                      _Insert_Return_Type
                      insert(const value_type& __v) 
                      { return _M_insert(__v, std::integral_constant<bool,
                			 __unique_keys>()); }
                
                      iterator
                      insert(const_iterator, const value_type& __v)
                      { return iterator(_Insert_Conv_Type()(this->insert(__v))); }
                
                      template<typename _InputIterator>
                        void
                        insert(_InputIterator __first, _InputIterator __last);
                
                      void
                      insert(initializer_list<value_type> __l)
                      { this->insert(__l.begin(), __l.end()); }
                
                      iterator
                      erase(const_iterator);
                
                      size_type
                      erase(const key_type&);
                
                      iterator
                      erase(const_iterator, const_iterator);
                
                      void
                      clear();
                
                      // Set number of buckets to be appropriate for container of n element.
                      void rehash(size_type __n);
                
                      // DR 1189.
                      // reserve, if present, comes from _Rehash_base.
                
                    private:
                      // Unconditionally change size of bucket array to n.
                      void _M_rehash(size_type __n);
                    };
                
                
                  // Definitions of class template _Hashtable's out-of-line member functions.
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                			_H1, _H2, _Hash, _RehashPolicy,
                			__chc, __cit, __uk>::_Node*
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    _M_allocate_node(const value_type& __v)
                    {
                      _Node* __n = _M_node_allocator.allocate(1);
                      __try
                	{
                	  _M_node_allocator.construct(__n, __v);
                	  __n->_M_next = 0;
                	  return __n;
                	}
                      __catch(...)
                	{
                	  _M_node_allocator.deallocate(__n, 1);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    void
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    _M_deallocate_node(_Node* __n)
                    {
                      _M_node_allocator.destroy(__n);
                      _M_node_allocator.deallocate(__n, 1);
                    }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    void
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    _M_deallocate_nodes(_Node** __array, size_type __n)
                    {
                      for (size_type __i = 0; __i < __n; ++__i)
                	{
                	  _Node* __p = __array[__i];
                	  while (__p)
                	    {
                	      _Node* __tmp = __p;
                	      __p = __p->_M_next;
                	      _M_deallocate_node(__tmp);
                	    }
                	  __array[__i] = 0;
                	}
                    }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                			_H1, _H2, _Hash, _RehashPolicy,
                			__chc, __cit, __uk>::_Node**
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    _M_allocate_buckets(size_type __n)
                    {
                      _Bucket_allocator_type __alloc(_M_node_allocator);
                
                      // We allocate one extra bucket to hold a sentinel, an arbitrary
                      // non-null pointer.  Iterator increment relies on this.
                      _Node** __p = __alloc.allocate(__n + 1);
                      std::fill(__p, __p + __n, (_Node*) 0);
                      __p[__n] = reinterpret_cast<_Node*>(0x1000);
                      return __p;
                    }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    void
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    _M_deallocate_buckets(_Node** __p, size_type __n)
                    {
                      _Bucket_allocator_type __alloc(_M_node_allocator);
                      __alloc.deallocate(__p, __n + 1);
                    }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
           3 ->     _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    _Hashtable(size_type __bucket_hint,
                	       const _H1& __h1, const _H2& __h2, const _Hash& __h,
                	       const _Equal& __eq, const _ExtractKey& __exk,
                	       const allocator_type& __a)
                    : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(),
                      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,
                				_H1, _H2, _Hash, __chc>(__exk, __eq,
                							__h1, __h2, __h),
                      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(),
                      _M_node_allocator(__a),
                      _M_bucket_count(0),
                      _M_element_count(0),
                      _M_rehash_policy()
                    {
                      _M_bucket_count = _M_rehash_policy._M_next_bkt(__bucket_hint);
                      _M_buckets = _M_allocate_buckets(_M_bucket_count);
                    }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    template<typename _InputIterator>
                      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                		 _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                      _Hashtable(_InputIterator __f, _InputIterator __l,
                		 size_type __bucket_hint,
                		 const _H1& __h1, const _H2& __h2, const _Hash& __h,
                		 const _Equal& __eq, const _ExtractKey& __exk,
                		 const allocator_type& __a)
                      : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(),
                	__detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,
                				  _H1, _H2, _Hash, __chc>(__exk, __eq,
                							  __h1, __h2, __h),
                	__detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(),
                	_M_node_allocator(__a),
                	_M_bucket_count(0),
                	_M_element_count(0),
                	_M_rehash_policy()
                      {
                	_M_bucket_count = std::max(_M_rehash_policy._M_next_bkt(__bucket_hint),
                				   _M_rehash_policy.
                				   _M_bkt_for_elements(__detail::
                						       __distance_fw(__f,
                								     __l)));
                	_M_buckets = _M_allocate_buckets(_M_bucket_count);
                	__try
                	  {
                	    for (; __f != __l; ++__f)
                	      this->insert(*__f);
                	  }
                	__catch(...)
                	  {
                	    clear();
                	    _M_deallocate_buckets(_M_buckets, _M_bucket_count);
                	    __throw_exception_again;
                	  }
                      }
                  
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    _Hashtable(const _Hashtable& __ht)
                    : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(__ht),
                      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,
                				_H1, _H2, _Hash, __chc>(__ht),
                      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(__ht),
                      _M_node_allocator(__ht._M_node_allocator),
                      _M_bucket_count(__ht._M_bucket_count),
                      _M_element_count(__ht._M_element_count),
                      _M_rehash_policy(__ht._M_rehash_policy)
                    {
                      _M_buckets = _M_allocate_buckets(_M_bucket_count);
                      __try
                	{
                	  for (size_type __i = 0; __i < __ht._M_bucket_count; ++__i)
                	    {
                	      _Node* __n = __ht._M_buckets[__i];
                	      _Node** __tail = _M_buckets + __i;
                	      while (__n)
                		{
                		  *__tail = _M_allocate_node(__n->_M_v);
                		  this->_M_copy_code(*__tail, __n);
                		  __tail = &((*__tail)->_M_next);
                		  __n = __n->_M_next;
                		}
                	    }
                	}
                      __catch(...)
                	{
                	  clear();
                	  _M_deallocate_buckets(_M_buckets, _M_bucket_count);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    _Hashtable(_Hashtable&& __ht)
                    : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(__ht),
                      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,
                				_H1, _H2, _Hash, __chc>(__ht),
                      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(__ht),
                      _M_node_allocator(__ht._M_node_allocator),
                      _M_bucket_count(__ht._M_bucket_count),
                      _M_element_count(__ht._M_element_count),
                      _M_rehash_policy(__ht._M_rehash_policy),
                      _M_buckets(__ht._M_buckets)
                    {
                      size_type __n_bkt = __ht._M_rehash_policy._M_next_bkt(0);
                      __ht._M_buckets = __ht._M_allocate_buckets(__n_bkt);
                      __ht._M_bucket_count = __n_bkt;
                      __ht._M_element_count = 0;
                      __ht._M_rehash_policy = _RehashPolicy();
                    }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>&
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    operator=(const _Hashtable& __ht)
                    {
                      _Hashtable __tmp(__ht);
                      this->swap(__tmp);
                      return *this;
                    }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
           3 ->     _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    ~_Hashtable()
                    {
                      clear();
                      _M_deallocate_buckets(_M_buckets, _M_bucket_count);
                    }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    void
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    swap(_Hashtable& __x)
                    {
                      // The only base class with member variables is hash_code_base.  We
                      // define _Hash_code_base::_M_swap because different specializations
                      // have different members.
                      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,
                	_H1, _H2, _Hash, __chc>::_M_swap(__x);
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 431. Swapping containers with unequal allocators.
                      std::__alloc_swap<_Node_allocator_type>::_S_do_it(_M_node_allocator,
                							__x._M_node_allocator);
                
                      std::swap(_M_rehash_policy, __x._M_rehash_policy);
                      std::swap(_M_buckets, __x._M_buckets);
                      std::swap(_M_bucket_count, __x._M_bucket_count);
                      std::swap(_M_element_count, __x._M_element_count);
                    }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    void
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    __rehash_policy(const _RehashPolicy& __pol)
                    {
                      _M_rehash_policy = __pol;
                      size_type __n_bkt = __pol._M_bkt_for_elements(_M_element_count);
                      if (__n_bkt > _M_bucket_count)
                	_M_rehash(__n_bkt);
                    }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                			_H1, _H2, _Hash, _RehashPolicy,
                			__chc, __cit, __uk>::iterator
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    find(const key_type& __k)
                    {
                      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);
                      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);
                      _Node* __p = _M_find_node(_M_buckets[__n], __k, __code);
                      return __p ? iterator(__p, _M_buckets + __n) : this->end();
                    }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                			_H1, _H2, _Hash, _RehashPolicy,
                			__chc, __cit, __uk>::const_iterator
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    find(const key_type& __k) const
                    {
                      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);
                      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);
                      _Node* __p = _M_find_node(_M_buckets[__n], __k, __code);
                      return __p ? const_iterator(__p, _M_buckets + __n) : this->end();
                    }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                			_H1, _H2, _Hash, _RehashPolicy,
                			__chc, __cit, __uk>::size_type
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    count(const key_type& __k) const
                    {
                      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);
                      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);
                      std::size_t __result = 0;
                      for (_Node* __p = _M_buckets[__n]; __p; __p = __p->_M_next)
                	if (this->_M_compare(__k, __code, __p))
                	  ++__result;
                      return __result;
                    }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    std::pair<typename _Hashtable<_Key, _Value, _Allocator,
                				  _ExtractKey, _Equal, _H1,
                				  _H2, _Hash, _RehashPolicy,
                				  __chc, __cit, __uk>::iterator,
                	      typename _Hashtable<_Key, _Value, _Allocator,
                				  _ExtractKey, _Equal, _H1,
                				  _H2, _Hash, _RehashPolicy,
                				  __chc, __cit, __uk>::iterator>
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    equal_range(const key_type& __k)
                    {
                      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);
                      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);
                      _Node** __head = _M_buckets + __n;
                      _Node* __p = _M_find_node(*__head, __k, __code);
                      
                      if (__p)
                	{
                	  _Node* __p1 = __p->_M_next;
                	  for (; __p1; __p1 = __p1->_M_next)
                	    if (!this->_M_compare(__k, __code, __p1))
                	      break;
                
                	  iterator __first(__p, __head);
                	  iterator __last(__p1, __head);
                	  if (!__p1)
                	    __last._M_incr_bucket();
                	  return std::make_pair(__first, __last);
                	}
                      else
                	return std::make_pair(this->end(), this->end());
                    }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    std::pair<typename _Hashtable<_Key, _Value, _Allocator,
                				  _ExtractKey, _Equal, _H1,
                				  _H2, _Hash, _RehashPolicy,
                				  __chc, __cit, __uk>::const_iterator,
                	      typename _Hashtable<_Key, _Value, _Allocator,
                				  _ExtractKey, _Equal, _H1,
                				  _H2, _Hash, _RehashPolicy,
                				  __chc, __cit, __uk>::const_iterator>
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    equal_range(const key_type& __k) const
                    {
                      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);
                      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);
                      _Node** __head = _M_buckets + __n;
                      _Node* __p = _M_find_node(*__head, __k, __code);
                
                      if (__p)
                	{
                	  _Node* __p1 = __p->_M_next;
                	  for (; __p1; __p1 = __p1->_M_next)
                	    if (!this->_M_compare(__k, __code, __p1))
                	      break;
                
                	  const_iterator __first(__p, __head);
                	  const_iterator __last(__p1, __head);
                	  if (!__p1)
                	    __last._M_incr_bucket();
                	  return std::make_pair(__first, __last);
                	}
                      else
                	return std::make_pair(this->end(), this->end());
                    }
                
                  // Find the node whose key compares equal to k, beginning the search
                  // at p (usually the head of a bucket).  Return nil if no node is found.
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey,
                			_Equal, _H1, _H2, _Hash, _RehashPolicy,
                			__chc, __cit, __uk>::_Node* 
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    _M_find_node(_Node* __p, const key_type& __k,
                		typename _Hashtable::_Hash_code_type __code) const
                    {
                      for (; __p; __p = __p->_M_next)
                	if (this->_M_compare(__k, __code, __p))
                	  return __p;
                      return false;
                    }
                
                  // Insert v in bucket n (assumes no element with its key already present).
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                			_H1, _H2, _Hash, _RehashPolicy,
                			__chc, __cit, __uk>::iterator
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    _M_insert_bucket(const value_type& __v, size_type __n,
                		     typename _Hashtable::_Hash_code_type __code)
                    {
                      std::pair<bool, std::size_t> __do_rehash
                	= _M_rehash_policy._M_need_rehash(_M_bucket_count,
                					  _M_element_count, 1);
                
                      // Allocate the new node before doing the rehash so that we don't
                      // do a rehash if the allocation throws.
                      _Node* __new_node = _M_allocate_node(__v);
                
                      __try
                	{
                	  if (__do_rehash.first)
                	    {
                	      const key_type& __k = this->_M_extract(__v);
                	      __n = this->_M_bucket_index(__k, __code, __do_rehash.second);
                	      _M_rehash(__do_rehash.second);
                	    }
                
                	  __new_node->_M_next = _M_buckets[__n];
                	  this->_M_store_code(__new_node, __code);
                	  _M_buckets[__n] = __new_node;
                	  ++_M_element_count;
                	  return iterator(__new_node, _M_buckets + __n);
                	}
                      __catch(...)
                	{
                	  _M_deallocate_node(__new_node);
                	  __throw_exception_again;
                	}
                    }
                
                  // Insert v if no element with its key is already present.
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    std::pair<typename _Hashtable<_Key, _Value, _Allocator,
                				  _ExtractKey, _Equal, _H1,
                				  _H2, _Hash, _RehashPolicy,
                				  __chc, __cit, __uk>::iterator, bool>
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    _M_insert(const value_type& __v, std::true_type)
                    {
                      const key_type& __k = this->_M_extract(__v);
                      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);
                      size_type __n = this->_M_bucket_index(__k, __code, _M_bucket_count);
                
                      if (_Node* __p = _M_find_node(_M_buckets[__n], __k, __code))
                	return std::make_pair(iterator(__p, _M_buckets + __n), false);
                      return std::make_pair(_M_insert_bucket(__v, __n, __code), true);
                    }
                
                  // Insert v unconditionally.
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                			_H1, _H2, _Hash, _RehashPolicy,
                			__chc, __cit, __uk>::iterator
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    _M_insert(const value_type& __v, std::false_type)
                    {
                      std::pair<bool, std::size_t> __do_rehash
                	= _M_rehash_policy._M_need_rehash(_M_bucket_count,
                					  _M_element_count, 1);
                      if (__do_rehash.first)
                	_M_rehash(__do_rehash.second);
                 
                      const key_type& __k = this->_M_extract(__v);
                      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);
                      size_type __n = this->_M_bucket_index(__k, __code, _M_bucket_count);
                
                      // First find the node, avoid leaking new_node if compare throws.
                      _Node* __prev = _M_find_node(_M_buckets[__n], __k, __code);
                      _Node* __new_node = _M_allocate_node(__v);
                
                      if (__prev)
                	{
                	  __new_node->_M_next = __prev->_M_next;
                	  __prev->_M_next = __new_node;
                	}
                      else
                	{
                	  __new_node->_M_next = _M_buckets[__n];
                	  _M_buckets[__n] = __new_node;
                	}
                      this->_M_store_code(__new_node, __code);
                
                      ++_M_element_count;
                      return iterator(__new_node, _M_buckets + __n);
                    }
                
                  // For erase(iterator) and erase(const_iterator).
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    void
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    _M_erase_node(_Node* __p, _Node** __b)
                    {
                      _Node* __cur = *__b;
                      if (__cur == __p)
                	*__b = __cur->_M_next;
                      else
                	{
                	  _Node* __next = __cur->_M_next;
                	  while (__next != __p)
                	    {
                	      __cur = __next;
                	      __next = __cur->_M_next;
                	    }
                	  __cur->_M_next = __next->_M_next;
                	}
                
                      _M_deallocate_node(__p);
                      --_M_element_count;
                    }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    template<typename _InputIterator>
                      void 
                      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                		 _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                      insert(_InputIterator __first, _InputIterator __last)
                      {
                	size_type __n_elt = __detail::__distance_fw(__first, __last);
                	std::pair<bool, std::size_t> __do_rehash
                	  = _M_rehash_policy._M_need_rehash(_M_bucket_count,
                					    _M_element_count, __n_elt);
                	if (__do_rehash.first)
                	  _M_rehash(__do_rehash.second);
                
                	for (; __first != __last; ++__first)
                	  this->insert(*__first);
                      }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                			_H1, _H2, _Hash, _RehashPolicy,
                			__chc, __cit, __uk>::iterator
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    erase(const_iterator __it)
                    {
                      iterator __result(__it._M_cur_node, __it._M_cur_bucket);
                      ++__result;
                      _M_erase_node(__it._M_cur_node, __it._M_cur_bucket);
                      return __result;
                    }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                			_H1, _H2, _Hash, _RehashPolicy,
                			__chc, __cit, __uk>::size_type
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    erase(const key_type& __k)
                    {
                      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);
                      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);
                      size_type __result = 0;
                      
                      _Node** __slot = _M_buckets + __n;
                      while (*__slot && !this->_M_compare(__k, __code, *__slot))
                	__slot = &((*__slot)->_M_next);
                
                      _Node** __saved_slot = 0;
                      while (*__slot && this->_M_compare(__k, __code, *__slot))
                	{
                	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                	  // 526. Is it undefined if a function in the standard changes
                	  // in parameters?
                	  if (&this->_M_extract((*__slot)->_M_v) != &__k)
                	    {
                              _Node* __p = *__slot;
                              *__slot = __p->_M_next;
                	      _M_deallocate_node(__p);
                	      --_M_element_count;
                	      ++__result;
                	    }
                	  else
                	    {
                	      __saved_slot = __slot;
                	      __slot = &((*__slot)->_M_next);
                	    }
                	}
                
                      if (__saved_slot)
                	{
                	  _Node* __p = *__saved_slot;
                	  *__saved_slot = __p->_M_next;
                	  _M_deallocate_node(__p);
                	  --_M_element_count;
                	  ++__result;
                	}
                
                      return __result;
                    }
                
                  // ??? This could be optimized by taking advantage of the bucket
                  // structure, but it's not clear that it's worth doing.  It probably
                  // wouldn't even be an optimization unless the load factor is large.
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                			_H1, _H2, _Hash, _RehashPolicy,
                			__chc, __cit, __uk>::iterator
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    erase(const_iterator __first, const_iterator __last)
                    {
                      while (__first != __last)
                	__first = this->erase(__first);
                      return iterator(__last._M_cur_node, __last._M_cur_bucket);
                    }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    void
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    clear()
                    {
                      _M_deallocate_nodes(_M_buckets, _M_bucket_count);
                      _M_element_count = 0;
                    }
                 
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    void
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    rehash(size_type __n)
                    {
                      _M_rehash(std::max(_M_rehash_policy._M_next_bkt(__n),
                			 _M_rehash_policy._M_bkt_for_elements(_M_element_count
                							      + 1)));
                    }
                
                  template<typename _Key, typename _Value, 
                	   typename _Allocator, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   bool __chc, bool __cit, bool __uk>
                    void
                    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
                    _M_rehash(size_type __n)
                    {
                      _Node** __new_array = _M_allocate_buckets(__n);
                      __try
                	{
                	  for (size_type __i = 0; __i < _M_bucket_count; ++__i)
                	    while (_Node* __p = _M_buckets[__i])
                	      {
                		std::size_t __new_index = this->_M_bucket_index(__p, __n);
                		_M_buckets[__i] = __p->_M_next;
                		__p->_M_next = __new_array[__new_index];
                		__new_array[__new_index] = __p;
                	      }
                	  _M_deallocate_buckets(_M_buckets, _M_bucket_count);
                	  _M_bucket_count = __n;
                	  _M_buckets = __new_array;
                	}
                      __catch(...)
                	{
                	  // A failure here means that a hash function threw an exception.
                	  // We can't restore the previous state without calling the hash
                	  // function again, so the only sensible recovery is to delete
                	  // everything.
                	  _M_deallocate_nodes(__new_array, __n);
                	  _M_deallocate_buckets(__new_array, __n);
                	  _M_deallocate_nodes(_M_buckets, _M_bucket_count);
                	  _M_element_count = 0;
                	  __throw_exception_again;
                	}
                    }
                }
                
                #endif // _HASHTABLE_H


Top 10 Lines:

     Line      Count

      541          3
      685          3

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        6   Total number of line executions
     3.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/util/VirtualButton.cpp:
                #include "stdafx.h"
                using namespace std;
                
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
                keymap VirtualButton::_mapDIK;
                bool VirtualButton::_is_init = false;
                
                //gWL[{[h
                VirtualButton::KEYBOARDMAP VirtualButton::_tagKeymap = {
                                              DIK_Z,      // BUTTON1
                                              DIK_X,      // BUTTON2
                                              DIK_C,      // BUTTON3
                                              DIK_A,      // BUTTON4
                                              DIK_S,      // BUTTON5
                                              DIK_D,      // BUTTON6
                                              DIK_V,      // BUTTON7
                                              DIK_B,      // BUTTON8
                                              DIK_ESCAPE, // PAUSE
                                              DIK_UP,     // UP
                                              DIK_DOWN,   // DOWN
                                              DIK_LEFT,   // LEFT
                                              DIK_RIGHT,  // RIGHT
                                              DIK_UP,     // UI_UP
                                              DIK_DOWN,   // UI_DOWN
                                              DIK_LEFT,   // UI_LEFT
                                              DIK_RIGHT,  // UI_RIGHT
                                              DIK_RETURN, // UI_EXECUTE
                                              DIK_ESCAPE, // UI_CANCEL
                                              DIK_Q       // UI_DEBUG
                                           };
                
                VirtualButton::JOYSTICKMAP VirtualButton::_tagJoymap = {
                                              0, // BUTTON1
                                              1, // BUTTON2
                                              2, // BUTTON3
                                              3, // BUTTON4
                                              4, // BUTTON5
                                              5, // BUTTON6
                                              6, // BUTTON7
                                              7, // BUTTON8
                                              9, // PAUSE
                                              0, // UI_EXECUTE
                                              1  // UI_CANCEL
                                           };
                
           2 -> VirtualButton::VirtualButton() {
                    //oAXg\z
                    _pVBRecord_Active = NEW VBRecord();
                    VBRecord* pVBRecord_Temp = _pVBRecord_Active;
                    for (int i = 1; i < VB_MAP_BUFFER - 1; i++) {
                        VBRecord* pVBRecordWork = NEW VBRecord();
                        pVBRecordWork->_next = pVBRecord_Temp;
                        pVBRecord_Temp->_prev = pVBRecordWork;
                        pVBRecord_Temp = pVBRecordWork;
                    }
                    VBRecord* pVBRecordOldest = NEW VBRecord();
                    pVBRecord_Temp->_prev = pVBRecordOldest;
                    pVBRecordOldest->_next = pVBRecord_Temp;
                    pVBRecordOldest->_prev = _pVBRecord_Active;
                    _pVBRecord_Active->_next = pVBRecordOldest;
                    _is_auto_repeat = false;
                    if (!_is_init) {
                        init();
                    }
                }
                
                void VirtualButton::init() {
                    _mapDIK["DIK_ESCAPE"]       = 0x01;
                    _mapDIK["DIK_1"]            = 0x02;
                    _mapDIK["DIK_2"]            = 0x03;
                    _mapDIK["DIK_3"]            = 0x04;
                    _mapDIK["DIK_4"]            = 0x05;
                    _mapDIK["DIK_5"]            = 0x06;
                    _mapDIK["DIK_6"]            = 0x07;
                    _mapDIK["DIK_7"]            = 0x08;
                    _mapDIK["DIK_8"]            = 0x09;
                    _mapDIK["DIK_9"]            = 0x0A;
                    _mapDIK["DIK_0"]            = 0x0B;
                    _mapDIK["DIK_MINUS"]        = 0x0C;
                    _mapDIK["DIK_EQUALS"]       = 0x0D;
                    _mapDIK["DIK_BACK"]         = 0x0E;
                    _mapDIK["DIK_TAB"]          = 0x0F;
                    _mapDIK["DIK_Q"]            = 0x10;
                    _mapDIK["DIK_W"]            = 0x11;
                    _mapDIK["DIK_E"]            = 0x12;
                    _mapDIK["DIK_R"]            = 0x13;
                    _mapDIK["DIK_T"]            = 0x14;
                    _mapDIK["DIK_Y"]            = 0x15;
                    _mapDIK["DIK_U"]            = 0x16;
                    _mapDIK["DIK_I"]            = 0x17;
                    _mapDIK["DIK_O"]            = 0x18;
                    _mapDIK["DIK_P"]            = 0x19;
                    _mapDIK["DIK_LBRACKET"]     = 0x1A;
                    _mapDIK["DIK_RBRACKET"]     = 0x1B;
                    _mapDIK["DIK_RETURN"]       = 0x1C;
                    _mapDIK["DIK_LCONTROL"]     = 0x1D;
                    _mapDIK["DIK_A"]            = 0x1E;
                    _mapDIK["DIK_S"]            = 0x1F;
                    _mapDIK["DIK_D"]            = 0x20;
                    _mapDIK["DIK_F"]            = 0x21;
                    _mapDIK["DIK_G"]            = 0x22;
                    _mapDIK["DIK_H"]            = 0x23;
                    _mapDIK["DIK_J"]            = 0x24;
                    _mapDIK["DIK_K"]            = 0x25;
                    _mapDIK["DIK_L"]            = 0x26;
                    _mapDIK["DIK_SEMICOLON"]    = 0x27;
                    _mapDIK["DIK_APOSTROPHE"]   = 0x28;
                    _mapDIK["DIK_GRAVE"]        = 0x29;
                    _mapDIK["DIK_LSHIFT"]       = 0x2A;
                    _mapDIK["DIK_BACKSLASH"]    = 0x2B;
                    _mapDIK["DIK_Z"]            = 0x2C;
                    _mapDIK["DIK_X"]            = 0x2D;
                    _mapDIK["DIK_C"]            = 0x2E;
                    _mapDIK["DIK_V"]            = 0x2F;
                    _mapDIK["DIK_B"]            = 0x30;
                    _mapDIK["DIK_N"]            = 0x31;
                    _mapDIK["DIK_M"]            = 0x32;
                    _mapDIK["DIK_COMMA"]        = 0x33;
                    _mapDIK["DIK_PERIOD"]       = 0x34;
                    _mapDIK["DIK_SLASH"]        = 0x35;
                    _mapDIK["DIK_RSHIFT"]       = 0x36;
                    _mapDIK["DIK_MULTIPLY"]     = 0x37;
                    _mapDIK["DIK_LMENU"]        = 0x38;
                    _mapDIK["DIK_SPACE"]        = 0x39;
                    _mapDIK["DIK_CAPITAL"]      = 0x3A;
                    _mapDIK["DIK_F1"]           = 0x3B;
                    _mapDIK["DIK_F2"]           = 0x3C;
                    _mapDIK["DIK_F3"]           = 0x3D;
                    _mapDIK["DIK_F4"]           = 0x3E;
                    _mapDIK["DIK_F5"]           = 0x3F;
                    _mapDIK["DIK_F6"]           = 0x40;
                    _mapDIK["DIK_F7"]           = 0x41;
                    _mapDIK["DIK_F8"]           = 0x42;
                    _mapDIK["DIK_F9"]           = 0x43;
                    _mapDIK["DIK_F10"]          = 0x44;
                    _mapDIK["DIK_NUMLOCK"]      = 0x45;
                    _mapDIK["DIK_SCROLL"]       = 0x46;
                    _mapDIK["DIK_NUMPAD7"]      = 0x47;
                    _mapDIK["DIK_NUMPAD8"]      = 0x48;
                    _mapDIK["DIK_NUMPAD9"]      = 0x49;
                    _mapDIK["DIK_SUBTRACT"]     = 0x4A;
                    _mapDIK["DIK_NUMPAD4"]      = 0x4B;
                    _mapDIK["DIK_NUMPAD5"]      = 0x4C;
                    _mapDIK["DIK_NUMPAD6"]      = 0x4D;
                    _mapDIK["DIK_ADD"]          = 0x4E;
                    _mapDIK["DIK_NUMPAD1"]      = 0x4F;
                    _mapDIK["DIK_NUMPAD2"]      = 0x50;
                    _mapDIK["DIK_NUMPAD3"]      = 0x51;
                    _mapDIK["DIK_NUMPAD0"]      = 0x52;
                    _mapDIK["DIK_DECIMAL"]      = 0x53;
                    _mapDIK["DIK_OEM_102"]      = 0x56;
                    _mapDIK["DIK_F11"]          = 0x57;
                    _mapDIK["DIK_F12"]          = 0x58;
                    _mapDIK["DIK_F13"]          = 0x64;
                    _mapDIK["DIK_F14"]          = 0x65;
                    _mapDIK["DIK_F15"]          = 0x66;
                    _mapDIK["DIK_KANA"]         = 0x70;
                    _mapDIK["DIK_ABNT_C1"]      = 0x73;
                    _mapDIK["DIK_CONVERT"]      = 0x79;
                    _mapDIK["DIK_NOCONVERT"]    = 0x7B;
                    _mapDIK["DIK_YEN"]          = 0x7D;
                    _mapDIK["DIK_ABNT_C2"]      = 0x7E;
                    _mapDIK["DIK_NUMPADEQUALS"] = 0x8D;
                    _mapDIK["DIK_PREVTRACK"]    = 0x90;
                    _mapDIK["DIK_AT"]           = 0x91;
                    _mapDIK["DIK_COLON"]        = 0x92;
                    _mapDIK["DIK_UNDERLINE"]    = 0x93;
                    _mapDIK["DIK_KANJI"]        = 0x94;
                    _mapDIK["DIK_STOP"]         = 0x95;
                    _mapDIK["DIK_AX"]           = 0x96;
                    _mapDIK["DIK_UNLABELED"]    = 0x97;
                    _mapDIK["DIK_NEXTTRACK"]    = 0x99;
                    _mapDIK["DIK_NUMPADENTER"]  = 0x9C;
                    _mapDIK["DIK_RCONTROL"]     = 0x9D;
                    _mapDIK["DIK_MUTE"]         = 0xA0;
                    _mapDIK["DIK_CALCULATOR"]   = 0xA1;
                    _mapDIK["DIK_PLAYPAUSE"]    = 0xA2;
                    _mapDIK["DIK_MEDIASTOP"]    = 0xA4;
                    _mapDIK["DIK_VOLUMEDOWN"]   = 0xAE;
                    _mapDIK["DIK_VOLUMEUP"]     = 0xB0;
                    _mapDIK["DIK_WEBHOME"]      = 0xB2;
                    _mapDIK["DIK_NUMPADCOMMA"]  = 0xB3;
                    _mapDIK["DIK_DIVIDE"]       = 0xB5;
                    _mapDIK["DIK_SYSRQ"]        = 0xB7;
                    _mapDIK["DIK_RMENU"]        = 0xB8;
                    _mapDIK["DIK_PAUSE"]        = 0xC5;
                    _mapDIK["DIK_HOME"]         = 0xC7;
                    _mapDIK["DIK_UP"]           = 0xC8;
                    _mapDIK["DIK_PRIOR"]        = 0xC9;
                    _mapDIK["DIK_LEFT"]         = 0xCB;
                    _mapDIK["DIK_RIGHT"]        = 0xCD;
                    _mapDIK["DIK_END"]          = 0xCF;
                    _mapDIK["DIK_DOWN"]         = 0xD0;
                    _mapDIK["DIK_NEXT"]         = 0xD1;
                    _mapDIK["DIK_INSERT"]       = 0xD2;
                    _mapDIK["DIK_DELETE"]       = 0xD3;
                    _mapDIK["DIK_LWIN"]         = 0xDB;
                    _mapDIK["DIK_RWIN"]         = 0xDC;
                    _mapDIK["DIK_APPS"]         = 0xDD;
                    _mapDIK["DIK_POWER"]        = 0xDE;
                    _mapDIK["DIK_SLEEP"]        = 0xDF;
                    _mapDIK["DIK_WAKE"]         = 0xE3;
                    _mapDIK["DIK_WEBSEARCH"]    = 0xE5;
                    _mapDIK["DIK_WEBFAVORITES"] = 0xE6;
                    _mapDIK["DIK_WEBREFRESH"]   = 0xE7;
                    _mapDIK["DIK_WEBSTOP"]      = 0xE8;
                    _mapDIK["DIK_WEBFORWARD"]   = 0xE9;
                    _mapDIK["DIK_WEBBACK"]      = 0xEA;
                    _mapDIK["DIK_MYCOMPUTER"]   = 0xEB;
                    _mapDIK["DIK_MAIL"]         = 0xEC;
                    _mapDIK["DIK_MEDIASELECT"]  = 0xED;
                    _mapDIK["DIK_BACKSPACE"]    = 0x0E;
                    _mapDIK["DIK_NUMPADSTAR"]   = 0x37;
                    _mapDIK["DIK_LALT"]         = 0x38;
                    _mapDIK["DIK_CAPSLOCK"]     = 0x3A;
                    _mapDIK["DIK_NUMPADMINUS"]  = 0x4A;
                    _mapDIK["DIK_NUMPADPLUS"]   = 0x4E;
                    _mapDIK["DIK_NUMPADPERIOD"] = 0x53;
                    _mapDIK["DIK_NUMPADSLASH"]  = 0xB5;
                    _mapDIK["DIK_RALT"]         = 0xB8;
                    _mapDIK["DIK_UPARROW"]      = 0xC8;
                    _mapDIK["DIK_PGUP"]         = 0xC9;
                    _mapDIK["DIK_LEFTARROW"]    = 0xCB;
                    _mapDIK["DIK_RIGHTARROW"]   = 0xCD;
                    _mapDIK["DIK_DOWNARROW"]    = 0xD0;
                    _mapDIK["DIK_PGDN"]         = 0xD1;
                
                    _mapDIK["JOY_BUTTON_00"]    = 0;
                    _mapDIK["JOY_BUTTON_01"]    = 1;
                    _mapDIK["JOY_BUTTON_02"]    = 2;
                    _mapDIK["JOY_BUTTON_03"]    = 3;
                    _mapDIK["JOY_BUTTON_04"]    = 4;
                    _mapDIK["JOY_BUTTON_05"]    = 5;
                    _mapDIK["JOY_BUTTON_06"]    = 6;
                    _mapDIK["JOY_BUTTON_07"]    = 7;
                    _mapDIK["JOY_BUTTON_08"]    = 8;
                    _mapDIK["JOY_BUTTON_09"]    = 9;
                    _mapDIK["JOY_BUTTON_10"]    = 10;
                    _mapDIK["JOY_BUTTON_11"]    = 11;
                    _mapDIK["JOY_BUTTON_12"]    = 12;
                
                }
                
                
                VirtualButton::VBRecord* VirtualButton::getPastVBRecord(frame prm_frame_ago) {
                    VBRecord* pVBRecord_Temp = _pVBRecord_Active;
                    for (frame i = 0; i < prm_frame_ago; i++) {
                        pVBRecord_Temp = pVBRecord_Temp->_prev;
                    }
                    return pVBRecord_Temp;
                }
                
                vbsta VirtualButton::isBeingPressed(vbsta prm_VB) {
                    return _pVBRecord_Active->_state & prm_VB;
                }
                
                vbsta VirtualButton::isAutoRepeat(vbsta prm_VB) {
                    vbsta sta = _pVBRecord_Active->_state & prm_VB;
                    if (sta) {
                        _is_auto_repeat = true;
                        if (sta == (_pVBRecord_Active->_prev->_state & prm_VB)) {
                            _repeat_counter[prm_VB] ++;
                        } else {
                            _repeat_counter[prm_VB] = 0;
                        }
                    } else {
                        _is_auto_repeat = false;
                        _repeat_counter[prm_VB] = 0;
                    }
                
                    if (_is_auto_repeat) {
                        if (_repeat_counter[prm_VB] == 0) {
                            //L[C
                            return sta;
                        } else if (_repeat_counter[prm_VB] > 20 && _repeat_counter[prm_VB] % 5 == 0) {
                            //20t[~5t[
                            return sta;
                        }
                    }
                    return false;
                }
                
                
                
                vbsta VirtualButton::wasBeingPressed(vbsta prm_VB, frame prm_frame_ago) {
                    VBRecord* pVBRecord_Temp = getPastVBRecord(prm_frame_ago);
                    return pVBRecord_Temp->_state & prm_VB;
                }
                
                vbsta VirtualButton::isNotBeingPressed(vbsta prm_VB) {
                    if (isBeingPressed(prm_VB)) {
                        return false;
                    } else {
                        return true;
                    }
                }
                
                vbsta VirtualButton::wasNotBeingPressed(vbsta prm_VB, frame prm_frame_ago) {
                    if (wasBeingPressed(prm_VB, prm_frame_ago)) {
                        return false;
                    } else {
                        return true;
                    }
                }
                
                vbsta VirtualButton::isPushedDown(vbsta prm_VB) {
                    if (isBeingPressed(prm_VB) && wasNotBeingPressed(prm_VB, 1)) {
                        return true;
                    } else {
                        return false;
                    }
                }
                vbsta VirtualButton::isDoublePushedDown(vbsta prm_VB, frame prm_frame_push, frame prm_frame_delay) {
                    //-------oooo-----o
                    //       <--><--->
                    //         |    `-- prm_frame_delay
                    //         `-- prm_frame_push
                    //k
                    VirtualButton::VBRecord* pVBRecord;
                    pVBRecord = _pVBRecord_Active;
                    if (pVBRecord->_state & prm_VB) {
                        //OK
                    } else {
                        return false;
                    }
                    pVBRecord = pVBRecord->_prev;
                    //OK
                    if (pVBRecord->_state & prm_VB) {
                        return false;
                    }
                    bool ok = false;
                    for (frame i = 0; i < prm_frame_delay; i++) {
                        pVBRecord = pVBRecord->_prev;
                        if (pVBRecord->_state & prm_VB) {
                            //OK
                            ok = true;
                            break;
                        }
                    }
                    if (ok) {
                
                    } else {
                        return false;
                    }
                    ok = false;
                    for (frame i = 0; i < prm_frame_push; i++) {
                        pVBRecord = pVBRecord->_prev;
                        if (pVBRecord->_state & prm_VB) {
                
                        } else {
                            //OK
                            ok = true;
                            break;
                        }
                    }
                    if (ok) {
                        return true;
                    } else {
                        return false;
                    }
                }
                
                
                
                ////
                //bool VirtualButton::isNonAfterPushedDown(int prm_VB) {
                //	if (_pVBRecord_Active->_state[prm_VB]) {
                //		for (int i = 0; i < VB_NUM; i++) {
                //			if (_pVBRecord_Active->_prev->_state[i]) {
                //				return false;
                //			}
                //		}
                //		return true;
                //	} else {
                //		return false;
                //	}
                //}
                
                vbsta VirtualButton::arePushedDownAtOnce(vbsta prm_aVB[], int prm_iButtonNum) {
                
                    //S
                    for (int i = 0; i < prm_iButtonNum; i++) {
                        if (isBeingPressed(prm_aVB[i]) == false) {
                            return false;
                        }
                    }
                
                    //Rt[]T
                    //S{^A`FbNB
                    //  > H > H > 
                    //       or
                    // H >  > H > 
                    //       or
                    // H > H >  > 
                    static bool prev1Flg, prev2Flg, prev3Flg;
                    for (int i = 0; i < prm_iButtonNum; i++) {
                        prev1Flg = wasNotBeingPressed(prm_aVB[i], 1);
                        prev2Flg = wasNotBeingPressed(prm_aVB[i], 2);
                        prev3Flg = wasNotBeingPressed(prm_aVB[i], 3);
                        if (prev1Flg) { // >  >  >
                            continue;
                        } else if (prev2Flg) { // >  >  >
                            continue;
                        } else if (prev3Flg) { // >  >  >
                            continue;
                        } else {
                            return false;
                        }
                    }
                
                    //A1Ot[ASB
                    //AuvARt[AB
                    for (int i = 0; i < prm_iButtonNum; i++) {
                        if (wasNotBeingPressed(prm_aVB[i], 1)) {
                            return true;
                        }
                    }
                    return false;
                }
                
                vbsta VirtualButton::wasPushedDown(vbsta prm_VB, frame prm_frame_ago) {
                    if (wasBeingPressed(prm_VB, prm_frame_ago) && wasNotBeingPressed(prm_VB, prm_frame_ago + 1)) {
                        return true;
                    } else {
                        return false;
                    }
                }
                
                vbsta VirtualButton::isReleasedUp(vbsta prm_VB) {
                    if (isNotBeingPressed(prm_VB) && wasBeingPressed(prm_VB, 1)) {
                        return true;
                    } else {
                        return false;
                    }
                }
                
                vbsta VirtualButton::isPushedUp(vbsta prm_VB, frame prm_frame_push) {
                    //      
                    //            
                    //---------ooo-
                    //       <--->
                    //         |
                    //         `-- prm_frame_push
                
                    //k
                    VirtualButton::VBRecord* pVBRecord;
                    pVBRecord = _pVBRecord_Active;
                    //
                    if (pVBRecord->_state & prm_VB) {
                        return false;
                    } else {
                        //OK
                    }
                    pVBRecord = pVBRecord->_prev;
                    //O
                    if (pVBRecord->_state & prm_VB) {
                        //OK
                    } else {
                        return false;
                    }
                    pVBRecord = pVBRecord->_prev;
                    bool ok = false;
                    for (frame i = 0; i < prm_frame_push; i++) {
                        pVBRecord = pVBRecord->_prev;
                        if (pVBRecord->_state & prm_VB) {
                
                        } else {
                            //prm_frame_pushOK
                            ok = true;
                            break;
                        }
                    }
                    if (ok) {
                        return true;
                    } else {
                        return false;
                    }
                
                }
                
                
                vbsta VirtualButton::wasReleasedUp(vbsta prm_VB, frame prm_frame_ago) {
                    if (wasNotBeingPressed(prm_VB, prm_frame_ago) && wasBeingPressed(prm_VB, prm_frame_ago + 1)) {
                        return true;
                    } else {
                        return false;
                    }
                }
                
                vbsta VirtualButton::getBeingPressedStick() {
                
                    return _pVBRecord_Active->_state & VB_STC_MASK;
                
                //    for (int i = VB_UP_RIGHT_STC; i <= VB_LEFT_STC; i++) {
                //        if (isBeingPressed(i)) {
                //            return i;
                //        }
                //    }
                //    return 0;
                }
                
                vbsta VirtualButton::getPushedDownStick() {
                    if ((_pVBRecord_Active->_prev->_state & VB_STC_MASK) == VB_NEUTRAL_STC) {
                        return _pVBRecord_Active->_state & VB_STC_MASK;
                    } else {
                        return 0;
                    }
                }
                
                
                vbsta VirtualButton::isDoublePushedDownStick(frame prm_frame_push, frame prm_frame_delay) {
                    vbsta STC = getPushedDownStick();
                    if (STC == 0 || STC == VB_NEUTRAL_STC) {
                        return 0;
                    }
                    //-------oooo-----o
                    //       <--><--->
                    //         |    `-- prm_frame_delay
                    //         `-- prm_frame_push
                    //k
                    VirtualButton::VBRecord* pVBRecord;
                    pVBRecord = _pVBRecord_Active;
                    pVBRecord = pVBRecord->_prev; //getPushedDownStickB
                    bool ok = false;
                    for (frame i = 0; i < prm_frame_delay; i++) {
                        pVBRecord = pVBRecord->_prev;
                        if (pVBRecord->_state & STC) {
                            //OK
                            ok = true;
                            break;
                        }
                    }
                    if (ok) {
                
                    } else {
                        return 0;
                    }
                    ok = false;
                    for (frame i = 0; i < prm_frame_push; i++) {
                        pVBRecord = pVBRecord->_prev;
                        if (pVBRecord->_state & STC) {
                
                        } else {
                            //OK
                            ok = true;
                            break;
                        }
                    }
                    if (ok) {
                        return STC;
                    } else {
                        return 0;
                    }
                }
                
                
                bool VirtualButton::isRoundPushDown(vbsta prm_VB, frame prm_frame_delay) {
                    if (isPushedDown(prm_VB)) {
                        VBRecord* pVBRecord;
                        pVBRecord = _pVBRecord_Active;
                        bool up = false;
                        bool down = false;
                        bool left = false;
                        bool right = false;
                        for (frame i = 0; i < prm_frame_delay; i++) {
                            pVBRecord = pVBRecord->_prev;
                            if (pVBRecord->_state & VB_UP) {
                                up = true;
                                continue;
                            }
                            if (pVBRecord->_state & VB_RIGHT) {
                                right = true;
                                continue;
                            }
                            if (pVBRecord->_state & VB_DOWN) {
                                down = true;
                                continue;
                            }
                            if (pVBRecord->_state & VB_LEFT) {
                                left = true;
                                continue;
                            }
                        }
                        if (up && down && left && right) {
                            return true;
                        } else {
                            return false;
                        }
                    } else {
                        return false;
                    }
                }
                
                
                
                //vbsta VirtualButton::getPushedDownStickWith(vbsta prm_VB) {
                //    if (isBeingPressed(prm_VB)) {
                //        static bool prev1Flg, prev2Flg, prev3Flg;
                //        //{^O
                //        prev1Flg = wasNotBeingPressed(prm_VB, 1);
                //        prev2Flg = wasNotBeingPressed(prm_VB, 2);
                //        prev3Flg = wasNotBeingPressed(prm_VB, 3);
                //        if (prev1Flg) { // >  >  >
                //            //OK
                //        } else if (prev2Flg) { // >  >  >
                //            //OK
                //        } else if (prev3Flg) { // >  >  >
                //            //OK
                //        } else {
                //            //NG
                //            return 0;
                //        }
                //
                //        //XeBbNO
                //        static bool prev1N_Flg, prev2N_Flg, prev3N_Flg;
                //        prev1N_Flg = wasBeingPressed(VB_NEUTRAL_STC, 1);
                //        prev2N_Flg = wasBeingPressed(VB_NEUTRAL_STC, 2);
                //        prev3N_Flg = wasBeingPressed(VB_NEUTRAL_STC, 3);
                //        if (prev1N_Flg) { // >  > m >
                //            //OK
                //        } else if (prev2N_Flg) { // > m >  >
                //            //OK
                //        } else if (prev3N_Flg) { //m >  >  >
                //            //OK
                //        } else {
                //            //NG
                //            return 0;
                //        }
                //
                //        for (int i = VB_UP_RIGHT_STC; i <= VB_LEFT_STC; i++) {
                //            //
                //            if (isBeingPressed(i)) {
                //
                //                //A1Ot[AB
                //                //iAuvAt[Aj
                //                if (wasBeingPressed(prm_VB, 1) && wasBeingPressed(i, 1)) {
                //                    //NG
                //                    continue;
                //                } else {
                //                    //OK
                //                    return i;
                //                }
                //
                //            }
                //        }
                //        return 0;
                //    } else {
                //        return 0;
                //    }
                //
                //}
                
                
                
                
                void VirtualButton::update() {
                #ifdef MY_DEBUG
                    if (_pVBRecord_Active == NULL) {
                        throwGgafCriticalException("VirtualButton::update() pOx init() oB");
                    }
                #endif
                    GgafDx9Input::updateKeyboardState();
                    GgafDx9Input::updateJoystickState();
                
                    _pVBRecord_Active = _pVBRecord_Active->_next;
                
                    _pVBRecord_Active->_state = 0; //Zbg
                    _pVBRecord_Active->_state |= (VB_BUTTON1 * (GgafDx9Input::isBeingPressedKey(_tagKeymap.BUTTON1) ||
                                                      GgafDx9Input::isBeingPressedJoyRgbButton(_tagJoymap.BUTTON1)));
                
                    _pVBRecord_Active->_state |= (VB_BUTTON2 * (GgafDx9Input::isBeingPressedKey(_tagKeymap.BUTTON2) ||
                                                      GgafDx9Input::isBeingPressedJoyRgbButton(_tagJoymap.BUTTON2)));
                
                    _pVBRecord_Active->_state |= (VB_BUTTON3 * (GgafDx9Input::isBeingPressedKey(_tagKeymap.BUTTON3) ||
                                                      GgafDx9Input::isBeingPressedJoyRgbButton(_tagJoymap.BUTTON3)));
                
                    _pVBRecord_Active->_state |= (VB_BUTTON4 * (GgafDx9Input::isBeingPressedKey(_tagKeymap.BUTTON4) ||
                                                      GgafDx9Input::isBeingPressedJoyRgbButton(_tagJoymap.BUTTON4)));
                
                    _pVBRecord_Active->_state |= (VB_BUTTON5 * (GgafDx9Input::isBeingPressedKey(_tagKeymap.BUTTON5) ||
                                                      GgafDx9Input::isBeingPressedJoyRgbButton(_tagJoymap.BUTTON5)));
                
                    _pVBRecord_Active->_state |= (VB_BUTTON6 * (GgafDx9Input::isBeingPressedKey(_tagKeymap.BUTTON6) ||
                                                      GgafDx9Input::isBeingPressedJoyRgbButton(_tagJoymap.BUTTON6)));
                
                    _pVBRecord_Active->_state |= (VB_BUTTON7 * (GgafDx9Input::isBeingPressedKey(_tagKeymap.BUTTON7) ||
                                                      GgafDx9Input::isBeingPressedJoyRgbButton(_tagJoymap.BUTTON7)));
                
                    _pVBRecord_Active->_state |= (VB_BUTTON8 * (GgafDx9Input::isBeingPressedKey(_tagKeymap.BUTTON8) ||
                                                      GgafDx9Input::isBeingPressedJoyRgbButton(_tagJoymap.BUTTON8)));
                
                    _pVBRecord_Active->_state |= (VB_PAUSE * (GgafDx9Input::isBeingPressedKey(_tagKeymap.PAUSE) ||
                                                    GgafDx9Input::isBeingPressedJoyRgbButton(_tagJoymap.PAUSE)));
                
                    _pVBRecord_Active->_state |= (VB_UP * (GgafDx9Input::isBeingPressedKey(_tagKeymap.UP) ||
                                                 GgafDx9Input::isBeingPressedJoyUp()));
                
                    _pVBRecord_Active->_state |= (VB_DOWN * (GgafDx9Input::isBeingPressedKey(_tagKeymap.DOWN) ||
                                                   GgafDx9Input::isBeingPressedJoyDown()));
                
                    _pVBRecord_Active->_state |= (VB_LEFT * (GgafDx9Input::isBeingPressedKey(_tagKeymap.LEFT) ||
                                                   GgafDx9Input::isBeingPressedJoyLeft()));
                
                    _pVBRecord_Active->_state |= (VB_RIGHT * (GgafDx9Input::isBeingPressedKey(_tagKeymap.RIGHT) ||
                                                    GgafDx9Input::isBeingPressedJoyRight()));
                
                    _pVBRecord_Active->_state |= (VB_UI_UP * (GgafDx9Input::isBeingPressedKey(_tagKeymap.UI_UP) ||
                                                    GgafDx9Input::isBeingPressedJoyUp()));
                
                    _pVBRecord_Active->_state |= (VB_UI_DOWN * (GgafDx9Input::isBeingPressedKey(_tagKeymap.UI_DOWN) ||
                                                      GgafDx9Input::isBeingPressedJoyDown()));
                
                    _pVBRecord_Active->_state |= (VB_UI_LEFT * (GgafDx9Input::isBeingPressedKey(_tagKeymap.UI_LEFT) ||
                                                      GgafDx9Input::isBeingPressedJoyLeft()));
                
                    _pVBRecord_Active->_state |= (VB_UI_RIGHT * (GgafDx9Input::isBeingPressedKey(_tagKeymap.UI_RIGHT) ||
                                                       GgafDx9Input::isBeingPressedJoyRight()));
                
                    _pVBRecord_Active->_state |= (VB_UI_EXECUTE * (GgafDx9Input::isBeingPressedKey(_tagKeymap.UI_EXECUTE) ||
                                                         GgafDx9Input::isBeingPressedJoyRgbButton(_tagJoymap.UI_EXECUTE)));
                
                    _pVBRecord_Active->_state |= (VB_UI_CANCEL * (GgafDx9Input::isBeingPressedKey(_tagKeymap.UI_CANCEL) ||
                                                        GgafDx9Input::isBeingPressedJoyRgbButton(_tagJoymap.UI_CANCEL)));
                
                    _pVBRecord_Active->_state |= (VB_UI_DEBUG * (GgafDx9Input::isBeingPressedKey(_tagKeymap.UI_DEBUG)));
                
                
                    if (_pVBRecord_Active->_state & VB_UP) {
                        if (_pVBRecord_Active->_state & VB_RIGHT) {
                            _pVBRecord_Active->_state |= VB_UP_RIGHT_STC;
                        } else if (_pVBRecord_Active->_state & VB_LEFT) {
                            _pVBRecord_Active->_state |= VB_UP_LEFT_STC;
                        } else {
                            _pVBRecord_Active->_state |= VB_UP_STC;
                        }
                    } else if (_pVBRecord_Active->_state & VB_DOWN) {
                        if (_pVBRecord_Active->_state & VB_UI_RIGHT) {
                            _pVBRecord_Active->_state |= VB_DOWN_RIGHT_STC;
                        } else if (_pVBRecord_Active->_state & VB_UI_LEFT) {
                            _pVBRecord_Active->_state |= VB_DOWN_LEFT_STC;
                        } else {
                            _pVBRecord_Active->_state |= VB_DOWN_STC;
                        }
                    } else if (_pVBRecord_Active->_state & VB_UI_RIGHT) {
                        _pVBRecord_Active->_state |= VB_RIGHT_STC;
                    } else if (_pVBRecord_Active->_state & VB_UI_LEFT) {
                        _pVBRecord_Active->_state |= VB_LEFT_STC;
                    } else {
                        _pVBRecord_Active->_state |= VB_NEUTRAL_STC;
                    }
                }
                
                
                void VirtualButton::clear() {
                    VBRecord* pVBRecord = _pVBRecord_Active;
                    for (int i = 0; i < VB_MAP_BUFFER; i++) {
                        pVBRecord->_state = 0;
                        pVBRecord = pVBRecord->_next;
                    }
                }
                
           4 -> VirtualButton::~VirtualButton() {
                    VBRecord* pLast = _pVBRecord_Active->_next;
                    VBRecord* pWk;
                    for (VBRecord* p = _pVBRecord_Active->_prev; p != _pVBRecord_Active; p = p->_prev) {
                        pWk = p->_next;
                        DELETE_IMPOSSIBLE_NULL(pWk);
                    }
                    DELETE_IMPOSSIBLE_NULL(pLast);
                }


Top 10 Lines:

     Line      Count

      765          4
       49          2

Execution Summary:

        4   Executable lines in this file
        2   Lines executed
    50.00   Percent of the file executed

        6   Total number of line executions
     1.50   Average executions per line


*** File c:/cygwin/mingw/bin/../lib/gcc/mingw32/4.5.2/include/c++/bits/unordered_map.h:
                // unordered_map implementation -*- C++ -*-
                
                // Copyright (C) 2010 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/unordered_map.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                #ifndef _UNORDERED_MAP_H
                #define _UNORDERED_MAP_H
                
                _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)
                
                  // XXX When we get typedef templates these class definitions
                  // will be unnecessary.
                  template<class _Key, class _Tp,
                	   class _Hash = hash<_Key>,
                	   class _Pred = std::equal_to<_Key>,
                	   class _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
                	   bool __cache_hash_code = false>
                    class __unordered_map
                    : public _Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc,
                			std::_Select1st<std::pair<const _Key, _Tp> >, _Pred, 
                			_Hash, __detail::_Mod_range_hashing,
                			__detail::_Default_ranged_hash,
                			__detail::_Prime_rehash_policy,
                			__cache_hash_code, false, true>
           3 ->     {
                      typedef _Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc,
                			 std::_Select1st<std::pair<const _Key, _Tp> >, _Pred,
                			 _Hash, __detail::_Mod_range_hashing,
                			 __detail::_Default_ranged_hash,
                			 __detail::_Prime_rehash_policy,
                			 __cache_hash_code, false, true>
                        _Base;
                
                    public:
                      typedef typename _Base::size_type       size_type;
                      typedef typename _Base::hasher          hasher;
                      typedef typename _Base::key_equal       key_equal;
                      typedef typename _Base::allocator_type  allocator_type;
                
                      explicit
           3 ->       __unordered_map(size_type __n = 10,
                		      const hasher& __hf = hasher(),
                		      const key_equal& __eql = key_equal(),
                		      const allocator_type& __a = allocator_type())
                      : _Base(__n, __hf, __detail::_Mod_range_hashing(),
                	      __detail::_Default_ranged_hash(),
                	      __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)
                      { }
                
                      template<typename _InputIterator>
                        __unordered_map(_InputIterator __f, _InputIterator __l, 
                			size_type __n = 10,
                			const hasher& __hf = hasher(), 
                			const key_equal& __eql = key_equal(), 
                			const allocator_type& __a = allocator_type())
                	: _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),
                		__detail::_Default_ranged_hash(),
                		__eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)
                	{ }
                
                      __unordered_map(__unordered_map&& __x)
                      : _Base(std::forward<_Base>(__x)) { }
                    };
                  
                  template<class _Key, class _Tp,
                	   class _Hash = hash<_Key>,
                	   class _Pred = std::equal_to<_Key>,
                	   class _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
                	   bool __cache_hash_code = false>
                    class __unordered_multimap
                    : public _Hashtable<_Key, std::pair<const _Key, _Tp>,
                			_Alloc,
                			std::_Select1st<std::pair<const _Key, _Tp> >, _Pred,
                			_Hash, __detail::_Mod_range_hashing,
                			__detail::_Default_ranged_hash,
                			__detail::_Prime_rehash_policy,
                			__cache_hash_code, false, false>
                    {
                      typedef _Hashtable<_Key, std::pair<const _Key, _Tp>,
                			 _Alloc,
                			 std::_Select1st<std::pair<const _Key, _Tp> >, _Pred,
                			 _Hash, __detail::_Mod_range_hashing,
                			 __detail::_Default_ranged_hash,
                			 __detail::_Prime_rehash_policy,
                			 __cache_hash_code, false, false>
                        _Base;
                
                    public:
                      typedef typename _Base::size_type       size_type;
                      typedef typename _Base::hasher          hasher;
                      typedef typename _Base::key_equal       key_equal;
                      typedef typename _Base::allocator_type  allocator_type;
                      
                      explicit
                      __unordered_multimap(size_type __n = 10,
                			   const hasher& __hf = hasher(),
                			   const key_equal& __eql = key_equal(),
                			   const allocator_type& __a = allocator_type())
                      : _Base(__n, __hf, __detail::_Mod_range_hashing(),
                	      __detail::_Default_ranged_hash(),
                	      __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)
                      { }
                
                
                      template<typename _InputIterator>
                        __unordered_multimap(_InputIterator __f, _InputIterator __l, 
                			     typename _Base::size_type __n = 0,
                			     const hasher& __hf = hasher(), 
                			     const key_equal& __eql = key_equal(), 
                			     const allocator_type& __a = allocator_type())
                	: _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),
                		__detail::_Default_ranged_hash(),
                		__eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)
                        { }
                
                      __unordered_multimap(__unordered_multimap&& __x)
                      : _Base(std::forward<_Base>(__x)) { }
                    };
                
                  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,
                	   bool __cache_hash_code>
                    inline void
                    swap(__unordered_map<_Key, _Tp, _Hash, _Pred,
                	 _Alloc, __cache_hash_code>& __x,
                	 __unordered_map<_Key, _Tp, _Hash, _Pred,
                	 _Alloc, __cache_hash_code>& __y)
                    { __x.swap(__y); }
                
                  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,
                	   bool __cache_hash_code>
                    inline void
                    swap(__unordered_multimap<_Key, _Tp, _Hash, _Pred,
                	 _Alloc, __cache_hash_code>& __x,
                	 __unordered_multimap<_Key, _Tp, _Hash, _Pred,
                	 _Alloc, __cache_hash_code>& __y)
                    { __x.swap(__y); }
                
                  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,
                	   bool __cache_hash_code>
                    inline bool
                    operator==(const __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc,
                	       __cache_hash_code>& __x,
                	       const __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc,
                	       __cache_hash_code>& __y)
                    { return __x._M_equal(__y); }
                
                  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,
                	   bool __cache_hash_code>
                    inline bool
                    operator!=(const __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc,
                	       __cache_hash_code>& __x,
                	       const __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc,
                	       __cache_hash_code>& __y)
                    { return !(__x == __y); }
                
                  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,
                	   bool __cache_hash_code>
                    inline bool
                    operator==(const __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc,
                	       __cache_hash_code>& __x,
                	       const __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc,
                	       __cache_hash_code>& __y)
                    { return __x._M_equal(__y); }
                
                  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc,
                	   bool __cache_hash_code>
                    inline bool
                    operator!=(const __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc,
                	       __cache_hash_code>& __x,
                	       const __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc,
                	       __cache_hash_code>& __y)
                    { return !(__x == __y); }
                
                  /**
                   *  @brief A standard container composed of unique keys (containing
                   *  at most one of each key value) that associates values of another type
                   *  with the keys.
                   *
                   *  @ingroup unordered_associative_containers
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, and
                   *  <a href="tables.html#xx">unordered associative container</a>
                   *
                   *  @param  Key  Type of key objects.
                   *  @param  Tp  Type of mapped objects.
                   *  @param  Hash  Hashing function object type, defaults to hash<Value>.
                   *  @param  Pred  Predicate function object type, defaults to equal_to<Value>.
                   *  @param  Alloc  Allocator type, defaults to allocator<Key>.
                   *
                   * The resulting value type of the container is std::pair<const Key, Tp>.
                   */
                  template<class _Key, class _Tp,
                	   class _Hash = hash<_Key>,
                	   class _Pred = std::equal_to<_Key>,
                	   class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
                    class unordered_map
                    : public __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>
           3 ->     {
                      typedef __unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>  _Base;
                
                    public:
                      typedef typename _Base::value_type      value_type;
                      typedef typename _Base::size_type       size_type;
                      typedef typename _Base::hasher          hasher;
                      typedef typename _Base::key_equal       key_equal;
                      typedef typename _Base::allocator_type  allocator_type;
                
                      explicit
           3 ->       unordered_map(size_type __n = 10,
                		    const hasher& __hf = hasher(),
                		    const key_equal& __eql = key_equal(),
                		    const allocator_type& __a = allocator_type())
                      : _Base(__n, __hf, __eql, __a)
                      { }
                
                      template<typename _InputIterator>
                        unordered_map(_InputIterator __f, _InputIterator __l, 
                		      size_type __n = 10,
                		      const hasher& __hf = hasher(), 
                		      const key_equal& __eql = key_equal(), 
                		      const allocator_type& __a = allocator_type())
                	: _Base(__f, __l, __n, __hf, __eql, __a)
                        { }
                
                      unordered_map(unordered_map&& __x)
                      : _Base(std::forward<_Base>(__x)) { }
                
                      unordered_map(initializer_list<value_type> __l,
                		    size_type __n = 10,
                		    const hasher& __hf = hasher(),
                		    const key_equal& __eql = key_equal(),
                		    const allocator_type& __a = allocator_type())
                	: _Base(__l.begin(), __l.end(), __n, __hf, __eql, __a)
                      { }
                
                      unordered_map&
                      operator=(unordered_map&& __x)
                      {
                	// NB: DR 1204.
                	// NB: DR 675.
                	this->clear();
                	this->swap(__x);
                	return *this;	
                      }
                
                      unordered_map&
                      operator=(initializer_list<value_type> __l)
                      {
                	this->clear();
                	this->insert(__l.begin(), __l.end());
                	return *this;
                      }
                    };
                  
                  /**
                   *  @brief A standard container composed of equivalent keys
                   *  (possibly containing multiple of each key value) that associates
                   *  values of another type with the keys.
                   *
                   *  @ingroup unordered_associative_containers
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, and
                   *  <a href="tables.html#xx">unordered associative container</a>
                   *
                   *  @param  Key  Type of key objects.
                   *  @param  Tp  Type of mapped objects.
                   *  @param  Hash  Hashing function object type, defaults to hash<Value>.
                   *  @param  Pred  Predicate function object type, defaults to equal_to<Value>.
                   *  @param  Alloc  Allocator type, defaults to allocator<Key>.
                   *
                   * The resulting value type of the container is std::pair<const Key, Tp>.
                   */
                  template<class _Key, class _Tp,
                	   class _Hash = hash<_Key>,
                	   class _Pred = std::equal_to<_Key>,
                	   class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
                    class unordered_multimap
                    : public __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>
                    {
                      typedef __unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>  _Base;
                
                    public:
                      typedef typename _Base::value_type      value_type;
                      typedef typename _Base::size_type       size_type;
                      typedef typename _Base::hasher          hasher;
                      typedef typename _Base::key_equal       key_equal;
                      typedef typename _Base::allocator_type  allocator_type;
                      
                      explicit
                      unordered_multimap(size_type __n = 10,
                			 const hasher& __hf = hasher(),
                			 const key_equal& __eql = key_equal(),
                			 const allocator_type& __a = allocator_type())
                      : _Base(__n, __hf, __eql, __a)
                      { }
                
                
                      template<typename _InputIterator>
                        unordered_multimap(_InputIterator __f, _InputIterator __l, 
                			   typename _Base::size_type __n = 0,
                			   const hasher& __hf = hasher(), 
                			   const key_equal& __eql = key_equal(), 
                			   const allocator_type& __a = allocator_type())
                	: _Base(__f, __l, __n, __hf, __eql, __a)
                        { }
                
                      unordered_multimap(unordered_multimap&& __x)
                      : _Base(std::forward<_Base>(__x)) { }
                
                      unordered_multimap(initializer_list<value_type> __l,
                			 size_type __n = 10,
                			 const hasher& __hf = hasher(),
                			 const key_equal& __eql = key_equal(),
                			 const allocator_type& __a = allocator_type())
                	: _Base(__l.begin(), __l.end(), __n, __hf, __eql, __a)
                      { }
                
                      unordered_multimap&
                      operator=(unordered_multimap&& __x)
                      {
                	// NB: DR 1204.
                	// NB: DR 675.
                	this->clear();
                	this->swap(__x);
                	return *this;	
                      }
                
                      unordered_multimap&
                      operator=(initializer_list<value_type> __l)
                      {
                	this->clear();
                	this->insert(__l.begin(), __l.end());
                	return *this;
                      }
                    };
                
                  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
                    inline void
                    swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
                	 unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
                    { __x.swap(__y); }
                
                  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
                    inline void
                    swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
                	 unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
                    { __x.swap(__y); }
                
                  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
                    inline bool
                    operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
                	       const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
                    { return __x._M_equal(__y); }
                
                  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
                    inline bool
                    operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
                	       const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
                    inline bool
                    operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
                	       const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
                    { return __x._M_equal(__y); }
                
                  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
                    inline bool
                    operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
                	       const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
                    { return !(__x == __y); }
                
                _GLIBCXX_END_NESTED_NAMESPACE
                
                #endif /* _UNORDERED_MAP_H */


Top 10 Lines:

     Line      Count

       49          3
       65          3
      222          3
      233          3

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

       12   Total number of line executions
     3.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9LibStg/include/jp/ggaf/dx9libstg/util/VirtualButton.h:
                #ifndef VBRTUALBUTTON_H_
                #define VBRTUALBUTTON_H_
                
                typedef _MAP_<string, int> keymap;
                typedef unsigned long int vbsta;
                
                namespace GgafDx9LibStg {
                
                #define VB_BUTTON1 (0x1)
                #define VB_BUTTON2 (0x2)
                #define VB_BUTTON3 (0x4)
                #define VB_BUTTON4 (0x8)
                #define VB_BUTTON5 (0x10)
                #define VB_BUTTON6 (0x20)
                #define VB_BUTTON7 (0x40)
                #define VB_BUTTON8 (0x80)
                
                #define VB_PAUSE   (0x400)
                #define VB_UP      (0x800)
                #define VB_DOWN    (0x1000)
                #define VB_LEFT    (0x2000)
                #define VB_RIGHT   (0x4000)
                
                #define VB_UI_UP      (0x8000)
                #define VB_UI_DOWN    (0x10000)
                #define VB_UI_LEFT    (0x20000)
                #define VB_UI_RIGHT   (0x40000)
                #define VB_UI_EXECUTE (0x80000)
                #define VB_UI_CANCEL  (0x100000)
                #define VB_UI_DEBUG   (0x200000)
                
                #define VB_NEUTRAL_STC    (0x400000)   //&B 00000000 01000000 00000000 00000000
                #define VB_UP_RIGHT_STC   (0x800000)   //&B 00000000 10000000 00000000 00000000
                #define VB_DOWN_RIGHT_STC (0x1000000)  //&B 00000001 00000000 00000000 00000000
                #define VB_DOWN_LEFT_STC  (0x2000000)  //&B 00000010 00000000 00000000 00000000
                #define VB_UP_LEFT_STC    (0x4000000)  //&B 00000100 00000000 00000000 00000000
                #define VB_UP_STC         (0x8000000)  //&B 00001000 00000000 00000000 00000000
                #define VB_RIGHT_STC      (0x10000000) //&B 00010000 00000000 00000000 00000000
                #define VB_DOWN_STC       (0x20000000) //&B 00100000 00000000 00000000 00000000
                #define VB_LEFT_STC       (0x40000000) //&B 01000000 00000000 00000000 00000000
                
                #define VB_STC_CLIP_MASK  (0x803FFFFF) //&B 10000000 00111111 11111111 11111111
                #define VB_STC_MASK       (0x7FC00000) //&B 01111111 11000000 00000000 00000000
                
                #define VB_MAP_BUFFER 120
                #define VB_NUM 29
                
                
                
                /**
                 * z{^ .
                 * @version 1.00
                 * @since 2008/09/08
                 * @author Masatoshi Tsuge
                 */
                class VirtualButton {
                
                public:
                
                    struct KEYBOARDMAP {
                        int BUTTON1;
                        int BUTTON2;
                        int BUTTON3;
                        int BUTTON4;
                        int BUTTON5;
                        int BUTTON6;
                        int BUTTON7;
                        int BUTTON8;
                        int PAUSE;
                        int UP;
                        int DOWN;
                        int LEFT;
                        int RIGHT;
                        int UI_UP;
                        int UI_DOWN;
                        int UI_LEFT;
                        int UI_RIGHT;
                        int UI_EXECUTE;
                        int UI_CANCEL;
                        int UI_DEBUG;
                    };
                
                    struct JOYSTICKMAP {
                        int BUTTON1;
                        int BUTTON2;
                        int BUTTON3;
                        int BUTTON4;
                        int BUTTON5;
                        int BUTTON6;
                        int BUTTON7;
                        int BUTTON8;
                        int PAUSE;
                        int UI_EXECUTE;
                        int UI_CANCEL;
                    };
                
                    static KEYBOARDMAP _tagKeymap;
                    static JOYSTICKMAP _tagJoymap;
                
                    /**
                     * z{^Rei .
                     */
                    class VBRecord {
                    public :
                        VBRecord* _next; //nt[
                        VBRecord* _prev; //nOt[
                
                        vbsta _state;
                
         240 ->         VBRecord() {
                            //for (int i = 0; i < VB_NUM; i++) {_state[i] = false;}
                            _next = NULL;
                            _prev = NULL;
                            _state = (vbsta)0;
                        }
         240 ->         ~VBRecord() {
                        }
                    };
                    /** I[gs[gpJE^[ */
                    _MAP_<vbsta, frame> _repeat_counter;
                    /** I[gs[g true */
                    bool _is_auto_repeat;
                
                    static keymap _mapDIK;
                    static bool _is_init;
                
                
                
                
                    VirtualButton();
                
                    VBRecord* _pVBRecord_Active; //t[
                
                    VBRecord* getPastVBRecord(frame prm_frame_ago);
                
                    /**
                     * {^ .
                     * @param prm_VB z{^BVB_ n(_a)
                     * @return true/false
                     */
                    vbsta isBeingPressed(vbsta prm_VB);
                
                    /**
                     * {^ .
                     * isBeingPressed(vbsta) B
                     * @param prm_VB z{^BVB_ n(_a)
                     * @return true/false
                     */
                    vbsta isNotBeingPressed(vbsta prm_VB);
                
                    /**
                     * {^ .
                     * @param prm_VB z{^BVB_ n(_a)
                     * @param prm_frame_ago t[O(>0)wB
                     *                      1  1t[OA2  2t[OA0  isBeingPressed(vbsta) B
                     *                       (VB_MAP_BUFFER-1) t[O
                     * @return true/false
                     */
                    vbsta wasBeingPressed(vbsta prm_VB, frame prm_frame_ago);
                
                    /**
                     * {^ .
                     * wasBeingPressed(vbsta, frame) B
                     * @param prm_VB z{^BVB_ n(_a)
                     * @param prm_frame_ago t[O(>0)wB
                     *                      1  1t[OA2  2t[OA0  isBeingPressed(vbsta) B
                     *                       (VB_MAP_BUFFER-1) t[O
                     * @return true/false
                     */
                    vbsta wasNotBeingPressed(vbsta prm_VB, frame prm_frame_ago);
                
                    /**
                     * {^u .
                     * AAPt[O true
                     * @param prm_VB z{^BVB_ n(_a)
                     * @return true/false
                     */
                    vbsta isPushedDown(vbsta prm_VB);
                
                    /**
                     * {^u .
                     * prm_frame_agot[OAA(prm_frame_ago+1)t[O true
                     * @param prm_VB z{^BVB_ n(_a)
                     * @param prm_frame_ago t[O(>0)wB
                     *                      1  1t[OA2  2t[OA0  isPushedDown(vbsta) B
                     *                       (VB_MAP_BUFFER-1) t[O
                     * @return true/false
                     */
                    vbsta wasPushedDown(vbsta prm_VB, frame prm_frame_ago);
                
                    /**
                     * {^u .
                     * AAPt[O true
                     * @param prm_VB z{^BVB_ n(_a)
                     * @return true/false
                     */
                    vbsta isReleasedUp(vbsta prm_VB);
                
                    /**
                     * {^u .
                     * prm_frame_agot[OAA(prm_frame_ago+1)t[O true
                     * @param prm_VB z{^BVB_ n(_a)
                     * @param prm_frame_ago t[O(>0)wB
                     *                      1  1t[OA2  2t[OA0  isReleasedUp(vbsta) B
                     * @return true/false
                     */
                    vbsta wasReleasedUp(vbsta prm_VB, frame prm_frame_ago);
                
                
                    /**
                     * ` .
                     * u{^{^{^vJA
                     * B
                     * A prm_frame_push i`FjB
                     * G{^ prm_frame_push=2 wB;
                     * @param prm_VB z{^BVB_ n(_a)
                     * @param prm_frame_push e{^t[(default=5)
                     * @return true/false
                     */
                    vbsta isPushedUp(vbsta prm_VB, frame prm_frame_push = 5);
                
                    /**
                     * _uvbV .
                     * u(a){^(b){^(c){^(d){^vJA
                     * B
                     * A   (b)`(c) prm_frame_push B
                     *  (c)`(d)Q{^ prm_frame_delay JB
                     * @param prm_VB z{^BVB_ n(_a)
                     * @param prm_frame_push e(b)`(c) 
                     * @param prm_frame_delay e(c)`(d) 
                     * @return
                     */
                    vbsta isDoublePushedDown(vbsta prm_VB, frame prm_frame_push = 5, frame prm_frame_delay = 5);
                
                    /**
                     * {^ .
                     * isPushedDown(vbsta) {^wsA\B
                     * A{^1t[ocLASB
                     * A{\bhAocLlB
                     * IA{^St[A
                     * J1sB
                     * <pre>
                     *  > H > H > 
                     *       or
                     * H >  > H > 
                     *       or
                     * H > H >  > 
                     *
                     * F ^ F ^ HFC
                     * EA
                     * </pre>
                     * @param prm_aVB z{^z
                     * @param prm_iButtonNum zvf
                     * @return
                     */
                    vbsta arePushedDownAtOnce(vbsta prm_aVB[], int prm_iButtonNum);
                
                    vbsta arePushedDownAtOnce(vbsta prm_VB1, vbsta prm_VB2) {
                        vbsta vb[2];
                        vb[0] = prm_VB1;
                        vb[1] = prm_VB2;
                        return arePushedDownAtOnce(vb, 2);
                    }
                
                    vbsta arePushedDownAtOnce(vbsta prm_VB1, vbsta prm_VB2, vbsta prm_VB3) {
                        vbsta vb[3];
                        vb[0] = prm_VB1;
                        vb[1] = prm_VB2;
                        vb[2] = prm_VB3;
                        return arePushedDownAtOnce(vb, 3);
                    }
                
                    vbsta arePushedDownAtOnce(vbsta prm_VB1, vbsta prm_VB2, vbsta prm_VB3, vbsta prm_VB4) {
                        vbsta vb[4];
                        vb[0] = prm_VB1;
                        vb[1] = prm_VB2;
                        vb[2] = prm_VB3;
                        vb[3] = prm_VB4;
                        return arePushedDownAtOnce(vb, 4);
                    }
                
                    /**
                     * I[gs[g .
                     * @param prm_VB z{^BVB_ n(_a)
                     * @return true/false
                     */
                    vbsta isAutoRepeat(vbsta prm_VB);
                
                    /**
                     * Ob| .
                     * UMGtXN[pChCo[R}hB
                     * IAprm_frame_delay 
                     *     S{^AisPushedDown(prm_VB) B
                     *  true B
                     * @param prm_VB uOb|vu|v{^
                     * @param prm_frame_delay uOb|vet[
                     * @return true/false
                     */
                    bool isRoundPushDown(vbsta prm_VB, frame prm_frame_delay=30);
                
                
                    /**
                     * XeBbNB
                     * @return 
                     * VB_UP_STC
                     * VB_UP_RIGHT_STC
                     * VB_RIGHT_STC
                     * VB_DOWN_RIGHT_STC
                     * VB_DOWN_STC
                     * VB_DOWN_LEFT_STC
                     * VB_LEFT_STC
                     * VB_UP_LEFT_STC
                     * VB_NEUTRAL_STC
                     */
                    vbsta getBeingPressedStick();
                
                    /**
                     * PushedDownXeBbNB
                     * @return 
                     * VB_UP_STC
                     * VB_UP_RIGHT_STC
                     * VB_RIGHT_STC
                     * VB_DOWN_RIGHT_STC
                     * VB_DOWN_STC
                     * VB_DOWN_LEFT_STC
                     * VB_LEFT_STC
                     * VB_UP_LEFT_STC
                     * VB_NEUTRAL_STC
                     */
                    vbsta getPushedDownStick();
                
                
                    vbsta isDoublePushedDownStick(frame prm_frame_push = 5, frame prm_frame_delay = 5);
                
                
                //    /**
                //     * Aprm_VB1PushedDownXeBbNB
                //     * @return 
                //     * VB_UP_STC
                //     * VB_UP_RIGHT_STC
                //     * VB_RIGHT_STC
                //     * VB_DOWN_RIGHT_STC
                //     * VB_DOWN_STC
                //     * VB_DOWN_LEFT_STC
                //     * VB_LEFT_STC
                //     * VB_UP_LEFT_STC
                //     * VB_NEUTRAL_STC
                //     */
                //    static vbsta getPushedDownStickWith(int prm_VB);
                
                
                    //vbsta isClicked(vbsta prm_VB);
                
                    void update();
                
                    void init();
                
                    void clear();
                
                
                
                
                    virtual ~VirtualButton();
                };
                
                }
                #endif /*VBRTUALBUTTON_H_*/


Top 10 Lines:

     Line      Count

      110        240
      116        240

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

      480   Total number of line executions
   240.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/scene/DefaultScene.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
          16 -> DefaultScene::DefaultScene(const char* prm_name) : GgafDx9Scene(prm_name) {
                    _class_name = "DefaultScene";
                    _paFrame_NextEvent = NULL;
                    _iCnt_Event = 0;
                    _event_num = 0;
                }
                
          16 -> DefaultScene::~DefaultScene() {
                    //V[Cxg
                    DELETEARR_POSSIBLE_NULL(_paFrame_NextEvent);
                }


Top 10 Lines:

     Line      Count

        7         16
       14         16

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       32   Total number of line executions
    10.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\GgafDx9LibStg\GprofCdt/../src/jp/ggaf/dx9libstg/scene/DefaultUniverse.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                
           1 -> DefaultUniverse::DefaultUniverse(const char* prm_name, GgafDx9Camera* prm_pCamera) : GgafDx9Universe(prm_name, prm_pCamera) {
                    _class_name = "DefaultUniverse";
                    //W
                    _pLinearOctree = NEW LinearOctreeForActor(6);
                    //_pLinearOctree->setRootSpace(-8000000 ,-8000000 ,-8000000 ,8000000 ,8000000 ,8000000);
                    _pLinearOctree->setRootSpace(_X_goneLeft  ,_Y_goneBottom, _Z_goneNear  ,
                                                 _X_goneRight ,_Y_goneTop   , _Z_goneFar);
                
                }
                
                
                void DefaultUniverse::processFinal() {
                //    if (GgafDx9Input::isBeingPressedKey(DIK_I)) {
                //        _TRACE_(" DefaultUniverse::processFinal() befor");
                //        _pLinearOctree->putTree();
                //    }
                
                    _pLinearOctree->clearElem();
                
                //    if (GgafDx9Input::isBeingPressedKey(DIK_I)) {
                //        _TRACE_(" DefaultUniverse::processFinal() _pLinearOctree->clearElem(); after");
                //        _pLinearOctree->putTree();
                //    }
                
                //    //[gV[XV
                //    float x1,y1,z1,x2,y2,z2;
                //    x1 = y1 = z1 = x2 = y2 = z2 = 0.0f;
                //    D3DXVECTOR3* pVecNear;
                //    D3DXVECTOR3* pVecFar;
                //
                //    for (int i = 0; i < 4; i++) {
                //        pVecNear =  &(P_CAM->_vecNear[i]);
                //        pVecFar  =  &(P_CAM->_vecFar[i]);
                //
                //
                //        if (x1 > pVecNear->x) {
                //            x1 = pVecNear->x;
                //        }
                //        if (y1 > pVecNear->y) {
                //            y1 = pVecNear->y;
                //        }
                //        if (z1 > pVecNear->z) {
                //            z1 = pVecNear->z;
                //        }
                //
                //        if (x2 < pVecNear->x) {
                //            x2 = pVecNear->x;
                //        }
                //        if (y2 < pVecNear->y) {
                //            y2 = pVecNear->y;
                //        }
                //        if (z2 < pVecNear->z) {
                //            z2 = pVecNear->z;
                //        }
                //
                //        if (x1 > pVecFar->x) {
                //            x1 = pVecFar->x;
                //        }
                //        if (y1 > pVecFar->y) {
                //            y1 = pVecFar->y;
                //        }
                //        if (z1 > pVecFar->z) {
                //            z1 = pVecFar->z;
                //        }
                //
                //        if (x2 < pVecFar->x) {
                //            x2 = pVecFar->x;
                //        }
                //        if (y2 < pVecFar->y) {
                //            y2 = pVecFar->y;
                //        }
                //        if (z2 < pVecFar->z) {
                //            z2 = pVecFar->z;
                //        }
                //    }
                //
                //
                //    _pLinearOctree->setRootSpace(x1*1.3 * PX_UNIT * LEN_UNIT,
                //                                 y1*1.3 * PX_UNIT * LEN_UNIT,
                //                                 z1*1.3 * PX_UNIT * LEN_UNIT,
                //                                 x2*1.3 * PX_UNIT * LEN_UNIT,
                //                                 y2*1.3 * PX_UNIT * LEN_UNIT,
                //                                 z2*1.3 * PX_UNIT * LEN_UNIT);
                //    if (GgafDx9Input::isBeingPressedKey(DIK_I)) {
                //        _TRACE_("ROOT(x1,y1,z1,x2,y2,z2)=("<<(_pLinearOctree->_root_X1)<<","<<
                //                                             (_pLinearOctree->_root_Y2)<<","<<
                //                                             (_pLinearOctree->_root_Z2)<<","<<
                //                                             (_pLinearOctree->_root_X2)<<","<<
                //                                             (_pLinearOctree->_root_Y2)<<","<<
                //                                             (_pLinearOctree->_root_Z2)<<")");
                //    }
                
                
                }
                
           1 -> DefaultUniverse::~DefaultUniverse() {
                #ifdef MY_DEBUG
                    _pLinearOctree->putTree();
                    ColliAABActor::release();
                    ColliAAPrismActor::release();
                    ColliSphereActor::release();
                #endif
                    DELETE_IMPOSSIBLE_NULL(_pLinearOctree);
                }


Top 10 Lines:

     Line      Count

        7          1
      102          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        2   Total number of line executions
     0.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../MySTG2nd.cpp:
                // MySTG2nd.cpp : AvP[VGg |Cg`B
                //
                #include "stdafx.h"
                #include "MySTG2nd.h"
                #include "resource.h"
                
                using namespace std;
                
                #define MAX_LOADSTRING 100
                //#define WINDOW_TITLE "MyStg2nd"
                
                
                // O[o:
                HINSTANCE hInst; // C^[tFCX
                TCHAR szTitle[MAX_LOADSTRING]; // ^Cg o[eLXg
                TCHAR szWindowClass[MAX_LOADSTRING]; // C EBhE NX
                
                // R[h W[]:
                ATOM MyRegisterClass(HINSTANCE hInstance);
                //BOOL				InitInstance(HINSTANCE, int);
                LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
                INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);
                
                //void adjustGameScreen(HWND);
                /**
                 * GNU GCC Gg|Cg
                 */
       ##### -> int main(int argc, char *argv[]) {
                    STARTUPINFO StatUpInfo;
                    HINSTANCE hInstance;
                    HANDLE hPrevInstance;
                    LPSTR lpCmdLine;
                    int nCmdShow;
                    //WNDCLASS	wc;
                    //	HWND		hWnd;
                    //	MSG			msg;
                
                    GetStartupInfo(&StatUpInfo);
                    hInstance = GetModuleHandle(0);
                    hPrevInstance = 0;
                    lpCmdLine = GetCommandLine();
                    nCmdShow = (StatUpInfo.dwFlags & STARTF_USESHOWWINDOW) ? StatUpInfo.wShowWindow : SW_SHOWNORMAL;
                    /* GetCommandLinevOB */
                    while (*lpCmdLine != ' ' && *lpCmdLine != '\0')
                        lpCmdLine++;
                    while (*lpCmdLine == ' ')
                        lpCmdLine++;
                    cout << lpCmdLine << endl;
                    /* A{ */
                    //wc.lpszClassName = "MySTG2nd";
                    /* dNh~ (oO...)*/
                    //	if((hWnd=FindWindow(WINDOW_CLASS, NULL))!=0) {
                    //		if (IsIconic(hWnd)) {
                    //			ShowWindow(hWnd, SW_RESTORE);
                    //		}
                    //		SetForegroundWindow(hWnd);
                    //		return 0;
                    //	}
                
                    //{WinMain
                    WinMain((HINSTANCE)hInstance, (HINSTANCE)hPrevInstance, lpCmdLine, nCmdShow);
                    return 0;
                }
                
                static MyStg2nd::God* pGod = NULL;
                static bool can_be_god = false;
                
                /**
                 * VCGg|Cg
                 */
                int APIENTRY _tWinMain(HINSTANCE hInstance,
                        HINSTANCE hPrevInstance,
                        LPTSTR lpCmdLine,
                        int nCmdShow)
           1 -> {
                
                    //_CrtSetBreakAlloc(95299);
                
                    UNREFERENCED_PARAMETER(hPrevInstance);
                    UNREFERENCED_PARAMETER(lpCmdLine);
                
                    MSG msg;
                    //	HACCEL hAccelTable;
                
                    // O[oB
                    LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
                    _TRACE_("szTitle = "<<szTitle);
                    LoadString(hInstance, IDC_MYSTG2ND, szWindowClass, MAX_LOADSTRING);
                    _TRACE_("szWindowClass = "<<szWindowClass);
                    //LoadStringI
                //    strcpy(szTitle,"MyStg2nd"); //
                //    strcpy(szWindowClass,"MYSTG2ND"); //I
                
                
                    //vpeBt@C
                    try {
                        MyStg2nd::Properties::load(".\\config.properties");
                    } catch (GgafCore::GgafCriticalException& e) {
                        MessageBox(NULL, (string("config.properties [hsB\nRF")+e.getMsg()).c_str(),"Error", MB_OK|MB_ICONSTOP);
                        MyStg2nd::Properties::clean();
                        _TRACE_("[GgafCriticalException]:" << e.getMsg());
                        return EXIT_FAILURE;
                    }
                
                    MyRegisterClass(hInstance);
                    HWND hWnd;
                    hInst = hInstance; // O[oCX^Xi[B
                    if (GGAFDX9_PROPERTY(FULL_SCREEN)) {
                
                        // EChE
                        hWnd = CreateWindowEx(
                            WS_EX_APPWINDOW,
                            szWindowClass, //WINDOW_CLASS,          // EChENX
                            szTitle,//WINDOW_TITLE,             // EChE^Cg
                            WS_POPUP | WS_VISIBLE,
                            CW_USEDEFAULT,
                            CW_USEDEFAULT,
                            GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH), // EBhE
                            GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT), // EBhE
                            HWND_DESKTOP,
                            NULL,
                            hInstance,
                            NULL);
                
                    } else {
                        hWnd = CreateWindow(
                                szWindowClass, //WINDOW_CLASS,			// EChENX
                                szTitle,//WINDOW_TITLE,				// EChE^Cg
                                //WS_OVERLAPPEDWINDOW & ~WS_THICKFRAME & ~WS_MAXIMIZEBOX, // EChEX^C
                                WS_OVERLAPPEDWINDOW, // EChEX^C
                                CW_USEDEFAULT, // EBhE\wW
                                CW_USEDEFAULT, // EBhE\xW
                                GGAFDX9_PROPERTY(VIEW_SCREEN_WIDTH), // EBhE
                                GGAFDX9_PROPERTY(VIEW_SCREEN_HEIGHT), // EBhE
                                HWND_DESKTOP, // eEChE
                                NULL, // EChEj[
                                hInstance, // CX^Xnh
                                NULL // WM_CREATE
                        );
                    }
                
                    if (!hWnd) {
                        cout << "can't CreateWindow " << endl;
                        cout << "szWindowClass=" << szWindowClass << endl;
                        cout << "szTitle=" << szTitle << endl;
                        return FALSE;
                    }
                
                    if (GGAFDX9_PROPERTY(FULL_SCREEN)) {
                
                    } else {
                        RECT wRect, cRect; // EBhES`ANCAg`
                        int ww, wh; // EBhESA
                        int cw, ch; // NCAgA
                        int fw, fh; // t[A
                        // EBhESEvZ
                        GetWindowRect(hWnd, &wRect);
                        ww = wRect.right - wRect.left;
                        wh = wRect.bottom - wRect.top;
                        // NCAgEvZ
                        GetClientRect(hWnd, &cRect);
                        cw = cRect.right - cRect.left;
                        ch = cRect.bottom - cRect.top;
                        // NCAgOKvTCYvZ
                        fw = ww - cw;
                        fh = wh - ch;
                        // vZEBhE
                        SetWindowPos(
                                hWnd,
                                HWND_TOP,
                                wRect.left,
                                wRect.top,
                                GGAFDX9_PROPERTY(VIEW_SCREEN_WIDTH) + fw,
                                GGAFDX9_PROPERTY(VIEW_SCREEN_HEIGHT) + fh,
                                SWP_NOMOVE
                        );
                
                        ShowWindow(hWnd, nCmdShow);
                        UpdateWindow(hWnd);
                        //hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MTSTG17_031));//V[gJbg[h
                    }
                
                #ifdef MY_DEBUG
                    #ifdef _MSC_VER
                        #ifdef _DEBUG
                            ::_CrtSetDbgFlag(_CRTDBG_LEAK_CHECK_DF | _CRTDBG_ALLOC_MEM_DF);
                        #else
                            //
                        #endif
                    #else
                        //[|N`FbNBEGIN
                        ::detectMemoryLeaksStart(std::cout);
                    #endif
                #else
                    #ifdef _MSC_VER
                        #ifdef _DEBUG
                            ::_CrtSetDbgFlag(_CRTDBG_LEAK_CHECK_DF | _CRTDBG_ALLOC_MEM_DF);
                        #else
                            //
                        #endif
                    #else
                        //
                    #endif
                #endif
                
                    try {
                        //_aI
                        pGod = NEW MyStg2nd::God(hInstance, hWnd);
                        can_be_god = true;
                        if (SUCCEEDED(pGod->init())) {
                
                            // [vEUE[v
                            ::timeBeginPeriod(1);
                            while (true) {
                                if (::PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                                    if (msg.message == WM_QUIT) {
                
                                        if (can_be_god) {
                                            can_be_god = false;
                                            pGod->_can_be = false;
                                            while (pGod->_is_being) {
                                                Sleep(2);
                                                _TRACE_("Wait! _ is being yet..");
                                            }
                                            delete pGod; //_
                
                                            //RELEASE_IMPOSSIBLE_NULL(_pID3DDevice9);
                                            pGod = NULL;
                                            MyStg2nd::Properties::clean();
                                        }
                
                                        ::timeEndPeriod(1);
                
                #ifdef MY_DEBUG
                    #ifdef _MSC_VER
                        #ifdef _DEBUG
                                        //_v
                                        //_CrtDumpMemoryLeaks();
                        #else
                                        //
                        #endif
                    #else
                                        //[|N`FbNEND
                                        ::detectMemoryLeaksEnd(std::cout);
                    #endif
                #else
                    #ifdef _MSC_VER
                        #ifdef _DEBUG
                                        //_v
                                        //_CrtDumpMemoryLeaks();
                                        _CrtMemDumpAllObjectsSince( NULL );
                
                        #else
                                        //
                        #endif
                    #else
                                        //
                    #endif
                #endif
                
                                        return EXIT_SUCCESS;
                                    }
                                    ::TranslateMessage(&msg);
                                    ::DispatchMessage(&msg);
                                } else {
                                    if (can_be_god && pGod->_is_being == false) {
                                        pGod->be(); //_ij
                                    }
                
                                }
                            }
                        }
                    } catch (GgafCore::GgafCriticalException& e) {
                        //I
                        if (can_be_god) {
                            _TRACE_("O"<<e.getMsg());
                            string message = "\nE"+e.getMsg()+"  \n\nG[SA{AvoO\B\n\B\n";
                            string message_dialog = message + "(uShift + Ctrl + CvbZ[WRs[B)";
                            MessageBox(NULL, message_dialog.c_str(),"LG[", MB_OK|MB_ICONSTOP);
                            _TRACE_("[GgafCriticalException]:"<<e.getMsg());
                        }
                        ::timeEndPeriod(1);
                        return EXIT_FAILURE;
                    } catch (exception& e2) {
                        if (can_be_god) {
                            string what(e2.what());
                            _TRACE_("vIO"<<what);
                            string message = "\nE"+what+"  \n\nA\vIG[B\n\B\n";
                            string message_dialog = message + "(uShift + Ctrl + CvbZ[WRs[B)";
                            MessageBox(NULL, message_dialog.c_str(),"LvIO", MB_OK|MB_ICONSTOP);
                            _TRACE_("[exception]:"<<what);
                        }
                        ::timeEndPeriod(1);
                        return EXIT_FAILURE;
                    }
                    /*
                     } catch (...) {
                     _TRACE_("sOANZX");
                     string message = "sOBSbZ[WAoOvB\nflB";
                     MessageBox(NULL, message.c_str(),"LG[", MB_OK|MB_ICONSTOP);
                     GgafCore::GgafLogger::write("sOANZX");
                     ::timeEndPeriod(1);
                     try { god->_pUniverse->dump();       } catch (...) { GgafCore::GgafLogger::write("god->_pUniverse->dump() s"); } //G[
                     try { delete god;                 } catch (...) { GgafCore::GgafLogger::write("delete god; s"); } //G[
                     try { GgafDx9Core::MyStg2nd::Properties::clean(); } catch (...) { GgafCore::GgafLogger::write("MyStg2nd::Properties::clean(); s"); } //G[
                     return EXIT_SUCCESS;
                     }
                     */
                    //_CrtDumpMemoryLeaks();	// _\
                    return (int) msg.wParam;
                }
                
                //
                //  : MyRegisterClass()
                //
                //  I: EBhE NXo^B
                //
                //  Rg:
                //
                //    gA'RegisterClassEx' 
                //    Windows 95 O Win32 VXeKvB
                //    AvP[VAAt
                //    `ACRA
                //    oB
                //
           1 -> ATOM MyRegisterClass(HINSTANCE hInstance) {
                    WNDCLASSEX wcex;
                
                    wcex.cbSize = sizeof(WNDCLASSEX);
                
                    wcex.style = CS_HREDRAW | CS_VREDRAW; //EEChETCYXEChEB
                    wcex.lpfnWndProc = WndProc; //EBhEvV[WAhXwB
                    wcex.cbClsExtra = 0;
                    wcex.cbWndExtra = 0;
                    wcex.hInstance = hInstance;
                    wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MYSTG2ND));
                    wcex.hCursor = LoadCursor(NULL, IDC_ARROW);
                    wcex.hbrBackground = CreateSolidBrush(RGB(30, 30, 30)); //0~255
                    wcex.lpszMenuName = NULL;//MAKEINTRESOURCE(IDC_MYSTG2ND);//NULL; //MAKEINTRESOURCE(IDC_MTSTG17_031);//j[o[
                    wcex.lpszClassName = szWindowClass;
                    wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));
                
                    return RegisterClassEx(&wcex);
                }
                
                //
                //   : InitInstance(HINSTANCE, int)
                //
                //   I: CX^X nhAC EBhEB
                //
                //   Rg:
                //
                //        AO[oCX^X nhA
                //        C vO EBhE\B
                //
                /*
                 BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
                 {
                 HWND hWnd;
                
                 hInst = hInstance; // O[oCX^Xi[B
                
                 hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
                 CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);
                
                 if (!hWnd)
                 {
                 return FALSE;
                 }
                
                 ShowWindow(hWnd, nCmdShow);
                 UpdateWindow(hWnd);
                
                 return TRUE;
                 }
                 */
                
                //
                //  : WndProc(HWND, UINT, WPARAM, LPARAM)
                //
                //  I:  C EBhEbZ[WB
                //
                //  WM_COMMAND	- AvP[V j[
                //  WM_PAINT	- C EBhE`
                //  WM_DESTROY	- ~bZ[W\
                //
                //
       ##### -> LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
                    //	int wmId, wmEvent;
                    PAINTSTRUCT ps;
                    HDC hdc;
                
                    switch (message) {
                        /*
                         case WM_COMMAND:
                         wmId    = LOWORD(wParam);
                         wmEvent = HIWORD(wParam);
                         // Ij[:
                         switch (wmId)
                         {
                         case IDM_ABOUT:
                         DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
                         break;
                         case IDM_EXIT:
                         DestroyWindow(hWnd);
                         break;
                         default:
                         return DefWindowProc(hWnd, message, wParam, lParam);
                         }
                         break;
                         */
                        case WM_SIZE:
                            if (can_be_god) {
                                if (!GGAFDX9_PROPERTY(FULL_SCREEN)) {
                                    GgafDx9Core::GgafDx9God::_adjustGameScreen = true;
                                }
                            }
                            break;
                
                            //    case WM_KEYDOWN:
                            //        //GXP[vL[I
                            //        case VK_ESCAPE:
                            //            PostMessage(hWnd,WM_CLOSE,0,0);
                            //            return 0;
                            //
                //        case WM_PAINT:
                //            if (can_be_god) {
                //                hdc = BeginPaint(hWnd, &ps);
                //                EndPaint(hWnd, &ps);
                //            }
                //            break;
                        case WM_SYSCOMMAND:
                            if(wParam == SC_CLOSE){
                //                if (can_be_god) {
                //                    can_be_god = false;
                //                    pGod->_can_be = false;
                //                    while (pGod->_is_being) {
                //                        Sleep(2);
                //                        _TRACE_("_ being yet");
                //                    }
                //                    delete pGod; //_
                //                    pGod = NULL;
                //                    MyStg2nd::Properties::clean();
                //                }
                                PostQuitMessage(0);
                
                            }
                            break;
                
                        case WM_DESTROY:
                            //                        SetActiveWindow(hWnd);
                            //                        SetPriorityClass( GetCurrentProcess(), HIGH_PRIORITY_CLASS );
                            //                        //DxRB
                            //                        //ANeBuxB
                //            if (can_be_god) {
                //                can_be_god = false;
                //                pGod->_can_be = false;
                //                while (pGod->_is_being) {
                //                    Sleep(2);
                //                    _TRACE_("_ being yet");
                //                }
                //                delete pGod; //_
                //                pGod = NULL;
                //                MyStg2nd::Properties::clean();
                //            }
                            PostQuitMessage(0);
                            break;
                        default:
                            break;
                    }
                    return DefWindowProc(hWnd, message, wParam, lParam);
                }
                
                // o[W{bNXbZ[W nhB
                /*
                 INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
                 {
                 UNREFERENCED_PARAMETER(lParam);
                 switch (message)
                 {
                 case WM_INITDIALOG:
                 return (INT_PTR)TRUE;
                
                 case WM_COMMAND:
                 if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
                 {
                 EndDialog(hDlg, LOWORD(wParam));
                 return (INT_PTR)TRUE;
                 }
                 break;
                 }
                 return (INT_PTR)FALSE;
                 }
                 */
                
                //GgafDx9God
                //void adjustGameScreen(HWND hWnd) {
                //    if (GGAFDX9_PROPERTY(FIXED_VIEW_ASPECT)) {
                //        RECT rect;
                //        GetClientRect(hWnd, &rect); //H
                //        if (1.0f * rect.right / rect.bottom > 1.0f * GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH) / GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT)) {
                //            //
                //            float rate = 1.0f * rect.bottom / GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT); //k=c
                //            GgafDx9Core::GgafDx9God::_rectPresentDest.left = (rect.right / 2.0f) - (GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)
                //                    * rate / 2.0f);
                //            GgafDx9Core::GgafDx9God::_rectPresentDest.top = 0;
                //            GgafDx9Core::GgafDx9God::_rectPresentDest.right = (rect.right / 2.0f)
                //                    + (GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH) * rate / 2.0f);
                //            GgafDx9Core::GgafDx9God::_rectPresentDest.bottom = GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT) * rate;
                //        } else {
                //            //c
                //            float rate = 1.0f * rect.right / GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH); //k=
                //            GgafDx9Core::GgafDx9God::_rectPresentDest.left = 0;
                //            GgafDx9Core::GgafDx9God::_rectPresentDest.top = (rect.bottom / 2.0f)
                //                    - (GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT) * rate / 2.0f);
                //            GgafDx9Core::GgafDx9God::_rectPresentDest.right = GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH) * rate;
                //            GgafDx9Core::GgafDx9God::_rectPresentDest.bottom = (rect.bottom / 2.0f)
                //                    + (GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT) * rate / 2.0f);
                //        }
                //    } else {
                //        GetClientRect(hWnd, &(GgafDx9Core::GgafDx9God::_rectPresentDest));
                //    }
                //}


Top 10 Lines:

     Line      Count

       75          1
      326          1

Execution Summary:

        9   Executable lines in this file
        4   Lines executed
    44.44   Percent of the file executed

        2   Total number of line executions
     0.22   Average executions per line


*** File c:/cygwin/mingw/bin/../lib/gcc/mingw32/4.5.2/include/c++/ext/new_allocator.h:
                // Allocator that wraps operator new -*- C++ -*-
                
                // Copyright (C) 2001, 2002, 2003, 2004, 2005, 2009
                // Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/new_allocator.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _NEW_ALLOCATOR_H
                #define _NEW_ALLOCATOR_H 1
                
                #include <new>
                #include <bits/functexcept.h>
                #include <bits/move.h>
                
                _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)
                
                  using std::size_t;
                  using std::ptrdiff_t;
                
                  /**
                   *  @brief  An allocator that uses global new, as per [20.4].
                   *  @ingroup allocators
                   *
                   *  This is precisely the allocator defined in the C++ Standard. 
                   *    - all allocation calls operator new
                   *    - all deallocation calls operator delete
                   */
                  template<typename _Tp>
                    class new_allocator
                    {
                    public:
                      typedef size_t     size_type;
                      typedef ptrdiff_t  difference_type;
                      typedef _Tp*       pointer;
                      typedef const _Tp* const_pointer;
                      typedef _Tp&       reference;
                      typedef const _Tp& const_reference;
                      typedef _Tp        value_type;
                
                      template<typename _Tp1>
                        struct rebind
                        { typedef new_allocator<_Tp1> other; };
                
         126 ->       new_allocator() throw() { }
                
       ##### ->       new_allocator(const new_allocator&) throw() { }
                
                      template<typename _Tp1>
                        new_allocator(const new_allocator<_Tp1>&) throw() { }
                
         126 ->       ~new_allocator() throw() { }
                
                      pointer
                      address(reference __x) const { return &__x; }
                
                      const_pointer
                      address(const_reference __x) const { return &__x; }
                
                      // NB: __n is permitted to be 0.  The C++ standard says nothing
                      // about what the return value is when __n == 0.
                      pointer
                      allocate(size_type __n, const void* = 0)
                      { 
                	if (__n > this->max_size())
                	  std::__throw_bad_alloc();
                
                	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
                      }
                
                      // __p is not permitted to be a null pointer.
                      void
                      deallocate(pointer __p, size_type)
                      { ::operator delete(__p); }
                
                      size_type
                      max_size() const throw() 
                      { return size_t(-1) / sizeof(_Tp); }
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 402. wrong new expression in [some_] allocator::construct
                      void 
                      construct(pointer __p, const _Tp& __val) 
                      { ::new((void *)__p) _Tp(__val); }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      template<typename... _Args>
                        void
                        construct(pointer __p, _Args&&... __args)
                	{ ::new((void *)__p) _Tp(std::forward<_Args>(__args)...); }
                #endif
                
                      void 
                      destroy(pointer __p) { __p->~_Tp(); }
                    };
                
                  template<typename _Tp>
                    inline bool
                    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
                    { return true; }
                  
                  template<typename _Tp>
                    inline bool
                    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
                    { return false; }
                
                _GLIBCXX_END_NAMESPACE
                
                #endif


Top 10 Lines:

     Line      Count

       66        126
       73        126

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

      252   Total number of line executions
    84.00   Average executions per line


*** File c:/cygwin/mingw/bin/../lib/gcc/mingw32/4.5.2/include/c++/bits/allocator.h:
                // Allocators -*- C++ -*-
                
                // Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
                // Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 * Copyright (c) 1996-1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file allocator.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                #ifndef _ALLOCATOR_H
                #define _ALLOCATOR_H 1
                
                // Define the base class to std::allocator.
                #include <bits/c++allocator.h>
                
                _GLIBCXX_BEGIN_NAMESPACE(std)
                
                  /**
                   * @defgroup allocators Allocators
                   * @ingroup memory
                   *
                   * Classes encapsulating memory operations.
                   */
                
                  template<typename _Tp>
                    class allocator;
                
                  /// allocator<void> specialization.
                  template<>
                    class allocator<void>
                    {
                    public:
                      typedef size_t      size_type;
                      typedef ptrdiff_t   difference_type;
                      typedef void*       pointer;
                      typedef const void* const_pointer;
                      typedef void        value_type;
                
                      template<typename _Tp1>
                        struct rebind
                        { typedef allocator<_Tp1> other; };
                    };
                
                  /**
                   * @brief  The @a standard allocator, as per [20.4].
                   * @ingroup allocators
                   *
                   *  Further details:
                   *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt04ch11.html
                   */
                  template<typename _Tp>
                    class allocator: public __glibcxx_base_allocator<_Tp>
                    {
                   public:
                      typedef size_t     size_type;
                      typedef ptrdiff_t  difference_type;
                      typedef _Tp*       pointer;
                      typedef const _Tp* const_pointer;
                      typedef _Tp&       reference;
                      typedef const _Tp& const_reference;
                      typedef _Tp        value_type;
                
                      template<typename _Tp1>
                        struct rebind
                        { typedef allocator<_Tp1> other; };
                
         103 ->       allocator() throw() { }
                
       ##### ->       allocator(const allocator& __a) throw()
                      : __glibcxx_base_allocator<_Tp>(__a) { }
                
                      template<typename _Tp1>
          23 ->         allocator(const allocator<_Tp1>&) throw() { }
                
         126 ->       ~allocator() throw() { }
                
                      // Inherit everything else.
                    };
                
                  template<typename _T1, typename _T2>
                    inline bool
                    operator==(const allocator<_T1>&, const allocator<_T2>&)
                    { return true; }
                
                  template<typename _Tp>
                    inline bool
                    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
                    { return true; }
                
                  template<typename _T1, typename _T2>
                    inline bool
                    operator!=(const allocator<_T1>&, const allocator<_T2>&)
                    { return false; }
                
                  template<typename _Tp>
                    inline bool
                    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
                    { return false; }
                
                  // Inhibit implicit instantiations for required instantiations,
                  // which are defined via explicit instantiations elsewhere.
                  // NB: This syntax is a GNU extension.
                #if _GLIBCXX_EXTERN_TEMPLATE
                  extern template class allocator<char>;
                  extern template class allocator<wchar_t>;
                #endif
                
                  // Undefine.
                #undef __glibcxx_base_allocator
                
                  // To implement Option 3 of DR 431.
                  template<typename _Alloc, bool = __is_empty(_Alloc)>
                    struct __alloc_swap
                    { static void _S_do_it(_Alloc&, _Alloc&) { } };
                
                  template<typename _Alloc>
                    struct __alloc_swap<_Alloc, false>
                    {
                      static void
                      _S_do_it(_Alloc& __one, _Alloc& __two)
                      {
                	// Precondition: swappable allocators.
                	if (__one != __two)
                	  swap(__one, __two);
                      }
                    };
                
                  // Optimize for stateless allocators.
                  template<typename _Alloc, bool = __is_empty(_Alloc)>
                    struct __alloc_neq
                    {
                      static bool
                      _S_do_it(const _Alloc&, const _Alloc&)
                      { return false; }
                    };
                
                  template<typename _Alloc>
                    struct __alloc_neq<_Alloc, false>
                    {
                      static bool
                      _S_do_it(const _Alloc& __one, const _Alloc& __two)
                      { return __one != __two; }
                    };
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                   // A very basic implementation for now.  In general we have to wait for
                   // the availability of the infrastructure described in N2983:  we should
                   // try when either T has a move constructor which cannot throw or T is
                   // CopyContructible.
                   // NB: This code doesn't properly belong here, we should find a more
                   // suited place common to std::vector and std::deque.
                   template<typename _Tp,
                	    bool = __has_trivial_copy(typename _Tp::value_type)>
                     struct __shrink_to_fit
                     { static void _S_do_it(_Tp&) { } };
                
                   template<typename _Tp>
                     struct __shrink_to_fit<_Tp, true>
                     {
                       static void
                       _S_do_it(_Tp& __v)
                       {
                	 __try
                	   { _Tp(__v).swap(__v); }
                	 __catch(...) { }
                       }
                     };
                #endif
                
                _GLIBCXX_END_NAMESPACE
                
                #endif


Top 10 Lines:

     Line      Count

      109        126
      101        103
      107         23

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

      252   Total number of line executions
    63.00   Average executions per line


*** File c:/cygwin/mingw/bin/../lib/gcc/mingw32/4.5.2/include/c++/bits/hashtable_policy.h:
                // Internal policy header for unordered_set and unordered_map -*- C++ -*-
                
                // Copyright (C) 2010 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/hashtable_policy.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                #ifndef _HASHTABLE_POLICY_H
                #define _HASHTABLE_POLICY_H 1
                
                namespace std
                {
                namespace __detail
                {
                  // Helper function: return distance(first, last) for forward
                  // iterators, or 0 for input iterators.
                  template<class _Iterator>
                    inline typename std::iterator_traits<_Iterator>::difference_type
                    __distance_fw(_Iterator __first, _Iterator __last,
                		  std::input_iterator_tag)
                    { return 0; }
                
                  template<class _Iterator>
                    inline typename std::iterator_traits<_Iterator>::difference_type
                    __distance_fw(_Iterator __first, _Iterator __last,
                		  std::forward_iterator_tag)
                    { return std::distance(__first, __last); }
                
                  template<class _Iterator>
                    inline typename std::iterator_traits<_Iterator>::difference_type
                    __distance_fw(_Iterator __first, _Iterator __last)
                    {
                      typedef typename std::iterator_traits<_Iterator>::iterator_category _Tag;
                      return __distance_fw(__first, __last, _Tag());
                    }
                
                  // Auxiliary types used for all instantiations of _Hashtable: nodes
                  // and iterators.
                  
                  // Nodes, used to wrap elements stored in the hash table.  A policy
                  // template parameter of class template _Hashtable controls whether
                  // nodes also store a hash code. In some cases (e.g. strings) this
                  // may be a performance win.
                  template<typename _Value, bool __cache_hash_code>
          67 ->     struct _Hash_node;
                
                  template<typename _Value>
                    struct _Hash_node<_Value, true>
                    {
                      _Value       _M_v;
                      std::size_t  _M_hash_code;
                      _Hash_node*  _M_next;
                
                      template<typename... _Args>
                        _Hash_node(_Args&&... __args)
                	: _M_v(std::forward<_Args>(__args)...),
                	  _M_hash_code(), _M_next() { }
                    };
                
                  template<typename _Value>
                    struct _Hash_node<_Value, false>
                    {
                      _Value       _M_v;
                      _Hash_node*  _M_next;
                
                      template<typename... _Args>
         239 ->         _Hash_node(_Args&&... __args)
                	: _M_v(std::forward<_Args>(__args)...),
                	  _M_next() { }
                    };
                
                  // Local iterators, used to iterate within a bucket but not between
                  // buckets.
                  template<typename _Value, bool __cache>
                    struct _Node_iterator_base
                    {
                      _Node_iterator_base(_Hash_node<_Value, __cache>* __p)
                      : _M_cur(__p) { }
                      
                      void
                      _M_incr()
                      { _M_cur = _M_cur->_M_next; }
                
                      _Hash_node<_Value, __cache>*  _M_cur;
                    };
                
                  template<typename _Value, bool __cache>
                    inline bool
                    operator==(const _Node_iterator_base<_Value, __cache>& __x,
                	       const _Node_iterator_base<_Value, __cache>& __y)
                    { return __x._M_cur == __y._M_cur; }
                
                  template<typename _Value, bool __cache>
                    inline bool
                    operator!=(const _Node_iterator_base<_Value, __cache>& __x,
                	       const _Node_iterator_base<_Value, __cache>& __y)
                    { return __x._M_cur != __y._M_cur; }
                
                  template<typename _Value, bool __constant_iterators, bool __cache>
                    struct _Node_iterator
                    : public _Node_iterator_base<_Value, __cache>
                    {
                      typedef _Value                                   value_type;
                      typedef typename std::conditional<__constant_iterators,
                					const _Value*, _Value*>::type
                                                                       pointer;
                      typedef typename std::conditional<__constant_iterators,
                					const _Value&, _Value&>::type
                                                                       reference;
                      typedef std::ptrdiff_t                           difference_type;
                      typedef std::forward_iterator_tag                iterator_category;
                
                      _Node_iterator()
                      : _Node_iterator_base<_Value, __cache>(0) { }
                
                      explicit
                      _Node_iterator(_Hash_node<_Value, __cache>* __p)
                      : _Node_iterator_base<_Value, __cache>(__p) { }
                
                      reference
                      operator*() const
                      { return this->_M_cur->_M_v; }
                  
                      pointer
                      operator->() const
                      { return &this->_M_cur->_M_v; }
                
                      _Node_iterator&
                      operator++()
                      { 
                	this->_M_incr();
                	return *this; 
                      }
                  
                      _Node_iterator
                      operator++(int)
                      { 
                	_Node_iterator __tmp(*this);
                	this->_M_incr();
                	return __tmp;
                      }
                    };
                
                  template<typename _Value, bool __constant_iterators, bool __cache>
                    struct _Node_const_iterator
                    : public _Node_iterator_base<_Value, __cache>
                    {
                      typedef _Value                                   value_type;
                      typedef const _Value*                            pointer;
                      typedef const _Value&                            reference;
                      typedef std::ptrdiff_t                           difference_type;
                      typedef std::forward_iterator_tag                iterator_category;
                
                      _Node_const_iterator()
                      : _Node_iterator_base<_Value, __cache>(0) { }
                
                      explicit
                      _Node_const_iterator(_Hash_node<_Value, __cache>* __p)
                      : _Node_iterator_base<_Value, __cache>(__p) { }
                
                      _Node_const_iterator(const _Node_iterator<_Value, __constant_iterators,
                			   __cache>& __x)
                      : _Node_iterator_base<_Value, __cache>(__x._M_cur) { }
                
                      reference
                      operator*() const
                      { return this->_M_cur->_M_v; }
                  
                      pointer
                      operator->() const
                      { return &this->_M_cur->_M_v; }
                
                      _Node_const_iterator&
                      operator++()
                      { 
                	this->_M_incr();
                	return *this; 
                      }
                  
                      _Node_const_iterator
                      operator++(int)
                      { 
                	_Node_const_iterator __tmp(*this);
                	this->_M_incr();
                	return __tmp;
                      }
                    };
                
                  template<typename _Value, bool __cache>
                    struct _Hashtable_iterator_base
                    {
         398 ->       _Hashtable_iterator_base(_Hash_node<_Value, __cache>* __node,
                			       _Hash_node<_Value, __cache>** __bucket)
                      : _M_cur_node(__node), _M_cur_bucket(__bucket) { }
                
                      void
                      _M_incr()
                      {
                	_M_cur_node = _M_cur_node->_M_next;
                	if (!_M_cur_node)
                	  _M_incr_bucket();
                      }
                
                      void
                      _M_incr_bucket();
                
                      _Hash_node<_Value, __cache>*   _M_cur_node;
                      _Hash_node<_Value, __cache>**  _M_cur_bucket;
                    };
                
                  // Global iterators, used for arbitrary iteration within a hash
                  // table.  Larger and more expensive than local iterators.
                  template<typename _Value, bool __cache>
                    void
                    _Hashtable_iterator_base<_Value, __cache>::
                    _M_incr_bucket()
                    {
                      ++_M_cur_bucket;
                
                      // This loop requires the bucket array to have a non-null sentinel.
                      while (!*_M_cur_bucket)
                	++_M_cur_bucket;
                      _M_cur_node = *_M_cur_bucket;
                    }
                
                  template<typename _Value, bool __cache>
                    inline bool
                    operator==(const _Hashtable_iterator_base<_Value, __cache>& __x,
                	       const _Hashtable_iterator_base<_Value, __cache>& __y)
                    { return __x._M_cur_node == __y._M_cur_node; }
                
                  template<typename _Value, bool __cache>
                    inline bool
                    operator!=(const _Hashtable_iterator_base<_Value, __cache>& __x,
                	       const _Hashtable_iterator_base<_Value, __cache>& __y)
                    { return __x._M_cur_node != __y._M_cur_node; }
                
                  template<typename _Value, bool __constant_iterators, bool __cache>
                    struct _Hashtable_iterator
                    : public _Hashtable_iterator_base<_Value, __cache>
                    {
                      typedef _Value                                   value_type;
                      typedef typename std::conditional<__constant_iterators,
                					const _Value*, _Value*>::type
                                                                       pointer;
                      typedef typename std::conditional<__constant_iterators,
                					const _Value&, _Value&>::type
                                                                       reference;
                      typedef std::ptrdiff_t                           difference_type;
                      typedef std::forward_iterator_tag                iterator_category;
                
          53 ->       _Hashtable_iterator()
                      : _Hashtable_iterator_base<_Value, __cache>(0, 0) { }
                
         292 ->       _Hashtable_iterator(_Hash_node<_Value, __cache>* __p,
                			  _Hash_node<_Value, __cache>** __b)
                      : _Hashtable_iterator_base<_Value, __cache>(__p, __b) { }
                
                      explicit
          53 ->       _Hashtable_iterator(_Hash_node<_Value, __cache>** __b)
                      : _Hashtable_iterator_base<_Value, __cache>(*__b, __b) { }
                
                      reference
                      operator*() const
                      { return this->_M_cur_node->_M_v; }
                  
                      pointer
                      operator->() const
                      { return &this->_M_cur_node->_M_v; }
                
                      _Hashtable_iterator&
                      operator++()
                      { 
                	this->_M_incr();
                	return *this;
                      }
                  
                      _Hashtable_iterator
                      operator++(int)
                      { 
                	_Hashtable_iterator __tmp(*this);
                	this->_M_incr();
                	return __tmp;
                      }
                    };
                
                  template<typename _Value, bool __constant_iterators, bool __cache>
                    struct _Hashtable_const_iterator
                    : public _Hashtable_iterator_base<_Value, __cache>
                    {
                      typedef _Value                                   value_type;
                      typedef const _Value*                            pointer;
                      typedef const _Value&                            reference;
                      typedef std::ptrdiff_t                           difference_type;
                      typedef std::forward_iterator_tag                iterator_category;
                
                      _Hashtable_const_iterator()
                      : _Hashtable_iterator_base<_Value, __cache>(0, 0) { }
                
                      _Hashtable_const_iterator(_Hash_node<_Value, __cache>* __p,
                				_Hash_node<_Value, __cache>** __b)
                      : _Hashtable_iterator_base<_Value, __cache>(__p, __b) { }
                
                      explicit
                      _Hashtable_const_iterator(_Hash_node<_Value, __cache>** __b)
                      : _Hashtable_iterator_base<_Value, __cache>(*__b, __b) { }
                
       ##### ->       _Hashtable_const_iterator(const _Hashtable_iterator<_Value,
                				__constant_iterators, __cache>& __x)
                      : _Hashtable_iterator_base<_Value, __cache>(__x._M_cur_node,
                						  __x._M_cur_bucket) { }
                
                      reference
                      operator*() const
                      { return this->_M_cur_node->_M_v; }
                  
                      pointer
                      operator->() const
                      { return &this->_M_cur_node->_M_v; }
                
                      _Hashtable_const_iterator&
                      operator++()
                      { 
                	this->_M_incr();
                	return *this;
                      }
                  
                      _Hashtable_const_iterator
                      operator++(int)
                      { 
                	_Hashtable_const_iterator __tmp(*this);
                	this->_M_incr();
                	return __tmp;
                      }
                    };
                
                
                  // Many of class template _Hashtable's template parameters are policy
                  // classes.  These are defaults for the policies.
                
                  // Default range hashing function: use division to fold a large number
                  // into the range [0, N).
                  struct _Mod_range_hashing
                  {
                    typedef std::size_t first_argument_type;
                    typedef std::size_t second_argument_type;
                    typedef std::size_t result_type;
                
                    result_type
                    operator()(first_argument_type __num, second_argument_type __den) const
                    { return __num % __den; }
                  };
                
                  // Default ranged hash function H.  In principle it should be a
                  // function object composed from objects of type H1 and H2 such that
                  // h(k, N) = h2(h1(k), N), but that would mean making extra copies of
                  // h1 and h2.  So instead we'll just use a tag to tell class template
                  // hashtable to do that composition.
                  struct _Default_ranged_hash { };
                
                  // Default value for rehash policy.  Bucket size is (usually) the
                  // smallest prime that keeps the load factor small enough.
                  struct _Prime_rehash_policy
                  {
           3 ->     _Prime_rehash_policy(float __z = 1.0)
                    : _M_max_load_factor(__z), _M_growth_factor(2.f), _M_next_resize(0) { }
                
                    float
                    max_load_factor() const
                    { return _M_max_load_factor; }      
                
                    // Return a bucket size no smaller than n.
                    std::size_t
                    _M_next_bkt(std::size_t __n) const;
                    
                    // Return a bucket count appropriate for n elements
                    std::size_t
                    _M_bkt_for_elements(std::size_t __n) const;
                    
                    // __n_bkt is current bucket count, __n_elt is current element count,
                    // and __n_ins is number of elements to be inserted.  Do we need to
                    // increase bucket count?  If so, return make_pair(true, n), where n
                    // is the new bucket count.  If not, return make_pair(false, 0).
                    std::pair<bool, std::size_t>
                    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
                		   std::size_t __n_ins) const;
                
                    enum { _S_n_primes = sizeof(unsigned long) != 8 ? 256 : 256 + 48 };
                
                    float                _M_max_load_factor;
                    float                _M_growth_factor;
                    mutable std::size_t  _M_next_resize;
                  };
                
                  extern const unsigned long __prime_list[];
                
                  // XXX This is a hack.  There's no good reason for any of
                  // _Prime_rehash_policy's member functions to be inline.  
                
                  // Return a prime no smaller than n.
                  inline std::size_t
                  _Prime_rehash_policy::
                  _M_next_bkt(std::size_t __n) const
                  {
                    const unsigned long* __p = std::lower_bound(__prime_list, __prime_list
                						+ _S_n_primes, __n);
                    _M_next_resize = 
                      static_cast<std::size_t>(__builtin_ceil(*__p * _M_max_load_factor));
                    return *__p;
                  }
                
                  // Return the smallest prime p such that alpha p >= n, where alpha
                  // is the load factor.
                  inline std::size_t
                  _Prime_rehash_policy::
                  _M_bkt_for_elements(std::size_t __n) const
                  {
                    const float __min_bkts = __n / _M_max_load_factor;
                    const unsigned long* __p = std::lower_bound(__prime_list, __prime_list
                						+ _S_n_primes, __min_bkts);
                    _M_next_resize =
                      static_cast<std::size_t>(__builtin_ceil(*__p * _M_max_load_factor));
                    return *__p;
                  }
                
                  // Finds the smallest prime p such that alpha p > __n_elt + __n_ins.
                  // If p > __n_bkt, return make_pair(true, p); otherwise return
                  // make_pair(false, 0).  In principle this isn't very different from 
                  // _M_bkt_for_elements.
                
                  // The only tricky part is that we're caching the element count at
                  // which we need to rehash, so we don't have to do a floating-point
                  // multiply for every insertion.
                
                  inline std::pair<bool, std::size_t>
                  _Prime_rehash_policy::
                  _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
                		 std::size_t __n_ins) const
                  {
                    if (__n_elt + __n_ins > _M_next_resize)
                      {
                	float __min_bkts = ((float(__n_ins) + float(__n_elt))
                			    / _M_max_load_factor);
                	if (__min_bkts > __n_bkt)
                	  {
                	    __min_bkts = std::max(__min_bkts, _M_growth_factor * __n_bkt);
                	    const unsigned long* __p =
                	      std::lower_bound(__prime_list, __prime_list + _S_n_primes,
                			       __min_bkts);
                	    _M_next_resize = static_cast<std::size_t>
                	      (__builtin_ceil(*__p * _M_max_load_factor));
                	    return std::make_pair(true, *__p);
                	  }
                	else 
                	  {
                	    _M_next_resize = static_cast<std::size_t>
                	      (__builtin_ceil(__n_bkt * _M_max_load_factor));
                	    return std::make_pair(false, 0);
                	  }
                      }
                    else
                      return std::make_pair(false, 0);
                  }
                
                  // Base classes for std::_Hashtable.  We define these base classes
                  // because in some cases we want to do different things depending
                  // on the value of a policy class.  In some cases the policy class
                  // affects which member functions and nested typedefs are defined;
                  // we handle that by specializing base class templates.  Several of
                  // the base class templates need to access other members of class
                  // template _Hashtable, so we use the "curiously recurring template
                  // pattern" for them.
                
                  // class template _Map_base.  If the hashtable has a value type of
                  // the form pair<T1, T2> and a key extraction policy that returns the
                  // first part of the pair, the hashtable gets a mapped_type typedef.
                  // If it satisfies those criteria and also has unique keys, then it
                  // also gets an operator[].  
                  template<typename _Key, typename _Value, typename _Ex, bool __unique,
                	   typename _Hashtable>
                    struct _Map_base { };
                
                  template<typename _Key, typename _Pair, typename _Hashtable>
                    struct _Map_base<_Key, _Pair, std::_Select1st<_Pair>, false, _Hashtable>
                    {
                      typedef typename _Pair::second_type mapped_type;
                    };
                
                  template<typename _Key, typename _Pair, typename _Hashtable>
                    struct _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>
                    {
                      typedef typename _Pair::second_type mapped_type;
                
                      mapped_type&
                      operator[](const _Key& __k);
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 761. unordered_map needs an at() member function.
                      mapped_type&
                      at(const _Key& __k);
                
                      const mapped_type&
                      at(const _Key& __k) const;
                    };
                
                  template<typename _Key, typename _Pair, typename _Hashtable>
                    typename _Map_base<_Key, _Pair, std::_Select1st<_Pair>,
                		       true, _Hashtable>::mapped_type&
                    _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>::
                    operator[](const _Key& __k)
                    {
                      _Hashtable* __h = static_cast<_Hashtable*>(this);
                      typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);
                      std::size_t __n = __h->_M_bucket_index(__k, __code,
                					     __h->_M_bucket_count);
                
                      typename _Hashtable::_Node* __p =
                	__h->_M_find_node(__h->_M_buckets[__n], __k, __code);
                      if (!__p)
                	return __h->_M_insert_bucket(std::make_pair(__k, mapped_type()),
                				     __n, __code)->second;
                      return (__p->_M_v).second;
                    }
                
                  template<typename _Key, typename _Pair, typename _Hashtable>
                    typename _Map_base<_Key, _Pair, std::_Select1st<_Pair>,
                		       true, _Hashtable>::mapped_type&
                    _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>::
                    at(const _Key& __k)
                    {
                      _Hashtable* __h = static_cast<_Hashtable*>(this);
                      typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);
                      std::size_t __n = __h->_M_bucket_index(__k, __code,
                					     __h->_M_bucket_count);
                
                      typename _Hashtable::_Node* __p =
                	__h->_M_find_node(__h->_M_buckets[__n], __k, __code);
                      if (!__p)
                	__throw_out_of_range(__N("_Map_base::at"));
                      return (__p->_M_v).second;
                    }
                
                  template<typename _Key, typename _Pair, typename _Hashtable>
                    const typename _Map_base<_Key, _Pair, std::_Select1st<_Pair>,
                			     true, _Hashtable>::mapped_type&
                    _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>::
                    at(const _Key& __k) const
                    {
                      const _Hashtable* __h = static_cast<const _Hashtable*>(this);
                      typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);
                      std::size_t __n = __h->_M_bucket_index(__k, __code,
                					     __h->_M_bucket_count);
                
                      typename _Hashtable::_Node* __p =
                	__h->_M_find_node(__h->_M_buckets[__n], __k, __code);
                      if (!__p)
                	__throw_out_of_range(__N("_Map_base::at"));
                      return (__p->_M_v).second;
                    }
                
                  // class template _Rehash_base.  Give hashtable the max_load_factor
                  // functions and reserve iff the rehash policy is _Prime_rehash_policy.
                  template<typename _RehashPolicy, typename _Hashtable>
                    struct _Rehash_base { };
                
                  template<typename _Hashtable>
                    struct _Rehash_base<_Prime_rehash_policy, _Hashtable>
                    {
                      float
                      max_load_factor() const
                      {
                	const _Hashtable* __this = static_cast<const _Hashtable*>(this);
                	return __this->__rehash_policy().max_load_factor();
                      }
                
                      void
                      max_load_factor(float __z)
                      {
                	_Hashtable* __this = static_cast<_Hashtable*>(this);
                	__this->__rehash_policy(_Prime_rehash_policy(__z));
                      }
                
                      void
                      reserve(std::size_t __n)
                      {
                	_Hashtable* __this = static_cast<_Hashtable*>(this);
                	__this->rehash(__builtin_ceil(__n / max_load_factor()));
                      }
                    };
                
                  // Class template _Hash_code_base.  Encapsulates two policy issues that
                  // aren't quite orthogonal.
                  //   (1) the difference between using a ranged hash function and using
                  //       the combination of a hash function and a range-hashing function.
                  //       In the former case we don't have such things as hash codes, so
                  //       we have a dummy type as placeholder.
                  //   (2) Whether or not we cache hash codes.  Caching hash codes is
                  //       meaningless if we have a ranged hash function.
                  // We also put the key extraction and equality comparison function 
                  // objects here, for convenience.
                  
                  // Primary template: unused except as a hook for specializations.  
                  template<typename _Key, typename _Value,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   bool __cache_hash_code>
                    struct _Hash_code_base;
                
                  // Specialization: ranged hash function, no caching hash codes.  H1
                  // and H2 are provided but ignored.  We define a dummy hash code type.
                  template<typename _Key, typename _Value,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash>
                    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2,
                			   _Hash, false>
                    {
                    protected:
                      _Hash_code_base(const _ExtractKey& __ex, const _Equal& __eq,
                		      const _H1&, const _H2&, const _Hash& __h)
                      : _M_extract(__ex), _M_eq(__eq), _M_ranged_hash(__h) { }
                
                      typedef void* _Hash_code_type;
                  
                      _Hash_code_type
                      _M_hash_code(const _Key& __key) const
                      { return 0; }
                  
                      std::size_t
                      _M_bucket_index(const _Key& __k, _Hash_code_type,
                		      std::size_t __n) const
                      { return _M_ranged_hash(__k, __n); }
                
                      std::size_t
                      _M_bucket_index(const _Hash_node<_Value, false>* __p,
                		      std::size_t __n) const
                      { return _M_ranged_hash(_M_extract(__p->_M_v), __n); }
                  
                      bool
                      _M_compare(const _Key& __k, _Hash_code_type,
                		 _Hash_node<_Value, false>* __n) const
                      { return _M_eq(__k, _M_extract(__n->_M_v)); }
                
                      void
                      _M_store_code(_Hash_node<_Value, false>*, _Hash_code_type) const
                      { }
                
                      void
                      _M_copy_code(_Hash_node<_Value, false>*,
                		   const _Hash_node<_Value, false>*) const
                      { }
                      
                      void
                      _M_swap(_Hash_code_base& __x)
                      {
                	std::swap(_M_extract, __x._M_extract);
                	std::swap(_M_eq, __x._M_eq);
                	std::swap(_M_ranged_hash, __x._M_ranged_hash);
                      }
                
                    protected:
                      _ExtractKey  _M_extract;
                      _Equal       _M_eq;
                      _Hash        _M_ranged_hash;
                    };
                
                
                  // No specialization for ranged hash function while caching hash codes.
                  // That combination is meaningless, and trying to do it is an error.
                  
                  
                  // Specialization: ranged hash function, cache hash codes.  This
                  // combination is meaningless, so we provide only a declaration
                  // and no definition.  
                  template<typename _Key, typename _Value,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash>
                    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2,
                			   _Hash, true>;
                
                  // Specialization: hash function and range-hashing function, no
                  // caching of hash codes.  H is provided but ignored.  Provides
                  // typedef and accessor required by TR1.  
                  template<typename _Key, typename _Value,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2>
                    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2,
                			   _Default_ranged_hash, false>
                    {
                      typedef _H1 hasher;
                
                      hasher
                      hash_function() const
                      { return _M_h1; }
                
                    protected:
           3 ->       _Hash_code_base(const _ExtractKey& __ex, const _Equal& __eq,
                		      const _H1& __h1, const _H2& __h2,
                		      const _Default_ranged_hash&)
                      : _M_extract(__ex), _M_eq(__eq), _M_h1(__h1), _M_h2(__h2) { }
                
                      typedef std::size_t _Hash_code_type;
                
                      _Hash_code_type
                      _M_hash_code(const _Key& __k) const
                      { return _M_h1(__k); }
                      
                      std::size_t
                      _M_bucket_index(const _Key&, _Hash_code_type __c,
                		      std::size_t __n) const
                      { return _M_h2(__c, __n); }
                
                      std::size_t
                      _M_bucket_index(const _Hash_node<_Value, false>* __p,
                		      std::size_t __n) const
                      { return _M_h2(_M_h1(_M_extract(__p->_M_v)), __n); }
                
                      bool
                      _M_compare(const _Key& __k, _Hash_code_type,
                		 _Hash_node<_Value, false>* __n) const
                      { return _M_eq(__k, _M_extract(__n->_M_v)); }
                
                      void
                      _M_store_code(_Hash_node<_Value, false>*, _Hash_code_type) const
                      { }
                
                      void
                      _M_copy_code(_Hash_node<_Value, false>*,
                		   const _Hash_node<_Value, false>*) const
                      { }
                
                      void
                      _M_swap(_Hash_code_base& __x)
                      {
                	std::swap(_M_extract, __x._M_extract);
                	std::swap(_M_eq, __x._M_eq);
                	std::swap(_M_h1, __x._M_h1);
                	std::swap(_M_h2, __x._M_h2);
                      }
                
                    protected:
                      _ExtractKey  _M_extract;
                      _Equal       _M_eq;
                      _H1          _M_h1;
                      _H2          _M_h2;
                    };
                
                  // Specialization: hash function and range-hashing function, 
                  // caching hash codes.  H is provided but ignored.  Provides
                  // typedef and accessor required by TR1.
                  template<typename _Key, typename _Value,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2>
                    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2,
                			   _Default_ranged_hash, true>
                    {
                      typedef _H1 hasher;
                      
                      hasher
                      hash_function() const
                      { return _M_h1; }
                
                    protected:
                      _Hash_code_base(const _ExtractKey& __ex, const _Equal& __eq,
                		      const _H1& __h1, const _H2& __h2,
                		      const _Default_ranged_hash&)
                      : _M_extract(__ex), _M_eq(__eq), _M_h1(__h1), _M_h2(__h2) { }
                
                      typedef std::size_t _Hash_code_type;
                  
                      _Hash_code_type
                      _M_hash_code(const _Key& __k) const
                      { return _M_h1(__k); }
                  
                      std::size_t
                      _M_bucket_index(const _Key&, _Hash_code_type __c,
                		      std::size_t __n) const
                      { return _M_h2(__c, __n); }
                
                      std::size_t
                      _M_bucket_index(const _Hash_node<_Value, true>* __p,
                		      std::size_t __n) const
                      { return _M_h2(__p->_M_hash_code, __n); }
                
                      bool
                      _M_compare(const _Key& __k, _Hash_code_type __c,
                		 _Hash_node<_Value, true>* __n) const
                      { return __c == __n->_M_hash_code && _M_eq(__k, _M_extract(__n->_M_v)); }
                
                      void
                      _M_store_code(_Hash_node<_Value, true>* __n, _Hash_code_type __c) const
                      { __n->_M_hash_code = __c; }
                
                      void
                      _M_copy_code(_Hash_node<_Value, true>* __to,
                		   const _Hash_node<_Value, true>* __from) const
                      { __to->_M_hash_code = __from->_M_hash_code; }
                
                      void
                      _M_swap(_Hash_code_base& __x)
                      {
                	std::swap(_M_extract, __x._M_extract);
                	std::swap(_M_eq, __x._M_eq);
                	std::swap(_M_h1, __x._M_h1);
                	std::swap(_M_h2, __x._M_h2);
                      }
                      
                    protected:
                      _ExtractKey  _M_extract;
                      _Equal       _M_eq;
                      _H1          _M_h1;
                      _H2          _M_h2;
                    };
                
                
                  // Class template _Equality_base.  This is for implementing equality
                  // comparison for unordered containers, per N3068, by John Lakos and
                  // Pablo Halpern.  Algorithmically, we follow closely the reference
                  // implementations therein.
                  template<typename _ExtractKey, bool __unique_keys,
                	   typename _Hashtable>
           3 ->     struct _Equality_base;
                
                  template<typename _ExtractKey, typename _Hashtable>
                    struct _Equality_base<_ExtractKey, true, _Hashtable>
                    {
                      bool _M_equal(const _Hashtable&) const;
                    };
                
                  template<typename _ExtractKey, typename _Hashtable>
                    bool
                    _Equality_base<_ExtractKey, true, _Hashtable>::
                    _M_equal(const _Hashtable& __other) const
                    {
                      const _Hashtable* __this = static_cast<const _Hashtable*>(this);
                
                      if (__this->size() != __other.size())
                	return false;
                
                      for (auto __itx = __this->begin(); __itx != __this->end(); ++__itx)
                	{
                	  const auto __ity = __other.find(_ExtractKey()(*__itx));
                	  if (__ity == __other.end() || *__ity != *__itx)
                	    return false;
                	}
                      return true;
                    }
                
                  template<typename _ExtractKey, typename _Hashtable>
                    struct _Equality_base<_ExtractKey, false, _Hashtable>
                    {
                      bool _M_equal(const _Hashtable&) const;
                
                    private:
                      template<typename _Uiterator>
                        static bool
                        _S_is_permutation(_Uiterator, _Uiterator, _Uiterator);
                    };
                
                  // See std::is_permutation in N3068.
                  template<typename _ExtractKey, typename _Hashtable>
                    template<typename _Uiterator>
                      bool
                      _Equality_base<_ExtractKey, false, _Hashtable>::
                      _S_is_permutation(_Uiterator __first1, _Uiterator __last1,
                			_Uiterator __first2)
                      {
                	for (; __first1 != __last1; ++__first1, ++__first2)
                	  if (!(*__first1 == *__first2))
                	    break;
                
                	if (__first1 == __last1)
                	  return true;
                
                	_Uiterator __last2 = __first2;
                	std::advance(__last2, std::distance(__first1, __last1));
                
                	for (_Uiterator __it1 = __first1; __it1 != __last1; ++__it1)
                	  {
                	    _Uiterator __tmp =  __first1;
                	    while (__tmp != __it1 && !(*__tmp == *__it1))
                	      ++__tmp;
                
                	    // We've seen this one before.
                	    if (__tmp != __it1)
                	      continue;
                
                	    std::ptrdiff_t __n2 = 0;
                	    for (__tmp = __first2; __tmp != __last2; ++__tmp)
                	      if (*__tmp == *__it1)
                		++__n2;
                
                	    if (!__n2)
                	      return false;
                
                	    std::ptrdiff_t __n1 = 0;
                	    for (__tmp = __it1; __tmp != __last1; ++__tmp)
                	      if (*__tmp == *__it1)
                		++__n1;
                
                	    if (__n1 != __n2)
                	      return false;
                	  }
                	return true;
                      }
                
                  template<typename _ExtractKey, typename _Hashtable>
                    bool
                    _Equality_base<_ExtractKey, false, _Hashtable>::
                    _M_equal(const _Hashtable& __other) const
                    {
                      const _Hashtable* __this = static_cast<const _Hashtable*>(this);
                
                      if (__this->size() != __other.size())
                	return false;
                
                      for (auto __itx = __this->begin(); __itx != __this->end();)
                	{
                	  const auto __xrange = __this->equal_range(_ExtractKey()(*__itx));
                	  const auto __yrange = __other.equal_range(_ExtractKey()(*__itx));
                
                	  if (std::distance(__xrange.first, __xrange.second)
                	      != std::distance(__yrange.first, __yrange.second))
                	    return false;
                
                	  if (!_S_is_permutation(__xrange.first,
                				 __xrange.second,
                				 __yrange.first))
                	    return false;
                
                	  __itx = __xrange.second;
                	}
                      return true;
                    }
                } // namespace __detail
                }
                
                #endif // _HASHTABLE_POLICY_H


Top 10 Lines:

     Line      Count

      214        398
      277        292
       89        239
       67         67
      274         53
      282         53
      387          3
      718          3
      843          3

Execution Summary:

       10   Executable lines in this file
       10   Lines executed
   100.00   Percent of the file executed

     1111   Total number of line executions
   111.10   Average executions per line


*** File c:/cygwin/mingw/bin/../lib/gcc/mingw32/4.5.2/include/c++/bits/stl_pair.h:
                // Pair implementation -*- C++ -*-
                
                // Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
                // Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file stl_pair.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly.
                 */
                
                #ifndef _STL_PAIR_H
                #define _STL_PAIR_H 1
                
                #include <bits/move.h> // for std::move / std::forward, std::decay, and
                                       // std::swap
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                #include <type_traits>
                #endif
                
                _GLIBCXX_BEGIN_NAMESPACE(std)
                
                  /// pair holds two objects of arbitrary type.
                  template<class _T1, class _T2>
                    struct pair
         955 ->     {
                      typedef _T1 first_type;    ///<  @c first_type is the first bound type
                      typedef _T2 second_type;   ///<  @c second_type is the second bound type
                
                      _T1 first;                 ///< @c first is a copy of the first object
                      _T2 second;                ///< @c second is a copy of the second object
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 265.  std::pair::pair() effects overly restrictive
                      /** The default constructor creates @c first and @c second using their
                       *  respective default constructors.  */
                      pair()
                      : first(), second() { }
                
                      /** Two objects may be passed to a @c pair constructor to be copied.  */
                      pair(const _T1& __a, const _T2& __b)
                      : first(__a), second(__b) { }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      // DR 811.
                      template<class _U1, class = typename
                	       std::enable_if<std::is_convertible<_U1, _T1>::value>::type>
           7 ->         pair(_U1&& __x, const _T2& __y)
                	: first(std::forward<_U1>(__x)),
                	  second(__y) { }
                
                      template<class _U2, class = typename
                	       std::enable_if<std::is_convertible<_U2, _T2>::value>::type>
         210 ->         pair(const _T1& __x, _U2&& __y)
                	: first(__x),
                	  second(std::forward<_U2>(__y)) { }
                
                      template<class _U1, class _U2, class = typename
                	       std::enable_if<std::is_convertible<_U1, _T1>::value
                			      && std::is_convertible<_U2, _T2>::value>::type>
         365 ->         pair(_U1&& __x, _U2&& __y)
                	: first(std::forward<_U1>(__x)),
                	  second(std::forward<_U2>(__y)) { }
                #endif
                
                      /** There is also a templated copy ctor for the @c pair class itself.  */
                      template<class _U1, class _U2>
                        pair(const pair<_U1, _U2>& __p)
                	: first(__p.first),
                	  second(__p.second) { }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                      template<class _U1, class _U2>
        1502 ->         pair(pair<_U1, _U2>&& __p)
                	: first(std::forward<_U1>(__p.first)),
                	  second(std::forward<_U2>(__p.second)) { }
                
                      pair&
                      operator=(pair&& __p)
                      { 
                	first = std::move(__p.first);
                	second = std::move(__p.second);
                	return *this;
                      }
                
                      template<class _U1, class _U2>
                        pair&
                        operator=(pair<_U1, _U2>&& __p)
                	{
                	  first = std::move(__p.first);
                	  second = std::move(__p.second);
                	  return *this;
                	}
                
                      void
                      swap(pair& __p)
                      {
                	using std::swap;
                	swap(first, __p.first);
                	swap(second, __p.second);	
                      }
                #endif
                    };
                
                  /// Two pairs of the same type are equal iff their members are equal.
                  template<class _T1, class _T2>
                    inline bool
                    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __x.first == __y.first && __x.second == __y.second; }
                
                  /// <http://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>
                  template<class _T1, class _T2>
                    inline bool
                    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __x.first < __y.first
                	     || (!(__y.first < __x.first) && __x.second < __y.second); }
                
                  /// Uses @c operator== to find the result.
                  template<class _T1, class _T2>
                    inline bool
                    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__x == __y); }
                
                  /// Uses @c operator< to find the result.
                  template<class _T1, class _T2>
                    inline bool
                    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __y < __x; }
                
                  /// Uses @c operator< to find the result.
                  template<class _T1, class _T2>
                    inline bool
                    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__y < __x); }
                
                  /// Uses @c operator< to find the result.
                  template<class _T1, class _T2>
                    inline bool
                    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__x < __y); }
                
                #ifdef __GXX_EXPERIMENTAL_CXX0X__
                  /// See std::pair::swap().
                  // Note:  no std::swap overloads in C++03 mode, this has performance
                  //        implications, see, eg, libstdc++/38466.
                  template<class _T1, class _T2>
                    inline void
                    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
                    { __x.swap(__y); }
                #endif
                
                  /**
                   *  @brief A convenience wrapper for creating a pair from two objects.
                   *  @param  x  The first object.
                   *  @param  y  The second object.
                   *  @return   A newly-constructed pair<> object of the appropriate type.
                   *
                   *  The standard requires that the objects be passed by reference-to-const,
                   *  but LWG issue #181 says they should be passed by const value.  We follow
                   *  the LWG by default.
                   */
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 181.  make_pair() unintended behavior
                #ifndef __GXX_EXPERIMENTAL_CXX0X__
                  template<class _T1, class _T2>
                    inline pair<_T1, _T2>
                    make_pair(_T1 __x, _T2 __y)
                    { return pair<_T1, _T2>(__x, __y); }
                #else
                  template<typename _Tp>
                    class reference_wrapper;
                
                  // Helper which adds a reference to a type when given a reference_wrapper
                  template<typename _Tp>
                    struct __strip_reference_wrapper
                    {
                      typedef _Tp __type;
                    };
                
                  template<typename _Tp>
                    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
                    {
                      typedef _Tp& __type;
                    };
                
                  template<typename _Tp>
                    struct __strip_reference_wrapper<const reference_wrapper<_Tp> >
                    {
                      typedef _Tp& __type;
                    };
                
                  template<typename _Tp>
                    struct __decay_and_strip
                    {
                      typedef typename __strip_reference_wrapper<
                	typename decay<_Tp>::type>::__type __type;
                    };
                
                  // NB: DR 706.
                  template<class _T1, class _T2>
                    inline pair<typename __decay_and_strip<_T1>::__type,
                		typename __decay_and_strip<_T2>::__type>
                    make_pair(_T1&& __x, _T2&& __y)
                    {
                      return pair<typename __decay_and_strip<_T1>::__type,
                	          typename __decay_and_strip<_T2>::__type>
                	(std::forward<_T1>(__x), std::forward<_T2>(__y));
                    }
                #endif
                
                _GLIBCXX_END_NAMESPACE
                
                #endif /* _STL_PAIR_H */


Top 10 Lines:

     Line      Count

      120       1502
       72        955
      107        365
      100        210
       94          7

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

     3039   Total number of line executions
   607.80   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/God.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
                
                VirtualButton* God::_pVbtn_PLAY = NULL;
                VirtualButton* God::_pVbtn_UI = NULL;
                VirtualButton* God::_pVbtn_Active = NULL;
                VirtualButton* God::_pVbtn_Active_next_frame = NULL;
                
           1 -> God::God(HINSTANCE prm_hInstance, HWND _hWnd) : DefaultGod(prm_hInstance, _hWnd) {
                    _pDispatcherManager = NEW DispatcherManager("DispatcherManager");
                    _pSpline3DManager = NEW Spline3DManager("Spline3DManager");
                    _pSplineManager = NEW SplineManager("SplineManager");
                
                    God::_pVbtn_PLAY = NEW VirtualButton();
                    God::_pVbtn_UI   = NEW VirtualButton();
                    God::_pVbtn_Active = God::_pVbtn_UI;
                    God::_pVbtn_Active_next_frame = God::_pVbtn_UI;
                
                    //z{^{AQ[p`
                    VirtualButton::_tagKeymap.BUTTON1    = VirtualButton::_mapDIK[ PROPERTY(MY_KEY_SHOT1)      ];
                    VirtualButton::_tagKeymap.BUTTON2    = VirtualButton::_mapDIK[ PROPERTY(MY_KEY_SHOT2)      ];
                    VirtualButton::_tagKeymap.BUTTON3    = VirtualButton::_mapDIK[ PROPERTY(MY_KEY_OPTION)     ];
                    VirtualButton::_tagKeymap.BUTTON4    = VirtualButton::_mapDIK[ PROPERTY(MY_KEY_VIEW)       ];
                    VirtualButton::_tagKeymap.BUTTON5    = VirtualButton::_mapDIK[ PROPERTY(MY_KEY_TURBO)      ];
                    VirtualButton::_tagKeymap.BUTTON6    = VirtualButton::_mapDIK[ PROPERTY(MY_KEY_POWERUP)    ];
                    VirtualButton::_tagKeymap.BUTTON7    = VirtualButton::_mapDIK[ PROPERTY(MY_KEY_BUTTON7)    ];
                    VirtualButton::_tagKeymap.BUTTON8    = VirtualButton::_mapDIK[ PROPERTY(MY_KEY_BUTTON8)    ];
                    VirtualButton::_tagKeymap.PAUSE      = VirtualButton::_mapDIK[ PROPERTY(MY_KEY_PAUSE)      ];
                    VirtualButton::_tagKeymap.UP         = VirtualButton::_mapDIK[ PROPERTY(MY_KEY_UP)         ];
                    VirtualButton::_tagKeymap.DOWN       = VirtualButton::_mapDIK[ PROPERTY(MY_KEY_DOWN)       ];
                    VirtualButton::_tagKeymap.LEFT       = VirtualButton::_mapDIK[ PROPERTY(MY_KEY_LEFT)       ];
                    VirtualButton::_tagKeymap.RIGHT      = VirtualButton::_mapDIK[ PROPERTY(MY_KEY_RIGHT)      ];
                    VirtualButton::_tagKeymap.UI_UP      = VirtualButton::_mapDIK[ PROPERTY(MY_KEY_UI_UP)      ];
                    VirtualButton::_tagKeymap.UI_DOWN    = VirtualButton::_mapDIK[ PROPERTY(MY_KEY_UI_DOWN)    ];
                    VirtualButton::_tagKeymap.UI_LEFT    = VirtualButton::_mapDIK[ PROPERTY(MY_KEY_UI_LEFT)    ];
                    VirtualButton::_tagKeymap.UI_RIGHT   = VirtualButton::_mapDIK[ PROPERTY(MY_KEY_UI_RIGHT)   ];
                    VirtualButton::_tagKeymap.UI_EXECUTE = VirtualButton::_mapDIK[ PROPERTY(MY_KEY_UI_EXECUTE) ];
                    VirtualButton::_tagKeymap.UI_CANCEL  = VirtualButton::_mapDIK[ PROPERTY(MY_KEY_UI_CANCEL)  ];
                    VirtualButton::_tagKeymap.UI_DEBUG   = VirtualButton::_mapDIK[ PROPERTY(MY_KEY_UI_DEBUG)   ];
                
                    VirtualButton::_tagJoymap.BUTTON1    = VirtualButton::_mapDIK[ PROPERTY(MY_JOY_SHOT1)      ];
                    VirtualButton::_tagJoymap.BUTTON2    = VirtualButton::_mapDIK[ PROPERTY(MY_JOY_SHOT2)      ];
                    VirtualButton::_tagJoymap.BUTTON3    = VirtualButton::_mapDIK[ PROPERTY(MY_JOY_OPTION)     ];
                    VirtualButton::_tagJoymap.BUTTON4    = VirtualButton::_mapDIK[ PROPERTY(MY_JOY_VIEW)       ];
                    VirtualButton::_tagJoymap.BUTTON5    = VirtualButton::_mapDIK[ PROPERTY(MY_JOY_TURBO)      ];
                    VirtualButton::_tagJoymap.BUTTON6    = VirtualButton::_mapDIK[ PROPERTY(MY_JOY_POWERUP)    ];
                    VirtualButton::_tagJoymap.BUTTON7    = VirtualButton::_mapDIK[ PROPERTY(MY_JOY_BUTTON7)    ];
                    VirtualButton::_tagJoymap.BUTTON8    = VirtualButton::_mapDIK[ PROPERTY(MY_JOY_BUTTON8)    ];
                    VirtualButton::_tagJoymap.PAUSE      = VirtualButton::_mapDIK[ PROPERTY(MY_JOY_PAUSE)      ];
                    VirtualButton::_tagJoymap.UI_EXECUTE = VirtualButton::_mapDIK[ PROPERTY(MY_JOY_UI_EXECUTE) ];
                    VirtualButton::_tagJoymap.UI_CANCEL  = VirtualButton::_mapDIK[ PROPERTY(MY_JOY_UI_CANCEL)  ];
                }
                
                GgafUniverse* God::createUniverse() {
                    Camera* pCamera = NEW Camera("CAMERA");    //FovXp80xA[~GAME_SPACE_DEPTH
                
                    Universe* pUniverse = NEW Universe("MYUNIVERSE", pCamera);
                    return (GgafUniverse*)pUniverse;
                }
                
                void God::clean() {
                    if (!_was_cleaned) {
                        _TRACE_("God::clean() begin");
                        DefaultGod::clean();
                        DELETE_IMPOSSIBLE_NULL(_pVbtn_PLAY);
                        DELETE_IMPOSSIBLE_NULL(_pVbtn_UI);
                        DELETE_IMPOSSIBLE_NULL(_pDispatcherManager);
                        DELETE_IMPOSSIBLE_NULL(_pSpline3DManager);
                        DELETE_IMPOSSIBLE_NULL(_pSplineManager);
                        _TRACE_("God::clean() end");
                    }
                }
                
           2 -> God::~God() {
                    clean();
                    _was_cleaned = true;
                }


Top 10 Lines:

     Line      Count

       79          2
       14          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File c:/cygwin/mingw/bin/../lib/gcc/mingw32/4.5.2/include/c++/new:
                // The -*- C++ -*- dynamic memory management header.
                
                // Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
                // 2003, 2004, 2005, 2006, 2007, 2009, 2010
                // Free Software Foundation
                
                // This file is part of GCC.
                //
                // GCC is free software; you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation; either version 3, or (at your option)
                // any later version.
                // 
                // GCC is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                // 
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file new
                 *  This is a Standard C++ Library header.
                 *
                 *  The header @c new defines several functions to manage dynamic memory and
                 *  handling memory allocation errors; see
                 *  http://gcc.gnu.org/onlinedocs/libstdc++/18_support/howto.html#4 for more.
                 */
                
                #ifndef _NEW
                #define _NEW
                
                #pragma GCC system_header
                
                #include <cstddef>
                #include <exception>
                
                #pragma GCC visibility push(default)
                
                extern "C++" {
                
                namespace std 
                {
                  /**
                   *  @brief  Exception possibly thrown by @c new.
                   *  @ingroup exceptions
                   *
                   *  @c bad_alloc (or classes derived from it) is used to report allocation
                   *  errors from the throwing forms of @c new.  */
                  class bad_alloc : public exception 
                  {
                  public:
       ##### ->     bad_alloc() throw() { }
                
                    // This declaration is not useless:
                    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
                    virtual ~bad_alloc() throw();
                
                    // See comment in eh_exception.cc.
                    virtual const char* what() const throw();
                  };
                
                  struct nothrow_t { };
                
                  extern const nothrow_t nothrow;
                
                  /** If you write your own error handler to be called by @c new, it must
                   *  be of this type.  */
                  typedef void (*new_handler)();
                
                  /// Takes a replacement handler as the argument, returns the
                  /// previous handler.
                  new_handler set_new_handler(new_handler) throw();
                } // namespace std
                
                //@{
                /** These are replaceable signatures:
                 *  - normal single new and delete (no arguments, throw @c bad_alloc on error)
                 *  - normal array new and delete (same)
                 *  - @c nothrow single new and delete (take a @c nothrow argument, return
                 *    @c NULL on error)
                 *  - @c nothrow array new and delete (same)
                 *
                 *  Placement new and delete signatures (take a memory address argument,
                 *  does nothing) may not be replaced by a user's program.
                */
                void* operator new(std::size_t) throw (std::bad_alloc);
                void* operator new[](std::size_t) throw (std::bad_alloc);
                void operator delete(void*) throw();
                void operator delete[](void*) throw();
                void* operator new(std::size_t, const std::nothrow_t&) throw();
                void* operator new[](std::size_t, const std::nothrow_t&) throw();
                void operator delete(void*, const std::nothrow_t&) throw();
                void operator delete[](void*, const std::nothrow_t&) throw();
                
                // Default placement versions of operator new.
         350 -> inline void* operator new(std::size_t, void* __p) throw() { return __p; }
                inline void* operator new[](std::size_t, void* __p) throw() { return __p; }
                
                // Default placement versions of operator delete.
       ##### -> inline void  operator delete  (void*, void*) throw() { }
                inline void  operator delete[](void*, void*) throw() { }
                //@}
                } // extern "C++"
                
                #pragma GCC visibility pop
                
                #endif


Top 10 Lines:

     Line      Count

      103        350

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

      350   Total number of line executions
   116.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/Camera.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> Camera::Camera(const char* prm_name) :
                        DefaultCamera(prm_name,
                                      PI * 80.0f / 180.0f,
                                      GGAFDX9_PROPERTY(GAME_SPACE_DEPTH)) {
                    _class_name = "Camera";
                }
                void Camera::initialize() {
                    DefaultCamera::initialize();
                }
                
                
                void Camera::processBehavior() {
                
                    DefaultCamera::processBehavior();
                }
                
           2 -> Camera::~Camera() {
                }


Top 10 Lines:

     Line      Count

       24          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/background/HoshiBoshi001.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
                
                
           1 -> HoshiBoshi001::HoshiBoshi001(const char* prm_name) :
                        GgafDx9PointSpriteActor(prm_name,
                                               "HoshiBoshi001",
                                               "HoshiBoshiEffect",
                                               "HoshiBoshiTechnique",
                                               NULL ) {
                    _class_name = "HoshiBoshi001";
                    _h_fX_MyShip  = _pPointSpriteEffect->_pID3DXEffect->GetParameterByName( NULL, "g_fX_MyShip" );
                    _h_fY_MyShip  = _pPointSpriteEffect->_pID3DXEffect->GetParameterByName( NULL, "g_fY_MyShip" );
                    _h_fZ_MyShip  = _pPointSpriteEffect->_pID3DXEffect->GetParameterByName( NULL, "g_fZ_MyShip" );
                
                    changeEffectTechnique("DestBlendOne"); //Z
                    setHitAble(false);
                    _CAM_ZF = abs(P_CAM->_zf * PX_UNIT * LEN_UNIT);
                    _TRACE_("HoshiBoshi001::HoshiBoshi001 _CAM_ZF="<<_CAM_ZF);
                    //[h
                    defineRotMvWorldMatrix(HoshiBoshi001::setWorldMatrix_HoshiBoshi001);
                    setSpecialDrawDepth(MAX_DRAW_DEPTH_LEVEL-10);//[EE
                    //DIRECTX-1.0`1.0OA
                    //U
                    _SX = _SY = _SZ =  P_CAM->_zf*1000;
                }
                
                int HoshiBoshi001::isOutOfView() {
                    //O
                    return 0;
                }
                
                bool HoshiBoshi001::isOutOfUniverse() {
                    //Q[WO
                    return false;
                }
                void HoshiBoshi001::initialize() {
                
                }
                
                void HoshiBoshi001::onActive() {
                    _pUvFlipper->setFlipMethod(FLIP_ORDER_LOOP, 6);
                }
                
                void HoshiBoshi001::processBehavior() {
                    if (_X < -_CAM_ZF) {
                        _X += (_CAM_ZF*2);
                    } else {
                        _X -= 1000;
                    }
                    _pUvFlipper->behave();
                }
                
                void HoshiBoshi001::processSettlementBehavior() {
                    //O
                    //GgafDx9GeometricActor::processSettlementBehavior() I
                    _fX = (FLOAT)(1.0f * _X / LEN_UNIT / PX_UNIT);
                    _fY = (FLOAT)(1.0f * _Y / LEN_UNIT / PX_UNIT);
                    _fZ = (FLOAT)(1.0f * _Z / LEN_UNIT / PX_UNIT);
                    (*_pFunc_calcRotMvWorldMatrix)(this, _matWorld); //[h
                }
                
                void HoshiBoshi001::processJudgement() {
                }
                
                void HoshiBoshi001::processDraw() {
                    ID3DXEffect* pID3DXEffect = _pPointSpriteEffect->_pID3DXEffect;
                    HRESULT hr;
                    hr = pID3DXEffect->SetFloat(_h_fX_MyShip, P_MYSHIP->_fX);
                    checkDxException(hr, D3D_OK, "GgafDx9PointSpriteActor::processDraw() SetFloat(_h_fX_MyShip) sB");
                    hr = pID3DXEffect->SetFloat(_h_fY_MyShip, P_MYSHIP->_fY);
                    checkDxException(hr, D3D_OK, "GgafDx9PointSpriteActor::processDraw() SetFloat(_h_fY_MyShip) sB");
                    hr = pID3DXEffect->SetFloat(_h_fZ_MyShip, P_MYSHIP->_fZ);
                    checkDxException(hr, D3D_OK, "GgafDx9PointSpriteActor::processDraw() SetFloat(_h_fZ_MyShip) sB");
                    GgafDx9PointSpriteActor::processDraw();
                }
                
                
                void HoshiBoshi001::drawHitArea() {
                }
                
           2 -> HoshiBoshi001::~HoshiBoshi001() {
                }
                
                void HoshiBoshi001::setWorldMatrix_HoshiBoshi001(GgafDx9GeometricActor* prm_pActor, D3DXMATRIX& out_matWorld) {
                    //World
                    //gk ~ X] ~ Z] ~ Y] ~ s s<BR>
                    //XYZ
                    static float fRateScale = 1.0f * LEN_UNIT;
                    float sinRx = GgafDx9Util::SIN[prm_pActor->_RX / ANGLE_RATE];
                    float cosRx = GgafDx9Util::COS[prm_pActor->_RX / ANGLE_RATE];
                    float sinRy = GgafDx9Util::SIN[prm_pActor->_RY / ANGLE_RATE];
                    float cosRy = GgafDx9Util::COS[prm_pActor->_RY / ANGLE_RATE];
                    float sinRz = GgafDx9Util::SIN[prm_pActor->_RZ / ANGLE_RATE];
                    float cosRz = GgafDx9Util::COS[prm_pActor->_RZ / ANGLE_RATE];
                    float Sx = prm_pActor->_SX / fRateScale;
                    float Sy = prm_pActor->_SY / fRateScale;
                    float Sz = prm_pActor->_SZ / fRateScale;
                
                    out_matWorld._11 = Sx * cosRz *cosRy;
                    out_matWorld._12 = Sx * sinRz;
                    out_matWorld._13 = Sx * cosRz * -sinRy;
                    out_matWorld._14 = 0.0f;
                
                    out_matWorld._21 = (Sy * cosRx * -sinRz *  cosRy) + (Sy * sinRx * sinRy);
                    out_matWorld._22 = Sy * cosRx *  cosRz;
                    out_matWorld._23 = (Sy * cosRx * -sinRz * -sinRy) + (Sy * sinRx * cosRy);
                    out_matWorld._24 = 0.0f;
                
                    out_matWorld._31 = (Sz * -sinRx * -sinRz *  cosRy) + (Sz * cosRx * sinRy);
                    out_matWorld._32 = Sz * -sinRx *  cosRz;
                    out_matWorld._33 = (Sz * -sinRx * -sinRz * -sinRy) + (Sz * cosRx * cosRy);
                    out_matWorld._34 = 0.0f;
                
                    out_matWorld._41 = prm_pActor->_fX;
                    out_matWorld._42 = prm_pActor->_fY;
                    out_matWorld._43 = prm_pActor->_fZ;
                    out_matWorld._44 = 1.0f;
                }


Top 10 Lines:

     Line      Count

       87          2
       10          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/background/WorldBound/WorldBoundSpace001.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> WorldBoundSpace001::WorldBoundSpace001(const char* prm_name) : WorldBoundActor(prm_name, "WorldBoundSpace001") {
                    _class_name = "WorldBoundSpace001";
                }
                void WorldBoundSpace001::initialize() {
                    //    _pUvFlipper->setTextureUvRotation(16, 1/16.0, 1/16.0);
                    //    _pUvFlipper->setFlipMethod(FLIP_ORDER_LOOP, 5);
                    //    _pUvFlipper->forcePtnNoRange(0, 16*16-1);
                    //    _pUvFlipper->setPtnNo(0);
                    setHitAble(false);
                    _X = _Y = _Z = 0;
                    _RX = _RY = _RZ = 0;
                    //WorldBoundSpace001faDIRECTX1(10px)
                    _SX = _SY = _SZ =  ((P_CAM->_zf-P_CAM->_zn)*1000)*0.989;
                }
                
                void WorldBoundSpace001::onActive() {
                    //_pUvFlipper->setFlipMethod(FLIP_ORDER_LOOP, 5);
                }
                
                void WorldBoundSpace001::processBehavior() {
                    //_pUvFlipper->behave();
                }
                void WorldBoundSpace001::processJudgement() {
                }
                
           2 -> WorldBoundSpace001::~WorldBoundSpace001() {
                }
                


Top 10 Lines:

     Line      Count

       33          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/common/CameraWorker.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           3 -> CameraWorker::CameraWorker(const char* prm_name) : GgafMainActor(prm_name) {
                    _class_name = "CameraWorker";
                    _pos_camera = 0;
                    _pLockOnTarget = NULL;
                    _move_target_XY_CAM_UP = ANGLE90;
                    _angXY_nowCamUp = ANGLE90;
                    _burenai_speed = 10000;
                    _cam_velo_renge = 30000;
                    _stop_renge = 60000;
                    _move_target_X_CAM = 0;
                    _move_target_Y_CAM = 0;
                    _move_target_Z_CAM = 0;
                    _move_target_X_VP =  0;
                    _move_target_Y_VP =  0;
                    _move_target_Z_VP =  0;
                    //FCameraP_CAMgps
                }
                
                void CameraWorker::setMoveTargetCamBy(GgafDx9Core::GgafDx9GeometricActor* pTarget) {
                    _move_target_X_CAM = pTarget->_X;
                    _move_target_Y_CAM = pTarget->_Y;
                    _move_target_Z_CAM = pTarget->_Z;
                }
                void CameraWorker::setMoveTargetCamVpBy(GgafDx9Core::GgafDx9GeometricActor* pTarget) {
                    _move_target_X_VP = pTarget->_X;
                    _move_target_Y_VP = pTarget->_Y;
                    _move_target_Z_VP = pTarget->_Z;
                }
                
                void CameraWorker::setMoveTargetCam(int X, int Y, int Z) {
                    _move_target_X_CAM = X;
                    _move_target_Y_CAM = Y;
                    _move_target_Z_CAM = Z;
                }
                void CameraWorker::setMoveTargetCamVp(int X, int Y, int Z) {
                    _move_target_X_VP = X;
                    _move_target_Y_VP = Y;
                    _move_target_Z_VP = Z;
                }
                void CameraWorker::lockCamVp(GgafDx9Core::GgafDx9GeometricActor* pTarget) {
                    _pLockOnTarget = pTarget;
                }
                void CameraWorker::unlockCamVp() {
                    _pLockOnTarget = NULL;
                }
                
                
                void CameraWorker::onSwitchCameraWork() {
                    setMoveTargetCamBy(P_CAM);
                    setMoveTargetCamVpBy(P_CAM->_pViewPoint);
                    _angXY_nowCamUp = GgafDx9Util::getAngle2D(P_CAM->_pVecCamUp->x, P_CAM->_pVecCamUp->y);
                }
                
                void CameraWorker::onUndoCameraWork() {
                }
                
                void CameraWorker::onSwitchToOherCameraWork() {
                }
                
                void CameraWorker::onCameBackFromOtherCameraWork() {
                    _angXY_nowCamUp = GgafDx9Util::getAngle2D(P_CAM->_pVecCamUp->x, P_CAM->_pVecCamUp->y);
                }
                
                void CameraWorker::processBehavior() {
                
                    //DefaultCameraWorker::processBehavior();
                
                    //J
                //    float revise = 0.7; //l|B1.0_hsVBJ
                    GgafDx9Camera* pCam = P_CAM;
                    GgafDx9GeometricActor* pVP = pCam->_pViewPoint;
                
                    int cam_velo_renge = _cam_velo_renge;  //JxA~l
                    //JxA
                    pCam->_pKuroko->forceVxMvVeloRange(-cam_velo_renge, cam_velo_renge);
                    pCam->_pKuroko->forceVyMvVeloRange(-cam_velo_renge, cam_velo_renge);
                    pCam->_pKuroko->forceVzMvVeloRange(-cam_velo_renge, cam_velo_renge);
                    pVP->_pKuroko->forceVxMvVeloRange(-cam_velo_renge, cam_velo_renge);
                    pVP->_pKuroko->forceVyMvVeloRange(-cam_velo_renge, cam_velo_renge);
                    pVP->_pKuroko->forceVzMvVeloRange(-cam_velo_renge, cam_velo_renge);
                
                    //JAyr[|CgxB
                
                    //JWWeiWj
                    int dX_CAM = _move_target_X_CAM - pCam->_X;
                    int dY_CAM = _move_target_Y_CAM - pCam->_Y;
                    int dZ_CAM = _move_target_Z_CAM - pCam->_Z;
                    if ( _pLockOnTarget) {
                        _move_target_X_VP = _pLockOnTarget->_X;
                        _move_target_Y_VP = _pLockOnTarget->_Y;
                        _move_target_Z_VP = _pLockOnTarget->_Z;
                    }
                    //r[|CgWWeiWj
                    int dX_VP = _move_target_X_VP - pVP->_X;
                    int dY_VP = _move_target_Y_VP - pVP->_Y;
                    int dZ_VP = _move_target_Z_VP - pVP->_Z;
                    velo veloVxRenge = 4000;
                    velo veloVyRenge = 4000;
                    velo veloVzRenge = 4000;
                
                    velo last_CAM_veloVxMv = pCam->_pKuroko->_veloVxMv;
                    velo  new_CAM_veloVxMv = _burenai_speed*(dX_CAM*1.0 / _stop_renge);
                    if (last_CAM_veloVxMv-veloVxRenge <= new_CAM_veloVxMv && new_CAM_veloVxMv <= last_CAM_veloVxMv+veloVxRenge) {
                        pCam->_pKuroko->setVxMvVelo(new_CAM_veloVxMv);
                    } else {
                        if (last_CAM_veloVxMv-veloVxRenge > new_CAM_veloVxMv) {
                            pCam->_pKuroko->setVxMvVelo(last_CAM_veloVxMv-veloVxRenge);
                        } else if (new_CAM_veloVxMv > last_CAM_veloVxMv+veloVxRenge) {
                            pCam->_pKuroko->setVxMvVelo(last_CAM_veloVxMv+veloVxRenge);
                        }
                    }
                    velo last_VP_veloVxMv = pVP->_pKuroko->_veloVxMv;
                    velo  new_VP_veloVxMv = _burenai_speed*(dX_VP*1.0 / _stop_renge);
                    if (last_VP_veloVxMv-veloVxRenge <= new_VP_veloVxMv && new_VP_veloVxMv <= last_VP_veloVxMv+veloVxRenge) {
                        pVP->_pKuroko->setVxMvVelo(new_VP_veloVxMv);
                    } else {
                        if (last_VP_veloVxMv-veloVxRenge > new_VP_veloVxMv) {
                            pVP->_pKuroko->setVxMvVelo(last_VP_veloVxMv-veloVxRenge);
                        } else if (new_VP_veloVxMv > last_VP_veloVxMv+veloVxRenge) {
                            pVP->_pKuroko->setVxMvVelo(last_VP_veloVxMv+veloVxRenge);
                        }
                    }
                
                    velo last_CAM_veloVyMv = pCam->_pKuroko->_veloVyMv;
                    velo  new_CAM_veloVyMv = _burenai_speed*(dY_CAM*1.0 / _stop_renge);
                    if (last_CAM_veloVyMv-veloVyRenge <= new_CAM_veloVyMv && new_CAM_veloVyMv <= last_CAM_veloVyMv+veloVyRenge) {
                        pCam->_pKuroko->setVyMvVelo(new_CAM_veloVyMv);
                    } else {
                        if (last_CAM_veloVyMv-veloVyRenge > new_CAM_veloVyMv) {
                            pCam->_pKuroko->setVyMvVelo(last_CAM_veloVyMv-veloVyRenge);
                        } else if (new_CAM_veloVyMv > last_CAM_veloVyMv+veloVyRenge) {
                            pCam->_pKuroko->setVyMvVelo(last_CAM_veloVyMv+veloVyRenge);
                        }
                    }
                    velo last_VP_veloVyMv = pVP->_pKuroko->_veloVyMv;
                    velo  new_VP_veloVyMv = _burenai_speed*(dY_VP*1.0 / _stop_renge);
                    if (last_VP_veloVyMv-veloVyRenge <= new_VP_veloVyMv && new_VP_veloVyMv <= last_VP_veloVyMv+veloVyRenge) {
                        pVP->_pKuroko->setVyMvVelo(new_VP_veloVyMv);
                    } else {
                        if (last_VP_veloVyMv-veloVyRenge > new_VP_veloVyMv) {
                            pVP->_pKuroko->setVyMvVelo(last_VP_veloVyMv-veloVyRenge);
                        } else if (new_VP_veloVyMv > last_VP_veloVyMv+veloVyRenge) {
                            pVP->_pKuroko->setVyMvVelo(last_VP_veloVyMv+veloVyRenge);
                        }
                    }
                
                    velo last_CAM_veloVzMv = pCam->_pKuroko->_veloVzMv;
                    velo  new_CAM_veloVzMv = _burenai_speed*(dZ_CAM*1.0 / _stop_renge);
                    if (last_CAM_veloVzMv-veloVzRenge <= new_CAM_veloVzMv && new_CAM_veloVzMv <= last_CAM_veloVzMv+veloVzRenge) {
                        pCam->_pKuroko->setVzMvVelo(new_CAM_veloVzMv);
                    } else {
                        if (last_CAM_veloVzMv-veloVzRenge > new_CAM_veloVzMv) {
                            pCam->_pKuroko->setVzMvVelo(last_CAM_veloVzMv-veloVzRenge);
                        } else if (new_CAM_veloVzMv > last_CAM_veloVzMv+veloVzRenge) {
                            pCam->_pKuroko->setVzMvVelo(last_CAM_veloVzMv+veloVzRenge);
                        }
                    }
                    velo last_VP_veloVzMv = pVP->_pKuroko->_veloVzMv;
                    velo  new_VP_veloVzMv = _burenai_speed*(dZ_VP*1.0 / _stop_renge);
                    if (last_VP_veloVzMv-veloVzRenge <= new_VP_veloVzMv && new_VP_veloVzMv <= last_VP_veloVzMv+veloVzRenge) {
                        pVP->_pKuroko->setVzMvVelo(new_VP_veloVzMv);
                    } else {
                        if (last_VP_veloVzMv-veloVzRenge > new_VP_veloVzMv) {
                            pVP->_pKuroko->setVzMvVelo(last_VP_veloVzMv-veloVzRenge);
                        } else if (new_VP_veloVzMv > last_VP_veloVzMv+veloVzRenge) {
                            pVP->_pKuroko->setVzMvVelo(last_VP_veloVzMv+veloVzRenge);
                        }
                    }
                
                    //JUPvZ
                    angvelo angvelo_cam_up = cam_velo_renge/20;
                
                    if (_angXY_nowCamUp != _move_target_XY_CAM_UP) {
                        angle da = GgafDx9Util::getAngDiff(_angXY_nowCamUp, _move_target_XY_CAM_UP);
                        if (-angvelo_cam_up < da && da < angvelo_cam_up) {
                            _angXY_nowCamUp = _move_target_XY_CAM_UP;
                        } else {
                            _angXY_nowCamUp += (angvelo_cam_up * sgn(da));
                        }
                        _angXY_nowCamUp = GgafDx9Util::simplifyAng(_angXY_nowCamUp);
                        pCam->_pVecCamUp->x = GgafDx9Util::COS[_angXY_nowCamUp/ANGLE_RATE];
                        pCam->_pVecCamUp->y = GgafDx9Util::SIN[_angXY_nowCamUp/ANGLE_RATE];
                        pCam->_pVecCamUp->z = 0.0f;
                    }
                
                    pCam->_pKuroko->behave();
                    pVP->_pKuroko->behave();
                
                }
           3 -> CameraWorker::~CameraWorker() {
                }


Top 10 Lines:

     Line      Count

        8          3
      197          3

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        6   Total number of line executions
     2.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/common/DefaultCamWorker.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> DefaultCamWorker::DefaultCamWorker(const char* prm_name) : CameraWorker(prm_name) {
                    _class_name = "DefaultCamWorker";
                }
                
           2 -> DefaultCamWorker::~DefaultCamWorker() {
                }


Top 10 Lines:

     Line      Count

       12          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafCore/include/jp/ggaf/core/actor/GgafActorDispatcher.h:
                #ifndef ACTORDISPATCHER_H_
                #define ACTORDISPATCHER_H_
                namespace GgafCore {
                
                /**
                 * AN^[fBXpb`[ijNX .
                 * AN^[Tu\AN^[o^(addSubLast)XgbNB<BR>
                 *  employ() \bhAXgbNAN^[TB<BR>
                 * AN^[gIinactivate()AXgbNB<BR>
                 * exgAN^[AoLnYB<BR>
                 * Aemploy()Aemploy()AN^[Km@B<BR>
                 * Aemploy()AN^[AXgbNB<BR>
                 * |Ci[U[jZPgpA_B<BR>
                 * (RotationActor)
                 * @version 1.00
                 * @since 2008/08/11
                 * @author Masatoshi Tsuge
                 */
                class GgafActorDispatcher : public GgafDummyActor {
                
                public:
                    GgafActorDispatcher(const char* prm_name);
                
                    /**
                     * o[o^.
                     * IAaddSubLast() oApB
                     * o^AN^[A{fBXpb`[AaddSubLastB
                     * @param prm_pSub o^AN^[
                     */
                    virtual void addSubLast(GgafActor* prm_pSub);
                
                
                    /**
                     * activatenqAN^[e
                     */
                    virtual void activateTree() override {
                        activate();
                    }
                
                //    virtual void inactivateTree() override {
                //        inactivate();
                //    }
                    /**
                     * activatenqAN^[e
                     */
                    virtual void activateTreeDelay(frame prm_frame_offset) override {
                        activateDelay(prm_frame_offset);
                    }
                
                //    virtual void inactivateTreeDelay(frame prm_frame_offset) override {
                //        inactivateDelay(prm_frame_offset);
                //    }
                
                    /**
                     * AN^[o .
                     * AN^[Tuo[iactiveAactive\jB<BR>
                     * o[ NULL B<BR>
                     * A|C^AAN^[AN^[TuB<BR>
                     * ILhC[W<BR>
                     * gp
                     * <pre><code>
                     * GgafMainActor* pActor = pDispatcher->employ();
                     * if (pActor) {
                     *     //AN^[
                     *     //EEE
                     *
                     *     pActor->active();
                     * }
                     *
                     * </code></pre>
                     * @return AN^[o[AN^[
                     */
                    virtual GgafCore::GgafMainActor* employ() {
                #ifdef MY_DEBUG
                        if (_pSubFirst == NULL) {
                            throwGgafCriticalException("GgafActorDispatcher::employ() "<<getName()<<" q");
                        }
                #endif
                        GgafMainActor* pActor = getSubFirst();
                        for (int i = 0; i <= 100000; i++) {
                            if (pActor->_is_active_flg == false && pActor->_will_activate_after_flg == false) {
                                //pActor->activate(); //activateIs
                                pActor->moveLast(); //K
                                break;//I
                            } else {   //AAt[\
                                if (pActor->isLast()) {
                                    pActor = NULL;
                                    break;
                                } else {
                                    pActor = pActor->getNext();
                                    continue;
                                }
                            }
                #ifdef MY_DEBUG
                            if (i == 100000) {
                                throwGgafCriticalException("GgafActorDispatcher::employ() "<<getName()<<" otOBz[v\B");
                            }
                #endif
                        }
                        return pActor;
                    }
                
                    /**
                     * IAN^[o .
                     * AN^[Tuo[iactiveAactive\j
                     * IB<BR>
                     * employ() oAIAN^[B<BR>
                     * <b></b><BR>
                     * oAAN^[ active() sAAN^[
                     * isActiveActor() == true AonActive() R[obN
                     * \B<BR>
                     * IonActive() R[obNoR[h
                     * mB
                     * <pre><code>
                     * GgafMainActor* pActor = pDispatcher->employForce();
                     * if (pActor->isActiveActor()) {
                     *     pActor->inactivateImmediately();
                     *     pActor->onInactive();
                     * }
                     * pActor->active();
                     * </code></pre>
                     *
                     * @return
                     */
                    virtual GgafCore::GgafMainActor* employForce() {
                        GgafMainActor* pActor = employ();
                        if (pActor == NULL) {
                            getSubFirst()->moveLastImmediately(); //K
                            pActor = getSubFirst();
                        }
                        return pActor;
                
                    }
                
                    /**
                     * Zbg .
                     * o[SinactivateImmediately()B
                     */
                    virtual void onReset() override;
                
         152 ->     virtual ~GgafActorDispatcher() {
                    }
                };
                
                }
                #endif /*ACTORDISPATCHER_H_*/


Top 10 Lines:

     Line      Count

      141        152

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      152   Total number of line executions
   152.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/effect/EffectExplosion001.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
         100 -> EffectExplosion001::EffectExplosion001(const char* prm_name) : DefaultSpriteSetActor(prm_name, "EffectExplosion001") {
                    _class_name = "EffectExplosion001";
                    changeEffectTechnique("DestBlendOne"); //ZTechniquew
                    defineRotMvWorldMatrix(GgafDx9Util::setWorldMatrix_RzBxyzMv);
                }
                
                void EffectExplosion001::initialize() {
                    _pUvFlipper->forcePtnNoRange(0, 15);
                    setHitAble(false);
                
                }
                
                void EffectExplosion001::onActive() {
                    _pUvFlipper->setPtnNoToTop();
                    _pUvFlipper->setFlipMethod(FLIP_ORDER_NOLOOP, 1);
                    _fAlpha = 0.99;
                    _SX = _SY = _SZ = 1000;
                }
                
                void EffectExplosion001::processBehavior() {
                    _fAlpha -= 0.03;
                    _SX+= 100;
                    _SY+= 100;
                    _pUvFlipper->behave();
                    _pKuroko->behave();
                    _pScaler->behave();
                }
                
                void EffectExplosion001::processJudgement() {
                    if (_fAlpha < 0) {
                        sayonara();
                    }
                }
                
                void EffectExplosion001::onInactive() {
                    _pKuroko->resetMv();
                }
                
                
         200 -> EffectExplosion001::~EffectExplosion001() {
                }


Top 10 Lines:

     Line      Count

       47        200
        8        100

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      300   Total number of line executions
   100.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/effect/EffectLaserRefraction001.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
         100 -> EffectLaserRefraction001::EffectLaserRefraction001(const char* prm_name)
                               : DefaultMeshSetActor(prm_name, "EffectLaserRefraction001") {
                    _class_name = "EffectLaserRefraction001";
                    changeEffectTechnique("DestBlendOne"); //ZTechniquew
                    setZEnable(true);        //Zobt@lL
                    setZWriteEnable(false);  //Zobt@
                }
                
                void EffectLaserRefraction001::initialize() {
                //    _pUvFlipper->forcePtnNoRange(0, 63);
                    setHitAble(false);
                }
                
                void EffectLaserRefraction001::onActive() {
                    //_pUvFlipper->setPtnNoToTop();
                    //_pUvFlipper->setFlipMethod(FLIP_ORDER_LOOP, 1); //ppAj
                    setAlpha(0.5);
                    _pScaler->setScale(6*1000);
                    _pKuroko->setFaceAngVelo(AXIS_X, 3*1000);
                    _pKuroko->setFaceAngVelo(AXIS_Y, 5*1000);
                    _pKuroko->setFaceAngVelo(AXIS_Z, 7*1000);
                }
                
                void EffectLaserRefraction001::processBehavior() {
                    _pScaler->addScale(100);
                
                    //_pUvFlipper->behave();
                    _pKuroko->behave();
                    _pScaler->behave();
                }
                
                void EffectLaserRefraction001::processJudgement() {
                //    if (_fAlpha < 0) {
                //        sayonara();
                //    }
                }
                
                void EffectLaserRefraction001::onInactive() {
                }
                
         200 -> EffectLaserRefraction001::~EffectLaserRefraction001() {
                }


Top 10 Lines:

     Line      Count

       48        200
        8        100

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      300   Total number of line executions
   100.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/effect/EffectTurbo001.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> EffectTurbo001::EffectTurbo001(const char* prm_name) : DefaultSpriteActor(prm_name, "Turbo001") {
                    _class_name = "EffectTurbo001";
                    inactivateImmediately();
                    changeEffectTechnique("DestBlendOne"); //Z
                    defineRotMvWorldMatrix(GgafDx9Util::setWorldMatrix_RzBxyzMv); //r{[hRz]
                    setHitAble(false); //
                }
                
                void EffectTurbo001::initialize() {
                    _pUvFlipper->forcePtnNoRange(0, 15);   //AjO`PT
                    _pUvFlipper->setFlipMethod(FLIP_ORDER_LOOP, 1); //Aj
                    setAlpha(0.99);
                }
                
                void EffectTurbo001::onActive() {
                    _pUvFlipper->setPtnNoToTop();
                    _pKuroko->setFaceAngVelo(AXIS_Z, 3000);        //]
                }
                
                void EffectTurbo001::processBehavior() {
                    _pUvFlipper->behave();
                    _pKuroko->behave();
                    _pScaler->behave();
                }
                
                void EffectTurbo001::processJudgement() {
                    if (VB_PLAY->isBeingPressed(VB_TURBO)) { //^[{
                
                    } else {
                        inactivate();
                    }
                }
                
                void EffectTurbo001::onInactive() {
                }
                
           2 -> EffectTurbo001::~EffectTurbo001() {
                }


Top 10 Lines:

     Line      Count

       44          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/effect/EffectTurbo002.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
          10 -> EffectTurbo002::EffectTurbo002(const char* prm_name) : DefaultSpriteActor(prm_name, "Turbo002") {
                    _class_name = "EffectTurbo002";
                    inactivateImmediately();
                    changeEffectTechnique("DestBlendOne"); //Z
                    setHitAble(false); //
                }
                
                void EffectTurbo002::initialize() {
                    _pUvFlipper->forcePtnNoRange(0, 0);   //AjO`PT
                    _pUvFlipper->setFlipMethod(FLIP_ORDER_LOOP, 2); //Aj
                
                }
                
                void EffectTurbo002::onActive() {
                    _pUvFlipper->setPtnNoToTop();
                    setAlpha(0.4);
                    _pScaler->forceScaleRange(100000, 1000); //XP[OE
                    _pScaler->setScale(1000);
                    _pScaler->intoTargetScaleLinerUntil(100000, 60);//XP[OE60F1000k
                    _pKuroko->setFaceAng(AXIS_Y, ANGLE90);
                    _pKuroko->setFaceAngVelo(AXIS_Z, 2000);
                }
                
                void EffectTurbo002::processBehavior() {
                    addAlpha(-(1.0/60.0));
                    _pUvFlipper->behave();
                    _pKuroko->behave();
                    _pScaler->behave();
                }
                
                void EffectTurbo002::processJudgement() {
                    if (_pScaler->_method[0] == NOSCALE) {
                        inactivate();
                    }
                }
                
                void EffectTurbo002::onInactive() {
                }
                
          20 -> EffectTurbo002::~EffectTurbo002() {
                }


Top 10 Lines:

     Line      Count

       47         20
        8         10

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       30   Total number of line executions
    10.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/enemy/Astraea/EnemyAstraea.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> EnemyAstraea::EnemyAstraea(const char* prm_name) : DefaultMeshActor(prm_name, "Astraea") {
                    MyStgUtil::resetEnemyAstraeaStatus(_pStatus);
                
                    //[U[
                    _laser_way = 3;
                    _X = 0;
                    _Y = 0;
                    _Z = 0;
                    _laser_length = 30;
                    _laser_interval = 600;
                    _angveloTurn = 100;
                    _angClearance = 40000;//J
                    _papapLaserChipDispatcher = NEW LaserChipDispatcher**[_laser_way];
                    for (int i = 0; i < _laser_way; i++) {
                        _papapLaserChipDispatcher[i] = NEW LaserChipDispatcher*[_laser_way];
                    }
                
                
                    for (int i = 0; i < _laser_way; i++) {
                        for (int j = 0; j < _laser_way; j++) {
                            _papapLaserChipDispatcher[i][j] = NULL;
                        }
                    }
                
                    _pDispatcherCon_RefractionEffect =
                            (DispatcherConnection*)(P_GOD->_pDispatcherManager->getConnection("DpCon_EffRefraction001"));
                
                    _pDispatcherCon_DpEnemyAstraeaLaserChip =
                            (DispatcherConnection*)(P_GOD->_pDispatcherManager->getConnection(
                                                                                   "DpCon_DpEnemyAstraeaLaserChip001",
                                                                                   //"DpCon_DpEnemyAstraeaLaserChip002",
                                                                                   _pDispatcherCon_RefractionEffect->refer()
                                                                                )
                                                   );
                
                
                    _papaPosLaser = NEW PosLaser*[_laser_way];
                    angle* paAngWay = NEW angle[_laser_way];
                    GgafDx9Util::getWayAngle2D(0, _laser_way, _angClearance, paAngWay);
                    angle Rz,Ry;
                    float vx, vy, vz;
                    for (int i = 0; i < _laser_way; i++) {
                        Rz = GgafDx9Util::simplifyAng(paAngWay[i]);
                        _papaPosLaser[i] = NEW PosLaser[_laser_way];
                        for (int j = 0; j < _laser_way; j++) {
                            Ry = GgafDx9Util::simplifyAng(paAngWay[j]);
                            GgafDx9Util::getNormalizeVectorZY(Rz, Ry,
                                                              vx, vy, vz);
                            _papaPosLaser[i][j].X = vx * 100*1000;
                            _papaPosLaser[i][j].Y = vy * 100*1000;
                            _papaPosLaser[i][j].Z = vz * 100*1000;
                        }
                    }
                    DELETEARR_IMPOSSIBLE_NULL(paAngWay);
                
                    _pEffect_Appearance = NULL;
                
                    _pSeTransmitter->useSe(2);
                    _pSeTransmitter->set(0, "yume_Sbend", GgafRepeatSeq::nextVal("CH_yume_Sbend"));
                    _pSeTransmitter->set(1, "bomb1", GgafRepeatSeq::nextVal("CH_bomb1"));
                    _iMovePatternNo = 0;
                
                
                
                }
                
                void EnemyAstraea::onCreateModel() {
                    _pGgafDx9Model->_pTextureBlinker->forceBlinkRange(0.5, 12.0);
                    _pGgafDx9Model->_pTextureBlinker->setBlink(1.0);
                    _pGgafDx9Model->_pTextureBlinker->beat(60*6, 60*2, 60*2, -1);
                    _pGgafDx9Model->_fBlinkThreshold = 0.97;
                }
                void EnemyAstraea::initialize() {
                    setHitAble(true);
                    setAlpha(0.99);
                    _pCollisionChecker->makeCollision(1);
                    _pCollisionChecker->setColliSphere(0, 200*1000);
                    _pKuroko->setMvVelo(-1000);
                    _iMovePatternNo = 0;
                    _X = GgafDx9Core::GgafDx9Universe::_X_goneRight;
                }
                
                
                void EnemyAstraea::onActive() {
                    //Xe[^XZbg
                    MyStgUtil::resetEnemyAstraeaStatus(_pStatus);
                    _pKuroko->setMvVelo(-5000);
                    _iMovePatternNo = 0;
                    _X = GgafDx9Core::GgafDx9Universe::_X_goneRight;
                
                    if (_pEffect_Appearance) {
                        _pEffect_Appearance->activate();
                    }
                }
                
                void EnemyAstraea::processBehavior() {
                    //ZN|Cg
                    _pStatus->mul(STAT_AddRankPoint, _pStatus->getDouble(STAT_AddRankPoint_Reduction));
                
                    /////////////[teXg(DefaultMorphMeshActorpv)////////////////
                //    if (GgafDx9Input::isBeingPressedKey(DIK_1)) {
                //        _pMorpher->loopTriangleWave(1, 30, 3, 22);
                //    } else if (GgafDx9Input::isBeingPressedKey(DIK_7)) {
                //        _pMorpher->stopImmediately(1);
                //    }
                //    if (GgafDx9Input::isBeingPressedKey(DIK_2)) {
                //        _pMorpher->intoTargetAcceStep(2, 1.0f, 0, 0.002f);
                //    } else if (GgafDx9Input::isBeingPressedKey(DIK_8)) {
                //        _pMorpher->intoTargetAcceStep(2, 0, 0, -0.004f);
                //    }
                //    if (GgafDx9Input::isBeingPressedKey(DIK_3)) {
                //        _pMorpher->loopTriangleWave(3, 20, 13, 2);
                //    } else if (GgafDx9Input::isBeingPressedKey(DIK_9)) {
                //        _pMorpher->stopImmediately(3);
                //    }
                //    if (GgafDx9Input::isBeingPressedKey(DIK_4)) {
                //        _pMorpher->loopTriangleWave(4, 60, 3, 20);
                //    } else if (GgafDx9Input::isBeingPressedKey(DIK_0)) {
                //        _pMorpher->stopImmediately(4);
                //    }
                //    _pMorpher->behave();
                
                //    if (GgafDx9Input::isBeingPressedKey(DIK_1)) {
                //        _pMorpher->intoTargetLinerUntil(1, 1.0, 30);
                //        _pMorpher->intoTargetLinerUntil(2, 0, 30);
                //        _pMorpher->intoTargetLinerUntil(3, 0, 30);
                //        _pMorpher->intoTargetLinerUntil(4, 0, 30);
                //    } else if (GgafDx9Input::isBeingPressedKey(DIK_7)) {
                //        _pMorpher->intoTargetLinerUntil(1, 0, 30);
                //    }
                //    if (GgafDx9Input::isBeingPressedKey(DIK_2)) {
                //        _pMorpher->intoTargetLinerUntil(1, 0, 30);
                //        _pMorpher->intoTargetLinerUntil(2, 1.0, 30);
                //        _pMorpher->intoTargetLinerUntil(3, 0, 30);
                //        _pMorpher->intoTargetLinerUntil(4, 0, 30);
                //    } else if (GgafDx9Input::isBeingPressedKey(DIK_8)) {
                //        _pMorpher->intoTargetLinerUntil(2, 0, 30);
                //    }
                //    if (GgafDx9Input::isBeingPressedKey(DIK_3)) {
                //        _pMorpher->intoTargetLinerUntil(1, 0, 30);
                //        _pMorpher->intoTargetLinerUntil(2, 0, 30);
                //        _pMorpher->intoTargetLinerUntil(3, 1.0, 30);
                //        _pMorpher->intoTargetLinerUntil(4, 0, 30);
                //    } else if (GgafDx9Input::isBeingPressedKey(DIK_9)) {
                //        _pMorpher->intoTargetLinerUntil(3, 0, 30);
                //    }
                //    if (GgafDx9Input::isBeingPressedKey(DIK_4)) {
                //        _pMorpher->intoTargetLinerUntil(1, 0, 30);
                //        _pMorpher->intoTargetLinerUntil(2, 0, 30);
                //        _pMorpher->intoTargetLinerUntil(3, 0, 30);
                //        _pMorpher->intoTargetLinerUntil(4, 1.0, 30);
                //    } else if (GgafDx9Input::isBeingPressedKey(DIK_0)) {
                //        _pMorpher->intoTargetLinerUntil(4, 0, 30);
                //    }
                //    _pMorpher->behave();
                    /////////////[teXg////////////////
                    if (_iMovePatternNo == 0) {
                        _pKuroko->setFaceAngVelo(AXIS_X, 0);
                        _pKuroko->setFaceAngVelo(AXIS_Z, _angveloTurn*1.5);
                        _pKuroko->setFaceAngVelo(AXIS_Y, _angveloTurn*0.5);
                        _pKuroko->setMvVelo(-3000);
                        _iMovePatternNo++;
                    } else if (_iMovePatternNo == 1 && _X > P_MYSHIP->_X-400000) {
                        if (getBehaveingFrame() % _laser_interval == 0) {
                            _pKuroko->orderTagettingFaceAngSequence(P_MYSHIP,
                                                                _angveloTurn*20, 0,
                                                                TURN_COUNTERCLOCKWISE, false);
                            _iMovePatternNo++;
                            _cnt_laserchip = 0;
                        } else {
                        }
                    } else if (_iMovePatternNo == 2) {
                        if (!_pKuroko->isTagettingFaceAng()) {
                            //@U
                            _iMovePatternNo++;
                        }
                    } else if (_iMovePatternNo == 3) {
                        _pKuroko->setFaceAngVelo(AXIS_X, _angveloTurn*40);
                        _pKuroko->setFaceAngVelo(AXIS_Z, 0);
                        _pKuroko->setFaceAngVelo(AXIS_Y, 0);
                        _pKuroko->setMvVelo(0);
                        if (_cnt_laserchip < _laser_length) {
                            _cnt_laserchip++;
                
                            LaserChip* pLaserChip;
                            D3DXMATRIX matWorldRot;
                            GgafDx9Util::setWorldMatrix_RxRzRy(this, matWorldRot);
                            angle Rz, Ry;
                            int vX, vY, vZ;
                            for (int i = 0; i < _laser_way; i++) {
                                for (int j = 0; j < _laser_way; j++) {
                                    if (_papapLaserChipDispatcher[i][j] == NULL) {
                                        GgafMainActor* p = _pDispatcherCon_DpEnemyAstraeaLaserChip->refer()->employ();
                                        if (p == NULL) {
                                            //[U[Zbgo
                                            continue;
                                        } else {
                                            _papapLaserChipDispatcher[i][j] = (LaserChipDispatcher*)p;
                                            _papapLaserChipDispatcher[i][j]->config(_laser_length, 1);
                                            _papapLaserChipDispatcher[i][j]->activate();
                                        }
                                    }
                
                                    pLaserChip = _papapLaserChipDispatcher[i][j]->employ();
                                    if (pLaserChip) {
                                        //[U[vZ
                                        //[JVbgxNg(_Xorg,_Yorg,_Zorg)A
                                        //[hs]imatWorldRot) mat_xxA
                                        //IIxNg(vX, vY, vZ) 
                                        //
                                        //                       | mat_11 mat_12 mat_13 |
                                        // | _Xorg _Yorg _Zorg | | mat_21 mat_22 mat_23 | = | vX vY vZ |
                                        //                       | mat_31 mat_32 mat_33 |
                                        //
                                        // vX = _Xorg*mat_11 + _Yorg*mat_21 + _Zorg*mat_31
                                        // vY = _Xorg*mat_12 + _Yorg*mat_22 + _Zorg*mat_32
                                        // vZ = _Xorg*mat_13 + _Yorg*mat_23 + _Zorg*mat_33
                                        //
                                        vX = _papaPosLaser[i][j].X*matWorldRot._11 + _papaPosLaser[i][j].Y*matWorldRot._21 + _papaPosLaser[i][j].Z*matWorldRot._31;
                                        vY = _papaPosLaser[i][j].X*matWorldRot._12 + _papaPosLaser[i][j].Y*matWorldRot._22 + _papaPosLaser[i][j].Z*matWorldRot._32;
                                        vZ = _papaPosLaser[i][j].X*matWorldRot._13 + _papaPosLaser[i][j].Y*matWorldRot._23 + _papaPosLaser[i][j].Z*matWorldRot._33;
                                        GgafDx9Util::getRzRyAng(vX, vY, vZ, Rz, Ry); //IIARzRy
                
                
                                        pLaserChip->locate(_X+vX, _Y+vY, _Z+vZ);
                                        pLaserChip->_pKuroko->setRzRyMvAng(Rz, Ry);
                                        pLaserChip->_pKuroko->_angFace[AXIS_Z] = Rz;
                                        pLaserChip->_pKuroko->_angFace[AXIS_Y] = Ry;
                                        pLaserChip->activate();
                                        //pLaserChip->_pKuroko->behave();
                
                                        if (i == 0 && j == 0 && pLaserChip->_pChip_front == NULL) {
                                            _pSeTransmitter->play3D(0); //
                                            changeEffectTechniqueInterim("Flush", 5); //tbV
                                        }
                                    }
                                }
                            }
                        } else {
                //            for (int i = 0; i < _laser_way; i++) {
                //                for (int j = 0; j < _laser_way; j++) {
                //                    _papapLaserChipDispatcher[i][j] = NULL;
                //                }
                //            }
                            _iMovePatternNo = 0;
                        }
                    }
                
                    _pSeTransmitter->behave();
                    _pKuroko->behave();
                }
                
                void EnemyAstraea::processJudgement() {
                    if (isOutOfUniverse()) {
                        sayonara();
                    }
                }
                
                void EnemyAstraea::onHit(GgafActor* prm_pOtherActor) {
                    GgafDx9GeometricActor* pOther = (GgafDx9GeometricActor*)prm_pOtherActor;
                    changeEffectTechniqueInterim("Flush", 2); //tbV
                    //EEERRqbgGtFNg
                    if (MyStgUtil::calcEnemyStatus(_pStatus, getKind(), pOther->_pStatus, pOther->getKind()) <= 0) {
                        //j
                        //EEERRjGtFNg
                        EffectExplosion001* pExplo001 = (EffectExplosion001*)P_COMMON_SCENE->_pDP_EffectExplosion001->employ();
                        if (pExplo001) {
                            pExplo001->activate();
                            pExplo001->locateAs(this);
                        }
                        _pSeTransmitter->play3D(1);
                        sayonara();
                        //GtFNg
                    } else {
                
                    }
                
                }
                
                
                void EnemyAstraea::onInactive() {
                    //[U[fBXpb`[x
                    for (int i = 0; i < _laser_way; i++) {
                        for (int j = 0; j < _laser_way; j++) {
                            if (_papapLaserChipDispatcher[i][j]) {
                                _papapLaserChipDispatcher[i][j]->sayonara(60*10);
                            }
                        }
                    }
                    sayonara();
                }
                
                
           2 -> EnemyAstraea::~EnemyAstraea() {
                    _pDispatcherCon_RefractionEffect->close();
                    _pDispatcherCon_DpEnemyAstraeaLaserChip->close();
                    for (int i = 0; i < _laser_way; i++) {
                        DELETEARR_IMPOSSIBLE_NULL(_papaPosLaser[i]);
                        DELETEARR_IMPOSSIBLE_NULL(_papapLaserChipDispatcher[i]);
                    }
                    DELETEARR_IMPOSSIBLE_NULL(_papaPosLaser);
                    DELETEARR_IMPOSSIBLE_NULL(_papapLaserChipDispatcher);
                
                
                }


Top 10 Lines:

     Line      Count

      301          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/enemy/Astraea/EnemyAstraeaLaserChip001.cpp:
                
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
                
        1350 -> EnemyAstraeaLaserChip001::EnemyAstraeaLaserChip001(const char* prm_name) :
                        HomingLaserChip(prm_name, "AstraeaLaserChip001") {
                    _class_name = "EnemyAstraeaLaserChip001";
                    MyStgUtil::resetEnemyAstraeaLaserChip001Status(_pStatus);
                }
                
                void EnemyAstraeaLaserChip001::initialize() {
                    registHitAreaCube(20000);
                    setHitAble(true, false);
                    setScaleRate(5.0);
                    setAlpha(0.9);
                }
                
                void EnemyAstraeaLaserChip001::onActive() {
                    HomingLaserChip::onActive();
                    //Xe[^XZbg
                    MyStgUtil::resetEnemyAstraeaLaserChip001Status(_pStatus);
                
                    _pKuroko->setMvVelo(10000);
                    _pKuroko->setMvAcce(400);
                    _pKuroko->relateRzRyFaceAngToMvAng(true);
                }
                
                void EnemyAstraeaLaserChip001::executeHitChk_MeAnd(GgafActor* prm_pOtherActor) {
                    if (((GgafMainActor*)prm_pOtherActor)->getKind() & KIND_CHIKEI) {
                        if (_chip_kind != 2 || _can_chikei_hit) {
                            GgafDx9DrawableActor::executeHitChk_MeAnd(prm_pOtherActor);
                        } else {
                            return;
                        }
                    } else {
                        GgafDx9DrawableActor::executeHitChk_MeAnd(prm_pOtherActor);
                    }
                }
                
                void EnemyAstraeaLaserChip001::processBehaviorHeadChip() {
                    if (getActivePartFrame() == 40) {
                        _pKuroko->orderTagettingMvAngSequence(
                                    P_MYSHIP,
                                    7000, 0,
                                    TURN_ANTICLOSE_TO, false);
                    }
                
                
                    if (_pKuroko->_mv_ang_ry_target_flg == false && _pKuroko->_mv_ang_rz_target_flg == false) {
                        _pKuroko->orderTagettingMvAngSequence(
                                    P_MYSHIP,
                                    100, 0,
                                    TURN_CLOSE_TO, false);
                    }
                //
                //    if (_frame_of_behaving_from_onActive == 35) {
                //        _pKuroko->orderTagettingMvAngSequence(
                //                    P_MYSHIP,
                //                    20000, TURN_ANTICLOSE_TO);
                //    }
                
                    _pKuroko->behave();
                }
                
                void EnemyAstraeaLaserChip001::onHit(GgafActor* prm_pOtherActor) {
                    GgafDx9GeometricActor* pOther = (GgafDx9GeometricActor*)prm_pOtherActor;
                    //qbg
                    //vZ
                    int sta = MyStgUtil::calcEnemyStatus(_pStatus, getKind(), pOther->_pStatus, pOther->getKind());
                    if (sta <= 0) {
                        //qbg
                        sayonara();
                    } else {
                        //qbg
                    }
                }
                
        2700 -> EnemyAstraeaLaserChip001::~EnemyAstraeaLaserChip001() {
                
                }
                


Top 10 Lines:

     Line      Count

       83       2700
       10       1350

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

     4050   Total number of line executions
  1350.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/enemy/Eunomia/EnemyEunomia.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
         800 -> EnemyEunomia::EnemyEunomia(const char* prm_name) : DefaultMeshSetActor(prm_name, "Eunomia") {
                    _class_name = "EnemyEunomia";
                    MyStgUtil::resetEnemyEunomiaStatus(_pStatus);
                    _iMovePatternNo = 0;
                    _pSplineProgram = NULL;
                    _pDispatcher_Shot = NULL;
                    _pDispatcher_ShotEffect = NULL;
                    _pSeTransmitter->useSe(1);
                    _pSeTransmitter->set(0, "bomb1", GgafRepeatSeq::nextVal("CH_bomb1"));     //
                    useProgress(10);
                }
                
                void EnemyEunomia::onCreateModel() {
                }
                
                void EnemyEunomia::initialize() {
                    setHitAble(true);
                    _pKuroko->setFaceAngVelo(AXIS_X, -4000);
                    _pKuroko->relateRzRyFaceAngToMvAng(true);
                    _pCollisionChecker->makeCollision(1);
                    _pCollisionChecker->setColliAAB_Cube(0, 40000);
                }
                
                void EnemyEunomia::onReset() {
                    MyStgUtil::resetEnemyEunomiaStatus(_pStatus);
                    _iMovePatternNo = 0; //sp^[Zbg
                    _pPrg->change(1);
                }
                
                
                void EnemyEunomia::onActive() {
                    if (_pSplineProgram == NULL) {
                        throwGgafCriticalException("EnemyEunomiaXvCK{config");
                    }
                    reset();
                }
                
                void EnemyEunomia::processBehavior() {
                    //ZN|Cg
                    _pStatus->mul(STAT_AddRankPoint, _pStatus->getDouble(STAT_AddRankPoint_Reduction));
                
                    //yp^[1FXvCz
                    if (_pPrg->wasChangedTo(1)) {
                        _pSplineProgram->begin(0); //XvCJn(1:W)
                    }
                    if (_pPrg->get() == 1) {
                        //XvCI
                        if (_pSplineProgram->isExecuting()) {
                            //
                        } else {
                            _pPrg->changeNext(); //p^[
                        }
                    }
                
                    switch (_iMovePatternNo) {
                        case 0:  //yp^[OFXvCJnz
                            if (_pSplineProgram) {
                                _pSplineProgram->begin(0); //XvCJn(1:W)
                            }
                            _iMovePatternNo++; //sp^[
                            break;
                
                        case 1:  //yp^[PFXvCIz
                            if (_pSplineProgram) {
                                //XvCL
                                if (!(_pSplineProgram->isExecuting())) {
                                    _iMovePatternNo++; //XvCIsp^[
                                }
                            } else {
                                //XvC
                                _iMovePatternNo++; //sp^[
                            }
                            break;
                
                        case 2:  //yp^[QFVbg@]z
                            if (_pDispatcher_Shot) {
                                //Vbg
                                int way = 10+_RANK_*10; //VbgWAY
                                angle* paAngWay = NEW angle[way];
                                GgafDx9Util::getRadialAngle2D(0, way, paAngWay);
                                GgafDx9DrawableActor* pActor_Shot;
                                for (int i = 0; i < way; i++) {
                                    pActor_Shot = (GgafDx9DrawableActor*)_pDispatcher_Shot->employ();
                                    if (pActor_Shot) {
                                        pActor_Shot->locateAs(this);
                                        pActor_Shot->_pKuroko->setRzRyMvAng(paAngWay[i], ANGLE90);
                                        pActor_Shot->activate();
                                    }
                                }
                                DELETEARR_IMPOSSIBLE_NULL(paAngWay);
                                //VbgGtFNg
                                if (_pDispatcher_ShotEffect) {
                                    GgafDx9DrawableActor* pEffectActor_Shot = (GgafDx9DrawableActor*)_pDispatcher_ShotEffect->employ();
                                    if (pEffectActor_Shot) {
                                        pEffectActor_Shot->locateAs(this);
                                        pEffectActor_Shot->activate();
                                    }
                                }
                            }
                //            //@]
                            _pKuroko->orderTagettingMvAngSequence(P_MYSHIP->_X, _Y, P_MYSHIP->_Z,
                                                                2000, 0,
                                                                TURN_CLOSE_TO);
                            _iMovePatternNo++; //sp^[
                            break;
                
                        case 3:  //ysp^[Rz
                
                            break;
                        default:
                            break;
                    }
                
                
                    if (_pSplineProgram) {
                        _pSplineProgram->behave(); //XvCU
                    }
                    _pKuroko->behave();
                    //_pSeTransmitter->behave();
                }
                
                void EnemyEunomia::processJudgement() {
                    if (isOutOfUniverse()) {
                        sayonara();
                    }
                }
                
                void EnemyEunomia::onHit(GgafActor* prm_pOtherActor) {
                    //_TRACE_("EnemyEunomia::onHit!!! this="<<getName()<<"("<<_pStatus->get(STAT_DEFAULT_ACTOR_KIND)<<")");
                    //_TRACE_("EnemyEunomia::onHit!!! prm_pOtherActor="<<prm_pOtherActor->getName()<<"("<<prm_pOtherActor->_pStatus->get(STAT_DEFAULT_ACTOR_KIND)<<")");
                    GgafDx9GeometricActor* pOther = (GgafDx9GeometricActor*)prm_pOtherActor;
                
                    if (MyStgUtil::calcEnemyStatus(_pStatus, getKind(), pOther->_pStatus, pOther->getKind()) <= 0) {
                        EffectExplosion001* pExplo001 = (EffectExplosion001*)P_COMMON_SCENE->_pDP_EffectExplosion001->employ();
                        _pSeTransmitter->play3D(0);
                        if (pExplo001) {
                            pExplo001->activate();
                            pExplo001->locateAs(this);
                            pExplo001->_pKuroko->takeoverMvFrom(_pKuroko);
                        }
                
                        //@AtH[VA
                        //tH[[Vg`B
                        if ((pOther->getKind() & KIND_MY) && (getParent()->_obj_class & Obj_GgafDx9FormationActor)) {
                            ((GgafDx9FormationActor*)getParent())->wasDestroyedFollower(this);
                        }
                        setHitAble(false); //At[~qbgidvj
                        sayonara();
                
                        Item* pItem = (Item*)P_COMMON_SCENE->_pDP_MagicPointItem001->employ();
                        if (pItem) {
                            pItem->locateAs(this);
                            pItem->activate();
                        }
                    }
                }
                
                void EnemyEunomia::onInactive() {
                    sayonara();
                }
                
        1600 -> EnemyEunomia::~EnemyEunomia() {
                    DELETE_POSSIBLE_NULL(_pSplineProgram);
                }
                
                


Top 10 Lines:

     Line      Count

      169       1600
        8        800

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

     2400   Total number of line executions
   800.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/enemy/Eunomia/FormationEunomia.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           8 -> FormationEunomia::FormationEunomia(const char* prm_name, int prm_col,
                                                                         int prm_row,
                                                                         frame prm_frame_interval,
                                                                         velo prm_mv_velo,
                                                                         const char* prm_spl_id) : GgafDx9FormationActor(prm_name, 30*60) {
                    _class_name = "FormationEunomia";
                    _num_formation_col = prm_col;   //
                    _num_formation_row = prm_row;  //P
                    _frame_interval    = prm_frame_interval;   //GEm~Au(frame)
                    _mv_velo           = prm_mv_velo; //x
                    _n = 0;
                    //GEm~A
                    //XvC`t@C
                    _papSplineCon = NEW SplineConnection*[_num_formation_col];
                    for (int i = 0; i < _num_formation_col; i++) {
                        stringstream spl_id;
                        spl_id << prm_spl_id << "_" << i;  //"FormationEunomia001_0"
                        _papSplineCon[i] = (SplineConnection*)(P_GOD->_pSplineManager->getConnection(spl_id.str().c_str()));
                    }
                
                    _papapEunomia = NEW EnemyEunomia**[_num_formation_col]; //nxN@g
                    for (int i = 0; i < _num_formation_col; i++) {
                        _papapEunomia[i] = NEW EnemyEunomia*[_num_formation_row];
                        for (int j = 0; j < _num_formation_row; j++) {
                            _papapEunomia[i][j] = NEW EnemyEunomia("EUNOMIA");
                            _papapEunomia[i][j]->config(_papSplineCon[i]->refer()->makeSplineProgram(_papapEunomia[i][j]), NULL, NULL);
                            _papapEunomia[i][j]->inactivateImmediately();
                            addSubLast(_papapEunomia[i][j]);
                        }
                    }
                    _pDispatcherCon = NULL;
                }
                void FormationEunomia::initialize() {
                    _n = 0;
                }
                
                
                void FormationEunomia::processBehavior() {
                    if (_n < _num_formation_row && getActivePartFrame() % _frame_interval == 0) {
                        for (int i = 0; i < _num_formation_col; i++) {
                            _papapEunomia[i][_n]->activate();
                            processOnActiveEunomia(_papapEunomia[i][_n], i); //
                        }
                        _n++;
                    }
                }
                
           8 -> FormationEunomia::~FormationEunomia() {
                    for (int i = 0; i < _num_formation_col; i++) {
                        _papSplineCon[i]->close();
                    }
                    DELETEARR_IMPOSSIBLE_NULL(_papSplineCon);
                
                    if (_pDispatcherCon) {
                        _pDispatcherCon->close();
                    }
                    for (int i = 0; i < _num_formation_col; i++) {
                        DELETEARR_IMPOSSIBLE_NULL(_papapEunomia[i]);
                    }
                    DELETEARR_IMPOSSIBLE_NULL(_papapEunomia);
                }


Top 10 Lines:

     Line      Count

        8          8
       55          8

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       16   Total number of line executions
     5.33   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/enemy/Eunomia/FormationEunomia001.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           8 -> FormationEunomia001::FormationEunomia001(const char* prm_name) :
                                                        FormationEunomia(prm_name,
                                                                         5  + _RANK_*2,
                                                                         20 + _RANK_*10,
                                                                         10 - _RANK_*5,
                                                                         10000 + _RANK_*10000,
                                                                         "FormationEunomia001") {
                    _class_name = "FormationEunomia001";
                }
                
                
                void FormationEunomia001::wasDestroyedFormation(GgafDx9GeometricActor* prm_pActorLast) {
                    //
                    EffectTurbo002* pTurbo002 = (EffectTurbo002*)P_COMMON_SCENE->_pDispatcher_EffectTurbo002->employForce();
                    if (pTurbo002) {
                        pTurbo002->locateAs(prm_pActorLast);
                        pTurbo002->activate();
                    }
                }
                
                void FormationEunomia001::processBehavior() {
                    FormationEunomia::processBehavior();
                }
                
           8 -> FormationEunomia001::~FormationEunomia001() {
                }


Top 10 Lines:

     Line      Count

        8          8
       32          8

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       16   Total number of line executions
     5.33   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/enemy/Eunomia/FormationEunomia001a.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           4 -> FormationEunomia001a::FormationEunomia001a(const char* prm_name) : FormationEunomia001(prm_name) {
                    _class_name = "FormationEunomia001a";
                }
                void FormationEunomia001a::processOnActiveEunomia(EnemyEunomia* pEnemyEunomia, int col) {
                    pEnemyEunomia->_pSplineProgram->adjustAxisRate(1.0, 1.0, 1.0);
                    pEnemyEunomia->_pSplineProgram->adjustAxisOffset(0, col*50*1000, col*50*1000);
                    pEnemyEunomia->_pSplineProgram->setAbsoluteBeginCoordinate();
                    pEnemyEunomia->_pKuroko->setMvVelo(_mv_velo);
                }
                
           8 -> FormationEunomia001a::~FormationEunomia001a() {
                }


Top 10 Lines:

     Line      Count

       18          8
        8          4

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       12   Total number of line executions
     4.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/enemy/Eunomia/FormationEunomia001b.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           4 -> FormationEunomia001b::FormationEunomia001b(const char* prm_name) : FormationEunomia001(prm_name) {
                    _class_name = "FormationEunomia001b";
                }
                
                void FormationEunomia001b::processOnActiveEunomia(EnemyEunomia* pEnemyEunomia, int col) {
                    pEnemyEunomia->_pSplineProgram->adjustAxisRate(1.0, -1.0, 1.0);
                    pEnemyEunomia->_pSplineProgram->adjustAxisOffset(col*50*1000, col*50*1000, col*50*1000);
                    pEnemyEunomia->_pSplineProgram->setAbsoluteBeginCoordinate();
                    pEnemyEunomia->_pKuroko->setMvVelo(_mv_velo);
                }
                
           8 -> FormationEunomia001b::~FormationEunomia001b() {
                }


Top 10 Lines:

     Line      Count

       19          8
        8          4

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       12   Total number of line executions
     4.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/enemy/Metis/EnemyMetis.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
          99 -> EnemyMetis::EnemyMetis(const char* prm_name) : DefaultMeshSetActor(prm_name, "Metis") {
                    _class_name = "EnemyMetis";
                    MyStgUtil::resetEnemyMetisStatus(_pStatus);
                    _width_X = 220*2*LEN_UNIT;
                    _height_Z = 220*2*LEN_UNIT;
                    _depth_Y = 36*2*LEN_UNIT;
                    _iMovePatternNo = 0;
                    _pSeTransmitter->useSe(2);
                    _pSeTransmitter->set(0, "yume_shototsu", GgafRepeatSeq::nextVal("CH_MetisHit"));
                    _pSeTransmitter->set(1, "bom10", GgafRepeatSeq::nextVal("CH_MetisDestroy"));     //
                }
                
                void EnemyMetis::initialize() {
                    int nArea = 0;
                    for (int i = 0; i < (_width_X - _depth_Y) ; i+= _depth_Y) {
                        nArea++;
                    }
                    _pCollisionChecker->makeCollision(nArea);
                    for (int i = 0, n = 0; i < (_width_X - _depth_Y)  ; i+= _depth_Y, n++) {
                        _pCollisionChecker->setColliAAB(n, i - ((_depth_Y/2.0)/1.5)-(_width_X/2 - _depth_Y/2.0), -((_depth_Y/2.0)/1.5), -(_height_Z/2.0),
                                                       i + ((_depth_Y/2.0)/1.5)-(_width_X/2 - _depth_Y/2.0),  ((_depth_Y/2.0)/1.5),  (_height_Z/2.0),
                                                       false, false, true
                                                   );
                    }
                }
                
                void EnemyMetis::onActive() {
                    MyStgUtil::resetEnemyMetisStatus(_pStatus);
                    _iMovePatternNo = 0;
                    setAlpha(1.0);
                    _pKuroko->setMvVelo(0);
                    _pKuroko->setVxMvVelo(-3000);
                    _pKuroko->setFaceAngVelo(AXIS_Z, 1000);
                
                    CmRandomNumberGenerator* pRndGen = CmRandomNumberGenerator::getInstance();
                    pRndGen->changeSeed(P_GAME_SCENE->_frame_of_behaving);
                    DWORD appearances_renge_Z = (MyShip::_lim_zleft - MyShip::_lim_zright) * 3;
                    DWORD appearances_renge_Y = (MyShip::_lim_top - MyShip::_lim_bottom) * 3;
                    _X = GgafDx9Universe::_X_goneRight - 1000;
                    _Y = (pRndGen->genrand_int32() % (appearances_renge_Y)) - (appearances_renge_Y/2);
                    _Z = (pRndGen->genrand_int32() % (appearances_renge_Z)) - (appearances_renge_Z/2);
                    setHitAble(true);
                }
                
                void EnemyMetis::processBehavior() {
                    //ZN|Cg
                    _pStatus->mul(STAT_AddRankPoint, _pStatus->getDouble(STAT_AddRankPoint_Reduction));
                    //Wf
                    _pKuroko->behave();
                    //_pSeTransmitter->behave();
                }
                
                void EnemyMetis::processJudgement() {
                    if (isOutOfUniverse()) {
                        sayonara();
                    }
                }
                
                void EnemyMetis::onHit(GgafActor* prm_pOtherActor) {
                    if (_pStatus->get(STAT_Stamina) < 0) {
                        return;
                    }
                    GgafDx9GeometricActor* pOther = (GgafDx9GeometricActor*)prm_pOtherActor;
                
                    //qbgGtFNg
                    changeEffectTechniqueInterim("Flush", 2); //tbV
                    _pSeTransmitter->play3D(0);
                        //GtFNg
                    if (pOther->getKind() & KIND_MY) {
                        EffectExplosion001* pExplo001 = (EffectExplosion001*)P_COMMON_SCENE->_pDP_EffectExplosion001->employ();
                        if (pExplo001) {
                            pExplo001->locateAs((GgafDx9GeometricActor*)prm_pOtherActor);
                            pExplo001->activate();
                        }
                    } else {
                        //n`GtFNgin`^\);
                    }
                    if (MyStgUtil::calcEnemyStatus(_pStatus, getKind(), pOther->_pStatus, pOther->getKind()) <= 0) {
                        //GtFNg
                
                        EffectExplosion001* pExplo001_2 = (EffectExplosion001*)P_COMMON_SCENE->_pDP_EffectExplosion001->employ();
                        _pSeTransmitter->play3D(1);
                        if (pExplo001_2) {
                            pExplo001_2->locateAs((GgafDx9GeometricActor*)prm_pOtherActor);
                            pExplo001_2->activate();
                        }
                        sayonara();
                    }
                }
                
                void EnemyMetis::onInactive() {
                    sayonara();
                }
         200 -> EnemyMetis::~EnemyMetis() {
                }


Top 10 Lines:

     Line      Count

      101        200
        8         99

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      299   Total number of line executions
    99.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/enemy/Pallas/EnemyPallas.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
          84 -> EnemyPallas::EnemyPallas(const char* prm_name) : DefaultMeshSetActor(prm_name, "Pallas") {
                    _class_name = "EnemyPallas";
                    MyStgUtil::resetEnemyPallasStatus(_pStatus);
                    _iMovePatternNo = 0;
                    _pSplineProgram = NULL;
                    _pDispatcher_Shot = NULL;
                    _pDispatcher_ShotEffect = NULL;
                    _pSeTransmitter->useSe(1);
                    _pSeTransmitter->set(0, "bomb1", GgafRepeatSeq::nextVal("CH_bomb1"));     //
                    useProgress(10);
                }
                
                void EnemyPallas::onCreateModel() {
                }
                
                void EnemyPallas::initialize() {
                    setHitAble(true);
                    _pKuroko->setFaceAngVelo(AXIS_Z, -7000);
                    _pKuroko->relateRzRyFaceAngToMvAng(true);
                    _pCollisionChecker->makeCollision(1);
                    _pCollisionChecker->setColliAAB_Cube(0, 40000);
                }
                
                void EnemyPallas::onActive() {
                    if (_pSplineProgram == NULL) {
                        throwGgafCriticalException("EnemyPallasXvCK{config");
                    }
                
                    MyStgUtil::resetEnemyPallasStatus(_pStatus);
                
                    _iMovePatternNo = 0; //sp^[Zbg
                    _pPrg->change(1);
                }
                
                void EnemyPallas::processBehavior() {
                    //ZN|Cg
                    _pStatus->mul(STAT_AddRankPoint, _pStatus->getDouble(STAT_AddRankPoint_Reduction));
                
                    //yp^[1FXvCz
                    if (_pPrg->wasChangedTo(1)) {
                        _pSplineProgram->begin(0); //XvCJn(1:W)
                    }
                    if (_pPrg->get() == 1) {
                        //XvCI
                        if (_pSplineProgram->isExecuting()) {
                            //
                        } else {
                            _pPrg->changeNext(); //p^[
                        }
                    }
                
                
                    switch (_iMovePatternNo) {
                        case 0:  //yp^[OFXvCJnz
                            if (_pSplineProgram) {
                                _pSplineProgram->begin(0); //XvCJn(1:W)
                            }
                            _iMovePatternNo++; //sp^[
                            break;
                
                        case 1:  //yp^[PFXvCIz
                            if (_pSplineProgram) {
                                //XvCL
                                if (!(_pSplineProgram->isExecuting())) {
                                    _iMovePatternNo++; //XvCIsp^[
                                }
                            } else {
                                //XvC
                                _iMovePatternNo++; //sp^[
                            }
                            break;
                
                        case 2:  //yp^[QFVbg@]z
                            if (_pDispatcher_Shot) {
                                //Vbg
                                int way = 10+_RANK_*10; //VbgWAY
                                angle* paAngWay = NEW angle[way];
                                GgafDx9Util::getRadialAngle2D(0, way, paAngWay);
                                GgafDx9DrawableActor* pActor_Shot;
                                for (int i = 0; i < way; i++) {
                                    pActor_Shot = (GgafDx9DrawableActor*)_pDispatcher_Shot->employ();
                                    if (pActor_Shot) {
                                        pActor_Shot->locateAs(this);
                                        pActor_Shot->_pKuroko->setRzRyMvAng(paAngWay[i], ANGLE90);
                                        pActor_Shot->activate();
                                    }
                                }
                                DELETEARR_IMPOSSIBLE_NULL(paAngWay);
                                //VbgGtFNg
                                if (_pDispatcher_ShotEffect) {
                                    GgafDx9DrawableActor* pEffectActor_Shot = (GgafDx9DrawableActor*)_pDispatcher_ShotEffect->employ();
                                    if (pEffectActor_Shot) {
                                        pEffectActor_Shot->locateAs(this);
                                        pEffectActor_Shot->activate();
                                    }
                                }
                            }
                //            //@]
                            _pKuroko->orderTagettingMvAngSequence(P_MYSHIP->_X, _Y, P_MYSHIP->_Z,
                                                                2000, 0,
                                                                TURN_CLOSE_TO);
                            _iMovePatternNo++; //sp^[
                            break;
                
                        case 3:  //ysp^[Rz
                
                            break;
                        default:
                            break;
                    }
                
                
                    if (_pSplineProgram) {
                        _pSplineProgram->behave(); //XvCU
                    }
                    _pKuroko->behave();
                    //_pSeTransmitter->behave();
                }
                
                void EnemyPallas::processJudgement() {
                    if (isOutOfUniverse()) {
                        sayonara();
                    }
                }
                
                void EnemyPallas::onHit(GgafActor* prm_pOtherActor) {
                    //_TRACE_("EnemyPallas::onHit!!! this="<<getName()<<"("<<_pStatus->get(STAT_DEFAULT_ACTOR_KIND)<<")");
                    //_TRACE_("EnemyPallas::onHit!!! prm_pOtherActor="<<prm_pOtherActor->getName()<<"("<<prm_pOtherActor->_pStatus->get(STAT_DEFAULT_ACTOR_KIND)<<")");
                    GgafDx9GeometricActor* pOther = (GgafDx9GeometricActor*)prm_pOtherActor;
                
                    if (MyStgUtil::calcEnemyStatus(_pStatus, getKind(), pOther->_pStatus, pOther->getKind()) <= 0) {
                        EffectExplosion001* pExplo001 = (EffectExplosion001*)P_COMMON_SCENE->_pDP_EffectExplosion001->employ();
                        _pSeTransmitter->play3D(0);
                        if (pExplo001) {
                            pExplo001->activate();
                            pExplo001->locateAs(this);
                            pExplo001->_pKuroko->takeoverMvFrom(_pKuroko);
                        }
                
                        //@AtH[VA
                        //tH[[Vg`B
                        if ((pOther->getKind() & KIND_MY) && (getParent()->_obj_class & Obj_GgafDx9FormationActor)) {
                            ((GgafDx9FormationActor*)getParent())->wasDestroyedFollower(this);
                        }
                        setHitAble(false); //At[~qbgidvj
                        sayonara();
                    }
                }
                
                void EnemyPallas::onInactive() {
                    sayonara();
                }
                
         168 -> EnemyPallas::~EnemyPallas() {
                    DELETE_POSSIBLE_NULL(_pSplineProgram);
                }


Top 10 Lines:

     Line      Count

      161        168
        8         84

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      252   Total number of line executions
    84.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/enemy/Pallas/FormationPallas001.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           7 -> FormationPallas001::FormationPallas001(const char* prm_name) : GgafDx9FormationActor(prm_name, 30*60) {
                    _class_name = "FormationPallas001";
                    _num_Pallas     = 12+_RANK_*8;    //
                    _frame_interval = 10-_RANK_*5;  //pXu(frame)
                    _mv_velo        = 10000+_RANK_*10000; //x
                    //pX
                    _pSplineCon     = (SplineConnection*)(P_GOD->_pSplineManager->getConnection("Pallas01")); //XvC`
                    _pDispatcherCon = NULL;
                    _papPallas = NEW EnemyPallas*[_num_Pallas];
                    for (int i = 0; i < _num_Pallas; i++) {
                        _papPallas[i] = NEW EnemyPallas("Pallas01");
                        //XvCvO
                        _papPallas[i]->config(_pSplineCon->refer()->makeSplineProgram(_papPallas[i]), NULL, NULL);
                        //_papPallas[i]->setDispatcher_Shot(_pDispatcherCon->refer()); //e
                        _papPallas[i]->inactivateImmediately();
                        addSubLast(_papPallas[i]);
                    }
                }
                void FormationPallas001::initialize() {
                }
                
                void FormationPallas001::onActive() {
                    GgafMainActor* pActor = getSubFirst();
                    EnemyPallas* pPallas = NULL;
                    int t = 0;
                    do {
                        pPallas = (EnemyPallas*)pActor;
                        pPallas->locate(_pSplineCon->refer()->_pSp->_X_basepoint[0], 0, 0);
                        pPallas->_pKuroko->setMvVelo(_mv_velo);
                        pPallas->activateDelay(t*_frame_interval + 1);//_frame_intervaluActiveB
                        t++;
                        pActor = pActor->getNext();
                    } while (!pActor->isFirst());
                
                
                }
                void FormationPallas001::wasDestroyedFormation(GgafDx9GeometricActor* prm_pActorLast) {
                    //
                    EffectTurbo002* pTurbo002 = (EffectTurbo002*)P_COMMON_SCENE->_pDispatcher_EffectTurbo002->employForce();
                    if (pTurbo002) {
                        pTurbo002->locateAs(prm_pActorLast);
                        pTurbo002->activate();
                    }
                }
                
                void FormationPallas001::processBehavior() {
                }
                
           7 -> FormationPallas001::~FormationPallas001() {
                    _pSplineCon->close();
                    if (_pDispatcherCon) {
                        _pDispatcherCon->close();
                    }
                    DELETEARR_IMPOSSIBLE_NULL(_papPallas);
                }


Top 10 Lines:

     Line      Count

        8          7
       56          7

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       14   Total number of line executions
     4.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/enemy/Pallas/FormationPallas001a.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           2 -> FormationPallas001a::FormationPallas001a(const char* prm_name) : FormationPallas001(prm_name) {
                    _class_name = "FormationPallas001a";
                }
                void FormationPallas001a::onActive() {
                    for (int i = 0; i < _num_Pallas; i++) {
                        _papPallas[i]->_pSplineProgram->adjustAxisRate(1.0, 1.0, 1.0);
                        _papPallas[i]->locate(_pSplineCon->refer()->_pSp->_X_basepoint[0] ,
                                                   0,
                                                   0);
                        _papPallas[i]->_pKuroko->setMvVelo(_mv_velo);
                        _papPallas[i]->activateDelay(i*_frame_interval + 1);//_frame_intervaluActiveB
                    }
                }
                
           4 -> FormationPallas001a::~FormationPallas001a() {
                }


Top 10 Lines:

     Line      Count

       22          4
        8          2

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        6   Total number of line executions
     2.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/enemy/Pallas/FormationPallas001b.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           2 -> FormationPallas001b::FormationPallas001b(const char* prm_name) : FormationPallas001(prm_name) {
                    _class_name = "FormationPallas001b";
                }
                void FormationPallas001b::onActive() {
                    for (int i = 0; i < _num_Pallas; i++) {
                        _papPallas[i]->_pSplineProgram->adjustAxisRate(1.0, -1.0, 1.0);
                        _papPallas[i]->locate(_pSplineCon->refer()->_pSp->_X_basepoint[0] ,
                                                   0,
                                                   0);
                        _papPallas[i]->_pKuroko->setMvVelo(_mv_velo);
                        _papPallas[i]->activateDelay(i*_frame_interval + 1);//_frame_intervaluActiveB
                    }
                }
                
           4 -> FormationPallas001b::~FormationPallas001b() {
                }


Top 10 Lines:

     Line      Count

       22          4
        8          2

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        6   Total number of line executions
     2.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/enemy/Pallas/FormationPallas001c.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> FormationPallas001c::FormationPallas001c(const char* prm_name) : FormationPallas001(prm_name) {
                    _class_name = "FormationPallas001c";
                }
                void FormationPallas001c::onActive() {
                    for (int i = 0; i < _num_Pallas; i++) {
                        _papPallas[i]->_pSplineProgram->adjustAxisRate(1.0, 1.0, -1.0);
                        _papPallas[i]->locate(_pSplineCon->refer()->_pSp->_X_basepoint[0] ,
                                                   0,
                                                   0);
                        _papPallas[i]->_pKuroko->setMvVelo(_mv_velo);
                        _papPallas[i]->activateDelay(i*_frame_interval + 1);//_frame_intervaluActiveB
                    }
                }
                
           2 -> FormationPallas001c::~FormationPallas001c() {
                }


Top 10 Lines:

     Line      Count

       22          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/enemy/Pallas/FormationPallas001d.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           2 -> FormationPallas001d::FormationPallas001d(const char* prm_name) : FormationPallas001(prm_name) {
                    _class_name = "FormationPallas001d";
                }
                void FormationPallas001d::onActive() {
                    for (int i = 0; i < _num_Pallas; i++) {
                        _papPallas[i]->_pSplineProgram->adjustAxisRate(1.0, -1.0, -1.0);
                        _papPallas[i]->locate(_pSplineCon->refer()->_pSp->_X_basepoint[0] ,
                                                   0,
                                                   0);
                        _papPallas[i]->_pKuroko->setMvVelo(_mv_velo);
                        _papPallas[i]->activateDelay(i*_frame_interval + 1);//_frame_intervaluActiveB
                    }
                }
                
           4 -> FormationPallas001d::~FormationPallas001d() {
                }


Top 10 Lines:

     Line      Count

       22          4
        8          2

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        6   Total number of line executions
     2.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/item/Item.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
         500 -> Item::Item(const char* prm_name, const char* prm_model)
                               : DefaultMeshSetActor(prm_name, prm_model) {
                    _class_name = "Item";
                }
                
                void Item::initialize() {
                }
                
                void Item::onReset() {
                }
                
                void Item::onActive() {
                }
                
                void Item::processBehavior() {
                }
                
                void Item::processJudgement() {
                }
                
                void Item::onInactive() {
                }
                
         500 -> Item::~Item() {
                }


Top 10 Lines:

     Line      Count

        8        500
       31        500

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

     1000   Total number of line executions
   333.33   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/item/MagicPointItem001.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
         500 -> MagicPointItem001::MagicPointItem001(const char* prm_name)
                               : Item(prm_name, "EffectMagic001") {
                    _class_name = "MagicPointItem001";
                    MyStgUtil::resetMagicPointItem001Status(_pStatus);
                    changeEffectTechnique("DestBlendOne"); //ZTechniquew
                    setZEnable(true);        //Zobt@lL
                    setZWriteEnable(false);  //Zobt@
                    setAlpha(0.9);
                
                    _pKuroko->setFaceAngVelo(AXIS_X, 3*1000);
                    _pKuroko->setFaceAngVelo(AXIS_Y, 5*1000);
                    _pKuroko->setFaceAngVelo(AXIS_Z, 7*1000);
                    _pKuroko->relateRzRyFaceAngToMvAng(true);
                    _kDX = _kDY = _kDZ = 0;
                }
                
                void MagicPointItem001::initialize() {
                    setHitAble(true, false); //O
                    _pCollisionChecker->makeCollision(1);
                    _pCollisionChecker->setColliAAB_Cube(0, 300000);
                    _pSeTransmitter->useSe(1);
                    _pSeTransmitter->set(0, "decide1");
                    useProgress();
                }
                
                void MagicPointItem001::onReset() {
                
                    MyStgUtil::resetMagicPointItem001Status(_pStatus);
                    setHitAble(true, false);
                    _pKuroko->setMvVelo(2000);
                    _pKuroko->setMvAcce(100);
                    _pKuroko->forceMvVeloRange(0, 20000);
                    _pKuroko->forceVxyzMvVeloRange(-20000, 20000);
                    _pKuroko->setZeroVxyzMvVelo();
                    _pKuroko->setZeroVxyzMvAcce();
                    _pKuroko->_gravitation_mv_seq_flg = false;
                    _pPrg->set(ITEM_PROG_DRIFT);
                    _SX = _SY = _SZ = 1000;
                }
                void MagicPointItem001::onActive() {
                    reset();
                    MyShip* pMyShip = P_MYSHIP;
                    CmRandomNumberGenerator* pRndGen = CmRandomNumberGenerator::getInstance();
                    //U`P
                    int scattered_renge    = _pCollisionChecker->_pCollisionArea->_papColliPart[0]->_dx; //
                    //n_A@U`uiscattered_distance > (scattered_renge/2) )
                    int scattered_distance = scattered_renge/2 + 800000;
                    //]Ascattered_distance A@SB
                
                    float vX, vY, vZ;
                    GgafDx9Util::getNormalizeVector(
                            pMyShip->_X - _X,
                            pMyShip->_Y - _Y,
                            pMyShip->_Z - _Z,
                            vX, vY, vZ);
                
                    _pKuroko->setMvAng(
                            (int)(_X + (vX * scattered_distance) + (((int)pRndGen->genrand_int32() % scattered_renge) - (scattered_renge/2))),
                            (int)(_Y + (vY * scattered_distance) + (((int)pRndGen->genrand_int32() % scattered_renge) - (scattered_renge/2))),
                            (int)(_Z + (vZ * scattered_distance) + (((int)pRndGen->genrand_int32() % scattered_renge) - (scattered_renge/2)))
                    );
                //    _TRACE_("---");
                //    _TRACE_("(X,Y,Z)=("<<_X<<","<<_Y<<","<<_Z<<")");
                //    _TRACE_("(pMyShip->_X,pMyShip->Y,pMyShip->Z)=("<<pMyShip->_X<<","<<pMyShip->_Y<<","<<pMyShip->_Z<<")");
                //    _TRACE_("(vX,vY,vZ)=("<<vX<<","<<vY<<","<<vZ<<")");
                //    _TRACE_("scattered_renge="<<scattered_renge<<"");
                //    _TRACE_("scattered_distance="<<scattered_distance<<"");
                //    _TRACE_("tX="<<(int)(_X + (vX * scattered_distance) + (((int)pRndGen->genrand_int32() % scattered_renge) - (scattered_renge/2))));
                //    _TRACE_("tY="<<(int)(_Y + (vY * scattered_distance) + (((int)pRndGen->genrand_int32() % scattered_renge) - (scattered_renge/2))));
                //    _TRACE_("tZ="<<(int)(_Z + (vZ * scattered_distance) + (((int)pRndGen->genrand_int32() % scattered_renge) - (scattered_renge/2))));
                
                }
                
                void MagicPointItem001::processBehavior() {
                    //TODO:
                
                    //
                    if (_pPrg->get() == ITEM_PROG_DRIFT) {
                        //onHit() 
                    }
                
                    //@qbgA@
                    if (_pPrg->get() == ITEM_PROG_ATTACH) {
                        MyShip* pMyShip = P_MYSHIP;
                        if (_pPrg->isJustChanged()) {
                            _pKuroko->setVxMvVelo(_pKuroko->_vX*_pKuroko->_veloMv);
                            _pKuroko->setVyMvVelo(_pKuroko->_vY*_pKuroko->_veloMv);
                            _pKuroko->setVzMvVelo(_pKuroko->_vZ*_pKuroko->_veloMv);
                            _pKuroko->setMvVelo(0);
                            _pKuroko->setMvAcce(0);
                            _pKuroko->orderGravitationVxyzMvSequence(pMyShip, 20000, 1000, 50000);
                            _pKuroko->setMvVelo(5000);
                        }
                    }
                
                    //@zAz
                    if (_pPrg->get() == ITEM_PROG_ABSORB) {
                        MyShip* pMyShip = P_MYSHIP;
                        if (_pPrg->isJustChanged()) {
                            _pKuroko->setZeroVxyzMvVelo();
                            _pKuroko->setZeroVxyzMvAcce();
                            _pKuroko->stopGravitationVxyzMvSequence();
                        }
                        _X = pMyShip->_X + _kDX;
                        _Y = pMyShip->_Y + _kDY;
                        _Z = pMyShip->_Z + _kDZ;
                        _SX -= 100;
                        _SY -= 100;
                        _SZ -= 100;
                        if (_SX < 5) {
                            _pSeTransmitter->playImmediately(0);
                            _pPrg->change(ITEM_PROG_NOTIONG);
                            sayonara(); //I
                        }
                        P_MYSHIP_SCENE->_pEnagyBar->_amount.inc(1);
                    }
                    _pKuroko->behave();
                }
                
                void MagicPointItem001::processJudgement() {
                    if (isOutOfUniverse()) {
                        sayonara();
                    }
                    //
                    if (_pPrg->get() == ITEM_PROG_DRIFT) {
                        //onHit() 
                    }
                
                    //@qbgA@
                    if (_pPrg->get() == ITEM_PROG_ATTACH) {
                        MyShip* pMyShip = P_MYSHIP;
                        if (abs(pMyShip->_X - _X) < 20000 &&
                            abs(pMyShip->_Y - _Y) < 20000 &&
                            abs(pMyShip->_Z - _Z) < 20000 ) {
                            //@z
                            _kDX = pMyShip->_X - _X;
                            _kDY = pMyShip->_Y - _Y;
                            _kDZ = pMyShip->_Z - _Z;
                            _pPrg->change(ITEM_PROG_ABSORB);
                        }
                    }
                
                    //@zAz
                    if (_pPrg->get() == ITEM_PROG_ABSORB) {
                    }
                }
                
                void MagicPointItem001::onInactive() {
                }
                
                void MagicPointItem001::onHit(GgafActor* prm_pOtherActor) {
                    GgafDx9GeometricActor* pOther = (GgafDx9GeometricActor*)prm_pOtherActor;
                    //qbgGtFNg
                
                
                    if (_pPrg->get() == ITEM_PROG_DRIFT && pOther->getKind() & KIND_MY_BODY)  {
                        setHitAble(false);
                        _pPrg->change(ITEM_PROG_ATTACH);
                    }
                
                }
                
        1000 -> MagicPointItem001::~MagicPointItem001() {
                }


Top 10 Lines:

     Line      Count

      170       1000
        8        500

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

     1500   Total number of line executions
   500.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/label/LabelGecchi16Font.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
          22 -> LabelGecchi16Font::LabelGecchi16Font(const char* prm_name) :
                        StringBoardActor(prm_name, "Gecchi_16Font")
                {
                    _class_name = "LabelGecchi16Font";
                    _aWidthPx['!'] = 10;
                    _aWidthPx['"'] = 10;
                    _aWidthPx['#'] = 14;
                    _aWidthPx['$'] = 14;
                    _aWidthPx['%'] = 14;
                    _aWidthPx['&'] = 14;
                    _aWidthPx['\''] = 10;
                    _aWidthPx['('] = 10;
                    _aWidthPx[')'] = 10;
                    _aWidthPx['*'] = 12;
                    _aWidthPx['+'] = 10;
                    _aWidthPx[','] = 8;
                    _aWidthPx['-'] = 10;
                    _aWidthPx['.'] = 8;
                    _aWidthPx['/'] = 14;
                    _aWidthPx['0'] = 14;
                    _aWidthPx['1'] = 14;
                    _aWidthPx['2'] = 14;
                    _aWidthPx['3'] = 14;
                    _aWidthPx['4'] = 14;
                    _aWidthPx['5'] = 14;
                    _aWidthPx['6'] = 14;
                    _aWidthPx['7'] = 14;
                    _aWidthPx['8'] = 14;
                    _aWidthPx['9'] = 14;
                    _aWidthPx[':'] = 8;
                    _aWidthPx[';'] = 8;
                    _aWidthPx['<'] = 14;
                    _aWidthPx['='] = 14;
                    _aWidthPx['>'] = 14;
                    _aWidthPx['?'] = 14;
                    _aWidthPx[' '] = 8;
                    _aWidthPx['A'] = 15;
                    _aWidthPx['B'] = 14;
                    _aWidthPx['C'] = 15;
                    _aWidthPx['D'] = 15;
                    _aWidthPx['E'] = 14;
                    _aWidthPx['F'] = 14;
                    _aWidthPx['G'] = 14;
                    _aWidthPx['H'] = 14;
                    _aWidthPx['I'] = 10;
                    _aWidthPx['J'] = 14;
                    _aWidthPx['K'] = 14;
                    _aWidthPx['L'] = 15;
                    _aWidthPx['M'] = 15;
                    _aWidthPx['N'] = 14;
                    _aWidthPx['O'] = 14;
                    _aWidthPx['P'] = 14;
                    _aWidthPx['Q'] = 14;
                    _aWidthPx['R'] = 14;
                    _aWidthPx['S'] = 14;
                    _aWidthPx['T'] = 13;
                    _aWidthPx['U'] = 14;
                    _aWidthPx['V'] = 14;
                    _aWidthPx['W'] = 15;
                    _aWidthPx['X'] = 14;
                    _aWidthPx['Y'] = 14;
                    _aWidthPx['Z'] = 14;
                    _aWidthPx['['] = 10;
                    _aWidthPx['\\'] = 12;
                    _aWidthPx[']'] = 10;
                    _aWidthPx['^'] = 12;
                    _aWidthPx['_'] = 16;
                }
                
                void LabelGecchi16Font::onCreateModel() {
                }
                
                void LabelGecchi16Font::initialize() {
                }
                
                void LabelGecchi16Font::processBehavior() {
                }
                
          43 -> LabelGecchi16Font::~LabelGecchi16Font() {
                }
                


Top 10 Lines:

     Line      Count

       86         43
        8         22

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       65   Total number of line executions
    21.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/label/LabelGecchi8Font.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           3 -> LabelGecchi8Font::LabelGecchi8Font(const char* prm_name) :
                        StringBoardActor(prm_name, "Gecchi_8Font")
                {
                    _class_name = "LabelGecchi8Font";
                }
                
                void LabelGecchi8Font::processBehavior() {
                }
                
           6 -> LabelGecchi8Font::~LabelGecchi8Font() {
                }
                


Top 10 Lines:

     Line      Count

       17          6
        8          3

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        9   Total number of line executions
     3.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/my/EffectMyShipExplosion.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> EffectMyShipExplosion::EffectMyShipExplosion(const char* prm_name) : DefaultSpriteSetActor(prm_name, "EffectExplosion001") {
                    _class_name = "EffectMyShipExplosion";
                    changeEffectTechnique("DestBlendOne"); //ZTechniquew
                    defineRotMvWorldMatrix(GgafDx9Util::setWorldMatrix_RzBxyzMv);
                }
                
                void EffectMyShipExplosion::initialize() {
                    _pUvFlipper->forcePtnNoRange(0, 15);
                    setHitAble(false);
                }
                
                void EffectMyShipExplosion::onActive() {
                    _pUvFlipper->setPtnNoToTop();
                    _pUvFlipper->setFlipMethod(FLIP_ORDER_NOLOOP, 20);
                    locateAs(P_MYSHIP);
                    _fAlpha = 0.99;
                    _pScaler->setScale(8000);
                    _pKuroko->setFaceAngVelo(AXIS_Z, 2000);
                }
                
                void EffectMyShipExplosion::processBehavior() {
                    _fAlpha -= 0.01;
                    locateAs(P_MYSHIP);
                    _pUvFlipper->behave();
                    _pKuroko->behave();
                    _pScaler->behave();
                }
                
                void EffectMyShipExplosion::processJudgement() {
                    if (_pUvFlipper->_uvflip_method == NOT_ANIMATED) {
                        inactivate();
                    }
                }
                
           2 -> EffectMyShipExplosion::~EffectMyShipExplosion() {
                }


Top 10 Lines:

     Line      Count

       42          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/my/MyOptionController.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                int MyOptionController::_max_option_num = 8;
                
                //MyOptionController::MyOptionController(const char* prm_name) :
                //    DefaultMeshActor(prm_name, "Gizmo") {
                
           1 -> MyOptionController::MyOptionController(const char* prm_name) :
                  GgafDx9GeometricActor(prm_name,
                                            NULL) {
                    _is_handle_move_mode = false;
                    _is_free_from_myship_mode = false;
                    _return_to_default_position_seq = false;
                    _angVelo_Turn = 3000;
                    _veloOptionsMv = 20000;
                
                    _now_option_num = 0;
                
                    _renge = 80000;
                    _pKuroko->forceVxMvVeloRange(-_renge, _renge);
                    _pKuroko->forceVyMvVeloRange(-_renge, _renge);
                    _pKuroko->forceVzMvVeloRange(-_renge, _renge);
                
                    _pKuroko->forceVxMvAcceRange(-_renge / 30, _renge / 30);
                    _pKuroko->forceVyMvAcceRange(-_renge / 30, _renge / 30);
                    _pKuroko->forceVzMvAcceRange(-_renge / 30, _renge / 30);
                
                    _papMyOption = NEW MyOption*[_max_option_num];
                    for (int i = 0; i < _max_option_num; i++) {
                        _papMyOption[i] = NULL;
                    }
                
                    _papMyOption[0] = NEW MyOption("MY_OPTION01", 0, this);
                    _papMyOption[0]->config(60000, ANGLE0, 0, 1000);
                    _papMyOption[0]->setMaterialColor(1.0, 1.0, 1.0);
                    _papMyOption[0]->setAlpha(0.7);
                    addSubGroup(_papMyOption[0]);
                
                    _papMyOption[1] = NEW MyOption("MY_OPTION02", 1, this);
                    _papMyOption[1]->config(60000, ANGLE90, 0, 1000);
                    _papMyOption[1]->setMaterialColor(0.8, 1.0, 1.0);
                    _papMyOption[1]->setAlpha(0.7);
                    addSubGroup(_papMyOption[1]);
                
                    _papMyOption[2] = NEW MyOption("MY_OPTION03", 2, this);
                    _papMyOption[2]->config(60000, ANGLE180, 0, 1000);
                    _papMyOption[2]->setMaterialColor(1.0, 0.8, 0.8);
                    _papMyOption[2]->setAlpha(0.7);
                    addSubGroup(_papMyOption[2]);
                
                    _papMyOption[3] = NEW MyOption("MY_OPTION04", 3, this);
                    _papMyOption[3]->config(60000, ANGLE270, 0, 1000);
                    _papMyOption[3]->setMaterialColor(0.8, 1.0, 0.8);
                    _papMyOption[3]->setAlpha(0.7);
                    addSubGroup(_papMyOption[3]);
                
                    _papMyOption[4] = NEW MyOption("MY_OPTION05", 4, this);
                    _papMyOption[4]->config(120000, ANGLE0, 0, -1500);
                    _papMyOption[4]->setMaterialColor(0.8, 0.8, 1.0);
                    _papMyOption[4]->setAlpha(0.7);
                    addSubGroup(_papMyOption[4]);
                
                    _papMyOption[5] = NEW MyOption("MY_OPTION06", 5, this);
                    _papMyOption[5]->config(120000, ANGLE90, 0, -1500);
                    _papMyOption[5]->setMaterialColor(0.8, 1.0, 0.8);
                    _papMyOption[5]->setAlpha(0.7);
                    addSubGroup(_papMyOption[5]);
                
                    _papMyOption[6] = NEW MyOption("MY_OPTION07", 6, this);
                    _papMyOption[6]->config(120000, ANGLE180, 0, -1500);
                    _papMyOption[6]->setMaterialColor(1.0, 0.8, 0);
                    _papMyOption[6]->setAlpha(0.7);
                    addSubGroup(_papMyOption[6]);
                
                    _papMyOption[7] = NEW MyOption("MY_OPTION08", 7, this);
                    _papMyOption[7]->config(120000, ANGLE270, 0, -1500);
                    _papMyOption[7]->setMaterialColor(1.0, 1.0, 1.0);
                    _papMyOption[7]->setAlpha(0.7);
                    addSubGroup(_papMyOption[7]);
                
                    for (int i = 0; i < _max_option_num; i++) {
                        _papMyOption[i]->inactivateImmediately();
                    }
                
                
                    for (int i = 0; i < _now_option_num; i++) {
                        _papMyOption[i]->activate();
                    }
                
                    //MY
                    _pGizmo = NEW MyOptionControllerGizmo("MyPGizmo");
                    addSubGroup(_pGizmo);
                    //xNg
                    _pDirectionVector = NEW MyOptionControllerDirectionVector("MyPDirectionVector");
                    addSubGroup(_pDirectionVector);
                
                    //g[Xp
                    _pRing_GeoHistory = NEW GgafLinkedListRing<GgafDx9GeoElem>();
                    for (DWORD i = 0; i < 100; i++) {
                        _pRing_GeoHistory->addLast(NEW GgafDx9GeoElem(this));
                    }
                
                }
                
                
                void MyOptionController::initialize() {
                }
                
                
                void MyOptionController::onReset() {
                    _pKuroko->setMvVelo(0);
                    _pKuroko->forceRyMvAngVeloRange(-1*_angVelo_Turn, _angVelo_Turn);
                    _pKuroko->forceRzMvAngVeloRange(-1*_angVelo_Turn, _angVelo_Turn);
                    _pKuroko->setRzRyMvAng(0,0);
                    _way_myship_prev = P_MYSHIP->_way;
                    _pKuroko->relateRzRyFaceAngToMvAng(true);
                    _pKuroko->behave();
                }
                
                void MyOptionController::onActive() {
                    reset();
                }
                
                void MyOptionController::processBehavior() {
                //    if (GgafDx9Input::isBeingPressedKey(DIK_I)) {
                //        dump();
                //    }
                
                
                    if (VB_PLAY->isDoublePushedDown(VB_OPTION,8,8)) {
                        //
                        _pKuroko->orderTagettingMvAngSequence(
                                        0,
                                        0,
                                        20000, 0,
                                        TURN_CLOSE_TO,
                                        false
                                 );
                        _is_free_from_myship_mode = false;
                        _is_handle_move_mode = false;
                        _return_to_default_position_seq = true;
                        adjustDefaltAngPosition(60);
                        for (int i = 0; i < _now_option_num; i++) {
                            //IvVauw
                            _papMyOption[i]->_return_to_base_radiusPosition_seq = true;
                            _papMyOption[i]->_return_to_base_angExpanse_seq= true;
                        }
                
                
                    } else if (VB_PLAY->isBeingPressed(VB_OPTION) && !VB_PLAY->isBeingPressed(VB_TURBO)) {
                        //IvV
                        if (VB_PLAY->isBeingPressed(VB_UP)) {
                            _pKuroko->addRzMvAng(_angVelo_Turn);
                        }
                        if (VB_PLAY->isBeingPressed(VB_DOWN)) {
                            _pKuroko->addRzMvAng(-_angVelo_Turn);
                        }
                        if (VB_PLAY->isBeingPressed(VB_RIGHT)) {
                            _pKuroko->addRyMvAng(_angVelo_Turn);
                        }
                        if (VB_PLAY->isBeingPressed(VB_LEFT)) {
                            _pKuroko->addRyMvAng(-_angVelo_Turn);
                        }
                
                    }
                
                    if (VB_PLAY->isPushedDown(VB_OPTION)) {
                        if (VB_PLAY->isRoundPushDown(VB_OPTION)) {
                        //if (VB_PLAY->isPushedDown(VB_OPTION) && GgafDx9Input::isBeingPressedKey(DIK_S)) {
                            if (_papMyOption[0]) {
                                _is_free_from_myship_mode = true;
                                _is_handle_move_mode = true;
                                _pKuroko->setVxMvAcce(0);
                                _pKuroko->setVyMvAcce(0);
                                _pKuroko->setVzMvAcce(0);
                                _pKuroko->setVxMvVelo(0);
                                _pKuroko->setVyMvVelo(0);
                                _pKuroko->setVzMvVelo(0);
                
                            }
                        }
                    }
                
                    if (_is_free_from_myship_mode) {
                        if (VB_PLAY->isBeingPressed(VB_OPTION) && _is_handle_move_mode) {
                            //IvVLpAIvVxAaxxNgB
                            //IvVxB
                            _pKuroko->setMvVelo(GgafDx9Util::COS[_papMyOption[0]->_angExpanse/ ANGLE_RATE] * _veloOptionsMv);
                            //axMyOptionNXsB
                        } else {
                            _is_handle_move_mode = false;
                            _pKuroko->setMvVelo(0);
                        }
                    } else {
                        GgafDx9GeoElem* pGeoMyShip = P_MYSHIP->_pRing_GeoHistory->getPrev(4); //@]
                        if (_return_to_default_position_seq) {
                            //u
                            int dx = pGeoMyShip->_X - (_X + _pKuroko->_veloVxMv*6);
                            int dy = pGeoMyShip->_Y - (_Y + _pKuroko->_veloVyMv*6);
                            int dz = pGeoMyShip->_Z - (_Z + _pKuroko->_veloVzMv*6);
                            _pKuroko->setVxMvAcce(dx);
                            _pKuroko->setVyMvAcce(dy);
                            _pKuroko->setVzMvAcce(dz);
                            if (abs(_X - pGeoMyShip->_X) < 10000 &&
                                abs(_Y - pGeoMyShip->_Y) < 10000 &&
                                abs(_Z - pGeoMyShip->_Z) < 10000 &&
                                abs(_pKuroko->_veloVxMv) < 20000 &&
                                abs(_pKuroko->_veloVyMv) < 20000 &&
                                abs(_pKuroko->_veloVzMv) < 20000    ) {
                
                                _TRACE_("I");
                                _pKuroko->setVxMvVelo(0);
                                _pKuroko->setVyMvVelo(0);
                                _pKuroko->setVzMvVelo(0);
                                _pKuroko->setVxMvAcce(0);
                                _pKuroko->setVyMvAcce(0);
                                _pKuroko->setVzMvAcce(0);
                                locateAs(pGeoMyShip);
                                _return_to_default_position_seq = false;
                            }
                
                        } else {
                            locateAs(pGeoMyShip);
                        }
                    }
                
                
                    //MY
                    _pDirectionVector->locateAs(this);
                    _pDirectionVector->_pKuroko->setRzRyMvAng(_pKuroko->_angRzMv, _pKuroko->_angRyMv);
                
                    _pKuroko->behave();
                    _pRing_GeoHistory->next()->set(this);
                }
                
                void MyOptionController::setNumOption(int prm_num) {
                    _now_option_num = prm_num;
                    for (int i = 0; i < _max_option_num; i++) {
                        if (i >= _now_option_num) {
                            _papMyOption[i]->inactivate();
                        }
                        if (i < _now_option_num) {
                            _papMyOption[i]->activate();
                        }
                    }
                }
                
                void MyOptionController::adjustDefaltAngPosition(frame prm_spent_frame) {
                    if (_now_option_num <= 4) {
                        for (int i = 0; i < _now_option_num; i++) {
                            _papMyOption[i]->adjustAngPosition((ANGLE360/_now_option_num)*i,prm_spent_frame);
                        }
                    } else if (_now_option_num > 4) {
                        for (int i = 0; i < 4; i++) {
                            _papMyOption[i]->adjustAngPosition((ANGLE360/4)*i, prm_spent_frame);
                        }
                        for (int i = 4; i < _now_option_num; i++) {
                            _papMyOption[i]->adjustAngPosition((ANGLE360/(_now_option_num-4))*(i-4), prm_spent_frame);
                        }
                    }
                }
           2 -> MyOptionController::~MyOptionController() {
                    DELETEARR_IMPOSSIBLE_NULL(_papMyOption);
                    DELETE_IMPOSSIBLE_NULL(_pRing_GeoHistory);
                }
                


Top 10 Lines:

     Line      Count

      266          2
       12          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/my/MyOptionControllerDirectionVector.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> MyOptionControllerDirectionVector::MyOptionControllerDirectionVector(const char* prm_name) : DefaultMeshActor(prm_name, "Nothing") {
                    _class_name = "MyOptionControllerDirectionVector";
                
                    _ptn_no = 0;
                }
                
                void MyOptionControllerDirectionVector::initialize() {
                    setAlpha(0.3);
                    setHitAble(false);
                    _pKuroko->relateRzRyFaceAngToMvAng(true);
                }
                
                void MyOptionControllerDirectionVector::onActive() {
                }
                
                void MyOptionControllerDirectionVector::processBehavior() {
                    _pKuroko->behave();
                }
                
                void MyOptionControllerDirectionVector::processJudgement() {
                }
                
                void MyOptionControllerDirectionVector::onInactive() {
                }
                
           2 -> MyOptionControllerDirectionVector::~MyOptionControllerDirectionVector() {
                }


Top 10 Lines:

     Line      Count

       33          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/my/MyOptionControllerGizmo.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> MyOptionControllerGizmo::MyOptionControllerGizmo(const char* prm_name) : DefaultMeshActor(prm_name, "Nothing") {
                    _class_name = "MyOptionControllerGizmo";
                
                    _ptn_no = 0;
                }
                
                void MyOptionControllerGizmo::initialize() {
                    setHitAble(false);
                    setAlpha(0.5);
                }
                
                void MyOptionControllerGizmo::onActive() {
                }
                
                void MyOptionControllerGizmo::processBehavior() {
                    _pKuroko->behave();
                }
                
                void MyOptionControllerGizmo::processJudgement() {
                }
                
                int MyOptionControllerGizmo::isOutOfView() {
                    //O
                    return 0;
                }
                
                bool MyOptionControllerGizmo::isOutOfUniverse() {
                    //Q[WO
                    return false;
                }
                
                void MyOptionControllerGizmo::drawHitArea() {
                    //ColliAABActor::get()->drawHitarea(_pCollisionChecker); ColliAAPrismActor::get()->drawHitarea(_pCollisionChecker); ColliSphereActor::get()->drawHitarea(_pCollisionChecker);
                }
                
           2 -> MyOptionControllerGizmo::~MyOptionControllerGizmo() {
                }


Top 10 Lines:

     Line      Count

       43          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/my/MyShip.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                int MyShip::wk_dist = 0;
                angle MyShip::wk_angRx = 0;
                
                #define S_OPTION 0
                int MyShip::_lim_top     =  0;
                int MyShip::_lim_bottom  =  0;
                int MyShip::_lim_front   =  0;
                int MyShip::_lim_behaind =  0;
                int MyShip::_lim_zleft   =  0;
                int MyShip::_lim_zright  =  0;
                
           1 -> MyShip::MyShip(const char* prm_name) : DefaultD3DXMeshActor(prm_name, "VicViper") {
                //MyShip::MyShip(const char* prm_name) : DefaultMeshActor(prm_name, "jiki") {
                //MyShip::MyShip(const char* prm_name) : CubeMapMeshActor(prm_name, "wakka") {
                //MyShip::MyShip(const char* prm_name) : DefaultD3DXAniMeshActor(prm_name, "AnimatedSkelton") {
                    _class_name = "MyShip";
                    MyStgUtil::resetMyShipStatus(_pStatus);
                    //changeEffectTechnique("DestBlendOne"); //ZTechniquew
                
                    GameGlobal::init();
                
                    //A
                    //FovXB
                    _lim_top     = GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT)*5*LEN_UNIT / 2;      //T
                    _lim_bottom  = -(GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT)*5*LEN_UNIT / 2);
                    _lim_front   = GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)*5*LEN_UNIT / 2 ;    //O5
                    _lim_behaind = -(GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)*2*LEN_UNIT / 2 ); //2
                    _lim_zleft   = GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)*5*LEN_UNIT / 2;       //OT
                    _lim_zright  = -(GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)*5*LEN_UNIT / 2);
                
                
                    /** Xs[hxXs[h */
                    _iMoveSpeed = 5000;
                    //CommonScenenew
                    _angRXVelo_BeginMZ = 1000; //OZJnX]pxx
                    _angRXAcce_MZ = 300; //OZX]pxpx
                    _angRXTopVelo_MZ = 5000; //OZX]pxpx
                    _angRXStop_MZ = 90000; //OZX]pW~px
                
                    //_angRXVelo_BeginMZT = 23000; //OTurboJnX]pxx
                    _angRXVelo_BeginMZT = 40000;
                
                    _iMvBtmVelo_MT = 0; //Turboxx
                    _iMvVelo_BeginMT = 40000; //TurboJnxx
                    _iMvAcce_MT = -200; //Turboxx
                
                //    _pMyOptionController = NEW MyOptionController("MY_OPTION_PARENT");
                //    addSubLast(_pMyOptionController);
                
                    _pDispatcher_MyShots001 = NEW GgafActorDispatcher("RotShot001");
                    MyShot001* pShot;
                    for (int i = 0; i < 25; i++) { //eXgbN
                        pShot = NEW MyShot001("MY_MyShot001");
                        pShot->inactivateImmediately();
                        _pDispatcher_MyShots001->addSubLast(pShot);
                    }
                    addSubGroup(_pDispatcher_MyShots001);
                
                    _pLaserChipDispatcher = NEW LaserChipDispatcher("MyRotLaser");
                    MyStraightLaserChip001* pChip;
                    for (int i = 0; i < 60; i++) { //[U[XgbN
                        stringstream name;
                        name <<  "MyStraightLaserChip001_" << i;
                        string name2 = name.str();
                        pChip = NEW MyStraightLaserChip001(name2.c_str());
                        pChip->setPositionSource(this); //u
                        pChip->inactivateImmediately();
                        _pLaserChipDispatcher->addSubLast(pChip);
                    }
                    addSubGroup(_pLaserChipDispatcher);
                
                
                    _pEffectTurbo001 = NEW EffectTurbo001("EffectTurbo001");
                    addSubGroup(_pEffectTurbo001);
                //    _pEffectTurbo002 = NEW EffectTurbo002("EffectTurbo002");
                //    addSubGroup(_pEffectTurbo002);
                
                
                
                
                    //g[Xp
                    _pRing_GeoHistory = NEW GgafLinkedListRing<GgafDx9GeoElem>();
                    for (UINT32 i = 0; i < 100; i++) {
                        _pRing_GeoHistory->addLast(NEW GgafDx9GeoElem(this));
                    }
                
                    _iMoveVelo = 0;
                
                    //     X   Y   Z
                    //    -----------
                    //    -1  -1  -1
                    //     0   0   0    S+13i
                    //    +1  +1  +1
                
                    //XCb`e[uzB
                    /////////////// X  Y  Z
                    paFuncMove[TN(-1,-1,-1)] = &MyShip::move_WAY_ZRIGHT_DOWN_BEHIND;   //TN(-1,-1,-1) =  WAY_ZRIGHT_DOWN_BEHIND  = 0
                    paFuncMove[TN(-1,-1, 0)] = &MyShip::move_WAY_DOWN_BEHIND;          //TN(-1,-1, 0) =  WAY_DOWN_BEHIND         = 1
                    paFuncMove[TN(-1,-1, 1)] = &MyShip::move_WAY_ZLEFT_DOWN_BEHIND;    //TN(-1,-1, 1) =  WAY_ZLEFT_DOWN_BEHIND   = 2
                    paFuncMove[TN(-1, 0,-1)] = &MyShip::move_WAY_ZRIGHT_BEHIND;        //TN(-1, 0,-1) =  WAY_ZRIGHT_BEHIND       = 3
                    paFuncMove[TN(-1, 0, 0)] = &MyShip::move_WAY_BEHIND;               //TN(-1, 0, 0) =  WAY_BEHIND              = 4
                    paFuncMove[TN(-1, 0, 1)] = &MyShip::move_WAY_ZLEFT_BEHIND;         //TN(-1, 0, 1) =  WAY_ZLEFT_BEHIND        = 5
                    paFuncMove[TN(-1, 1,-1)] = &MyShip::move_WAY_ZRIGHT_UP_BEHIND;     //TN(-1, 1,-1) =  WAY_ZRIGHT_UP_BEHIND    = 6
                    paFuncMove[TN(-1, 1, 0)] = &MyShip::move_WAY_UP_BEHIND;            //TN(-1, 1, 0) =  WAY_UP_BEHIND           = 7
                    paFuncMove[TN(-1, 1, 1)] = &MyShip::move_WAY_ZLEFT_UP_BEHIND;      //TN(-1, 1, 1) =  WAY_ZLEFT_UP_BEHIND     = 8
                    paFuncMove[TN( 0,-1,-1)] = &MyShip::move_WAY_ZRIGHT_DOWN;          //TN( 0,-1,-1) =  WAY_ZRIGHT_DOWN         = 9
                    paFuncMove[TN( 0,-1, 0)] = &MyShip::move_WAY_DOWN;                 //TN( 0,-1, 0) =  WAY_DOWN                = 10
                    paFuncMove[TN( 0,-1, 1)] = &MyShip::move_WAY_ZLEFT_DOWN;           //TN( 0,-1, 1) =  WAY_ZLEFT_DOWN          = 11
                    paFuncMove[TN( 0, 0,-1)] = &MyShip::move_WAY_ZRIGHT;               //TN( 0, 0,-1) =  WAY_ZRIGHT              = 12
                    paFuncMove[TN( 0, 0, 0)] = &MyShip::move_WAY_NONE;                 //TN( 0, 0, 0) =  WAY_NONE                = 13
                    paFuncMove[TN( 0, 0, 1)] = &MyShip::move_WAY_ZLEFT;                //TN( 0, 0, 1) =  WAY_ZLEFT               = 14
                    paFuncMove[TN( 0, 1,-1)] = &MyShip::move_WAY_ZRIGHT_UP;            //TN( 0, 1,-1) =  WAY_ZRIGHT_UP           = 15
                    paFuncMove[TN( 0, 1, 0)] = &MyShip::move_WAY_UP;                   //TN( 0, 1, 0) =  WAY_UP                  = 16
                    paFuncMove[TN( 0, 1, 1)] = &MyShip::move_WAY_ZLEFT_UP;             //TN( 0, 1, 1) =  WAY_ZLEFT_UP            = 17
                    paFuncMove[TN( 1,-1,-1)] = &MyShip::move_WAY_ZRIGHT_DOWN_FRONT;    //TN( 1,-1,-1) =  WAY_ZRIGHT_DOWN_FRONT   = 18
                    paFuncMove[TN( 1,-1, 0)] = &MyShip::move_WAY_DOWN_FRONT;           //TN( 1,-1, 0) =  WAY_DOWN_FRONT          = 19
                    paFuncMove[TN( 1,-1, 1)] = &MyShip::move_WAY_ZLEFT_DOWN_FRONT;     //TN( 1,-1, 1) =  WAY_ZLEFT_DOWN_FRONT    = 20
                    paFuncMove[TN( 1, 0,-1)] = &MyShip::move_WAY_ZRIGHT_FRONT;         //TN( 1, 0,-1) =  WAY_ZRIGHT_FRONT        = 21
                    paFuncMove[TN( 1, 0, 0)] = &MyShip::move_WAY_FRONT;                //TN( 1, 0, 0) =  WAY_FRONT               = 22
                    paFuncMove[TN( 1, 0, 1)] = &MyShip::move_WAY_ZLEFT_FRONT;          //TN( 1, 0, 1) =  WAY_ZLEFT_FRONT         = 23
                    paFuncMove[TN( 1, 1,-1)] = &MyShip::move_WAY_ZRIGHT_UP_FRONT;      //TN( 1, 1,-1) =  WAY_ZRIGHT_UP_FRONT     = 24
                    paFuncMove[TN( 1, 1, 0)] = &MyShip::move_WAY_UP_FRONT;             //TN( 1, 1, 0) =  WAY_UP_FRONT            = 25
                    paFuncMove[TN( 1, 1, 1)] = &MyShip::move_WAY_ZLEFT_UP_FRONT;       //TN( 1, 1, 1) =  WAY_ZLEFT_UP_FRONT      = 26
                
                
                    paFuncTurbo[TN(-1,-1,-1)] = &MyShip::turbo_WAY_ZRIGHT_DOWN_BEHIND;   //TN(-1,-1,-1) =  WAY_ZRIGHT_DOWN_BEHIND  = 0
                    paFuncTurbo[TN(-1,-1, 0)] = &MyShip::turbo_WAY_DOWN_BEHIND;          //TN(-1,-1, 0) =  WAY_DOWN_BEHIND         = 1
                    paFuncTurbo[TN(-1,-1, 1)] = &MyShip::turbo_WAY_ZLEFT_DOWN_BEHIND;    //TN(-1,-1, 1) =  WAY_ZLEFT_DOWN_BEHIND   = 2
                    paFuncTurbo[TN(-1, 0,-1)] = &MyShip::turbo_WAY_ZRIGHT_BEHIND;        //TN(-1, 0,-1) =  WAY_ZRIGHT_BEHIND       = 3
                    paFuncTurbo[TN(-1, 0, 0)] = &MyShip::turbo_WAY_BEHIND;               //TN(-1, 0, 0) =  WAY_BEHIND              = 4
                    paFuncTurbo[TN(-1, 0, 1)] = &MyShip::turbo_WAY_ZLEFT_BEHIND;         //TN(-1, 0, 1) =  WAY_ZLEFT_BEHIND        = 5
                    paFuncTurbo[TN(-1, 1,-1)] = &MyShip::turbo_WAY_ZRIGHT_UP_BEHIND;     //TN(-1, 1,-1) =  WAY_ZRIGHT_UP_BEHIND    = 6
                    paFuncTurbo[TN(-1, 1, 0)] = &MyShip::turbo_WAY_UP_BEHIND;            //TN(-1, 1, 0) =  WAY_UP_BEHIND           = 7
                    paFuncTurbo[TN(-1, 1, 1)] = &MyShip::turbo_WAY_ZLEFT_UP_BEHIND;      //TN(-1, 1, 1) =  WAY_ZLEFT_UP_BEHIND     = 8
                    paFuncTurbo[TN( 0,-1,-1)] = &MyShip::turbo_WAY_ZRIGHT_DOWN;          //TN( 0,-1,-1) =  WAY_ZRIGHT_DOWN         = 9
                    paFuncTurbo[TN( 0,-1, 0)] = &MyShip::turbo_WAY_DOWN;                 //TN( 0,-1, 0) =  WAY_DOWN                = 10
                    paFuncTurbo[TN( 0,-1, 1)] = &MyShip::turbo_WAY_ZLEFT_DOWN;           //TN( 0,-1, 1) =  WAY_ZLEFT_DOWN          = 11
                    paFuncTurbo[TN( 0, 0,-1)] = &MyShip::turbo_WAY_ZRIGHT;               //TN( 0, 0,-1) =  WAY_ZRIGHT              = 12
                    paFuncTurbo[TN( 0, 0, 0)] = &MyShip::turbo_WAY_NONE;                 //TN( 0, 0, 0) =  WAY_NONE                = 13
                    paFuncTurbo[TN( 0, 0, 1)] = &MyShip::turbo_WAY_ZLEFT;                //TN( 0, 0, 1) =  WAY_ZLEFT               = 14
                    paFuncTurbo[TN( 0, 1,-1)] = &MyShip::turbo_WAY_ZRIGHT_UP;            //TN( 0, 1,-1) =  WAY_ZRIGHT_UP           = 15
                    paFuncTurbo[TN( 0, 1, 0)] = &MyShip::turbo_WAY_UP;                   //TN( 0, 1, 0) =  WAY_UP                  = 16
                    paFuncTurbo[TN( 0, 1, 1)] = &MyShip::turbo_WAY_ZLEFT_UP;             //TN( 0, 1, 1) =  WAY_ZLEFT_UP            = 17
                    paFuncTurbo[TN( 1,-1,-1)] = &MyShip::turbo_WAY_ZRIGHT_DOWN_FRONT;    //TN( 1,-1,-1) =  WAY_ZRIGHT_DOWN_FRONT   = 18
                    paFuncTurbo[TN( 1,-1, 0)] = &MyShip::turbo_WAY_DOWN_FRONT;           //TN( 1,-1, 0) =  WAY_DOWN_FRONT          = 19
                    paFuncTurbo[TN( 1,-1, 1)] = &MyShip::turbo_WAY_ZLEFT_DOWN_FRONT;     //TN( 1,-1, 1) =  WAY_ZLEFT_DOWN_FRONT    = 20
                    paFuncTurbo[TN( 1, 0,-1)] = &MyShip::turbo_WAY_ZRIGHT_FRONT;         //TN( 1, 0,-1) =  WAY_ZRIGHT_FRONT        = 21
                    paFuncTurbo[TN( 1, 0, 0)] = &MyShip::turbo_WAY_FRONT;                //TN( 1, 0, 0) =  WAY_FRONT               = 22
                    paFuncTurbo[TN( 1, 0, 1)] = &MyShip::turbo_WAY_ZLEFT_FRONT;          //TN( 1, 0, 1) =  WAY_ZLEFT_FRONT         = 23
                    paFuncTurbo[TN( 1, 1,-1)] = &MyShip::turbo_WAY_ZRIGHT_UP_FRONT;      //TN( 1, 1,-1) =  WAY_ZRIGHT_UP_FRONT     = 24
                    paFuncTurbo[TN( 1, 1, 0)] = &MyShip::turbo_WAY_UP_FRONT;             //TN( 1, 1, 0) =  WAY_UP_FRONT            = 25
                    paFuncTurbo[TN( 1, 1, 1)] = &MyShip::turbo_WAY_ZLEFT_UP_FRONT;       //TN( 1, 1, 1) =  WAY_ZLEFT_UP_FRONT      = 26
                
                    _pSeTransmitter->useSe(4);
                    _pSeTransmitter->set(0, "se-020");
                    _pSeTransmitter->set(1,"laser001", 99);
                    _pSeTransmitter->set(2,"fire01", 99);
                    _pSeTransmitter->set(3,"bse5", 99);
                    char rankstr[80] = {0} ;// S0
                    MyStgUtil::getRankStr(99999, rankstr);
                    _TRACE_("RANKSTR:"<<rankstr);
                
                
                    _iMvVelo_TurboTop = 30000;
                    _iMvVelo_TurboBottom = 10000;
                
                    _can_control = true;
                    _is_diving = false;
                
                    _blown_veloX = 0;
                    _blown_veloY = 0;
                    _blown_veloZ = 0;
                    _anti_blown_velo = 100;
                }
                
                void MyShip::initialize() {
                
                    //U
                //    getLordActor()->addSubGroup(KIND_MY_SHOT_NOMAL, _pDispatcher_MyShots001->extract());
                //    getLordActor()->addSubGroup(KIND_MY_SHOT_NOMAL, _pDispatcher_MyWaves001->extract());
                    //getLordActor()->addSubGroup(KIND_MY_SHOT_NOMAL, _pLaserChipDispatcher->extract());
                
                    setHitAble(true);
                    _pCollisionChecker->makeCollision(1);
                //    _pCollisionChecker->setColliSphere(0, -100000, -50000, 20000, 100000);
                // _pCollisionChecker->setColliAAB(0, -100000, -50000, 20000, 10000, 40000, 80000);
                      _pCollisionChecker->setColliAAB_Cube(0, 40000);
                //    _pCollisionChecker->setColliSphere(1, 0,-100000,0, 30000, true, true, true);
                //    _pCollisionChecker->setColliSphere(2, 0,100000,0, 30000, true, true, true);
                //    _pCollisionChecker->setColliSphere(3, 0,0,-100000, 30000, true, true, true);
                //    _pCollisionChecker->setColliSphere(4, 0,0,100000, 30000, true, true, true);
                
                    _pKuroko->setMvVelo(0);
                    _pScaler->setScale(1000);
                    _pScaler->forceScaleRange(1000, 7000);
                
                    setMaterialColor(1.0, 0.5, 0.5);
                    setAlpha(0.4);
                
                
                    _pKuroko->forceVxMvVeloRange(-_iMvVelo_TurboTop, _iMvVelo_TurboTop);
                    _pKuroko->forceVyMvVeloRange(-_iMvVelo_TurboTop, _iMvVelo_TurboTop);
                    _pKuroko->forceVzMvVeloRange(-_iMvVelo_TurboTop, _iMvVelo_TurboTop);
                
                    _pKuroko->setVxMvAcce(0);
                    _pKuroko->setVyMvAcce(0);
                    _pKuroko->setVzMvAcce(0);
                    //        _pKuroko->forceMvVeloRange(_iMvBtmVelo_MT, _iMvVelo_BeginMT);
                    //        _pKuroko->addMvVelo(_iMvVelo_BeginMT);  //x
                    //        _pKuroko->setMvAcce(_iMvAcce_MT);
                
                    _pKuroko->setFaceAngVelo(AXIS_X, 300);
                }
                
                
                void MyShip::onReset() {
                    _frame_soft_rapidshot = 0;
                    _is_being_soft_rapidshot = false;
                    _just_shot = false;
                    _is_shooting_laser = false;
                    _frame_shot_pressed = 0;
                    _X = Universe::_X_goneLeft + 1000;
                    _Y = _Z = 0;
                    _way = WAY_NONE;
                    _way_switch.reset();
                    MyStgUtil::resetMyShipStatus(_pStatus);
                }
                
                void MyShip::onActive() {
                
                }
                
                
                
                
                void MyShip::processBehavior() {
                    if (!_can_control) {
                        return;
                    }
                
                    //VAMSystem
                    // (Viewpoint Adaptive Moving System _K^VXe)
                    _stc = VB_PLAY->getBeingPressedStick();
                    if (P_VAM->_pos_camera == VAM_POS_RIGHT) {
                        //ETChr[(EXN[)
                        if (VB_PLAY->isPushedDown(VB_UP)) {     // 
                            _way_switch.ON_UP(SW_NOP, SW_ADD, SW_NOP);    //
                        }
                        if (VB_PLAY->isPushedDown(VB_RIGHT)) {  // 
                            _way_switch.ON_RIGHT(SW_ADD, SW_NOP, SW_NOP); //O
                        }
                        if (VB_PLAY->isPushedDown(VB_LEFT)) {   // 
                            _way_switch.ON_LEFT(SW_SUB, SW_NOP, SW_NOP);  //
                        }
                        if (VB_PLAY->isPushedDown(VB_DOWN)) {   // 
                            _way_switch.ON_DOWN(SW_NOP, SW_SUB, SW_NOP);  //
                        }
                    } else if (P_VAM->_pos_camera == VAM_POS_LEFT) {
                        //TChr[(EXN[)
                        if (VB_PLAY->isPushedDown(VB_UP)) {     // 
                            _way_switch.ON_UP(SW_NOP, SW_ADD, SW_NOP);    //
                        }
                        if (VB_PLAY->isPushedDown(VB_RIGHT)) {  // 
                            _way_switch.ON_RIGHT(SW_SUB, SW_NOP, SW_NOP); //
                        }
                        if (VB_PLAY->isPushedDown(VB_LEFT)) {   // 
                            _way_switch.ON_LEFT(SW_ADD, SW_NOP, SW_NOP);  //O
                        }
                        if (VB_PLAY->isPushedDown(VB_DOWN)) {   // 
                            _way_switch.ON_DOWN(SW_NOP, SW_SUB, SW_NOP);  //
                        }
                    } else if (P_VAM->_pos_camera == VAM_POS_TOP) {
                        //gbvr[(XN[)
                        if (VB_PLAY->isPushedDown(VB_UP)) {     // 
                            _way_switch.ON_UP(SW_ADD, SW_NOP, SW_NOP);    //O
                        }
                        if (VB_PLAY->isPushedDown(VB_RIGHT)) {  // 
                            _way_switch.ON_RIGHT(SW_NOP, SW_NOP, SW_SUB); //E
                        }
                        if (VB_PLAY->isPushedDown(VB_LEFT)) {   // 
                            _way_switch.ON_LEFT(SW_NOP, SW_NOP, SW_ADD);  //
                        }
                        if (VB_PLAY->isPushedDown(VB_DOWN)) {   // 
                            _way_switch.ON_DOWN(SW_SUB, SW_NOP, SW_NOP);  //
                        }
                    } else if (P_VAM->_pos_camera == VAM_POS_BOTTOM) {
                        //{gr[(XN[)
                        if (VB_PLAY->isPushedDown(VB_UP)) {     // 
                            _way_switch.ON_UP(SW_SUB, SW_NOP, SW_NOP);    //
                        }
                        if (VB_PLAY->isPushedDown(VB_RIGHT)) {  // 
                            _way_switch.ON_RIGHT(SW_NOP, SW_NOP, SW_SUB); //E
                        }
                        if (VB_PLAY->isPushedDown(VB_LEFT)) {   // 
                            _way_switch.ON_LEFT(SW_NOP, SW_NOP, SW_ADD);  //
                        }
                        if (VB_PLAY->isPushedDown(VB_DOWN)) {   // 
                            _way_switch.ON_DOWN(SW_ADD, SW_NOP, SW_NOP);  //O
                        }
                    } else if (P_VAM->_pos_camera > VAM_POS_TO_BEHIND) {
                        //wr[iOXN[j
                        if (VB_PLAY->isPushedDown(VB_UP)) {     // 
                            _way_switch.ON_UP(SW_NOP, SW_ADD, SW_NOP);    //
                        }
                        if (VB_PLAY->isPushedDown(VB_RIGHT)) {  // 
                            _way_switch.ON_RIGHT(SW_NOP, SW_NOP, SW_SUB); //E
                        }
                        if (VB_PLAY->isPushedDown(VB_LEFT)) {   // 
                            _way_switch.ON_LEFT(SW_NOP, SW_NOP, SW_ADD);  //
                        }
                        if (VB_PLAY->isPushedDown(VB_DOWN)) {   // 
                            _way_switch.ON_DOWN(SW_NOP, SW_SUB, SW_NOP);  //
                        }
                    }
                    if (VB_PLAY->isReleasedUp(VB_UP)) {
                        _way_switch.OFF_UP();    //  
                    }
                    if (VB_PLAY->isReleasedUp(VB_RIGHT)) {
                        _way_switch.OFF_RIGHT(); //  
                    }
                    if (VB_PLAY->isReleasedUp(VB_LEFT)) {
                        _way_switch.OFF_LEFT();  //  
                    }
                    if (VB_PLAY->isReleasedUp(VB_DOWN)) {
                        _way_switch.OFF_DOWN();  //  
                    }
                    _way = (MoveWay)(_way_switch.getIndex()); //Lll
                
                    if (VB_PLAY->isBeingPressed(VB_OPTION)) {
                        int tmp = _iMoveSpeed;
                        _iMoveSpeed = _iMoveSpeed / 8; //IvVx
                        (this->*paFuncMove[_way])();   //l\bho
                        _iMoveSpeed = tmp;
                    } else {
                        (this->*paFuncMove[_way])();   //l\bho
                    }
                
                    if (VB_PLAY->isPushedDown(VB_TURBO)) {
                        //^[{Jn
                        EffectTurbo002* pTurbo002 = (EffectTurbo002*)P_COMMON_SCENE->_pDispatcher_EffectTurbo002->employForce();
                         if (pTurbo002) {
                             pTurbo002->locateAs(this);
                             pTurbo002->activate();
                         }
                        (this->*paFuncTurbo[_way])();
                    } else {
                        //Not^[{Jn
                        if (VB_PLAY->isBeingPressed(VB_TURBO)) {
                            //^[{AL
                            _pKuroko->_veloVxMv *= 0.95;
                            _pKuroko->_veloVyMv *= 0.95;
                            _pKuroko->_veloVzMv *= 0.95;
                        } else {
                            _pKuroko->_veloVxMv *= 0.9;
                            _pKuroko->_veloVyMv *= 0.9;
                            _pKuroko->_veloVzMv *= 0.9;
                        }
                    }
                
                    //Xsx
                    angvelo MZ = _angRXTopVelo_MZ-3000; //3000x_angRXTopVelo_MZAOiTODO:vjB
                    if (_pKuroko->_angveloFace[AXIS_X] >= MZ) {
                        _pKuroko->_angveloFace[AXIS_X] *= 0.93;
                        //_pKuroko->setFaceAngAcce(AXIS_X, -1*_angRXAcce_MZ*2);
                    } else if (_pKuroko->_angveloFace[AXIS_X] <= -MZ) {
                        _pKuroko->_angveloFace[AXIS_X] *= 0.93;
                        //_pKuroko->setFaceAngAcce(AXIS_X, _angRXAcce_MZ*2);
                    }
                
                    //EA@iABsetStopTarget_FaceAng4pxj
                    if (VB_PLAY->isBeingPressed(VB_LEFT) || VB_PLAY->isBeingPressed(VB_RIGHT)) {
                
                    } else {
                
                        angle dist = _pKuroko->getFaceAngDistance(AXIS_X, 0, TURN_CLOSE_TO);
                        if (0 <= dist && dist < ANGLE180) {
                            _pKuroko->setFaceAngAcce(AXIS_X, _angRXAcce_MZ);
                        } else if (-1*ANGLE180 < dist && dist < 0) {
                            _pKuroko->setFaceAngAcce(AXIS_X, -1*_angRXAcce_MZ);
                        }
                        _pKuroko->setMvAcce(0);
                        _pKuroko->setStopTarget_FaceAng(AXIS_X, 0, TURN_BOTH, _angRXTopVelo_MZ);
                    }
                
                    ////////////////////////////////////////////////////
                
                
                
                    //Wf
                    _pKuroko->behave();
                    _pScaler->behave();
                    _pSeTransmitter->behave();
                
                    //
                    if (GgafUtil::abs(_blown_veloX) < 1000) {
                        _blown_veloX = 0;
                    } else if (_blown_veloX > 0) {
                        _blown_veloX -= 1000;
                    } else if (_blown_veloX < 0) {
                        _blown_veloX += 1000;
                    }
                    if (GgafUtil::abs(_blown_veloY) < 1000) {
                        _blown_veloY = 0;
                    } else if (_blown_veloY > 0) {
                        _blown_veloY -= 1000;
                    } else if (_blown_veloY < 0) {
                        _blown_veloY += 1000;
                    }
                    if (GgafUtil::abs(_blown_veloZ) < 1000) {
                        _blown_veloZ = 0;
                    } else if (_blown_veloZ > 0) {
                        _blown_veloZ -= 1000;
                    } else if (_blown_veloZ < 0) {
                        _blown_veloZ += 1000;
                    }
                    _X += _blown_veloX;
                    _Y += _blown_veloY;
                    _Z += _blown_veloZ;
                
                
                    if (!_is_diving) {
                        if (_Y > MyShip::_lim_top) {
                            _Y = MyShip::_lim_top;
                        }
                        if (_Y < MyShip::_lim_bottom ) {
                            _Y = MyShip::_lim_bottom;
                        }
                
                        if (_X > MyShip::_lim_front) {
                            _X = MyShip::_lim_front;
                        }
                        if (_X < MyShip::_lim_behaind) {
                            _X = MyShip::_lim_behaind;
                        }
                
                        if (_Z > MyShip::_lim_zleft) {
                            _Z = MyShip::_lim_zleft;
                        }
                        if (_Z < MyShip::_lim_zright) {
                            _Z = MyShip::_lim_zright;
                        }
                    }
                    _pRing_GeoHistory->next()->set(this);
                }
                
                void MyShip::processJudgement() {
                    if (!_can_control) {
                        return;
                    }
                    //@eXg
                    if (VB_PLAY->isBeingPressed(VB_BUTTON8)) {
                        _TRACE_("@eXg");
                        throwEventToUpperTree(EVENT_MY_SHIP_WAS_DESTROYED_BEGIN);
                    }
                
                
                    //VbgA
                    _is_shooting_laser = false;
                    if (VB_PLAY->isBeingPressed(VB_SHOT1)) {
                        _frame_shot_pressed ++;
                        if (_frame_shot_pressed > 30) { //12t[[U[
                            _is_shooting_laser = true;
                        }
                    } else {
                        _frame_shot_pressed = 0;
                    }
                
                
                    if (_is_shooting_laser) {
                        if (VB_PLAY->isBeingPressed(VB_SHOT1)) {//isBeingPressed
                            //GgafActorDispatcherAAN^[ play ASvf play ?B
                            MyStraightLaserChip001* pLaser = (MyStraightLaserChip001*)_pLaserChipDispatcher->employ();
                            if (pLaser) {
                                pLaser->activate();
                                if (pLaser->_pChip_front == NULL) {
                                    _pSeTransmitter->play3D(1);
                                }
                            }
                        }
                    }
                
                    //\tgA
                    //1vbV4F3
                    if (VB_PLAY->isPushedDown(VB_SHOT1)) {
                        _is_being_soft_rapidshot = true;
                        if (_frame_soft_rapidshot >= SOFT_RAPIDSHOT_INTERVAL) {
                            //SOFT_RAPIDSHOT_INTERVAL t[x
                            //AA
                            _frame_soft_rapidshot = _frame_soft_rapidshot % SOFT_RAPIDSHOT_INTERVAL;
                        } else {
                            //SOFT_RAPIDSHOT_INTERVAL t[A
                            //I(AAB)
                            _frame_soft_rapidshot = 0;
                        }
                    }
                    _just_shot = false;
                    if (_is_being_soft_rapidshot) {
                        if (_frame_soft_rapidshot % SOFT_RAPIDSHOT_INTERVAL == 0) {
                            _just_shot = true;//VbgtO
                            MyShot001* pShot = (MyShot001*)_pDispatcher_MyShots001->employ();
                            if (pShot) {
                                _pSeTransmitter->play3D(2);
                                pShot->locateAs(this);
                                pShot->activate();
                            }
                            if (_frame_soft_rapidshot >= SOFT_RAPIDSHOT_INTERVAL*(SOFT_RAPIDSHOT_NUM-1)) {
                                //SOFT_RAPIDSHOT_NUM I\tgAI
                                _is_being_soft_rapidshot = false;
                            }
                        }
                    }
                    if (_is_being_soft_rapidshot) {
                        _frame_soft_rapidshot++;
                    }
                
                
                    //    if (VB_PLAY->isPushedDown(VB_SHOT2)) {
                    if (VB_PLAY->isBeingPressed(VB_SHOT2)) {
                        bool can_fire = true;
                        for (int i = 0; i < P_MYOPTIONCON->_now_option_num; i++) {
                            if (P_MYOPTIONCON->_papMyOption[i]->_pTorpedoController->_in_firing) {
                                can_fire = false;
                                break;
                            }
                        }
                        if (can_fire) {
                            for (int i = 0; i < P_MYOPTIONCON->_now_option_num; i++) {
                                if (i == 0) {
                                    _pSeTransmitter->play3D(3);
                                }
                                P_MYOPTIONCON->_papMyOption[i]->_pTorpedoController->fire();
                            }
                        }
                    }
                
                
                
                }
                
                void MyShip::onHit(GgafActor* prm_pOtherActor) {
                    GgafDx9GeometricActor* pOther = (GgafDx9GeometricActor*)prm_pOtherActor;
                    //qbgGtFNg
                
                
                    if (MyStgUtil::calcMyStatus(_pStatus, getKind(), pOther->_pStatus, pOther->getKind()) <= 0) {
                        //GtFNg
                    }
                
                    //
                    if (pOther->getKind() & KIND_CHIKEI) {
                
                        _blown_veloX = (GgafUtil::sign(_pCollisionChecker->_blown_sgn_vX)*(10000+GgafUtil::abs(_pKuroko->_veloVxMv)));
                        _blown_veloY = (GgafUtil::sign(_pCollisionChecker->_blown_sgn_vY)*(10000+GgafUtil::abs(_pKuroko->_veloVyMv)));
                        _blown_veloZ = (GgafUtil::sign(_pCollisionChecker->_blown_sgn_vZ)*(10000+GgafUtil::abs(_pKuroko->_veloVzMv)));
                    }
                    if (pOther->getKind() & KIND_ITEM)  {
                    } else {
                        EffectExplosion001* pExplo001 = (EffectExplosion001*)P_COMMON_SCENE->_pDP_EffectExplosion001->employ();
                        if (pExplo001) {
                            pExplo001->locateAs(this);
                            pExplo001->activate();
                        }
                        _pSeTransmitter->play3D(0);
                    }
                
                    if (pOther->getKind() & KIND_ITEM)  {
                
                    }
                }
                
                
                
                void MyShip::doNotingMoveInput() {
                
                }
                
                void MyShip::onCatchEvent(UINT32 prm_no, void* prm_pSource) {
                    if (prm_no == EVENT_MY_SHIP_WAS_DESTROYED_BEGIN) {
                
                    } else if (prm_no == EVENT_MY_SHIP_WAS_DESTROYED_FINISH) {
                
                    }
                }
                
           2 -> MyShip::~MyShip() {
                    DELETE_IMPOSSIBLE_NULL(_pRing_GeoHistory);
                
                }
                


Top 10 Lines:

     Line      Count

      591          2
       18          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/MyStg2nd/src/gecchi/actor/my/MyShip.h:
                #ifndef MYSHIP_H_
                #define MYSHIP_H_
                namespace MyStg2nd {
                
                #define SH_NOMAL 0;
                #define SH_LASER 1;
                
                #define MAX_LEVEL_MOVE_SPEED 5
                #define MIN_LEVEL_MOVE_SPEED 0
                //Ternary numeral -1,0.1 33i@  zvf10i}N
                #define TN(X,Y,Z) (((3*3)*(X+1)) + ((3)*(Y+1)) + (Z+1))
                
                #define EQ_OPTION 1
                #define EQ_MAX_OPTION 0
                /** \tgA */
                #define SOFT_RAPIDSHOT_NUM 3
                /** \tgAu */
                #define SOFT_RAPIDSHOT_INTERVAL 4
                
                enum Switch {
                    SW_ADD = 1,
                    SW_NOP = 0,
                    SW_SUB = -1
                };
                
                /**
                 * @NX
                 * @version 1.00
                 * @since 2006/06/22
                 * @author Masatoshi Tsuge
                 */
                class MyShip : public GgafDx9LibStg::DefaultD3DXMeshActor {
                //class MyShip : public GgafDx9LibStg::DefaultMeshActor {
                //class MyShip : public GgafDx9LibStg::CubeMapMeshActor {
                //class MyShip : public GgafDx9LibStg::DefaultD3DXAniMeshActor {
                
                
                    class State {
                    public:
                        int eq_option;
                        int eq_speed;
                        int mp;
           1 ->         State() {
                            eq_option = 0;
                            eq_speed = 1;
                            mp = 10000;
                        }
                
                    };
                
                    struct VERTEX {
                        float x, y, z; // _W
                        float nx, ny, nz; // @
                        DWORD color; // _F
                        float tu, tv; // eNX`W
                    };
                
                
                
                
                
                
                    class WaySwitch {
                    public :
                        class SW {
                            public:
                            int X, Y, Z;
           5 ->             SW() { X = Y = Z = SW_NOP; }
                        };
                        bool _sw_UP, _sw_LEFT, _sw_RIGHT, _sw_DOWN;
                        SW _on_UP, _on_LEFT, _on_RIGHT, _on_DOWN;
                
                        /**  */
                        SW _way;
                
                
                
           1 ->         WaySwitch() {
                            _way.X = _way.Y = _way.Z = SW_NOP;
                            _sw_UP = _sw_LEFT = _sw_RIGHT = _sw_DOWN = false;
                        }
                
                        void reset() {
                            _way.X = _way.Y = _way.Z = SW_NOP;
                            _sw_UP = _sw_LEFT = _sw_RIGHT = _sw_DOWN = false;
                        }
                        void ON_UP(Switch swX, Switch swY, Switch swZ) {
                            if (!_sw_UP) {
                                _way.X += swX;
                                _way.Y += swY;
                                _way.Z += swZ;
                                _on_UP.X = swX;
                                _on_UP.Y = swY;
                                _on_UP.Z = swZ;
                                _sw_UP = true;
                            }
                        }
                        void ON_LEFT(Switch swX, Switch swY, Switch swZ) {
                            if (!_sw_LEFT) {
                                _way.X += swX;
                                _way.Y += swY;
                                _way.Z += swZ;
                                _on_LEFT.X = swX;
                                _on_LEFT.Y = swY;
                                _on_LEFT.Z = swZ;
                                _sw_LEFT = true;
                            }
                        }
                        void ON_RIGHT(Switch swX, Switch swY, Switch swZ) {
                            if (!_sw_RIGHT) {
                                _way.X += swX;
                                _way.Y += swY;
                                _way.Z += swZ;
                                _on_RIGHT.X = swX;
                                _on_RIGHT.Y = swY;
                                _on_RIGHT.Z = swZ;
                                _sw_RIGHT = true;
                            }
                        }
                        void ON_DOWN(Switch swX, Switch swY, Switch swZ) {
                            if (!_sw_DOWN) {
                                _way.X += swX;
                                _way.Y += swY;
                                _way.Z += swZ;
                                _on_DOWN.X = swX;
                                _on_DOWN.Y = swY;
                                _on_DOWN.Z = swZ;
                                _sw_DOWN = true;
                            }
                        }
                        void OFF_UP() {
                            if (_sw_UP) {
                                _way.X -= _on_UP.X;
                                _way.Y -= _on_UP.Y;
                                _way.Z -= _on_UP.Z;
                                _sw_UP = false;
                            }
                        }
                        void OFF_RIGHT() {
                            if (_sw_RIGHT) {
                                _way.X -= _on_RIGHT.X;
                                _way.Y -= _on_RIGHT.Y;
                                _way.Z -= _on_RIGHT.Z;
                                _sw_RIGHT = false;
                            }
                        }
                        void OFF_LEFT() {
                            if (_sw_LEFT) {
                                _way.X -= _on_LEFT.X;
                                _way.Y -= _on_LEFT.Y;
                                _way.Z -= _on_LEFT.Z;
                                _sw_LEFT = false;
                            }
                        }
                        void OFF_DOWN() {
                            if (_sw_DOWN) {
                                _way.X -= _on_DOWN.X;
                                _way.Y -= _on_DOWN.Y;
                                _way.Z -= _on_DOWN.Z;
                                _sw_DOWN = false;
                            }
                        }
                        int getIndex() {
                            //3i10i
                            //_TRACE_("_way.X, _way.Y, _way.Z="<<_way.X<<","<<_way.Y<<","<< _way.Z);
                            return (3*3*(sgn(_way.X)+1)) + (3*(sgn(_way.Y)+1)) + (sgn(_way.Z)+1);
                        }
                    };
                public:
                    /** YW */
                    static int _lim_top;
                    /** YW */
                    static int _lim_bottom;
                    /** XW */
                    static int _lim_front;
                    /** XW */
                    static int _lim_behaind;
                    /** ZW */
                    static int _lim_zleft;
                    /** ZW */
                    static int _lim_zright;
                
                    WaySwitch _way_switch;
                    void (MyShip::*paFuncMove[3*3*3])();
                    void (MyShip::*paFuncTurbo[3*3*3])();
                
                //    void (MyShip::*fpaFunc[])() =  {
                //          move_WAY_UP,
                //          move_WAY_UP_FRONT
                //    };
                
                
                
                
                    /** l */
                    int _stc;
                
                    /** ^[{Ap */
                    MoveWay _way;
                
                    /** Xs[hxXs[h */
                    int _iMoveSpeed;
                
                    int _iMoveVelo;
                
                
                    int _iMvVelo_TurboTop;
                    int _iMvVelo_TurboBottom;
                
                    /** TurboJnxx */
                    int _iMvVelo_BeginMT; //Move Velo when I Begin To Move with Turbo
                    //ZAlvZiZxj
                
                    /** Turboxx */
                    int _iMvAcce_MT; //Move Acce while I Move with Turbo
                    //A l < 0 B x
                    //ZAlvZ
                
                    /** Turboxx */
                    int _iMvBtmVelo_MT; //Move Bottom Velo while I Move with Turbo
                    //A l < 0 B
                    //ZAlvZ
                
                    /** TurboIfx */
                    int _iMvVelo_FMT; //Rotation axisX angle Velo when I Finish Moveing with Turbo
                    //A l < 0 B
                    //ZAlvZ
                
                    /** (+Z)O(-Z)JnX]pxx */
                    angle _angRXVelo_BeginMZ; //Rotation axisX angle Velo when I Begin To Move Z
                    //AO -1 
                
                    /** (+Z)O(-Z)X]pxpx */
                    angle _angRXAcce_MZ; //Rotation axisX angle Acce while I Move Z
                    //AO -1 
                
                    /** (+Z)O(-Z)X]pxpx */
                    angle _angRXTopVelo_MZ; //Rotation axisX Top angle Velo while I Move Z
                    //px -1 
                
                    /** (+Z)O(-Z)ZX]p~px */
                    angle _angRXStop_MZ; //Rotation axisX Stop angle while I Move Z
                
                
                    /** (+Y)(-Y)TurboJnZ]pxx */
                    angle _angRXVelo_BeginMZT; //Rotation axisX angle Velo when I Begin To Move Z with Turbo
                    //A -1 
                
                    State _state;
                
                    GgafCore::GgafLinkedListRing<GgafDx9Core::GgafDx9GeoElem>* _pRing_GeoHistory;
                
                    GgafCore::GgafActorDispatcher* _pDispatcher_MyShots001;
                    GgafCore::GgafActorDispatcher* _pDP_EffectExplosion001;
                    GgafDx9LibStg::LaserChipDispatcher* _pLaserChipDispatcher;
                
                //    MyOptionController* _pMyOptionController;
                    EffectTurbo001* _pEffectTurbo001;
                
                    /** \tgAJnot[ */
                    frame _frame_soft_rapidshot;
                    /** \tgA */
                    bool _is_being_soft_rapidshot;
                    /** Vbgt[ true  */
                    bool _just_shot;
                    /** [U[ */
                    bool _is_shooting_laser;
                    /** SHOT{^ot[i[U[Jnj */
                    frame _frame_shot_pressed;
                
                    /** V[ */
                    bool _is_diving;
                
                    /**  */
                    bool _can_control;
                
                    /** X */
                    int _blown_veloX;
                    /** Y */
                    int _blown_veloY;
                    /** Z */
                    int _blown_veloZ;
                    /** } */
                    int _anti_blown_velo;
                
                    MyShip(const char* prm_name);
                
                    void initialize() override;
                
                    void onReset() override;
                
                    void onActive() override;
                
                    void processBehavior() override;
                
                    void processJudgement() override;
                
                    void onHit(GgafCore::GgafActor* prm_pOtherActor) override;
                
                    void setMoveSpeedLv(int lv) {
                        //_lv_MoveSpeed = lv;
                        _iMoveSpeed = lv * 1000;
                    }
                
                    //OX]
                
                    void doNotingMoveInput();
                
                    static angle wk_dist, wk_angRx;
                    void move_WAY_NONE() {
                        //_way = WAY_NONE;
                        _iMoveVelo = 0;
                    }
                    /**
                     * 
                     */
                    void move_WAY_UP() {
                        _pKuroko->setRzRyMvAng(ANGLE90, 0);
                        _Y += _iMoveSpeed;
                        _iMoveVelo = _iMoveSpeed;
                    }
                    /**
                     * O
                     */
                    void move_WAY_UP_FRONT() {
                        _pKuroko->setRzRyMvAng(ANGLE45, 0);
                        _Y += _iMoveSpeed * NANAME;
                        _X += _iMoveSpeed * NANAME;
                        _iMoveVelo = _iMoveSpeed * NANAME;
                    }
                    /**
                     * 
                     */
                    void move_WAY_UP_BEHIND() {
                        _pKuroko->setRzRyMvAng(ANGLE135, 0);
                        _Y += _iMoveSpeed * NANAME;
                        _X -= _iMoveSpeed * NANAME;
                        _iMoveVelo = _iMoveSpeed * NANAME;
                    }
                    /**
                     * O
                     */
                    void move_WAY_FRONT() {
                        _pKuroko->setRzRyMvAng(0, 0);
                        _X += _iMoveSpeed;
                        _iMoveVelo = _iMoveSpeed;
                    }
                    /**
                     * 
                     */
                    void move_WAY_BEHIND() {
                        _pKuroko->setRzRyMvAng(ANGLE180, 0);
                        _X -= _iMoveSpeed;
                        _iMoveVelo = _iMoveSpeed;
                    }
                    /**
                     * 
                     */
                    void move_WAY_DOWN() {
                        _pKuroko->setRzRyMvAng(ANGLE270, 0);
                        _Y -= _iMoveSpeed;
                        _iMoveVelo = _iMoveSpeed;
                    }
                    /**
                     * 
                     */
                    void move_WAY_DOWN_BEHIND() {
                        _pKuroko->setRzRyMvAng(ANGLE225, 0);
                        _Y -= _iMoveSpeed * NANAME;
                        _X -= _iMoveSpeed * NANAME;
                        _iMoveVelo = _iMoveSpeed * NANAME;
                    }
                    /**
                     * O
                     */
                    void move_WAY_DOWN_FRONT() {
                        _pKuroko->setRzRyMvAng(ANGLE315, 0);
                        _Y -= _iMoveSpeed * NANAME;
                        _X += _iMoveSpeed * NANAME;
                        _iMoveVelo = _iMoveSpeed * NANAME;
                    }
                    /**
                     * 
                     */
                    void move_WAY_ZLEFT() {
                        _pKuroko->setRzRyMvAng(0, ANGLE270);
                        _Z += _iMoveSpeed;
                        _iMoveVelo = _iMoveSpeed;
                        //
                        _pKuroko->setFaceAngAcce(AXIS_X, _angRXAcce_MZ);
                        _pKuroko->setStopTarget_FaceAng(AXIS_X, _angRXStop_MZ, TURN_COUNTERCLOCKWISE, _angRXTopVelo_MZ);
                    }
                    /**
                     * O
                     */
                    void move_WAY_ZLEFT_FRONT() {
                        _pKuroko->setRzRyMvAng(0, ANGLE315);
                        _Z += _iMoveSpeed * NANAME;
                        _X += _iMoveSpeed * NANAME;
                        _iMoveVelo = _iMoveSpeed * NANAME;
                        //
                        _pKuroko->setFaceAngAcce(AXIS_X, (_angRXAcce_MZ/2)); //v
                        _pKuroko->setStopTarget_FaceAng(AXIS_X, _angRXStop_MZ - (_angRXStop_MZ/2), TURN_COUNTERCLOCKWISE, _angRXTopVelo_MZ);
                    }
                    /**
                     * 
                     */
                    void move_WAY_ZLEFT_BEHIND() {
                        _pKuroko->setRzRyMvAng(ANGLE180, ANGLE45);
                        _Z += _iMoveSpeed * NANAME;
                        _X -= _iMoveSpeed * NANAME;
                        _iMoveVelo = _iMoveSpeed * NANAME;
                        //
                        _pKuroko->setFaceAngAcce(AXIS_X, (_angRXAcce_MZ/2));
                        _pKuroko->setStopTarget_FaceAng(AXIS_X, _angRXStop_MZ + (_angRXStop_MZ/2), TURN_COUNTERCLOCKWISE, _angRXTopVelo_MZ);
                    }
                    /**
                     * OE
                     */
                    void move_WAY_ZRIGHT_FRONT() {
                        _pKuroko->setRzRyMvAng(ANGLE180, ANGLE135);
                        _Z -= _iMoveSpeed * NANAME;
                        _X += _iMoveSpeed * NANAME;
                        _iMoveVelo = _iMoveSpeed * NANAME;
                        //
                        _pKuroko->setFaceAngAcce(AXIS_X, -1*(_angRXAcce_MZ/2));
                        _pKuroko->setStopTarget_FaceAng(AXIS_X, -1*(_angRXStop_MZ - (_angRXStop_MZ/2)), TURN_CLOCKWISE, _angRXTopVelo_MZ);
                    }
                    /**
                     * E
                     */
                    void move_WAY_ZRIGHT() {
                        _pKuroko->setRzRyMvAng(0, ANGLE90);
                        _Z -= _iMoveSpeed;
                        _iMoveVelo = _iMoveSpeed;
                        //
                        _pKuroko->setFaceAngAcce(AXIS_X, -1*_angRXAcce_MZ);
                        _pKuroko->setStopTarget_FaceAng(AXIS_X, -1*_angRXStop_MZ, TURN_CLOCKWISE, _angRXTopVelo_MZ);
                    }
                    /**
                     * E
                     */
                    void move_WAY_ZRIGHT_BEHIND() {
                        _pKuroko->setRzRyMvAng(0, ANGLE135);
                        _Z -= _iMoveSpeed * NANAME;
                        _X -= _iMoveSpeed * NANAME;
                        _iMoveVelo = _iMoveSpeed * NANAME;
                        //
                        _pKuroko->setFaceAngAcce(AXIS_X, -1*(_angRXAcce_MZ/2));
                        _pKuroko->setStopTarget_FaceAng(AXIS_X, -1*(_angRXStop_MZ + (_angRXStop_MZ/2)), TURN_CLOCKWISE, _angRXTopVelo_MZ);
                    }
                    /**
                     * 
                     */
                    void move_WAY_ZLEFT_UP() {
                        _pKuroko->setRzRyMvAng(ANGLE45, ANGLE270);
                        _Z += _iMoveSpeed * NANAME;
                        _Y += _iMoveSpeed * NANAME;
                        _iMoveVelo = _iMoveSpeed * NANAME;
                        //
                        _pKuroko->setFaceAngAcce(AXIS_X, _angRXAcce_MZ);
                        _pKuroko->setStopTarget_FaceAng(AXIS_X, _angRXStop_MZ - (_angRXStop_MZ/2), TURN_COUNTERCLOCKWISE, _angRXTopVelo_MZ);
                    }
                    /**
                     * 
                     */
                    void move_WAY_ZLEFT_DOWN() {
                        _pKuroko->setRzRyMvAng(ANGLE315, ANGLE270);
                        _Z += _iMoveSpeed * NANAME;
                        _Y -= _iMoveSpeed * NANAME;
                        _iMoveVelo = _iMoveSpeed * NANAME;
                        //
                        _pKuroko->setFaceAngAcce(AXIS_X, _angRXAcce_MZ/2);
                        _pKuroko->setStopTarget_FaceAng(AXIS_X, _angRXStop_MZ + (_angRXStop_MZ/2), TURN_COUNTERCLOCKWISE, _angRXTopVelo_MZ);
                    }
                    /**
                     * E
                     */
                    void move_WAY_ZRIGHT_UP() {
                        _pKuroko->setRzRyMvAng(ANGLE45, ANGLE90);
                        _Z -= _iMoveSpeed * NANAME;
                        _Y += _iMoveSpeed * NANAME;
                        _iMoveVelo = _iMoveSpeed * NANAME;
                        //
                        _pKuroko->setFaceAngAcce(AXIS_X, -1*(_angRXAcce_MZ/2));
                        _pKuroko->setStopTarget_FaceAng(AXIS_X, -1*(_angRXStop_MZ - (_angRXStop_MZ/2)), TURN_CLOCKWISE, _angRXTopVelo_MZ);
                    }
                    /**
                     * E
                     */
                    void move_WAY_ZRIGHT_DOWN() {
                        _pKuroko->setRzRyMvAng(ANGLE315, ANGLE90);
                        _Z -= _iMoveSpeed * NANAME;
                        _Y -= _iMoveSpeed * NANAME;
                        _iMoveVelo = _iMoveSpeed * NANAME;
                        //
                        _pKuroko->setFaceAngAcce(AXIS_X, -1*(_angRXAcce_MZ/2));
                        _pKuroko->setStopTarget_FaceAng(AXIS_X, -1*(_angRXStop_MZ + (_angRXStop_MZ/2)), TURN_CLOCKWISE, _angRXTopVelo_MZ);
                    }
                    /**
                     * O
                     */
                    void move_WAY_ZLEFT_UP_FRONT() {
                        _TRACE_("move_WAY_ZLEFT_UP_FRONTLEFT() came!");
                    }
                    /**
                     * 
                     */
                    void move_WAY_ZLEFT_UP_BEHIND() {
                        _TRACE_("move_WAY_ZLEFT_UP_BEHINDLEFT() came!");
                    }
                
                    void move_WAY_ZLEFT_DOWN_FRONT() {
                        _TRACE_("move_WAY_ZLEFT_DOWN_FRONTLEFT() came!");
                    }
                
                    void move_WAY_ZLEFT_DOWN_BEHIND() {
                        _TRACE_("move_WAY_ZLEFT_DOWN_BEHINDLEFT() came!");
                    }
                
                    void move_WAY_ZRIGHT_UP_FRONT() {
                        _TRACE_("move_WAY_ZRIGHT_UP_FRONTLEFT() came!");
                    }
                
                    void move_WAY_ZRIGHT_UP_BEHIND() {
                        _TRACE_("move_WAY_ZRIGHT_UP_BEHINDLEFT() came!");
                    }
                
                    void move_WAY_ZRIGHT_DOWN_FRONT() {
                        _TRACE_("move_WAY_ZRIGHT_DOWN_FRONTLEFT() came!");
                    }
                
                    void move_WAY_ZRIGHT_DOWN_BEHIND() {
                        _TRACE_("move_WAY_ZRIGHT_DOWN_BEHIND() came!");
                    }
                
                
                    /////////////////TURBO_BEGIN
                
                    void turbo_WAY_NONE() {
                
                    }
                
                    /**
                     * ^[{Jn
                     */
                    void turbo_WAY_UP() {
                        _pKuroko->setRzRyMvAng(ANGLE90, 0);
                        _pKuroko->addVyMvVelo(_iMvVelo_BeginMT);
                    }
                    /**
                     * O^[{Jn
                     */
                    void turbo_WAY_UP_FRONT() {
                        _pKuroko->setRzRyMvAng(ANGLE45, 0);
                        _pKuroko->addVyMvVelo(_iMvVelo_BeginMT * NANAME);
                        _pKuroko->addVxMvVelo(_iMvVelo_BeginMT * NANAME);
                    }
                    /**
                     * ^[{Jn
                     */
                    void turbo_WAY_UP_BEHIND() {
                        _pKuroko->setRzRyMvAng(ANGLE135, 0);
                        _pKuroko->addVyMvVelo(_iMvVelo_BeginMT * NANAME);
                        _pKuroko->addVxMvVelo(-_iMvVelo_BeginMT * NANAME);
                    }
                    /**
                     * O^[{Jn
                     */
                    void turbo_WAY_FRONT() {
                        _pKuroko->setRzRyMvAng(0, 0);
                        _pKuroko->addVxMvVelo(_iMvVelo_BeginMT);
                    }
                    /**
                     * ^[{Jn
                     */
                    void turbo_WAY_BEHIND() {
                        _pKuroko->setRzRyMvAng(ANGLE180, 0);
                        _pKuroko->addVxMvVelo(-_iMvVelo_BeginMT);
                    }
                    /**
                     * ^[{Jn
                     */
                    void turbo_WAY_DOWN() {
                        _pKuroko->setRzRyMvAng(ANGLE270, 0);
                        _pKuroko->addVyMvVelo(-_iMvVelo_BeginMT);
                    }
                    /**
                     * ^[{Jn
                     */
                    void turbo_WAY_DOWN_BEHIND() {
                        _pKuroko->setRzRyMvAng(ANGLE225, 0);
                        _pKuroko->addVyMvVelo(-_iMvVelo_BeginMT * NANAME);
                        _pKuroko->addVxMvVelo(-_iMvVelo_BeginMT * NANAME);
                    }
                    /**
                     * O^[{Jn
                     */
                    void turbo_WAY_DOWN_FRONT() {
                        _pKuroko->setRzRyMvAng(ANGLE315, 0);
                        _pKuroko->addVyMvVelo(-_iMvVelo_BeginMT * NANAME);
                        _pKuroko->addVxMvVelo(_iMvVelo_BeginMT * NANAME);
                    }
                    /**
                     * ^[{Jn
                     */
                    void turbo_WAY_ZLEFT() {
                        _pKuroko->addVzMvVelo(_iMvVelo_BeginMT);
                        //
                        _pKuroko->setFaceAngVelo(AXIS_X, _angRXVelo_BeginMZT); //]Jn
                    }
                    /**
                     * O^[{Jn
                     */
                    void turbo_WAY_ZLEFT_FRONT() {
                        _pKuroko->setRzRyMvAng(0, ANGLE270);
                        _pKuroko->addVzMvVelo(_iMvVelo_BeginMT * NANAME);
                        _pKuroko->addVxMvVelo(_iMvVelo_BeginMT * NANAME);
                        //
                        _pKuroko->setFaceAngVelo(AXIS_X, _angRXVelo_BeginMZT*NANAME); //]Jn
                    }
                    /**
                     * ^[{Jn
                     */
                    void turbo_WAY_ZLEFT_BEHIND() {
                        _pKuroko->setRzRyMvAng(ANGLE180, ANGLE45);
                        _pKuroko->addVzMvVelo(_iMvVelo_BeginMT * NANAME);
                        _pKuroko->addVxMvVelo(-_iMvVelo_BeginMT * NANAME);
                        //
                        _pKuroko->setFaceAngVelo(AXIS_X, _angRXVelo_BeginMZT*NANAME); //]Jn
                    }
                    /**
                     * OE^[{Jn
                     */
                    void turbo_WAY_ZRIGHT_FRONT() {
                        _pKuroko->setRzRyMvAng(ANGLE180, ANGLE135);
                        _pKuroko->addVzMvVelo(-_iMvVelo_BeginMT * NANAME);
                        _pKuroko->addVxMvVelo(_iMvVelo_BeginMT * NANAME);
                        //
                        _pKuroko->setFaceAngVelo(AXIS_X, -_angRXVelo_BeginMZT*NANAME); //]Jn
                    }
                    /**
                     * E^[{Jn
                     */
                    void turbo_WAY_ZRIGHT() {
                        _pKuroko->setRzRyMvAng(0, ANGLE90);
                        _pKuroko->addVzMvVelo(-_iMvVelo_BeginMT);
                        //
                        _pKuroko->setFaceAngVelo(AXIS_X, -_angRXVelo_BeginMZT); //]Jn
                    }
                    /**
                     * E
                     */
                    void turbo_WAY_ZRIGHT_BEHIND() {
                        _pKuroko->setRzRyMvAng(0, ANGLE135);
                        _pKuroko->addVzMvVelo(-_iMvVelo_BeginMT * NANAME);
                        _pKuroko->addVxMvVelo(-_iMvVelo_BeginMT * NANAME);
                        //
                        _pKuroko->setFaceAngVelo(AXIS_X, -_angRXVelo_BeginMZT*NANAME); //]Jn
                    }
                    /**
                     * ^[{Jn
                     */
                    void turbo_WAY_ZLEFT_UP() {
                        _pKuroko->setRzRyMvAng(ANGLE45, ANGLE270);
                        _pKuroko->addVzMvVelo(_iMvVelo_BeginMT * NANAME);
                        _pKuroko->addVyMvVelo(_iMvVelo_BeginMT * NANAME);
                        //
                        _pKuroko->setFaceAngVelo(AXIS_X, _angRXVelo_BeginMZT*NANAME); //]Jn
                    }
                    /**
                     * ^[{Jn
                     */
                    void turbo_WAY_ZLEFT_DOWN() {
                        _pKuroko->setRzRyMvAng(ANGLE315, ANGLE270);
                        _pKuroko->addVzMvVelo(_iMvVelo_BeginMT * NANAME);
                        _pKuroko->addVyMvVelo(-_iMvVelo_BeginMT * NANAME);
                        //
                        _pKuroko->setFaceAngVelo(AXIS_X, _angRXVelo_BeginMZT*NANAME); //]Jn
                    }
                    /**
                     * E^[{Jn
                     */
                    void turbo_WAY_ZRIGHT_UP() {
                        _pKuroko->setRzRyMvAng(ANGLE45, ANGLE90);
                        _pKuroko->addVzMvVelo(-_iMvVelo_BeginMT * NANAME);
                        _pKuroko->addVyMvVelo(_iMvVelo_BeginMT * NANAME);
                        //
                        _pKuroko->setFaceAngVelo(AXIS_X, -_angRXVelo_BeginMZT*NANAME); //]Jn
                    }
                    /**
                     * E^[{Jn
                     */
                    void turbo_WAY_ZRIGHT_DOWN() {
                        _pKuroko->setRzRyMvAng(ANGLE315, ANGLE90);
                        _pKuroko->addVzMvVelo(-_iMvVelo_BeginMT * NANAME);
                        _pKuroko->addVyMvVelo(-_iMvVelo_BeginMT * NANAME);
                        //
                        _pKuroko->setFaceAngVelo(AXIS_X, -_angRXVelo_BeginMZT*NANAME); //]Jn
                    }
                    /**
                     * O^[{Jn
                     */
                    void turbo_WAY_ZLEFT_UP_FRONT() {
                        _TRACE_("turbo_WAY_ZLEFT_UP_FRONTLEFT() came!");
                    }
                    /**
                     * ^[{Jn
                     */
                    void turbo_WAY_ZLEFT_UP_BEHIND() {
                        _TRACE_("turbo_WAY_ZLEFT_UP_BEHINDLEFT() came!");
                    }
                
                    void turbo_WAY_ZLEFT_DOWN_FRONT() {
                        _TRACE_("turbo_WAY_ZLEFT_DOWN_FRONTLEFT() came!");
                    }
                
                    void turbo_WAY_ZLEFT_DOWN_BEHIND() {
                        _TRACE_("turbo_WAY_ZLEFT_DOWN_BEHINDLEFT() came!");
                    }
                
                    void turbo_WAY_ZRIGHT_UP_FRONT() {
                        _TRACE_("turbo_WAY_ZRIGHT_UP_FRONTLEFT() came!");
                    }
                
                    void turbo_WAY_ZRIGHT_UP_BEHIND() {
                        _TRACE_("turbo_WAY_ZRIGHT_UP_BEHINDLEFT() came!");
                    }
                
                    void turbo_WAY_ZRIGHT_DOWN_FRONT() {
                        _TRACE_("turbo_WAY_ZRIGHT_DOWN_FRONTLEFT() came!");
                    }
                
                    void turbo_WAY_ZRIGHT_DOWN_BEHIND() {
                        _TRACE_("turbo_WAY_ZRIGHT_DOWN_BEHIND() came!");
                    }
                
                
                    void onCatchEvent(UINT32 prm_no, void* prm_pSource) override;
                
                    virtual ~MyShip();
                
                };
                
                }
                #endif /*MYSHIP_H_*/
                


Top 10 Lines:

     Line      Count

       68          5
       43          1
       78          1

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

        7   Total number of line executions
     2.33   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9Core/include/jp/ggaf/dx9core/util/GgafDx9GeoElem.h:
                #ifndef GGAFDX9GEOELEM_H_
                #define GGAFDX9GEOELEM_H_
                namespace GgafDx9Core {
                
                /**
                 * WRei
                 * @version 1.00
                 * @since 2008/12/19
                 * @author Masatoshi Tsuge
                 */
                class GgafDx9GeoElem {
                public:
                    int _X;
                    int _Y;
                    int _Z;
                    int _RX;
                    int _RY;
                    int _RZ;
                    GgafDx9GeoElem* _next;
                
                    GgafDx9GeoElem() {
                        _X = 0;
                        _Y = 0;
                        _Z = 0;
                        _RX = 0;
                        _RY = 0;
                        _RZ = 0;
                        _next = NULL;
                    }
                
                    GgafDx9GeoElem(int prm_X, int prm_Y, int prm_Z) {
                        _X = prm_X;
                        _Y = prm_Y;
                        _Z = prm_Z;
                        _RX = 0;
                        _RY = 0;
                        _RZ = 0;
                        _next = NULL;
                    }
                
                    GgafDx9GeoElem(int prm_X, int prm_Y, int prm_Z, int prm_RX, int prm_RY, int prm_RZ) {
                        _X = prm_X;
                        _Y = prm_Y;
                        _Z = prm_Z;
                        _RX = prm_RX;
                        _RY = prm_RY;
                        _RZ = prm_RZ;
                        _next = NULL;
                    }
                
         200 ->     GgafDx9GeoElem(GgafDx9GeometricActor* prm_pActor) {
                        _X = prm_pActor->_X;
                        _Y = prm_pActor->_Y;
                        _Z = prm_pActor->_Z;
                        _RX = prm_pActor->_RX;
                        _RY = prm_pActor->_RY;
                        _RZ = prm_pActor->_RZ;
                        _next = NULL;
                    }
                
                    void set(int prm_X, int prm_Y, int prm_Z, int prm_RX, int prm_RY, int prm_RZ) {
                        _X = prm_X;
                        _Y = prm_Y;
                        _Z = prm_Z;
                        _RX = prm_RX;
                        _RY = prm_RY;
                        _RZ = prm_RZ;
                    }
                
                    void set(int prm_X, int prm_Y, int prm_Z) {
                        _X = prm_X;
                        _Y = prm_Y;
                        _Z = prm_Z;
                    }
                
                    void set(GgafDx9GeometricActor* prm_pActor) {
                        _X = prm_pActor->_X;
                        _Y = prm_pActor->_Y;
                        _Z = prm_pActor->_Z;
                        _RX = prm_pActor->_RX;
                        _RY = prm_pActor->_RY;
                        _RZ = prm_pActor->_RZ;
                    }
         400 ->     virtual ~GgafDx9GeoElem() {
                        _next = NULL;
                    }
                };
                
                }
                #endif /*GGAFDX9GEOELEM_H_*/


Top 10 Lines:

     Line      Count

       84        400
       51        200

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

      600   Total number of line executions
   300.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/my/MyShot001.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
         225 -> MyShot001::MyShot001(const char* prm_name) :
                        SingleLaser(prm_name, "MyShot001") { //SingleLaser27Zbg
                    _class_name = "MyShot001";
                    MyStgUtil::resetMyShot001Status(_pStatus);
                }
                
                void MyShot001::initialize() {
                    setHitAble(false);
                    _SX = 45 * 1000;
                    _SY = _SZ = 35 * 1000;
                    setBoundingSphereRadiusRate(45.0f);
                    setAlpha(0.99); //_O
                    _pCollisionChecker->makeCollision(1);
                    _pCollisionChecker->setColliAAB(0, -50000, -40000, -40000, 50000, 40000, 40000);
                    _pKuroko->setFaceAngVelo(AXIS_X, 12000);
                }
                
                void MyShot001::onActive() {
                    setHitAble(true);
                    _pKuroko->setMvVelo(70000);             //x
                    _pKuroko->setMvAcce(100);
                }
                
                void MyShot001::processBehavior() {
                    //ZN|Cg
                    //_pStatus->mul(STAT_AddRankPoint, _pStatus->getDouble(STAT_AddRankPoint_Reduction));
                    //esv
                
                    //Wf
                    //if (onChangeToActive()) {
                
                    //} else {
                        _pKuroko->behave();
                    //}
                }
                
                void MyShot001::processJudgement() {
                    if (isOutOfUniverse()) {
                        sayonara();
                    }
                }
                
                void MyShot001::onHit(GgafActor* prm_pOtherActor) {
                    GgafDx9GeometricActor* pOther = (GgafDx9GeometricActor*)prm_pOtherActor;
                    //if (MyStgUtil::calcMyStatus(_pStatus, getKind(), pOther->_pStatus, pOther->getKind()) <= 0) {
                        EffectExplosion001* pExplo001 = (EffectExplosion001*)P_COMMON_SCENE->_pDP_EffectExplosion001->employ();
                        if (pExplo001) {
                            pExplo001->activate();
                            pExplo001->locateAs(this);
                        }
                        sayonara();
                    //}
                }
                
                
                void MyShot001::drawHitArea() {
                    ColliAABActor::get()->drawHitarea(_pCollisionChecker); ColliAAPrismActor::get()->drawHitarea(_pCollisionChecker); ColliSphereActor::get()->drawHitarea(_pCollisionChecker);
                }
         450 -> MyShot001::~MyShot001() {
                }


Top 10 Lines:

     Line      Count

       66        450
        8        225

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      675   Total number of line executions
   225.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/my/MyStraightLaserChip001.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
                
          60 -> MyStraightLaserChip001::MyStraightLaserChip001(const char* prm_name) :
                        StraightLaserChip(prm_name, "MyCurveLaserChip001") {
                    _class_name = "MyStraightLaserChip001";
                    MyStgUtil::resetMyStraightLaserChip001Status(_pStatus);
                    _default_stamina = _pStatus->get(STAT_Stamina);
                    _veloMv = 100000;
                }
                
                void MyStraightLaserChip001::initialize() {
                    _pKuroko->setRzRyMvAng(0,0);
                    registHitAreaCube(60000);
                    setHitAble(true);
                    _SX = _SY = _SZ = 5 * 1000;
                    _fAlpha = 0.99;
                    _fBoundingSphereRadius = 20.0;
                }
                
                void MyStraightLaserChip001::processBehavior() {
                    StraightLaserChip::processBehavior();
                    //[U[\GW
                    if (onChangeToActive()) {
                        locateAs(P_MYSHIP);
                    }
                }
                
                void MyStraightLaserChip001::executeHitChk_MeAnd(GgafActor* prm_pOtherActor) {
                    if (((GgafMainActor*)prm_pOtherActor)->getKind() & KIND_CHIKEI) {
                        if (_chip_kind != 2 || _can_chikei_hit) {
                            GgafDx9DrawableActor::executeHitChk_MeAnd(prm_pOtherActor);
                        } else {
                            return;
                        }
                    } else {
                        GgafDx9DrawableActor::executeHitChk_MeAnd(prm_pOtherActor);
                    }
                }
                
                
                void MyStraightLaserChip001::onActive() {
                    StraightLaserChip::onActive();
                    _pKuroko->setMvVelo(80000);
                    _pKuroko->setMvAcce(300);
                    MyStgUtil::resetMyStraightLaserChip001Status(_pStatus);
                    _default_stamina = _pStatus->get(STAT_Stamina);
                }
                
                void MyStraightLaserChip001::onHit(GgafActor* prm_pOtherActor) {
                    GgafDx9GeometricActor* pOther = (GgafDx9GeometricActor*)prm_pOtherActor;
                
                
                    if ((pOther->getKind() & KIND_ENEMY_BODY) ) {
                        int stamina = MyStgUtil::calcMyStatus(_pStatus, getKind(), pOther->_pStatus, pOther->getKind());
                        if (stamina <= 0) {
                            //`bvU
                
                            //jGtFNg
                            EffectExplosion001* pExplo001 = (EffectExplosion001*)P_COMMON_SCENE->_pDP_EffectExplosion001->employ();
                            if (pExplo001) {
                                pExplo001->locateAs(this);
                                pExplo001->activate();
                            }
                            sayonara();
                        } else {
                            //AAX^~iiU100Gj
                            _pStatus->set(STAT_Stamina, _default_stamina);
                        }
                    } else if (pOther->getKind() & KIND_CHIKEI) {
                        //n`
                        //jGtFNg
                        EffectExplosion001* pExplo001 = (EffectExplosion001*)P_COMMON_SCENE->_pDP_EffectExplosion001->employ();
                        if (pExplo001) {
                            pExplo001->locateAs(this);
                            pExplo001->activate();
                        }
                        sayonara();
                    }
                
                }
                
                
         120 -> MyStraightLaserChip001::~MyStraightLaserChip001() {
                }
                


Top 10 Lines:

     Line      Count

       89        120
        9         60

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      180   Total number of line executions
    60.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/my/camera_worker/MyShipDivingCamWorker.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> MyShipDivingCamWorker::MyShipDivingCamWorker(const char* prm_name) : CameraWorker(prm_name) {
                    _class_name = "MyShipDivingCamWorker";
                //    _pMyShip = NULL; //MyShipScene
                }
                void MyShipDivingCamWorker::initialize() {
                }
                
           2 -> MyShipDivingCamWorker::~MyShipDivingCamWorker() {
                }


Top 10 Lines:

     Line      Count

       15          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:/Program Files/Microsoft DirectX SDK (February 2010)/Include/d3dx9math.h:
                //////////////////////////////////////////////////////////////////////////////
                //
                //  Copyright (C) Microsoft Corporation.  All Rights Reserved.
                //
                //  File:       d3dx9math.h
                //  Content:    D3DX math types and functions
                //
                //////////////////////////////////////////////////////////////////////////////
                
                #include "d3dx9.h"
                
                #ifndef __D3DX9MATH_H__
                #define __D3DX9MATH_H__
                
                #include <math.h>
                #if _MSC_VER >= 1200
                #pragma warning(push)
                #endif
                #pragma warning(disable:4201) // anonymous unions warning
                
                
                
                //===========================================================================
                //
                // General purpose utilities
                //
                //===========================================================================
                #define D3DX_PI    ((FLOAT)  3.141592654f)
                #define D3DX_1BYPI ((FLOAT)  0.318309886f)
                
                #define D3DXToRadian( degree ) ((degree) * (D3DX_PI / 180.0f))
                #define D3DXToDegree( radian ) ((radian) * (180.0f / D3DX_PI))
                
                
                
                //===========================================================================
                //
                // 16 bit floating point numbers
                //
                //===========================================================================
                
                #define D3DX_16F_DIG          3                // # of decimal digits of precision
                #define D3DX_16F_EPSILON      4.8875809e-4f    // smallest such that 1.0 + epsilon != 1.0
                #define D3DX_16F_MANT_DIG     11               // # of bits in mantissa
                #define D3DX_16F_MAX          6.550400e+004    // max value
                #define D3DX_16F_MAX_10_EXP   4                // max decimal exponent
                #define D3DX_16F_MAX_EXP      15               // max binary exponent
                #define D3DX_16F_MIN          6.1035156e-5f    // min positive value
                #define D3DX_16F_MIN_10_EXP   (-4)             // min decimal exponent
                #define D3DX_16F_MIN_EXP      (-14)            // min binary exponent
                #define D3DX_16F_RADIX        2                // exponent radix
                #define D3DX_16F_ROUNDS       1                // addition rounding: near
                
                
                typedef struct D3DXFLOAT16
                {
                #ifdef __cplusplus
                public:
                    D3DXFLOAT16() {};
                    D3DXFLOAT16( FLOAT );
                    D3DXFLOAT16( CONST D3DXFLOAT16& );
                
                    // casting
                    operator FLOAT ();
                
                    // binary operators
                    BOOL operator == ( CONST D3DXFLOAT16& ) const;
                    BOOL operator != ( CONST D3DXFLOAT16& ) const;
                
                protected:
                #endif //__cplusplus
                    WORD value;
                } D3DXFLOAT16, *LPD3DXFLOAT16;
                
                
                
                //===========================================================================
                //
                // Vectors
                //
                //===========================================================================
                
                
                //--------------------------
                // 2D Vector
                //--------------------------
                typedef struct D3DXVECTOR2
                {
                #ifdef __cplusplus
                public:
                    D3DXVECTOR2() {};
                    D3DXVECTOR2( CONST FLOAT * );
                    D3DXVECTOR2( CONST D3DXFLOAT16 * );
                    D3DXVECTOR2( FLOAT x, FLOAT y );
                
                    // casting
                    operator FLOAT* ();
                    operator CONST FLOAT* () const;
                
                    // assignment operators
                    D3DXVECTOR2& operator += ( CONST D3DXVECTOR2& );
                    D3DXVECTOR2& operator -= ( CONST D3DXVECTOR2& );
                    D3DXVECTOR2& operator *= ( FLOAT );
                    D3DXVECTOR2& operator /= ( FLOAT );
                
                    // unary operators
                    D3DXVECTOR2 operator + () const;
                    D3DXVECTOR2 operator - () const;
                
                    // binary operators
                    D3DXVECTOR2 operator + ( CONST D3DXVECTOR2& ) const;
                    D3DXVECTOR2 operator - ( CONST D3DXVECTOR2& ) const;
                    D3DXVECTOR2 operator * ( FLOAT ) const;
                    D3DXVECTOR2 operator / ( FLOAT ) const;
                
                    friend D3DXVECTOR2 operator * ( FLOAT, CONST D3DXVECTOR2& );
                
                    BOOL operator == ( CONST D3DXVECTOR2& ) const;
                    BOOL operator != ( CONST D3DXVECTOR2& ) const;
                
                
                public:
                #endif //__cplusplus
                    FLOAT x, y;
                } D3DXVECTOR2, *LPD3DXVECTOR2;
                
                
                
                //--------------------------
                // 2D Vector (16 bit)
                //--------------------------
                
                typedef struct D3DXVECTOR2_16F
                {
                #ifdef __cplusplus
                public:
                    D3DXVECTOR2_16F() {};
                    D3DXVECTOR2_16F( CONST FLOAT * );
                    D3DXVECTOR2_16F( CONST D3DXFLOAT16 * );
                    D3DXVECTOR2_16F( CONST D3DXFLOAT16 &x, CONST D3DXFLOAT16 &y );
                
                    // casting
                    operator D3DXFLOAT16* ();
                    operator CONST D3DXFLOAT16* () const;
                
                    // binary operators
                    BOOL operator == ( CONST D3DXVECTOR2_16F& ) const;
                    BOOL operator != ( CONST D3DXVECTOR2_16F& ) const;
                
                public:
                #endif //__cplusplus
                    D3DXFLOAT16 x, y;
                
                } D3DXVECTOR2_16F, *LPD3DXVECTOR2_16F;
                
                
                
                //--------------------------
                // 3D Vector
                //--------------------------
                #ifdef __cplusplus
                typedef struct D3DXVECTOR3 : public D3DVECTOR
                {
                public:
          35 ->     D3DXVECTOR3() {};
                    D3DXVECTOR3( CONST FLOAT * );
                    D3DXVECTOR3( CONST D3DVECTOR& );
                    D3DXVECTOR3( CONST D3DXFLOAT16 * );
                    D3DXVECTOR3( FLOAT x, FLOAT y, FLOAT z );
                
                    // casting
                    operator FLOAT* ();
                    operator CONST FLOAT* () const;
                
                    // assignment operators
                    D3DXVECTOR3& operator += ( CONST D3DXVECTOR3& );
                    D3DXVECTOR3& operator -= ( CONST D3DXVECTOR3& );
                    D3DXVECTOR3& operator *= ( FLOAT );
                    D3DXVECTOR3& operator /= ( FLOAT );
                
                    // unary operators
                    D3DXVECTOR3 operator + () const;
                    D3DXVECTOR3 operator - () const;
                
                    // binary operators
                    D3DXVECTOR3 operator + ( CONST D3DXVECTOR3& ) const;
                    D3DXVECTOR3 operator - ( CONST D3DXVECTOR3& ) const;
                    D3DXVECTOR3 operator * ( FLOAT ) const;
                    D3DXVECTOR3 operator / ( FLOAT ) const;
                
                    friend D3DXVECTOR3 operator * ( FLOAT, CONST struct D3DXVECTOR3& );
                
                    BOOL operator == ( CONST D3DXVECTOR3& ) const;
                    BOOL operator != ( CONST D3DXVECTOR3& ) const;
                
                } D3DXVECTOR3, *LPD3DXVECTOR3;
                
                #else //!__cplusplus
                typedef struct _D3DVECTOR D3DXVECTOR3, *LPD3DXVECTOR3;
                #endif //!__cplusplus
                
                
                
                //--------------------------
                // 3D Vector (16 bit)
                //--------------------------
                typedef struct D3DXVECTOR3_16F
                {
                #ifdef __cplusplus
                public:
                    D3DXVECTOR3_16F() {};
                    D3DXVECTOR3_16F( CONST FLOAT * );
                    D3DXVECTOR3_16F( CONST D3DVECTOR& );
                    D3DXVECTOR3_16F( CONST D3DXFLOAT16 * );
                    D3DXVECTOR3_16F( CONST D3DXFLOAT16 &x, CONST D3DXFLOAT16 &y, CONST D3DXFLOAT16 &z );
                
                    // casting
                    operator D3DXFLOAT16* ();
                    operator CONST D3DXFLOAT16* () const;
                
                    // binary operators
                    BOOL operator == ( CONST D3DXVECTOR3_16F& ) const;
                    BOOL operator != ( CONST D3DXVECTOR3_16F& ) const;
                
                public:
                #endif //__cplusplus
                    D3DXFLOAT16 x, y, z;
                
                } D3DXVECTOR3_16F, *LPD3DXVECTOR3_16F;
                
                
                
                //--------------------------
                // 4D Vector
                //--------------------------
                typedef struct D3DXVECTOR4
                {
                #ifdef __cplusplus
                public:
                    D3DXVECTOR4() {};
                    D3DXVECTOR4( CONST FLOAT* );
                    D3DXVECTOR4( CONST D3DXFLOAT16* );
                    D3DXVECTOR4( CONST D3DVECTOR& xyz, FLOAT w );
                    D3DXVECTOR4( FLOAT x, FLOAT y, FLOAT z, FLOAT w );
                
                    // casting
                    operator FLOAT* ();
                    operator CONST FLOAT* () const;
                
                    // assignment operators
                    D3DXVECTOR4& operator += ( CONST D3DXVECTOR4& );
                    D3DXVECTOR4& operator -= ( CONST D3DXVECTOR4& );
                    D3DXVECTOR4& operator *= ( FLOAT );
                    D3DXVECTOR4& operator /= ( FLOAT );
                
                    // unary operators
                    D3DXVECTOR4 operator + () const;
                    D3DXVECTOR4 operator - () const;
                
                    // binary operators
                    D3DXVECTOR4 operator + ( CONST D3DXVECTOR4& ) const;
                    D3DXVECTOR4 operator - ( CONST D3DXVECTOR4& ) const;
                    D3DXVECTOR4 operator * ( FLOAT ) const;
                    D3DXVECTOR4 operator / ( FLOAT ) const;
                
                    friend D3DXVECTOR4 operator * ( FLOAT, CONST D3DXVECTOR4& );
                
                    BOOL operator == ( CONST D3DXVECTOR4& ) const;
                    BOOL operator != ( CONST D3DXVECTOR4& ) const;
                
                public:
                #endif //__cplusplus
                    FLOAT x, y, z, w;
                } D3DXVECTOR4, *LPD3DXVECTOR4;
                
                
                //--------------------------
                // 4D Vector (16 bit)
                //--------------------------
                typedef struct D3DXVECTOR4_16F
                {
                #ifdef __cplusplus
                public:
                    D3DXVECTOR4_16F() {};
                    D3DXVECTOR4_16F( CONST FLOAT * );
                    D3DXVECTOR4_16F( CONST D3DXFLOAT16* );
                    D3DXVECTOR4_16F( CONST D3DXVECTOR3_16F& xyz, CONST D3DXFLOAT16& w );
                    D3DXVECTOR4_16F( CONST D3DXFLOAT16& x, CONST D3DXFLOAT16& y, CONST D3DXFLOAT16& z, CONST D3DXFLOAT16& w );
                
                    // casting
                    operator D3DXFLOAT16* ();
                    operator CONST D3DXFLOAT16* () const;
                
                    // binary operators
                    BOOL operator == ( CONST D3DXVECTOR4_16F& ) const;
                    BOOL operator != ( CONST D3DXVECTOR4_16F& ) const;
                
                public:
                #endif //__cplusplus
                    D3DXFLOAT16 x, y, z, w;
                
                } D3DXVECTOR4_16F, *LPD3DXVECTOR4_16F;
                
                
                
                //===========================================================================
                //
                // Matrices
                //
                //===========================================================================
                #ifdef __cplusplus
                typedef struct D3DXMATRIX : public D3DMATRIX
                {
                public:
       14098 ->     D3DXMATRIX() {};
                    D3DXMATRIX( CONST FLOAT * );
                    D3DXMATRIX( CONST D3DMATRIX& );
                    D3DXMATRIX( CONST D3DXFLOAT16 * );
                    D3DXMATRIX( FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,
                                FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,
                                FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,
                                FLOAT _41, FLOAT _42, FLOAT _43, FLOAT _44 );
                
                
                    // access grants
                    FLOAT& operator () ( UINT Row, UINT Col );
                    FLOAT  operator () ( UINT Row, UINT Col ) const;
                
                    // casting operators
                    operator FLOAT* ();
                    operator CONST FLOAT* () const;
                
                    // assignment operators
                    D3DXMATRIX& operator *= ( CONST D3DXMATRIX& );
                    D3DXMATRIX& operator += ( CONST D3DXMATRIX& );
                    D3DXMATRIX& operator -= ( CONST D3DXMATRIX& );
                    D3DXMATRIX& operator *= ( FLOAT );
                    D3DXMATRIX& operator /= ( FLOAT );
                
                    // unary operators
                    D3DXMATRIX operator + () const;
                    D3DXMATRIX operator - () const;
                
                    // binary operators
                    D3DXMATRIX operator * ( CONST D3DXMATRIX& ) const;
                    D3DXMATRIX operator + ( CONST D3DXMATRIX& ) const;
                    D3DXMATRIX operator - ( CONST D3DXMATRIX& ) const;
                    D3DXMATRIX operator * ( FLOAT ) const;
                    D3DXMATRIX operator / ( FLOAT ) const;
                
                    friend D3DXMATRIX operator * ( FLOAT, CONST D3DXMATRIX& );
                
                    BOOL operator == ( CONST D3DXMATRIX& ) const;
                    BOOL operator != ( CONST D3DXMATRIX& ) const;
                
                } D3DXMATRIX, *LPD3DXMATRIX;
                
                #else //!__cplusplus
                typedef struct _D3DMATRIX D3DXMATRIX, *LPD3DXMATRIX;
                #endif //!__cplusplus
                
                
                //---------------------------------------------------------------------------
                // Aligned Matrices
                //
                // This class helps keep matrices 16-byte aligned as preferred by P4 cpus.
                // It aligns matrices on the stack and on the heap or in global scope.
                // It does this using __declspec(align(16)) which works on VC7 and on VC 6
                // with the processor pack. Unfortunately there is no way to detect the 
                // latter so this is turned on only on VC7. On other compilers this is the
                // the same as D3DXMATRIX.
                //
                // Using this class on a compiler that does not actually do the alignment
                // can be dangerous since it will not expose bugs that ignore alignment.
                // E.g if an object of this class in inside a struct or class, and some code
                // memcopys data in it assuming tight packing. This could break on a compiler
                // that eventually start aligning the matrix.
                //---------------------------------------------------------------------------
                #ifdef __cplusplus
                typedef struct _D3DXMATRIXA16 : public D3DXMATRIX
                {
                    _D3DXMATRIXA16() {}
                    _D3DXMATRIXA16( CONST FLOAT * );
                    _D3DXMATRIXA16( CONST D3DMATRIX& );
                    _D3DXMATRIXA16( CONST D3DXFLOAT16 * );
                    _D3DXMATRIXA16( FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,
                                    FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,
                                    FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,
                                    FLOAT _41, FLOAT _42, FLOAT _43, FLOAT _44 );
                
                    // new operators
                    void* operator new   ( size_t );
                    void* operator new[] ( size_t );
                
                    // delete operators
                    void operator delete   ( void* );   // These are NOT virtual; Do not 
                    void operator delete[] ( void* );   // cast to D3DXMATRIX and delete.
                    
                    // assignment operators
                    _D3DXMATRIXA16& operator = ( CONST D3DXMATRIX& );
                
                } _D3DXMATRIXA16;
                
                #else //!__cplusplus
                typedef D3DXMATRIX  _D3DXMATRIXA16;
                #endif //!__cplusplus
                
                
                
                #if _MSC_VER >= 1300  // VC7
                #define D3DX_ALIGN16 __declspec(align(16))
                #else
                #define D3DX_ALIGN16  // Earlier compiler may not understand this, do nothing.
                #endif
                
                typedef D3DX_ALIGN16 _D3DXMATRIXA16 D3DXMATRIXA16, *LPD3DXMATRIXA16;
                
                
                
                //===========================================================================
                //
                //    Quaternions
                //
                //===========================================================================
                typedef struct D3DXQUATERNION
                {
                #ifdef __cplusplus
                public:
                    D3DXQUATERNION() {}
                    D3DXQUATERNION( CONST FLOAT * );
                    D3DXQUATERNION( CONST D3DXFLOAT16 * );
                    D3DXQUATERNION( FLOAT x, FLOAT y, FLOAT z, FLOAT w );
                
                    // casting
                    operator FLOAT* ();
                    operator CONST FLOAT* () const;
                
                    // assignment operators
                    D3DXQUATERNION& operator += ( CONST D3DXQUATERNION& );
                    D3DXQUATERNION& operator -= ( CONST D3DXQUATERNION& );
                    D3DXQUATERNION& operator *= ( CONST D3DXQUATERNION& );
                    D3DXQUATERNION& operator *= ( FLOAT );
                    D3DXQUATERNION& operator /= ( FLOAT );
                
                    // unary operators
                    D3DXQUATERNION  operator + () const;
                    D3DXQUATERNION  operator - () const;
                
                    // binary operators
                    D3DXQUATERNION operator + ( CONST D3DXQUATERNION& ) const;
                    D3DXQUATERNION operator - ( CONST D3DXQUATERNION& ) const;
                    D3DXQUATERNION operator * ( CONST D3DXQUATERNION& ) const;
                    D3DXQUATERNION operator * ( FLOAT ) const;
                    D3DXQUATERNION operator / ( FLOAT ) const;
                
                    friend D3DXQUATERNION operator * (FLOAT, CONST D3DXQUATERNION& );
                
                    BOOL operator == ( CONST D3DXQUATERNION& ) const;
                    BOOL operator != ( CONST D3DXQUATERNION& ) const;
                
                #endif //__cplusplus
                    FLOAT x, y, z, w;
                } D3DXQUATERNION, *LPD3DXQUATERNION;
                
                
                //===========================================================================
                //
                // Planes
                //
                //===========================================================================
                typedef struct D3DXPLANE
                {
                #ifdef __cplusplus
                public:
        2263 ->     D3DXPLANE() {}
                    D3DXPLANE( CONST FLOAT* );
                    D3DXPLANE( CONST D3DXFLOAT16* );
                    D3DXPLANE( FLOAT a, FLOAT b, FLOAT c, FLOAT d );
                
                    // casting
                    operator FLOAT* ();
                    operator CONST FLOAT* () const;
                
                    // assignment operators
                    D3DXPLANE& operator *= ( FLOAT );
                    D3DXPLANE& operator /= ( FLOAT );
                
                    // unary operators
                    D3DXPLANE operator + () const;
                    D3DXPLANE operator - () const;
                
                    // binary operators
                    D3DXPLANE operator * ( FLOAT ) const;
                    D3DXPLANE operator / ( FLOAT ) const;
                
                    friend D3DXPLANE operator * ( FLOAT, CONST D3DXPLANE& );
                
                    BOOL operator == ( CONST D3DXPLANE& ) const;
                    BOOL operator != ( CONST D3DXPLANE& ) const;
                
                #endif //__cplusplus
                    FLOAT a, b, c, d;
                } D3DXPLANE, *LPD3DXPLANE;
                
                
                //===========================================================================
                //
                // Colors
                //
                //===========================================================================
                
                typedef struct D3DXCOLOR
                {
                #ifdef __cplusplus
                public:
                    D3DXCOLOR() {}
                    D3DXCOLOR( DWORD argb );
                    D3DXCOLOR( CONST FLOAT * );
                    D3DXCOLOR( CONST D3DXFLOAT16 * );
                    D3DXCOLOR( CONST D3DCOLORVALUE& );
                    D3DXCOLOR( FLOAT r, FLOAT g, FLOAT b, FLOAT a );
                
                    // casting
                    operator DWORD () const;
                
                    operator FLOAT* ();
                    operator CONST FLOAT* () const;
                
                    operator D3DCOLORVALUE* ();
                    operator CONST D3DCOLORVALUE* () const;
                
                    operator D3DCOLORVALUE& ();
                    operator CONST D3DCOLORVALUE& () const;
                
                    // assignment operators
                    D3DXCOLOR& operator += ( CONST D3DXCOLOR& );
                    D3DXCOLOR& operator -= ( CONST D3DXCOLOR& );
                    D3DXCOLOR& operator *= ( FLOAT );
                    D3DXCOLOR& operator /= ( FLOAT );
                
                    // unary operators
                    D3DXCOLOR operator + () const;
                    D3DXCOLOR operator - () const;
                
                    // binary operators
                    D3DXCOLOR operator + ( CONST D3DXCOLOR& ) const;
                    D3DXCOLOR operator - ( CONST D3DXCOLOR& ) const;
                    D3DXCOLOR operator * ( FLOAT ) const;
                    D3DXCOLOR operator / ( FLOAT ) const;
                
                    friend D3DXCOLOR operator * ( FLOAT, CONST D3DXCOLOR& );
                
                    BOOL operator == ( CONST D3DXCOLOR& ) const;
                    BOOL operator != ( CONST D3DXCOLOR& ) const;
                
                #endif //__cplusplus
                    FLOAT r, g, b, a;
                } D3DXCOLOR, *LPD3DXCOLOR;
                
                
                
                //===========================================================================
                //
                // D3DX math functions:
                //
                // NOTE:
                //  * All these functions can take the same object as in and out parameters.
                //
                //  * Out parameters are typically also returned as return values, so that
                //    the output of one function may be used as a parameter to another.
                //
                //===========================================================================
                
                //--------------------------
                // Float16
                //--------------------------
                
                // non-inline
                #ifdef __cplusplus
                extern "C" {
                #endif
                
                // Converts an array 32-bit floats to 16-bit floats
                D3DXFLOAT16* WINAPI D3DXFloat32To16Array
                    ( D3DXFLOAT16 *pOut, CONST FLOAT *pIn, UINT n );
                
                // Converts an array 16-bit floats to 32-bit floats
                FLOAT* WINAPI D3DXFloat16To32Array
                    ( FLOAT *pOut, CONST D3DXFLOAT16 *pIn, UINT n );
                
                #ifdef __cplusplus
                }
                #endif
                
                
                //--------------------------
                // 2D Vector
                //--------------------------
                
                // inline
                
                FLOAT D3DXVec2Length
                    ( CONST D3DXVECTOR2 *pV );
                
                FLOAT D3DXVec2LengthSq
                    ( CONST D3DXVECTOR2 *pV );
                
                FLOAT D3DXVec2Dot
                    ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );
                
                // Z component of ((x1,y1,0) cross (x2,y2,0))
                FLOAT D3DXVec2CCW
                    ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );
                
                D3DXVECTOR2* D3DXVec2Add
                    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );
                
                D3DXVECTOR2* D3DXVec2Subtract
                    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );
                
                // Minimize each component.  x = min(x1, x2), y = min(y1, y2)
                D3DXVECTOR2* D3DXVec2Minimize
                    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );
                
                // Maximize each component.  x = max(x1, x2), y = max(y1, y2)
                D3DXVECTOR2* D3DXVec2Maximize
                    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );
                
                D3DXVECTOR2* D3DXVec2Scale
                    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s );
                
                // Linear interpolation. V1 + s(V2-V1)
                D3DXVECTOR2* D3DXVec2Lerp
                    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
                      FLOAT s );
                
                // non-inline
                #ifdef __cplusplus
                extern "C" {
                #endif
                
                D3DXVECTOR2* WINAPI D3DXVec2Normalize
                    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV );
                
                // Hermite interpolation between position V1, tangent T1 (when s == 0)
                // and position V2, tangent T2 (when s == 1).
                D3DXVECTOR2* WINAPI D3DXVec2Hermite
                    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pT1,
                      CONST D3DXVECTOR2 *pV2, CONST D3DXVECTOR2 *pT2, FLOAT s );
                
                // CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
                D3DXVECTOR2* WINAPI D3DXVec2CatmullRom
                    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV0, CONST D3DXVECTOR2 *pV1,
                      CONST D3DXVECTOR2 *pV2, CONST D3DXVECTOR2 *pV3, FLOAT s );
                
                // Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
                D3DXVECTOR2* WINAPI D3DXVec2BaryCentric
                    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
                      CONST D3DXVECTOR2 *pV3, FLOAT f, FLOAT g);
                
                // Transform (x, y, 0, 1) by matrix.
                D3DXVECTOR4* WINAPI D3DXVec2Transform
                    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );
                
                // Transform (x, y, 0, 1) by matrix, project result back into w=1.
                D3DXVECTOR2* WINAPI D3DXVec2TransformCoord
                    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );
                
                // Transform (x, y, 0, 0) by matrix.
                D3DXVECTOR2* WINAPI D3DXVec2TransformNormal
                    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );
                     
                // Transform Array (x, y, 0, 1) by matrix.
                D3DXVECTOR4* WINAPI D3DXVec2TransformArray
                    ( D3DXVECTOR4 *pOut, UINT OutStride, CONST D3DXVECTOR2 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n);
                
                // Transform Array (x, y, 0, 1) by matrix, project result back into w=1.
                D3DXVECTOR2* WINAPI D3DXVec2TransformCoordArray
                    ( D3DXVECTOR2 *pOut, UINT OutStride, CONST D3DXVECTOR2 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n );
                
                // Transform Array (x, y, 0, 0) by matrix.
                D3DXVECTOR2* WINAPI D3DXVec2TransformNormalArray
                    ( D3DXVECTOR2 *pOut, UINT OutStride, CONST D3DXVECTOR2 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n );
                    
                    
                
                #ifdef __cplusplus
                }
                #endif
                
                
                //--------------------------
                // 3D Vector
                //--------------------------
                
                // inline
                
                FLOAT D3DXVec3Length
                    ( CONST D3DXVECTOR3 *pV );
                
                FLOAT D3DXVec3LengthSq
                    ( CONST D3DXVECTOR3 *pV );
                
                FLOAT D3DXVec3Dot
                    ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );
                
                D3DXVECTOR3* D3DXVec3Cross
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );
                
                D3DXVECTOR3* D3DXVec3Add
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );
                
                D3DXVECTOR3* D3DXVec3Subtract
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );
                
                // Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
                D3DXVECTOR3* D3DXVec3Minimize
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );
                
                // Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
                D3DXVECTOR3* D3DXVec3Maximize
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );
                
                D3DXVECTOR3* D3DXVec3Scale
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, FLOAT s);
                
                // Linear interpolation. V1 + s(V2-V1)
                D3DXVECTOR3* D3DXVec3Lerp
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
                      FLOAT s );
                
                // non-inline
                #ifdef __cplusplus
                extern "C" {
                #endif
                
                D3DXVECTOR3* WINAPI D3DXVec3Normalize
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV );
                
                // Hermite interpolation between position V1, tangent T1 (when s == 0)
                // and position V2, tangent T2 (when s == 1).
                D3DXVECTOR3* WINAPI D3DXVec3Hermite
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pT1,
                      CONST D3DXVECTOR3 *pV2, CONST D3DXVECTOR3 *pT2, FLOAT s );
                
                // CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
                D3DXVECTOR3* WINAPI D3DXVec3CatmullRom
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV0, CONST D3DXVECTOR3 *pV1,
                      CONST D3DXVECTOR3 *pV2, CONST D3DXVECTOR3 *pV3, FLOAT s );
                
                // Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
                D3DXVECTOR3* WINAPI D3DXVec3BaryCentric
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
                      CONST D3DXVECTOR3 *pV3, FLOAT f, FLOAT g);
                
                // Transform (x, y, z, 1) by matrix.
                D3DXVECTOR4* WINAPI D3DXVec3Transform
                    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );
                
                // Transform (x, y, z, 1) by matrix, project result back into w=1.
                D3DXVECTOR3* WINAPI D3DXVec3TransformCoord
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );
                
                // Transform (x, y, z, 0) by matrix.  If you transforming a normal by a 
                // non-affine matrix, the matrix you pass to this function should be the 
                // transpose of the inverse of the matrix you would use to transform a coord.
                D3DXVECTOR3* WINAPI D3DXVec3TransformNormal
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );
                    
                    
                // Transform Array (x, y, z, 1) by matrix. 
                D3DXVECTOR4* WINAPI D3DXVec3TransformArray
                    ( D3DXVECTOR4 *pOut, UINT OutStride, CONST D3DXVECTOR3 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n );
                
                // Transform Array (x, y, z, 1) by matrix, project result back into w=1.
                D3DXVECTOR3* WINAPI D3DXVec3TransformCoordArray
                    ( D3DXVECTOR3 *pOut, UINT OutStride, CONST D3DXVECTOR3 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n );
                
                // Transform (x, y, z, 0) by matrix.  If you transforming a normal by a 
                // non-affine matrix, the matrix you pass to this function should be the 
                // transpose of the inverse of the matrix you would use to transform a coord.
                D3DXVECTOR3* WINAPI D3DXVec3TransformNormalArray
                    ( D3DXVECTOR3 *pOut, UINT OutStride, CONST D3DXVECTOR3 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n );
                
                // Project vector from object space into screen space
                D3DXVECTOR3* WINAPI D3DXVec3Project
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DVIEWPORT9 *pViewport,
                      CONST D3DXMATRIX *pProjection, CONST D3DXMATRIX *pView, CONST D3DXMATRIX *pWorld);
                
                // Project vector from screen space into object space
                D3DXVECTOR3* WINAPI D3DXVec3Unproject
                    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DVIEWPORT9 *pViewport,
                      CONST D3DXMATRIX *pProjection, CONST D3DXMATRIX *pView, CONST D3DXMATRIX *pWorld);
                      
                // Project vector Array from object space into screen space
                D3DXVECTOR3* WINAPI D3DXVec3ProjectArray
                    ( D3DXVECTOR3 *pOut, UINT OutStride,CONST D3DXVECTOR3 *pV, UINT VStride,CONST D3DVIEWPORT9 *pViewport,
                      CONST D3DXMATRIX *pProjection, CONST D3DXMATRIX *pView, CONST D3DXMATRIX *pWorld, UINT n);
                
                // Project vector Array from screen space into object space
                D3DXVECTOR3* WINAPI D3DXVec3UnprojectArray
                    ( D3DXVECTOR3 *pOut, UINT OutStride, CONST D3DXVECTOR3 *pV, UINT VStride, CONST D3DVIEWPORT9 *pViewport,
                      CONST D3DXMATRIX *pProjection, CONST D3DXMATRIX *pView, CONST D3DXMATRIX *pWorld, UINT n);
                
                
                #ifdef __cplusplus
                }
                #endif
                
                
                
                //--------------------------
                // 4D Vector
                //--------------------------
                
                // inline
                
                FLOAT D3DXVec4Length
                    ( CONST D3DXVECTOR4 *pV );
                
                FLOAT D3DXVec4LengthSq
                    ( CONST D3DXVECTOR4 *pV );
                
                FLOAT D3DXVec4Dot
                    ( CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2 );
                
                D3DXVECTOR4* D3DXVec4Add
                    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);
                
                D3DXVECTOR4* D3DXVec4Subtract
                    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);
                
                // Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
                D3DXVECTOR4* D3DXVec4Minimize
                    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);
                
                // Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
                D3DXVECTOR4* D3DXVec4Maximize
                    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);
                
                D3DXVECTOR4* D3DXVec4Scale
                    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV, FLOAT s);
                
                // Linear interpolation. V1 + s(V2-V1)
                D3DXVECTOR4* D3DXVec4Lerp
                    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
                      FLOAT s );
                
                // non-inline
                #ifdef __cplusplus
                extern "C" {
                #endif
                
                // Cross-product in 4 dimensions.
                D3DXVECTOR4* WINAPI D3DXVec4Cross
                    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
                      CONST D3DXVECTOR4 *pV3);
                
                D3DXVECTOR4* WINAPI D3DXVec4Normalize
                    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV );
                
                // Hermite interpolation between position V1, tangent T1 (when s == 0)
                // and position V2, tangent T2 (when s == 1).
                D3DXVECTOR4* WINAPI D3DXVec4Hermite
                    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pT1,
                      CONST D3DXVECTOR4 *pV2, CONST D3DXVECTOR4 *pT2, FLOAT s );
                
                // CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
                D3DXVECTOR4* WINAPI D3DXVec4CatmullRom
                    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV0, CONST D3DXVECTOR4 *pV1,
                      CONST D3DXVECTOR4 *pV2, CONST D3DXVECTOR4 *pV3, FLOAT s );
                
                // Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
                D3DXVECTOR4* WINAPI D3DXVec4BaryCentric
                    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
                      CONST D3DXVECTOR4 *pV3, FLOAT f, FLOAT g);
                
                // Transform vector by matrix.
                D3DXVECTOR4* WINAPI D3DXVec4Transform
                    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV, CONST D3DXMATRIX *pM );
                    
                // Transform vector array by matrix.
                D3DXVECTOR4* WINAPI D3DXVec4TransformArray
                    ( D3DXVECTOR4 *pOut, UINT OutStride, CONST D3DXVECTOR4 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n );
                
                #ifdef __cplusplus
                }
                #endif
                
                
                //--------------------------
                // 4D Matrix
                //--------------------------
                
                // inline
                
                D3DXMATRIX* D3DXMatrixIdentity
                    ( D3DXMATRIX *pOut );
                
                BOOL D3DXMatrixIsIdentity
                    ( CONST D3DXMATRIX *pM );
                
                
                // non-inline
                #ifdef __cplusplus
                extern "C" {
                #endif
                
                FLOAT WINAPI D3DXMatrixDeterminant
                    ( CONST D3DXMATRIX *pM );
                
                HRESULT WINAPI D3DXMatrixDecompose
                    ( D3DXVECTOR3 *pOutScale, D3DXQUATERNION *pOutRotation, 
                	  D3DXVECTOR3 *pOutTranslation, CONST D3DXMATRIX *pM );
                
                D3DXMATRIX* WINAPI D3DXMatrixTranspose
                    ( D3DXMATRIX *pOut, CONST D3DXMATRIX *pM );
                
                // Matrix multiplication.  The result represents the transformation M2
                // followed by the transformation M1.  (Out = M1 * M2)
                D3DXMATRIX* WINAPI D3DXMatrixMultiply
                    ( D3DXMATRIX *pOut, CONST D3DXMATRIX *pM1, CONST D3DXMATRIX *pM2 );
                
                // Matrix multiplication, followed by a transpose. (Out = T(M1 * M2))
                D3DXMATRIX* WINAPI D3DXMatrixMultiplyTranspose
                    ( D3DXMATRIX *pOut, CONST D3DXMATRIX *pM1, CONST D3DXMATRIX *pM2 );
                
                // Calculate inverse of matrix.  Inversion my fail, in which case NULL will
                // be returned.  The determinant of pM is also returned it pfDeterminant
                // is non-NULL.
                D3DXMATRIX* WINAPI D3DXMatrixInverse
                    ( D3DXMATRIX *pOut, FLOAT *pDeterminant, CONST D3DXMATRIX *pM );
                
                // Build a matrix which scales by (sx, sy, sz)
                D3DXMATRIX* WINAPI D3DXMatrixScaling
                    ( D3DXMATRIX *pOut, FLOAT sx, FLOAT sy, FLOAT sz );
                
                // Build a matrix which translates by (x, y, z)
                D3DXMATRIX* WINAPI D3DXMatrixTranslation
                    ( D3DXMATRIX *pOut, FLOAT x, FLOAT y, FLOAT z );
                
                // Build a matrix which rotates around the X axis
                D3DXMATRIX* WINAPI D3DXMatrixRotationX
                    ( D3DXMATRIX *pOut, FLOAT Angle );
                
                // Build a matrix which rotates around the Y axis
                D3DXMATRIX* WINAPI D3DXMatrixRotationY
                    ( D3DXMATRIX *pOut, FLOAT Angle );
                
                // Build a matrix which rotates around the Z axis
                D3DXMATRIX* WINAPI D3DXMatrixRotationZ
                    ( D3DXMATRIX *pOut, FLOAT Angle );
                
                // Build a matrix which rotates around an arbitrary axis
                D3DXMATRIX* WINAPI D3DXMatrixRotationAxis
                    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pV, FLOAT Angle );
                
                // Build a matrix from a quaternion
                D3DXMATRIX* WINAPI D3DXMatrixRotationQuaternion
                    ( D3DXMATRIX *pOut, CONST D3DXQUATERNION *pQ);
                
                // Yaw around the Y axis, a pitch around the X axis,
                // and a roll around the Z axis.
                D3DXMATRIX* WINAPI D3DXMatrixRotationYawPitchRoll
                    ( D3DXMATRIX *pOut, FLOAT Yaw, FLOAT Pitch, FLOAT Roll );
                
                // Build transformation matrix.  NULL arguments are treated as identity.
                // Mout = Msc-1 * Msr-1 * Ms * Msr * Msc * Mrc-1 * Mr * Mrc * Mt
                D3DXMATRIX* WINAPI D3DXMatrixTransformation
                    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pScalingCenter,
                      CONST D3DXQUATERNION *pScalingRotation, CONST D3DXVECTOR3 *pScaling,
                      CONST D3DXVECTOR3 *pRotationCenter, CONST D3DXQUATERNION *pRotation,
                      CONST D3DXVECTOR3 *pTranslation);
                
                // Build 2D transformation matrix in XY plane.  NULL arguments are treated as identity.
                // Mout = Msc-1 * Msr-1 * Ms * Msr * Msc * Mrc-1 * Mr * Mrc * Mt
                D3DXMATRIX* WINAPI D3DXMatrixTransformation2D
                    ( D3DXMATRIX *pOut, CONST D3DXVECTOR2* pScalingCenter, 
                      FLOAT ScalingRotation, CONST D3DXVECTOR2* pScaling, 
                      CONST D3DXVECTOR2* pRotationCenter, FLOAT Rotation, 
                      CONST D3DXVECTOR2* pTranslation);
                
                // Build affine transformation matrix.  NULL arguments are treated as identity.
                // Mout = Ms * Mrc-1 * Mr * Mrc * Mt
                D3DXMATRIX* WINAPI D3DXMatrixAffineTransformation
                    ( D3DXMATRIX *pOut, FLOAT Scaling, CONST D3DXVECTOR3 *pRotationCenter,
                      CONST D3DXQUATERNION *pRotation, CONST D3DXVECTOR3 *pTranslation);
                
                // Build 2D affine transformation matrix in XY plane.  NULL arguments are treated as identity.
                // Mout = Ms * Mrc-1 * Mr * Mrc * Mt
                D3DXMATRIX* WINAPI D3DXMatrixAffineTransformation2D
                    ( D3DXMATRIX *pOut, FLOAT Scaling, CONST D3DXVECTOR2* pRotationCenter, 
                      FLOAT Rotation, CONST D3DXVECTOR2* pTranslation);
                
                // Build a lookat matrix. (right-handed)
                D3DXMATRIX* WINAPI D3DXMatrixLookAtRH
                    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pEye, CONST D3DXVECTOR3 *pAt,
                      CONST D3DXVECTOR3 *pUp );
                
                // Build a lookat matrix. (left-handed)
                D3DXMATRIX* WINAPI D3DXMatrixLookAtLH
                    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pEye, CONST D3DXVECTOR3 *pAt,
                      CONST D3DXVECTOR3 *pUp );
                
                // Build a perspective projection matrix. (right-handed)
                D3DXMATRIX* WINAPI D3DXMatrixPerspectiveRH
                    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );
                
                // Build a perspective projection matrix. (left-handed)
                D3DXMATRIX* WINAPI D3DXMatrixPerspectiveLH
                    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );
                
                // Build a perspective projection matrix. (right-handed)
                D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFovRH
                    ( D3DXMATRIX *pOut, FLOAT fovy, FLOAT Aspect, FLOAT zn, FLOAT zf );
                
                // Build a perspective projection matrix. (left-handed)
                D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFovLH
                    ( D3DXMATRIX *pOut, FLOAT fovy, FLOAT Aspect, FLOAT zn, FLOAT zf );
                
                // Build a perspective projection matrix. (right-handed)
                D3DXMATRIX* WINAPI D3DXMatrixPerspectiveOffCenterRH
                    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
                      FLOAT zf );
                
                // Build a perspective projection matrix. (left-handed)
                D3DXMATRIX* WINAPI D3DXMatrixPerspectiveOffCenterLH
                    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
                      FLOAT zf );
                
                // Build an ortho projection matrix. (right-handed)
                D3DXMATRIX* WINAPI D3DXMatrixOrthoRH
                    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );
                
                // Build an ortho projection matrix. (left-handed)
                D3DXMATRIX* WINAPI D3DXMatrixOrthoLH
                    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );
                
                // Build an ortho projection matrix. (right-handed)
                D3DXMATRIX* WINAPI D3DXMatrixOrthoOffCenterRH
                    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
                      FLOAT zf );
                
                // Build an ortho projection matrix. (left-handed)
                D3DXMATRIX* WINAPI D3DXMatrixOrthoOffCenterLH
                    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
                      FLOAT zf );
                
                // Build a matrix which flattens geometry into a plane, as if casting
                // a shadow from a light.
                D3DXMATRIX* WINAPI D3DXMatrixShadow
                    ( D3DXMATRIX *pOut, CONST D3DXVECTOR4 *pLight,
                      CONST D3DXPLANE *pPlane );
                
                // Build a matrix which reflects the coordinate system about a plane
                D3DXMATRIX* WINAPI D3DXMatrixReflect
                    ( D3DXMATRIX *pOut, CONST D3DXPLANE *pPlane );
                
                #ifdef __cplusplus
                }
                #endif
                
                
                //--------------------------
                // Quaternion
                //--------------------------
                
                // inline
                
                FLOAT D3DXQuaternionLength
                    ( CONST D3DXQUATERNION *pQ );
                
                // Length squared, or "norm"
                FLOAT D3DXQuaternionLengthSq
                    ( CONST D3DXQUATERNION *pQ );
                
                FLOAT D3DXQuaternionDot
                    ( CONST D3DXQUATERNION *pQ1, CONST D3DXQUATERNION *pQ2 );
                
                // (0, 0, 0, 1)
                D3DXQUATERNION* D3DXQuaternionIdentity
                    ( D3DXQUATERNION *pOut );
                
                BOOL D3DXQuaternionIsIdentity
                    ( CONST D3DXQUATERNION *pQ );
                
                // (-x, -y, -z, w)
                D3DXQUATERNION* D3DXQuaternionConjugate
                    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );
                
                
                // non-inline
                #ifdef __cplusplus
                extern "C" {
                #endif
                
                // Compute a quaternin's axis and angle of rotation. Expects unit quaternions.
                void WINAPI D3DXQuaternionToAxisAngle
                    ( CONST D3DXQUATERNION *pQ, D3DXVECTOR3 *pAxis, FLOAT *pAngle );
                
                // Build a quaternion from a rotation matrix.
                D3DXQUATERNION* WINAPI D3DXQuaternionRotationMatrix
                    ( D3DXQUATERNION *pOut, CONST D3DXMATRIX *pM);
                
                // Rotation about arbitrary axis.
                D3DXQUATERNION* WINAPI D3DXQuaternionRotationAxis
                    ( D3DXQUATERNION *pOut, CONST D3DXVECTOR3 *pV, FLOAT Angle );
                
                // Yaw around the Y axis, a pitch around the X axis,
                // and a roll around the Z axis.
                D3DXQUATERNION* WINAPI D3DXQuaternionRotationYawPitchRoll
                    ( D3DXQUATERNION *pOut, FLOAT Yaw, FLOAT Pitch, FLOAT Roll );
                
                // Quaternion multiplication.  The result represents the rotation Q2
                // followed by the rotation Q1.  (Out = Q2 * Q1)
                D3DXQUATERNION* WINAPI D3DXQuaternionMultiply
                    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
                      CONST D3DXQUATERNION *pQ2 );
                
                D3DXQUATERNION* WINAPI D3DXQuaternionNormalize
                    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );
                
                // Conjugate and re-norm
                D3DXQUATERNION* WINAPI D3DXQuaternionInverse
                    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );
                
                // Expects unit quaternions.
                // if q = (cos(theta), sin(theta) * v); ln(q) = (0, theta * v)
                D3DXQUATERNION* WINAPI D3DXQuaternionLn
                    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );
                
                // Expects pure quaternions. (w == 0)  w is ignored in calculation.
                // if q = (0, theta * v); exp(q) = (cos(theta), sin(theta) * v)
                D3DXQUATERNION* WINAPI D3DXQuaternionExp
                    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );
                      
                // Spherical linear interpolation between Q1 (t == 0) and Q2 (t == 1).
                // Expects unit quaternions.
                D3DXQUATERNION* WINAPI D3DXQuaternionSlerp
                    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
                      CONST D3DXQUATERNION *pQ2, FLOAT t );
                
                // Spherical quadrangle interpolation.
                // Slerp(Slerp(Q1, C, t), Slerp(A, B, t), 2t(1-t))
                D3DXQUATERNION* WINAPI D3DXQuaternionSquad
                    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
                      CONST D3DXQUATERNION *pA, CONST D3DXQUATERNION *pB,
                      CONST D3DXQUATERNION *pC, FLOAT t );
                
                // Setup control points for spherical quadrangle interpolation
                // from Q1 to Q2.  The control points are chosen in such a way 
                // to ensure the continuity of tangents with adjacent segments.
                void WINAPI D3DXQuaternionSquadSetup
                    ( D3DXQUATERNION *pAOut, D3DXQUATERNION *pBOut, D3DXQUATERNION *pCOut,
                      CONST D3DXQUATERNION *pQ0, CONST D3DXQUATERNION *pQ1, 
                      CONST D3DXQUATERNION *pQ2, CONST D3DXQUATERNION *pQ3 );
                
                // Barycentric interpolation.
                // Slerp(Slerp(Q1, Q2, f+g), Slerp(Q1, Q3, f+g), g/(f+g))
                D3DXQUATERNION* WINAPI D3DXQuaternionBaryCentric
                    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
                      CONST D3DXQUATERNION *pQ2, CONST D3DXQUATERNION *pQ3,
                      FLOAT f, FLOAT g );
                
                #ifdef __cplusplus
                }
                #endif
                
                
                //--------------------------
                // Plane
                //--------------------------
                
                // inline
                
                // ax + by + cz + dw
                FLOAT D3DXPlaneDot
                    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR4 *pV);
                
                // ax + by + cz + d
                FLOAT D3DXPlaneDotCoord
                    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV);
                
                // ax + by + cz
                FLOAT D3DXPlaneDotNormal
                    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV);
                
                D3DXPLANE* D3DXPlaneScale
                    (D3DXPLANE *pOut, CONST D3DXPLANE *pP, FLOAT s);
                
                // non-inline
                #ifdef __cplusplus
                extern "C" {
                #endif
                
                // Normalize plane (so that |a,b,c| == 1)
                D3DXPLANE* WINAPI D3DXPlaneNormalize
                    ( D3DXPLANE *pOut, CONST D3DXPLANE *pP);
                
                // Find the intersection between a plane and a line.  If the line is
                // parallel to the plane, NULL is returned.
                D3DXVECTOR3* WINAPI D3DXPlaneIntersectLine
                    ( D3DXVECTOR3 *pOut, CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV1,
                      CONST D3DXVECTOR3 *pV2);
                
                // Construct a plane from a point and a normal
                D3DXPLANE* WINAPI D3DXPlaneFromPointNormal
                    ( D3DXPLANE *pOut, CONST D3DXVECTOR3 *pPoint, CONST D3DXVECTOR3 *pNormal);
                
                // Construct a plane from 3 points
                D3DXPLANE* WINAPI D3DXPlaneFromPoints
                    ( D3DXPLANE *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
                      CONST D3DXVECTOR3 *pV3);
                
                // Transform a plane by a matrix.  The vector (a,b,c) must be normal.
                // M should be the inverse transpose of the transformation desired.
                D3DXPLANE* WINAPI D3DXPlaneTransform
                    ( D3DXPLANE *pOut, CONST D3DXPLANE *pP, CONST D3DXMATRIX *pM );
                    
                // Transform an array of planes by a matrix.  The vectors (a,b,c) must be normal.
                // M should be the inverse transpose of the transformation desired.
                D3DXPLANE* WINAPI D3DXPlaneTransformArray
                    ( D3DXPLANE *pOut, UINT OutStride, CONST D3DXPLANE *pP, UINT PStride, CONST D3DXMATRIX *pM, UINT n );
                
                #ifdef __cplusplus
                }
                #endif
                
                
                //--------------------------
                // Color
                //--------------------------
                
                // inline
                
                // (1-r, 1-g, 1-b, a)
                D3DXCOLOR* D3DXColorNegative
                    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC);
                
                D3DXCOLOR* D3DXColorAdd
                    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);
                
                D3DXCOLOR* D3DXColorSubtract
                    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);
                
                D3DXCOLOR* D3DXColorScale
                    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT s);
                
                // (r1*r2, g1*g2, b1*b2, a1*a2)
                D3DXCOLOR* D3DXColorModulate
                    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);
                
                // Linear interpolation of r,g,b, and a. C1 + s(C2-C1)
                D3DXCOLOR* D3DXColorLerp
                    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2, FLOAT s);
                
                // non-inline
                #ifdef __cplusplus
                extern "C" {
                #endif
                
                // Interpolate r,g,b between desaturated color and color.
                // DesaturatedColor + s(Color - DesaturatedColor)
                D3DXCOLOR* WINAPI D3DXColorAdjustSaturation
                    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT s);
                
                // Interpolate r,g,b between 50% grey and color.  Grey + s(Color - Grey)
                D3DXCOLOR* WINAPI D3DXColorAdjustContrast
                    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT c);
                
                #ifdef __cplusplus
                }
                #endif
                
                
                
                
                //--------------------------
                // Misc
                //--------------------------
                
                #ifdef __cplusplus
                extern "C" {
                #endif
                
                // Calculate Fresnel term given the cosine of theta (likely obtained by
                // taking the dot of two normals), and the refraction index of the material.
                FLOAT WINAPI D3DXFresnelTerm
                    (FLOAT CosTheta, FLOAT RefractionIndex);     
                
                #ifdef __cplusplus
                }
                #endif
                
                
                
                //===========================================================================
                //
                //    Matrix Stack
                //
                //===========================================================================
                
                typedef interface ID3DXMatrixStack ID3DXMatrixStack;
                typedef interface ID3DXMatrixStack *LPD3DXMATRIXSTACK;
                
                // {C7885BA7-F990-4fe7-922D-8515E477DD85}
                DEFINE_GUID(IID_ID3DXMatrixStack, 
                0xc7885ba7, 0xf990, 0x4fe7, 0x92, 0x2d, 0x85, 0x15, 0xe4, 0x77, 0xdd, 0x85);
                
                
                #undef INTERFACE
                #define INTERFACE ID3DXMatrixStack
                
                DECLARE_INTERFACE_(ID3DXMatrixStack, IUnknown)
                {
                    //
                    // IUnknown methods
                    //
                    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
                    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
                    STDMETHOD_(ULONG,Release)(THIS) PURE;
                
                    //
                    // ID3DXMatrixStack methods
                    //
                
                    // Pops the top of the stack, returns the current top
                    // *after* popping the top.
                    STDMETHOD(Pop)(THIS) PURE;
                
                    // Pushes the stack by one, duplicating the current matrix.
                    STDMETHOD(Push)(THIS) PURE;
                
                    // Loads identity in the current matrix.
                    STDMETHOD(LoadIdentity)(THIS) PURE;
                
                    // Loads the given matrix into the current matrix
                    STDMETHOD(LoadMatrix)(THIS_ CONST D3DXMATRIX* pM ) PURE;
                
                    // Right-Multiplies the given matrix to the current matrix.
                    // (transformation is about the current world origin)
                    STDMETHOD(MultMatrix)(THIS_ CONST D3DXMATRIX* pM ) PURE;
                
                    // Left-Multiplies the given matrix to the current matrix
                    // (transformation is about the local origin of the object)
                    STDMETHOD(MultMatrixLocal)(THIS_ CONST D3DXMATRIX* pM ) PURE;
                
                    // Right multiply the current matrix with the computed rotation
                    // matrix, counterclockwise about the given axis with the given angle.
                    // (rotation is about the current world origin)
                    STDMETHOD(RotateAxis)
                        (THIS_ CONST D3DXVECTOR3* pV, FLOAT Angle) PURE;
                
                    // Left multiply the current matrix with the computed rotation
                    // matrix, counterclockwise about the given axis with the given angle.
                    // (rotation is about the local origin of the object)
                    STDMETHOD(RotateAxisLocal)
                        (THIS_ CONST D3DXVECTOR3* pV, FLOAT Angle) PURE;
                
                    // Right multiply the current matrix with the computed rotation
                    // matrix. All angles are counterclockwise. (rotation is about the
                    // current world origin)
                
                    // The rotation is composed of a yaw around the Y axis, a pitch around
                    // the X axis, and a roll around the Z axis.
                    STDMETHOD(RotateYawPitchRoll)
                        (THIS_ FLOAT Yaw, FLOAT Pitch, FLOAT Roll) PURE;
                
                    // Left multiply the current matrix with the computed rotation
                    // matrix. All angles are counterclockwise. (rotation is about the
                    // local origin of the object)
                
                    // The rotation is composed of a yaw around the Y axis, a pitch around
                    // the X axis, and a roll around the Z axis.
                    STDMETHOD(RotateYawPitchRollLocal)
                        (THIS_ FLOAT Yaw, FLOAT Pitch, FLOAT Roll) PURE;
                
                    // Right multiply the current matrix with the computed scale
                    // matrix. (transformation is about the current world origin)
                    STDMETHOD(Scale)(THIS_ FLOAT x, FLOAT y, FLOAT z) PURE;
                
                    // Left multiply the current matrix with the computed scale
                    // matrix. (transformation is about the local origin of the object)
                    STDMETHOD(ScaleLocal)(THIS_ FLOAT x, FLOAT y, FLOAT z) PURE;
                
                    // Right multiply the current matrix with the computed translation
                    // matrix. (transformation is about the current world origin)
                    STDMETHOD(Translate)(THIS_ FLOAT x, FLOAT y, FLOAT z ) PURE;
                
                    // Left multiply the current matrix with the computed translation
                    // matrix. (transformation is about the local origin of the object)
                    STDMETHOD(TranslateLocal)(THIS_ FLOAT x, FLOAT y, FLOAT z) PURE;
                
                    // Obtain the current matrix at the top of the stack
                    STDMETHOD_(D3DXMATRIX*, GetTop)(THIS) PURE;
                };
                
                #ifdef __cplusplus
                extern "C" {
                #endif
                
                HRESULT WINAPI 
                    D3DXCreateMatrixStack( 
                        DWORD               Flags, 
                        LPD3DXMATRIXSTACK*  ppStack);
                
                #ifdef __cplusplus
                }
                #endif
                
                //===========================================================================
                //
                //  Spherical Harmonic Runtime Routines
                //
                // NOTE:
                //  * Most of these functions can take the same object as in and out parameters.
                //    The exceptions are the rotation functions.  
                //
                //  * Out parameters are typically also returned as return values, so that
                //    the output of one function may be used as a parameter to another.
                //
                //============================================================================
                
                
                // non-inline
                #ifdef __cplusplus
                extern "C" {
                #endif
                
                //============================================================================
                //
                //  Basic Spherical Harmonic math routines
                //
                //============================================================================
                
                #define D3DXSH_MINORDER 2
                #define D3DXSH_MAXORDER 6
                
                //============================================================================
                //
                //  D3DXSHEvalDirection:
                //  --------------------
                //  Evaluates the Spherical Harmonic basis functions
                //
                //  Parameters:
                //   pOut
                //      Output SH coefficients - basis function Ylm is stored at l*l + m+l
                //      This is the pointer that is returned.
                //   Order
                //      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1
                //   pDir
                //      Direction to evaluate in - assumed to be normalized
                //
                //============================================================================
                
                FLOAT* WINAPI D3DXSHEvalDirection
                    (  FLOAT *pOut, UINT Order, CONST D3DXVECTOR3 *pDir );
                    
                //============================================================================
                //
                //  D3DXSHRotate:
                //  --------------------
                //  Rotates SH vector by a rotation matrix
                //
                //  Parameters:
                //   pOut
                //      Output SH coefficients - basis function Ylm is stored at l*l + m+l
                //      This is the pointer that is returned (should not alias with pIn.)
                //   Order
                //      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1
                //   pMatrix
                //      Matrix used for rotation - rotation sub matrix should be orthogonal
                //      and have a unit determinant.
                //   pIn
                //      Input SH coeffs (rotated), incorect results if this is also output.
                //
                //============================================================================
                
                FLOAT* WINAPI D3DXSHRotate
                    ( FLOAT *pOut, UINT Order, CONST D3DXMATRIX *pMatrix, CONST FLOAT *pIn );
                    
                //============================================================================
                //
                //  D3DXSHRotateZ:
                //  --------------------
                //  Rotates the SH vector in the Z axis by an angle
                //
                //  Parameters:
                //   pOut
                //      Output SH coefficients - basis function Ylm is stored at l*l + m+l
                //      This is the pointer that is returned (should not alias with pIn.)
                //   Order
                //      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1
                //   Angle
                //      Angle in radians to rotate around the Z axis.
                //   pIn
                //      Input SH coeffs (rotated), incorect results if this is also output.
                //
                //============================================================================
                
                
                FLOAT* WINAPI D3DXSHRotateZ
                    ( FLOAT *pOut, UINT Order, FLOAT Angle, CONST FLOAT *pIn );
                    
                //============================================================================
                //
                //  D3DXSHAdd:
                //  --------------------
                //  Adds two SH vectors, pOut[i] = pA[i] + pB[i];
                //
                //  Parameters:
                //   pOut
                //      Output SH coefficients - basis function Ylm is stored at l*l + m+l
                //      This is the pointer that is returned.
                //   Order
                //      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1
                //   pA
                //      Input SH coeffs.
                //   pB
                //      Input SH coeffs (second vector.)
                //
                //============================================================================
                
                FLOAT* WINAPI D3DXSHAdd
                    ( FLOAT *pOut, UINT Order, CONST FLOAT *pA, CONST FLOAT *pB );
                
                //============================================================================
                //
                //  D3DXSHScale:
                //  --------------------
                //  Adds two SH vectors, pOut[i] = pA[i]*Scale;
                //
                //  Parameters:
                //   pOut
                //      Output SH coefficients - basis function Ylm is stored at l*l + m+l
                //      This is the pointer that is returned.
                //   Order
                //      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1
                //   pIn
                //      Input SH coeffs.
                //   Scale
                //      Scale factor.
                //
                //============================================================================
                
                FLOAT* WINAPI D3DXSHScale
                    ( FLOAT *pOut, UINT Order, CONST FLOAT *pIn, CONST FLOAT Scale );
                    
                //============================================================================
                //
                //  D3DXSHDot:
                //  --------------------
                //  Computes the dot product of two SH vectors
                //
                //  Parameters:
                //   Order
                //      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1
                //   pA
                //      Input SH coeffs.
                //   pB
                //      Second set of input SH coeffs.
                //
                //============================================================================
                
                FLOAT WINAPI D3DXSHDot
                    ( UINT Order, CONST FLOAT *pA, CONST FLOAT *pB );
                
                //============================================================================
                //
                //  D3DXSHMultiply[O]:
                //  --------------------
                //  Computes the product of two functions represented using SH (f and g), where:
                //  pOut[i] = int(y_i(s) * f(s) * g(s)), where y_i(s) is the ith SH basis
                //  function, f(s) and g(s) are SH functions (sum_i(y_i(s)*c_i)).  The order O
                //  determines the lengths of the arrays, where there should always be O^2 
                //  coefficients.  In general the product of two SH functions of order O generates
                //  and SH function of order 2*O - 1, but we truncate the result.  This means
                //  that the product commutes (f*g == g*f) but doesn't associate 
                //  (f*(g*h) != (f*g)*h.
                //
                //  Parameters:
                //   pOut
                //      Output SH coefficients - basis function Ylm is stored at l*l + m+l
                //      This is the pointer that is returned.
                //   pF
                //      Input SH coeffs for first function.
                //   pG
                //      Second set of input SH coeffs.
                //
                //============================================================================
                
                FLOAT* WINAPI D3DXSHMultiply2( FLOAT *pOut, CONST FLOAT *pF, CONST FLOAT *pG);
                FLOAT* WINAPI D3DXSHMultiply3( FLOAT *pOut, CONST FLOAT *pF, CONST FLOAT *pG);
                FLOAT* WINAPI D3DXSHMultiply4( FLOAT *pOut, CONST FLOAT *pF, CONST FLOAT *pG);
                FLOAT* WINAPI D3DXSHMultiply5( FLOAT *pOut, CONST FLOAT *pF, CONST FLOAT *pG);
                FLOAT* WINAPI D3DXSHMultiply6( FLOAT *pOut, CONST FLOAT *pF, CONST FLOAT *pG);
                
                
                //============================================================================
                //
                //  Basic Spherical Harmonic lighting routines
                //
                //============================================================================
                
                //============================================================================
                //
                //  D3DXSHEvalDirectionalLight:
                //  --------------------
                //  Evaluates a directional light and returns spectral SH data.  The output 
                //  vector is computed so that if the intensity of R/G/B is unit the resulting
                //  exit radiance of a point directly under the light on a diffuse object with
                //  an albedo of 1 would be 1.0.  This will compute 3 spectral samples, pROut
                //  has to be specified, while pGout and pBout are optional.
                //
                //  Parameters:
                //   Order
                //      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1
                //   pDir
                //      Direction light is coming from (assumed to be normalized.)
                //   RIntensity
                //      Red intensity of light.
                //   GIntensity
                //      Green intensity of light.
                //   BIntensity
                //      Blue intensity of light.
                //   pROut
                //      Output SH vector for Red.
                //   pGOut
                //      Output SH vector for Green (optional.)
                //   pBOut
                //      Output SH vector for Blue (optional.)        
                //
                //============================================================================
                
                HRESULT WINAPI D3DXSHEvalDirectionalLight
                    ( UINT Order, CONST D3DXVECTOR3 *pDir, 
                      FLOAT RIntensity, FLOAT GIntensity, FLOAT BIntensity,
                      FLOAT *pROut, FLOAT *pGOut, FLOAT *pBOut );
                
                //============================================================================
                //
                //  D3DXSHEvalSphericalLight:
                //  --------------------
                //  Evaluates a spherical light and returns spectral SH data.  There is no 
                //  normalization of the intensity of the light like there is for directional
                //  lights, care has to be taken when specifiying the intensities.  This will 
                //  compute 3 spectral samples, pROut has to be specified, while pGout and 
                //  pBout are optional.
                //
                //  Parameters:
                //   Order
                //      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1
                //   pPos
                //      Position of light - reciever is assumed to be at the origin.
                //   Radius
                //      Radius of the spherical light source.
                //   RIntensity
                //      Red intensity of light.
                //   GIntensity
                //      Green intensity of light.
                //   BIntensity
                //      Blue intensity of light.
                //   pROut
                //      Output SH vector for Red.
                //   pGOut
                //      Output SH vector for Green (optional.)
                //   pBOut
                //      Output SH vector for Blue (optional.)        
                //
                //============================================================================
                
                HRESULT WINAPI D3DXSHEvalSphericalLight
                    ( UINT Order, CONST D3DXVECTOR3 *pPos, FLOAT Radius,
                      FLOAT RIntensity, FLOAT GIntensity, FLOAT BIntensity,
                      FLOAT *pROut, FLOAT *pGOut, FLOAT *pBOut );
                
                //============================================================================
                //
                //  D3DXSHEvalConeLight:
                //  --------------------
                //  Evaluates a light that is a cone of constant intensity and returns spectral
                //  SH data.  The output vector is computed so that if the intensity of R/G/B is
                //  unit the resulting exit radiance of a point directly under the light oriented
                //  in the cone direction on a diffuse object with an albedo of 1 would be 1.0.
                //  This will compute 3 spectral samples, pROut has to be specified, while pGout
                //  and pBout are optional.
                //
                //  Parameters:
                //   Order
                //      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1
                //   pDir
                //      Direction light is coming from (assumed to be normalized.)
                //   Radius
                //      Radius of cone in radians.
                //   RIntensity
                //      Red intensity of light.
                //   GIntensity
                //      Green intensity of light.
                //   BIntensity
                //      Blue intensity of light.
                //   pROut
                //      Output SH vector for Red.
                //   pGOut
                //      Output SH vector for Green (optional.)
                //   pBOut
                //      Output SH vector for Blue (optional.)        
                //
                //============================================================================
                
                HRESULT WINAPI D3DXSHEvalConeLight
                    ( UINT Order, CONST D3DXVECTOR3 *pDir, FLOAT Radius,
                      FLOAT RIntensity, FLOAT GIntensity, FLOAT BIntensity,
                      FLOAT *pROut, FLOAT *pGOut, FLOAT *pBOut );
                      
                //============================================================================
                //
                //  D3DXSHEvalHemisphereLight:
                //  --------------------
                //  Evaluates a light that is a linear interpolant between two colors over the
                //  sphere.  The interpolant is linear along the axis of the two points, not
                //  over the surface of the sphere (ie: if the axis was (0,0,1) it is linear in
                //  Z, not in the azimuthal angle.)  The resulting spherical lighting function
                //  is normalized so that a point on a perfectly diffuse surface with no
                //  shadowing and a normal pointed in the direction pDir would result in exit
                //  radiance with a value of 1 if the top color was white and the bottom color
                //  was black.  This is a very simple model where Top represents the intensity 
                //  of the "sky" and Bottom represents the intensity of the "ground".
                //
                //  Parameters:
                //   Order
                //      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1
                //   pDir
                //      Axis of the hemisphere.
                //   Top
                //      Color of the upper hemisphere.
                //   Bottom
                //      Color of the lower hemisphere.
                //   pROut
                //      Output SH vector for Red.
                //   pGOut
                //      Output SH vector for Green
                //   pBOut
                //      Output SH vector for Blue        
                //
                //============================================================================
                
                HRESULT WINAPI D3DXSHEvalHemisphereLight
                    ( UINT Order, CONST D3DXVECTOR3 *pDir, D3DXCOLOR Top, D3DXCOLOR Bottom,
                      FLOAT *pROut, FLOAT *pGOut, FLOAT *pBOut );
                
                //============================================================================
                //
                //  Basic Spherical Harmonic projection routines
                //
                //============================================================================
                
                //============================================================================
                //
                //  D3DXSHProjectCubeMap:
                //  --------------------
                //  Projects a function represented on a cube map into spherical harmonics.
                //
                //  Parameters:
                //   Order
                //      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1
                //   pCubeMap
                //      CubeMap that is going to be projected into spherical harmonics
                //   pROut
                //      Output SH vector for Red.
                //   pGOut
                //      Output SH vector for Green
                //   pBOut
                //      Output SH vector for Blue        
                //
                //============================================================================
                
                HRESULT WINAPI D3DXSHProjectCubeMap
                    ( UINT uOrder, LPDIRECT3DCUBETEXTURE9 pCubeMap,
                      FLOAT *pROut, FLOAT *pGOut, FLOAT *pBOut );
                
                
                #ifdef __cplusplus
                }
                #endif
                
                
                #include "d3dx9math.inl"
                
                #if _MSC_VER >= 1200
                #pragma warning(pop)
                #else
                #pragma warning(default:4201)
                #endif
                
                #endif // __D3DX9MATH_H__
                


Top 10 Lines:

     Line      Count

      315      14098
      475       2263
      165         35

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

    16396   Total number of line executions
  5465.33   Average executions per line


*** File C:/Program Files/Microsoft DirectX SDK (February 2010)/Include/d3d9types.h:
                /*==========================================================================;
                 *
                 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
                 *
                 *  File:       d3d9types.h
                 *  Content:    Direct3D capabilities include file
                 *
                 ***************************************************************************/
                
                #ifndef _d3d9TYPES_H_
                #define _d3d9TYPES_H_
                
                #ifndef DIRECT3D_VERSION
                #define DIRECT3D_VERSION         0x0900
                #endif  //DIRECT3D_VERSION
                
                // include this file content only if compiling for DX9 interfaces
                #if(DIRECT3D_VERSION >= 0x0900)
                
                #include <float.h>
                
                #if _MSC_VER >= 1200
                #pragma warning(push)
                #endif
                #pragma warning(disable:4201) // anonymous unions warning
                #if defined(_X86_) || defined(_IA64_)
                #pragma pack(4)
                #endif
                
                // D3DCOLOR is equivalent to D3DFMT_A8R8G8B8
                #ifndef D3DCOLOR_DEFINED
                typedef DWORD D3DCOLOR;
                #define D3DCOLOR_DEFINED
                #endif
                
                // maps unsigned 8 bits/channel to D3DCOLOR
                #define D3DCOLOR_ARGB(a,r,g,b) \
                    ((D3DCOLOR)((((a)&0xff)<<24)|(((r)&0xff)<<16)|(((g)&0xff)<<8)|((b)&0xff)))
                #define D3DCOLOR_RGBA(r,g,b,a) D3DCOLOR_ARGB(a,r,g,b)
                #define D3DCOLOR_XRGB(r,g,b)   D3DCOLOR_ARGB(0xff,r,g,b)
                
                #define D3DCOLOR_XYUV(y,u,v)   D3DCOLOR_ARGB(0xff,y,u,v)
                #define D3DCOLOR_AYUV(a,y,u,v) D3DCOLOR_ARGB(a,y,u,v)
                
                // maps floating point channels (0.f to 1.f range) to D3DCOLOR
                #define D3DCOLOR_COLORVALUE(r,g,b,a) \
                    D3DCOLOR_RGBA((DWORD)((r)*255.f),(DWORD)((g)*255.f),(DWORD)((b)*255.f),(DWORD)((a)*255.f))
                
                
                #ifndef D3DVECTOR_DEFINED
      221091 -> typedef struct _D3DVECTOR {
                    float x;
                    float y;
                    float z;
                } D3DVECTOR;
                #define D3DVECTOR_DEFINED
                #endif
                
                #ifndef D3DCOLORVALUE_DEFINED
                typedef struct _D3DCOLORVALUE {
                    float r;
                    float g;
                    float b;
                    float a;
                } D3DCOLORVALUE;
                #define D3DCOLORVALUE_DEFINED
                #endif
                
                #ifndef D3DRECT_DEFINED
                typedef struct _D3DRECT {
                    LONG x1;
                    LONG y1;
                    LONG x2;
                    LONG y2;
                } D3DRECT;
                #define D3DRECT_DEFINED
                #endif
                
                #ifndef D3DMATRIX_DEFINED
       14098 -> typedef struct _D3DMATRIX {
                    union {
                        struct {
                            float        _11, _12, _13, _14;
                            float        _21, _22, _23, _24;
                            float        _31, _32, _33, _34;
                            float        _41, _42, _43, _44;
                
                        };
                        float m[4][4];
                    };
                } D3DMATRIX;
                #define D3DMATRIX_DEFINED
                #endif
                
                typedef struct _D3DVIEWPORT9 {
                    DWORD       X;
                    DWORD       Y;            /* Viewport Top left */
                    DWORD       Width;
                    DWORD       Height;       /* Viewport Dimensions */
                    float       MinZ;         /* Min/max of clip Volume */
                    float       MaxZ;
                } D3DVIEWPORT9;
                
                /*
                 * Values for clip fields.
                 */
                
                // Max number of user clipping planes, supported in D3D.
                #define D3DMAXUSERCLIPPLANES 32
                
                // These bits could be ORed together to use with D3DRS_CLIPPLANEENABLE
                //
                #define D3DCLIPPLANE0 (1 << 0)
                #define D3DCLIPPLANE1 (1 << 1)
                #define D3DCLIPPLANE2 (1 << 2)
                #define D3DCLIPPLANE3 (1 << 3)
                #define D3DCLIPPLANE4 (1 << 4)
                #define D3DCLIPPLANE5 (1 << 5)
                
                // The following bits are used in the ClipUnion and ClipIntersection
                // members of the D3DCLIPSTATUS9
                //
                
                #define D3DCS_LEFT        0x00000001L
                #define D3DCS_RIGHT       0x00000002L
                #define D3DCS_TOP         0x00000004L
                #define D3DCS_BOTTOM      0x00000008L
                #define D3DCS_FRONT       0x00000010L
                #define D3DCS_BACK        0x00000020L
                #define D3DCS_PLANE0      0x00000040L
                #define D3DCS_PLANE1      0x00000080L
                #define D3DCS_PLANE2      0x00000100L
                #define D3DCS_PLANE3      0x00000200L
                #define D3DCS_PLANE4      0x00000400L
                #define D3DCS_PLANE5      0x00000800L
                
                #define D3DCS_ALL (D3DCS_LEFT   | \
                                   D3DCS_RIGHT  | \
                                   D3DCS_TOP    | \
                                   D3DCS_BOTTOM | \
                                   D3DCS_FRONT  | \
                                   D3DCS_BACK   | \
                                   D3DCS_PLANE0 | \
                                   D3DCS_PLANE1 | \
                                   D3DCS_PLANE2 | \
                                   D3DCS_PLANE3 | \
                                   D3DCS_PLANE4 | \
                                   D3DCS_PLANE5)
                
                typedef struct _D3DCLIPSTATUS9 {
                    DWORD ClipUnion;
                    DWORD ClipIntersection;
                } D3DCLIPSTATUS9;
                
                typedef struct _D3DMATERIAL9 {
                    D3DCOLORVALUE   Diffuse;        /* Diffuse color RGBA */
                    D3DCOLORVALUE   Ambient;        /* Ambient color RGB */
                    D3DCOLORVALUE   Specular;       /* Specular 'shininess' */
                    D3DCOLORVALUE   Emissive;       /* Emissive color RGB */
                    float           Power;          /* Sharpness if specular highlight */
                } D3DMATERIAL9;
                
                typedef enum _D3DLIGHTTYPE {
                    D3DLIGHT_POINT          = 1,
                    D3DLIGHT_SPOT           = 2,
                    D3DLIGHT_DIRECTIONAL    = 3,
                    D3DLIGHT_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
                } D3DLIGHTTYPE;
                
                typedef struct _D3DLIGHT9 {
                    D3DLIGHTTYPE    Type;            /* Type of light source */
                    D3DCOLORVALUE   Diffuse;         /* Diffuse color of light */
                    D3DCOLORVALUE   Specular;        /* Specular color of light */
                    D3DCOLORVALUE   Ambient;         /* Ambient color of light */
                    D3DVECTOR       Position;         /* Position in world space */
                    D3DVECTOR       Direction;        /* Direction in world space */
                    float           Range;            /* Cutoff range */
                    float           Falloff;          /* Falloff */
                    float           Attenuation0;     /* Constant attenuation */
                    float           Attenuation1;     /* Linear attenuation */
                    float           Attenuation2;     /* Quadratic attenuation */
                    float           Theta;            /* Inner angle of spotlight cone */
                    float           Phi;              /* Outer angle of spotlight cone */
                } D3DLIGHT9;
                
                /*
                 * Options for clearing
                 */
                #define D3DCLEAR_TARGET            0x00000001l  /* Clear target surface */
                #define D3DCLEAR_ZBUFFER           0x00000002l  /* Clear target z buffer */
                #define D3DCLEAR_STENCIL           0x00000004l  /* Clear stencil planes */
                
                /*
                 * The following defines the rendering states
                 */
                
                typedef enum _D3DSHADEMODE {
                    D3DSHADE_FLAT               = 1,
                    D3DSHADE_GOURAUD            = 2,
                    D3DSHADE_PHONG              = 3,
                    D3DSHADE_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
                } D3DSHADEMODE;
                
                typedef enum _D3DFILLMODE {
                    D3DFILL_POINT               = 1,
                    D3DFILL_WIREFRAME           = 2,
                    D3DFILL_SOLID               = 3,
                    D3DFILL_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
                } D3DFILLMODE;
                
                typedef enum _D3DBLEND {
                    D3DBLEND_ZERO               = 1,
                    D3DBLEND_ONE                = 2,
                    D3DBLEND_SRCCOLOR           = 3,
                    D3DBLEND_INVSRCCOLOR        = 4,
                    D3DBLEND_SRCALPHA           = 5,
                    D3DBLEND_INVSRCALPHA        = 6,
                    D3DBLEND_DESTALPHA          = 7,
                    D3DBLEND_INVDESTALPHA       = 8,
                    D3DBLEND_DESTCOLOR          = 9,
                    D3DBLEND_INVDESTCOLOR       = 10,
                    D3DBLEND_SRCALPHASAT        = 11,
                    D3DBLEND_BOTHSRCALPHA       = 12,
                    D3DBLEND_BOTHINVSRCALPHA    = 13,
                    D3DBLEND_BLENDFACTOR        = 14, /* Only supported if D3DPBLENDCAPS_BLENDFACTOR is on */
                    D3DBLEND_INVBLENDFACTOR     = 15, /* Only supported if D3DPBLENDCAPS_BLENDFACTOR is on */
                /* D3D9Ex only -- */
                #if !defined(D3D_DISABLE_9EX)
                
                    D3DBLEND_SRCCOLOR2          = 16,
                    D3DBLEND_INVSRCCOLOR2       = 17,
                
                #endif // !D3D_DISABLE_9EX
                /* -- D3D9Ex only */
                    D3DBLEND_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
                } D3DBLEND;
                
                typedef enum _D3DBLENDOP {
                    D3DBLENDOP_ADD              = 1,
                    D3DBLENDOP_SUBTRACT         = 2,
                    D3DBLENDOP_REVSUBTRACT      = 3,
                    D3DBLENDOP_MIN              = 4,
                    D3DBLENDOP_MAX              = 5,
                    D3DBLENDOP_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
                } D3DBLENDOP;
                
                typedef enum _D3DTEXTUREADDRESS {
                    D3DTADDRESS_WRAP            = 1,
                    D3DTADDRESS_MIRROR          = 2,
                    D3DTADDRESS_CLAMP           = 3,
                    D3DTADDRESS_BORDER          = 4,
                    D3DTADDRESS_MIRRORONCE      = 5,
                    D3DTADDRESS_FORCE_DWORD     = 0x7fffffff, /* force 32-bit size enum */
                } D3DTEXTUREADDRESS;
                
                typedef enum _D3DCULL {
                    D3DCULL_NONE                = 1,
                    D3DCULL_CW                  = 2,
                    D3DCULL_CCW                 = 3,
                    D3DCULL_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
                } D3DCULL;
                
                typedef enum _D3DCMPFUNC {
                    D3DCMP_NEVER                = 1,
                    D3DCMP_LESS                 = 2,
                    D3DCMP_EQUAL                = 3,
                    D3DCMP_LESSEQUAL            = 4,
                    D3DCMP_GREATER              = 5,
                    D3DCMP_NOTEQUAL             = 6,
                    D3DCMP_GREATEREQUAL         = 7,
                    D3DCMP_ALWAYS               = 8,
                    D3DCMP_FORCE_DWORD          = 0x7fffffff, /* force 32-bit size enum */
                } D3DCMPFUNC;
                
                typedef enum _D3DSTENCILOP {
                    D3DSTENCILOP_KEEP           = 1,
                    D3DSTENCILOP_ZERO           = 2,
                    D3DSTENCILOP_REPLACE        = 3,
                    D3DSTENCILOP_INCRSAT        = 4,
                    D3DSTENCILOP_DECRSAT        = 5,
                    D3DSTENCILOP_INVERT         = 6,
                    D3DSTENCILOP_INCR           = 7,
                    D3DSTENCILOP_DECR           = 8,
                    D3DSTENCILOP_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
                } D3DSTENCILOP;
                
                typedef enum _D3DFOGMODE {
                    D3DFOG_NONE                 = 0,
                    D3DFOG_EXP                  = 1,
                    D3DFOG_EXP2                 = 2,
                    D3DFOG_LINEAR               = 3,
                    D3DFOG_FORCE_DWORD          = 0x7fffffff, /* force 32-bit size enum */
                } D3DFOGMODE;
                
                typedef enum _D3DZBUFFERTYPE {
                    D3DZB_FALSE                 = 0,
                    D3DZB_TRUE                  = 1, // Z buffering
                    D3DZB_USEW                  = 2, // W buffering
                    D3DZB_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
                } D3DZBUFFERTYPE;
                
                // Primitives supported by draw-primitive API
                typedef enum _D3DPRIMITIVETYPE {
                    D3DPT_POINTLIST             = 1,
                    D3DPT_LINELIST              = 2,
                    D3DPT_LINESTRIP             = 3,
                    D3DPT_TRIANGLELIST          = 4,
                    D3DPT_TRIANGLESTRIP         = 5,
                    D3DPT_TRIANGLEFAN           = 6,
                    D3DPT_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
                } D3DPRIMITIVETYPE;
                
                typedef enum _D3DTRANSFORMSTATETYPE {
                    D3DTS_VIEW          = 2,
                    D3DTS_PROJECTION    = 3,
                    D3DTS_TEXTURE0      = 16,
                    D3DTS_TEXTURE1      = 17,
                    D3DTS_TEXTURE2      = 18,
                    D3DTS_TEXTURE3      = 19,
                    D3DTS_TEXTURE4      = 20,
                    D3DTS_TEXTURE5      = 21,
                    D3DTS_TEXTURE6      = 22,
                    D3DTS_TEXTURE7      = 23,
                    D3DTS_FORCE_DWORD     = 0x7fffffff, /* force 32-bit size enum */
                } D3DTRANSFORMSTATETYPE;
                
                #define D3DTS_WORLDMATRIX(index) (D3DTRANSFORMSTATETYPE)(index + 256)
                #define D3DTS_WORLD  D3DTS_WORLDMATRIX(0)
                #define D3DTS_WORLD1 D3DTS_WORLDMATRIX(1)
                #define D3DTS_WORLD2 D3DTS_WORLDMATRIX(2)
                #define D3DTS_WORLD3 D3DTS_WORLDMATRIX(3)
                
                typedef enum _D3DRENDERSTATETYPE {
                    D3DRS_ZENABLE                   = 7,    /* D3DZBUFFERTYPE (or TRUE/FALSE for legacy) */
                    D3DRS_FILLMODE                  = 8,    /* D3DFILLMODE */
                    D3DRS_SHADEMODE                 = 9,    /* D3DSHADEMODE */
                    D3DRS_ZWRITEENABLE              = 14,   /* TRUE to enable z writes */
                    D3DRS_ALPHATESTENABLE           = 15,   /* TRUE to enable alpha tests */
                    D3DRS_LASTPIXEL                 = 16,   /* TRUE for last-pixel on lines */
                    D3DRS_SRCBLEND                  = 19,   /* D3DBLEND */
                    D3DRS_DESTBLEND                 = 20,   /* D3DBLEND */
                    D3DRS_CULLMODE                  = 22,   /* D3DCULL */
                    D3DRS_ZFUNC                     = 23,   /* D3DCMPFUNC */
                    D3DRS_ALPHAREF                  = 24,   /* D3DFIXED */
                    D3DRS_ALPHAFUNC                 = 25,   /* D3DCMPFUNC */
                    D3DRS_DITHERENABLE              = 26,   /* TRUE to enable dithering */
                    D3DRS_ALPHABLENDENABLE          = 27,   /* TRUE to enable alpha blending */
                    D3DRS_FOGENABLE                 = 28,   /* TRUE to enable fog blending */
                    D3DRS_SPECULARENABLE            = 29,   /* TRUE to enable specular */
                    D3DRS_FOGCOLOR                  = 34,   /* D3DCOLOR */
                    D3DRS_FOGTABLEMODE              = 35,   /* D3DFOGMODE */
                    D3DRS_FOGSTART                  = 36,   /* Fog start (for both vertex and pixel fog) */
                    D3DRS_FOGEND                    = 37,   /* Fog end      */
                    D3DRS_FOGDENSITY                = 38,   /* Fog density  */
                    D3DRS_RANGEFOGENABLE            = 48,   /* Enables range-based fog */
                    D3DRS_STENCILENABLE             = 52,   /* BOOL enable/disable stenciling */
                    D3DRS_STENCILFAIL               = 53,   /* D3DSTENCILOP to do if stencil test fails */
                    D3DRS_STENCILZFAIL              = 54,   /* D3DSTENCILOP to do if stencil test passes and Z test fails */
                    D3DRS_STENCILPASS               = 55,   /* D3DSTENCILOP to do if both stencil and Z tests pass */
                    D3DRS_STENCILFUNC               = 56,   /* D3DCMPFUNC fn.  Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true */
                    D3DRS_STENCILREF                = 57,   /* Reference value used in stencil test */
                    D3DRS_STENCILMASK               = 58,   /* Mask value used in stencil test */
                    D3DRS_STENCILWRITEMASK          = 59,   /* Write mask applied to values written to stencil buffer */
                    D3DRS_TEXTUREFACTOR             = 60,   /* D3DCOLOR used for multi-texture blend */
                    D3DRS_WRAP0                     = 128,  /* wrap for 1st texture coord. set */
                    D3DRS_WRAP1                     = 129,  /* wrap for 2nd texture coord. set */
                    D3DRS_WRAP2                     = 130,  /* wrap for 3rd texture coord. set */
                    D3DRS_WRAP3                     = 131,  /* wrap for 4th texture coord. set */
                    D3DRS_WRAP4                     = 132,  /* wrap for 5th texture coord. set */
                    D3DRS_WRAP5                     = 133,  /* wrap for 6th texture coord. set */
                    D3DRS_WRAP6                     = 134,  /* wrap for 7th texture coord. set */
                    D3DRS_WRAP7                     = 135,  /* wrap for 8th texture coord. set */
                    D3DRS_CLIPPING                  = 136,
                    D3DRS_LIGHTING                  = 137,
                    D3DRS_AMBIENT                   = 139,
                    D3DRS_FOGVERTEXMODE             = 140,
                    D3DRS_COLORVERTEX               = 141,
                    D3DRS_LOCALVIEWER               = 142,
                    D3DRS_NORMALIZENORMALS          = 143,
                    D3DRS_DIFFUSEMATERIALSOURCE     = 145,
                    D3DRS_SPECULARMATERIALSOURCE    = 146,
                    D3DRS_AMBIENTMATERIALSOURCE     = 147,
                    D3DRS_EMISSIVEMATERIALSOURCE    = 148,
                    D3DRS_VERTEXBLEND               = 151,
                    D3DRS_CLIPPLANEENABLE           = 152,
                    D3DRS_POINTSIZE                 = 154,   /* float point size */
                    D3DRS_POINTSIZE_MIN             = 155,   /* float point size min threshold */
                    D3DRS_POINTSPRITEENABLE         = 156,   /* BOOL point texture coord control */
                    D3DRS_POINTSCALEENABLE          = 157,   /* BOOL point size scale enable */
                    D3DRS_POINTSCALE_A              = 158,   /* float point attenuation A value */
                    D3DRS_POINTSCALE_B              = 159,   /* float point attenuation B value */
                    D3DRS_POINTSCALE_C              = 160,   /* float point attenuation C value */
                    D3DRS_MULTISAMPLEANTIALIAS      = 161,  // BOOL - set to do FSAA with multisample buffer
                    D3DRS_MULTISAMPLEMASK           = 162,  // DWORD - per-sample enable/disable
                    D3DRS_PATCHEDGESTYLE            = 163,  // Sets whether patch edges will use float style tessellation
                    D3DRS_DEBUGMONITORTOKEN         = 165,  // DEBUG ONLY - token to debug monitor
                    D3DRS_POINTSIZE_MAX             = 166,   /* float point size max threshold */
                    D3DRS_INDEXEDVERTEXBLENDENABLE  = 167,
                    D3DRS_COLORWRITEENABLE          = 168,  // per-channel write enable
                    D3DRS_TWEENFACTOR               = 170,   // float tween factor
                    D3DRS_BLENDOP                   = 171,   // D3DBLENDOP setting
                    D3DRS_POSITIONDEGREE            = 172,   // NPatch position interpolation degree. D3DDEGREE_LINEAR or D3DDEGREE_CUBIC (default)
                    D3DRS_NORMALDEGREE              = 173,   // NPatch normal interpolation degree. D3DDEGREE_LINEAR (default) or D3DDEGREE_QUADRATIC
                    D3DRS_SCISSORTESTENABLE         = 174,
                    D3DRS_SLOPESCALEDEPTHBIAS       = 175,
                    D3DRS_ANTIALIASEDLINEENABLE     = 176,
                    D3DRS_MINTESSELLATIONLEVEL      = 178,
                    D3DRS_MAXTESSELLATIONLEVEL      = 179,
                    D3DRS_ADAPTIVETESS_X            = 180,
                    D3DRS_ADAPTIVETESS_Y            = 181,
                    D3DRS_ADAPTIVETESS_Z            = 182,
                    D3DRS_ADAPTIVETESS_W            = 183,
                    D3DRS_ENABLEADAPTIVETESSELLATION = 184,
                    D3DRS_TWOSIDEDSTENCILMODE       = 185,   /* BOOL enable/disable 2 sided stenciling */
                    D3DRS_CCW_STENCILFAIL           = 186,   /* D3DSTENCILOP to do if ccw stencil test fails */
                    D3DRS_CCW_STENCILZFAIL          = 187,   /* D3DSTENCILOP to do if ccw stencil test passes and Z test fails */
                    D3DRS_CCW_STENCILPASS           = 188,   /* D3DSTENCILOP to do if both ccw stencil and Z tests pass */
                    D3DRS_CCW_STENCILFUNC           = 189,   /* D3DCMPFUNC fn.  ccw Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true */
                    D3DRS_COLORWRITEENABLE1         = 190,   /* Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS */
                    D3DRS_COLORWRITEENABLE2         = 191,   /* Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS */
                    D3DRS_COLORWRITEENABLE3         = 192,   /* Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS */
                    D3DRS_BLENDFACTOR               = 193,   /* D3DCOLOR used for a constant blend factor during alpha blending for devices that support D3DPBLENDCAPS_BLENDFACTOR */
                    D3DRS_SRGBWRITEENABLE           = 194,   /* Enable rendertarget writes to be DE-linearized to SRGB (for formats that expose D3DUSAGE_QUERY_SRGBWRITE) */
                    D3DRS_DEPTHBIAS                 = 195,
                    D3DRS_WRAP8                     = 198,   /* Additional wrap states for vs_3_0+ attributes with D3DDECLUSAGE_TEXCOORD */
                    D3DRS_WRAP9                     = 199,
                    D3DRS_WRAP10                    = 200,
                    D3DRS_WRAP11                    = 201,
                    D3DRS_WRAP12                    = 202,
                    D3DRS_WRAP13                    = 203,
                    D3DRS_WRAP14                    = 204,
                    D3DRS_WRAP15                    = 205,
                    D3DRS_SEPARATEALPHABLENDENABLE  = 206,  /* TRUE to enable a separate blending function for the alpha channel */
                    D3DRS_SRCBLENDALPHA             = 207,  /* SRC blend factor for the alpha channel when D3DRS_SEPARATEDESTALPHAENABLE is TRUE */
                    D3DRS_DESTBLENDALPHA            = 208,  /* DST blend factor for the alpha channel when D3DRS_SEPARATEDESTALPHAENABLE is TRUE */
                    D3DRS_BLENDOPALPHA              = 209,  /* Blending operation for the alpha channel when D3DRS_SEPARATEDESTALPHAENABLE is TRUE */
                
                
                    D3DRS_FORCE_DWORD               = 0x7fffffff, /* force 32-bit size enum */
                } D3DRENDERSTATETYPE;
                
                // Maximum number of simultaneous render targets D3D supports
                #define D3D_MAX_SIMULTANEOUS_RENDERTARGETS 4
                
                // Values for material source
                typedef enum _D3DMATERIALCOLORSOURCE
                {
                    D3DMCS_MATERIAL         = 0,            // Color from material is used
                    D3DMCS_COLOR1           = 1,            // Diffuse vertex color is used
                    D3DMCS_COLOR2           = 2,            // Specular vertex color is used
                    D3DMCS_FORCE_DWORD      = 0x7fffffff,   // force 32-bit size enum
                } D3DMATERIALCOLORSOURCE;
                
                // Bias to apply to the texture coordinate set to apply a wrap to.
                #define D3DRENDERSTATE_WRAPBIAS                 128UL
                
                /* Flags to construct the WRAP render states */
                #define D3DWRAP_U   0x00000001L
                #define D3DWRAP_V   0x00000002L
                #define D3DWRAP_W   0x00000004L
                
                /* Flags to construct the WRAP render states for 1D thru 4D texture coordinates */
                #define D3DWRAPCOORD_0   0x00000001L    // same as D3DWRAP_U
                #define D3DWRAPCOORD_1   0x00000002L    // same as D3DWRAP_V
                #define D3DWRAPCOORD_2   0x00000004L    // same as D3DWRAP_W
                #define D3DWRAPCOORD_3   0x00000008L
                
                /* Flags to construct D3DRS_COLORWRITEENABLE */
                #define D3DCOLORWRITEENABLE_RED     (1L<<0)
                #define D3DCOLORWRITEENABLE_GREEN   (1L<<1)
                #define D3DCOLORWRITEENABLE_BLUE    (1L<<2)
                #define D3DCOLORWRITEENABLE_ALPHA   (1L<<3)
                
                /*
                 * State enumerants for per-stage processing of fixed function pixel processing
                 * Two of these affect fixed function vertex processing as well: TEXTURETRANSFORMFLAGS and TEXCOORDINDEX.
                 */
                typedef enum _D3DTEXTURESTAGESTATETYPE
                {
                    D3DTSS_COLOROP        =  1, /* D3DTEXTUREOP - per-stage blending controls for color channels */
                    D3DTSS_COLORARG1      =  2, /* D3DTA_* (texture arg) */
                    D3DTSS_COLORARG2      =  3, /* D3DTA_* (texture arg) */
                    D3DTSS_ALPHAOP        =  4, /* D3DTEXTUREOP - per-stage blending controls for alpha channel */
                    D3DTSS_ALPHAARG1      =  5, /* D3DTA_* (texture arg) */
                    D3DTSS_ALPHAARG2      =  6, /* D3DTA_* (texture arg) */
                    D3DTSS_BUMPENVMAT00   =  7, /* float (bump mapping matrix) */
                    D3DTSS_BUMPENVMAT01   =  8, /* float (bump mapping matrix) */
                    D3DTSS_BUMPENVMAT10   =  9, /* float (bump mapping matrix) */
                    D3DTSS_BUMPENVMAT11   = 10, /* float (bump mapping matrix) */
                    D3DTSS_TEXCOORDINDEX  = 11, /* identifies which set of texture coordinates index this texture */
                    D3DTSS_BUMPENVLSCALE  = 22, /* float scale for bump map luminance */
                    D3DTSS_BUMPENVLOFFSET = 23, /* float offset for bump map luminance */
                    D3DTSS_TEXTURETRANSFORMFLAGS = 24, /* D3DTEXTURETRANSFORMFLAGS controls texture transform */
                    D3DTSS_COLORARG0      = 26, /* D3DTA_* third arg for triadic ops */
                    D3DTSS_ALPHAARG0      = 27, /* D3DTA_* third arg for triadic ops */
                    D3DTSS_RESULTARG      = 28, /* D3DTA_* arg for result (CURRENT or TEMP) */
                    D3DTSS_CONSTANT       = 32, /* Per-stage constant D3DTA_CONSTANT */
                
                
                    D3DTSS_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
                } D3DTEXTURESTAGESTATETYPE;
                
                /*
                 * State enumerants for per-sampler texture processing.
                 */
                typedef enum _D3DSAMPLERSTATETYPE
                {
                    D3DSAMP_ADDRESSU       = 1,  /* D3DTEXTUREADDRESS for U coordinate */
                    D3DSAMP_ADDRESSV       = 2,  /* D3DTEXTUREADDRESS for V coordinate */
                    D3DSAMP_ADDRESSW       = 3,  /* D3DTEXTUREADDRESS for W coordinate */
                    D3DSAMP_BORDERCOLOR    = 4,  /* D3DCOLOR */
                    D3DSAMP_MAGFILTER      = 5,  /* D3DTEXTUREFILTER filter to use for magnification */
                    D3DSAMP_MINFILTER      = 6,  /* D3DTEXTUREFILTER filter to use for minification */
                    D3DSAMP_MIPFILTER      = 7,  /* D3DTEXTUREFILTER filter to use between mipmaps during minification */
                    D3DSAMP_MIPMAPLODBIAS  = 8,  /* float Mipmap LOD bias */
                    D3DSAMP_MAXMIPLEVEL    = 9,  /* DWORD 0..(n-1) LOD index of largest map to use (0 == largest) */
                    D3DSAMP_MAXANISOTROPY  = 10, /* DWORD maximum anisotropy */
                    D3DSAMP_SRGBTEXTURE    = 11, /* Default = 0 (which means Gamma 1.0,
                                                   no correction required.) else correct for
                                                   Gamma = 2.2 */
                    D3DSAMP_ELEMENTINDEX   = 12, /* When multi-element texture is assigned to sampler, this
                                                    indicates which element index to use.  Default = 0.  */
                    D3DSAMP_DMAPOFFSET     = 13, /* Offset in vertices in the pre-sampled displacement map.
                                                    Only valid for D3DDMAPSAMPLER sampler  */
                    D3DSAMP_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
                } D3DSAMPLERSTATETYPE;
                
                /* Special sampler which is used in the tesselator */
                #define D3DDMAPSAMPLER 256
                
                // Samplers used in vertex shaders
                #define D3DVERTEXTEXTURESAMPLER0 (D3DDMAPSAMPLER+1)
                #define D3DVERTEXTEXTURESAMPLER1 (D3DDMAPSAMPLER+2)
                #define D3DVERTEXTEXTURESAMPLER2 (D3DDMAPSAMPLER+3)
                #define D3DVERTEXTEXTURESAMPLER3 (D3DDMAPSAMPLER+4)
                
                // Values, used with D3DTSS_TEXCOORDINDEX, to specify that the vertex data(position
                // and normal in the camera space) should be taken as texture coordinates
                // Low 16 bits are used to specify texture coordinate index, to take the WRAP mode from
                //
                #define D3DTSS_TCI_PASSTHRU                             0x00000000
                #define D3DTSS_TCI_CAMERASPACENORMAL                    0x00010000
                #define D3DTSS_TCI_CAMERASPACEPOSITION                  0x00020000
                #define D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR          0x00030000
                #define D3DTSS_TCI_SPHEREMAP                            0x00040000
                
                /*
                 * Enumerations for COLOROP and ALPHAOP texture blending operations set in
                 * texture processing stage controls in D3DTSS.
                 */
                typedef enum _D3DTEXTUREOP
                {
                    // Control
                    D3DTOP_DISABLE              = 1,      // disables stage
                    D3DTOP_SELECTARG1           = 2,      // the default
                    D3DTOP_SELECTARG2           = 3,
                
                    // Modulate
                    D3DTOP_MODULATE             = 4,      // multiply args together
                    D3DTOP_MODULATE2X           = 5,      // multiply and  1 bit
                    D3DTOP_MODULATE4X           = 6,      // multiply and  2 bits
                
                    // Add
                    D3DTOP_ADD                  =  7,   // add arguments together
                    D3DTOP_ADDSIGNED            =  8,   // add with -0.5 bias
                    D3DTOP_ADDSIGNED2X          =  9,   // as above but left  1 bit
                    D3DTOP_SUBTRACT             = 10,   // Arg1 - Arg2, with no saturation
                    D3DTOP_ADDSMOOTH            = 11,   // add 2 args, subtract product
                                                        // Arg1 + Arg2 - Arg1*Arg2
                                                        // = Arg1 + (1-Arg1)*Arg2
                
                    // Linear alpha blend: Arg1*(Alpha) + Arg2*(1-Alpha)
                    D3DTOP_BLENDDIFFUSEALPHA    = 12, // iterated alpha
                    D3DTOP_BLENDTEXTUREALPHA    = 13, // texture alpha
                    D3DTOP_BLENDFACTORALPHA     = 14, // alpha from D3DRS_TEXTUREFACTOR
                
                    // Linear alpha blend with pre-multiplied arg1 input: Arg1 + Arg2*(1-Alpha)
                    D3DTOP_BLENDTEXTUREALPHAPM  = 15, // texture alpha
                    D3DTOP_BLENDCURRENTALPHA    = 16, // by alpha of current color
                
                    // Specular mapping
                    D3DTOP_PREMODULATE            = 17,     // modulate with next texture before use
                    D3DTOP_MODULATEALPHA_ADDCOLOR = 18,     // Arg1.RGB + Arg1.A*Arg2.RGB
                                                            // COLOROP only
                    D3DTOP_MODULATECOLOR_ADDALPHA = 19,     // Arg1.RGB*Arg2.RGB + Arg1.A
                                                            // COLOROP only
                    D3DTOP_MODULATEINVALPHA_ADDCOLOR = 20,  // (1-Arg1.A)*Arg2.RGB + Arg1.RGB
                                                            // COLOROP only
                    D3DTOP_MODULATEINVCOLOR_ADDALPHA = 21,  // (1-Arg1.RGB)*Arg2.RGB + Arg1.A
                                                            // COLOROP only
                
                    // Bump mapping
                    D3DTOP_BUMPENVMAP           = 22, // per pixel env map perturbation
                    D3DTOP_BUMPENVMAPLUMINANCE  = 23, // with luminance channel
                
                    // This can do either diffuse or specular bump mapping with correct input.
                    // Performs the function (Arg1.R*Arg2.R + Arg1.G*Arg2.G + Arg1.B*Arg2.B)
                    // where each component has been scaled and offset to make it signed.
                    // The result is replicated into all four (including alpha) channels.
                    // This is a valid COLOROP only.
                    D3DTOP_DOTPRODUCT3          = 24,
                
                    // Triadic ops
                    D3DTOP_MULTIPLYADD          = 25, // Arg0 + Arg1*Arg2
                    D3DTOP_LERP                 = 26, // (Arg0)*Arg1 + (1-Arg0)*Arg2
                
                    D3DTOP_FORCE_DWORD = 0x7fffffff,
                } D3DTEXTUREOP;
                
                /*
                 * Values for COLORARG0,1,2, ALPHAARG0,1,2, and RESULTARG texture blending
                 * operations set in texture processing stage controls in D3DRENDERSTATE.
                 */
                #define D3DTA_SELECTMASK        0x0000000f  // mask for arg selector
                #define D3DTA_DIFFUSE           0x00000000  // select diffuse color (read only)
                #define D3DTA_CURRENT           0x00000001  // select stage destination register (read/write)
                #define D3DTA_TEXTURE           0x00000002  // select texture color (read only)
                #define D3DTA_TFACTOR           0x00000003  // select D3DRS_TEXTUREFACTOR (read only)
                #define D3DTA_SPECULAR          0x00000004  // select specular color (read only)
                #define D3DTA_TEMP              0x00000005  // select temporary register color (read/write)
                #define D3DTA_CONSTANT          0x00000006  // select texture stage constant
                #define D3DTA_COMPLEMENT        0x00000010  // take 1.0 - x (read modifier)
                #define D3DTA_ALPHAREPLICATE    0x00000020  // replicate alpha to color components (read modifier)
                
                //
                // Values for D3DSAMP_***FILTER texture stage states
                //
                typedef enum _D3DTEXTUREFILTERTYPE
                {
                    D3DTEXF_NONE            = 0,    // filtering disabled (valid for mip filter only)
                    D3DTEXF_POINT           = 1,    // nearest
                    D3DTEXF_LINEAR          = 2,    // linear interpolation
                    D3DTEXF_ANISOTROPIC     = 3,    // anisotropic
                    D3DTEXF_PYRAMIDALQUAD   = 6,    // 4-sample tent
                    D3DTEXF_GAUSSIANQUAD    = 7,    // 4-sample gaussian
                /* D3D9Ex only -- */
                #if !defined(D3D_DISABLE_9EX)
                
                    D3DTEXF_CONVOLUTIONMONO = 8,    // Convolution filter for monochrome textures
                
                #endif // !D3D_DISABLE_9EX
                /* -- D3D9Ex only */
                    D3DTEXF_FORCE_DWORD     = 0x7fffffff,   // force 32-bit size enum
                } D3DTEXTUREFILTERTYPE;
                
                /* Bits for Flags in ProcessVertices call */
                
                #define D3DPV_DONOTCOPYDATA     (1 << 0)
                
                //-------------------------------------------------------------------
                
                // Flexible vertex format bits
                //
                #define D3DFVF_RESERVED0        0x001
                #define D3DFVF_POSITION_MASK    0x400E
                #define D3DFVF_XYZ              0x002
                #define D3DFVF_XYZRHW           0x004
                #define D3DFVF_XYZB1            0x006
                #define D3DFVF_XYZB2            0x008
                #define D3DFVF_XYZB3            0x00a
                #define D3DFVF_XYZB4            0x00c
                #define D3DFVF_XYZB5            0x00e
                #define D3DFVF_XYZW             0x4002
                
                #define D3DFVF_NORMAL           0x010
                #define D3DFVF_PSIZE            0x020
                #define D3DFVF_DIFFUSE          0x040
                #define D3DFVF_SPECULAR         0x080
                
                #define D3DFVF_TEXCOUNT_MASK    0xf00
                #define D3DFVF_TEXCOUNT_SHIFT   8
                #define D3DFVF_TEX0             0x000
                #define D3DFVF_TEX1             0x100
                #define D3DFVF_TEX2             0x200
                #define D3DFVF_TEX3             0x300
                #define D3DFVF_TEX4             0x400
                #define D3DFVF_TEX5             0x500
                #define D3DFVF_TEX6             0x600
                #define D3DFVF_TEX7             0x700
                #define D3DFVF_TEX8             0x800
                
                #define D3DFVF_LASTBETA_UBYTE4   0x1000
                #define D3DFVF_LASTBETA_D3DCOLOR 0x8000
                
                #define D3DFVF_RESERVED2         0x6000  // 2 reserved bits
                
                //---------------------------------------------------------------------
                // Vertex Shaders
                //
                
                // Vertex shader declaration
                
                // Vertex element semantics
                //
                typedef enum _D3DDECLUSAGE
                {
                    D3DDECLUSAGE_POSITION = 0,
                    D3DDECLUSAGE_BLENDWEIGHT,   // 1
                    D3DDECLUSAGE_BLENDINDICES,  // 2
                    D3DDECLUSAGE_NORMAL,        // 3
                    D3DDECLUSAGE_PSIZE,         // 4
                    D3DDECLUSAGE_TEXCOORD,      // 5
                    D3DDECLUSAGE_TANGENT,       // 6
                    D3DDECLUSAGE_BINORMAL,      // 7
                    D3DDECLUSAGE_TESSFACTOR,    // 8
                    D3DDECLUSAGE_POSITIONT,     // 9
                    D3DDECLUSAGE_COLOR,         // 10
                    D3DDECLUSAGE_FOG,           // 11
                    D3DDECLUSAGE_DEPTH,         // 12
                    D3DDECLUSAGE_SAMPLE,        // 13
                } D3DDECLUSAGE;
                
                #define MAXD3DDECLUSAGE         D3DDECLUSAGE_SAMPLE
                #define MAXD3DDECLUSAGEINDEX    15
                #define MAXD3DDECLLENGTH        64 // does not include "end" marker vertex element
                
                typedef enum _D3DDECLMETHOD
                {
                    D3DDECLMETHOD_DEFAULT = 0,
                    D3DDECLMETHOD_PARTIALU,
                    D3DDECLMETHOD_PARTIALV,
                    D3DDECLMETHOD_CROSSUV,    // Normal
                    D3DDECLMETHOD_UV,
                    D3DDECLMETHOD_LOOKUP,               // Lookup a displacement map
                    D3DDECLMETHOD_LOOKUPPRESAMPLED,     // Lookup a pre-sampled displacement map
                } D3DDECLMETHOD;
                
                #define MAXD3DDECLMETHOD D3DDECLMETHOD_LOOKUPPRESAMPLED
                
                // Declarations for _Type fields
                //
                typedef enum _D3DDECLTYPE
                {
                    D3DDECLTYPE_FLOAT1    =  0,  // 1D float expanded to (value, 0., 0., 1.)
                    D3DDECLTYPE_FLOAT2    =  1,  // 2D float expanded to (value, value, 0., 1.)
                    D3DDECLTYPE_FLOAT3    =  2,  // 3D float expanded to (value, value, value, 1.)
                    D3DDECLTYPE_FLOAT4    =  3,  // 4D float
                    D3DDECLTYPE_D3DCOLOR  =  4,  // 4D packed unsigned bytes mapped to 0. to 1. range
                                                 // Input is in D3DCOLOR format (ARGB) expanded to (R, G, B, A)
                    D3DDECLTYPE_UBYTE4    =  5,  // 4D unsigned byte
                    D3DDECLTYPE_SHORT2    =  6,  // 2D signed short expanded to (value, value, 0., 1.)
                    D3DDECLTYPE_SHORT4    =  7,  // 4D signed short
                
                // The following types are valid only with vertex shaders >= 2.0
                
                
                    D3DDECLTYPE_UBYTE4N   =  8,  // Each of 4 bytes is normalized by dividing to 255.0
                    D3DDECLTYPE_SHORT2N   =  9,  // 2D signed short normalized (v[0]/32767.0,v[1]/32767.0,0,1)
                    D3DDECLTYPE_SHORT4N   = 10,  // 4D signed short normalized (v[0]/32767.0,v[1]/32767.0,v[2]/32767.0,v[3]/32767.0)
                    D3DDECLTYPE_USHORT2N  = 11,  // 2D unsigned short normalized (v[0]/65535.0,v[1]/65535.0,0,1)
                    D3DDECLTYPE_USHORT4N  = 12,  // 4D unsigned short normalized (v[0]/65535.0,v[1]/65535.0,v[2]/65535.0,v[3]/65535.0)
                    D3DDECLTYPE_UDEC3     = 13,  // 3D unsigned 10 10 10 format expanded to (value, value, value, 1)
                    D3DDECLTYPE_DEC3N     = 14,  // 3D signed 10 10 10 format normalized and expanded to (v[0]/511.0, v[1]/511.0, v[2]/511.0, 1)
                    D3DDECLTYPE_FLOAT16_2 = 15,  // Two 16-bit floating point values, expanded to (value, value, 0, 1)
                    D3DDECLTYPE_FLOAT16_4 = 16,  // Four 16-bit floating point values
                    D3DDECLTYPE_UNUSED    = 17,  // When the type field in a decl is unused.
                } D3DDECLTYPE;
                
                #define MAXD3DDECLTYPE      D3DDECLTYPE_UNUSED
                
                typedef struct _D3DVERTEXELEMENT9
                {
                    WORD    Stream;     // Stream index
                    WORD    Offset;     // Offset in the stream in bytes
                    BYTE    Type;       // Data type
                    BYTE    Method;     // Processing method
                    BYTE    Usage;      // Semantics
                    BYTE    UsageIndex; // Semantic index
                } D3DVERTEXELEMENT9, *LPD3DVERTEXELEMENT9;
                
                // This is used to initialize the last vertex element in a vertex declaration
                // array
                //
                #define D3DDECL_END() {0xFF,0,D3DDECLTYPE_UNUSED,0,0,0}
                
                // Maximum supported number of texture coordinate sets
                #define D3DDP_MAXTEXCOORD   8
                
                //---------------------------------------------------------------------
                // Values for IDirect3DDevice9::SetStreamSourceFreq's Setting parameter
                //---------------------------------------------------------------------
                #define D3DSTREAMSOURCE_INDEXEDDATA  (1<<30)
                #define D3DSTREAMSOURCE_INSTANCEDATA (2<<30)
                
                
                
                //---------------------------------------------------------------------
                //
                // The internal format of Pixel Shader (PS) & Vertex Shader (VS)
                // Instruction Tokens is defined in the Direct3D Device Driver Kit
                //
                //---------------------------------------------------------------------
                
                //
                // Instruction Token Bit Definitions
                //
                #define D3DSI_OPCODE_MASK       0x0000FFFF
                
                #define D3DSI_INSTLENGTH_MASK   0x0F000000
                #define D3DSI_INSTLENGTH_SHIFT  24
                
                typedef enum _D3DSHADER_INSTRUCTION_OPCODE_TYPE
                {
                    D3DSIO_NOP          = 0,
                    D3DSIO_MOV          ,
                    D3DSIO_ADD          ,
                    D3DSIO_SUB          ,
                    D3DSIO_MAD          ,
                    D3DSIO_MUL          ,
                    D3DSIO_RCP          ,
                    D3DSIO_RSQ          ,
                    D3DSIO_DP3          ,
                    D3DSIO_DP4          ,
                    D3DSIO_MIN          ,
                    D3DSIO_MAX          ,
                    D3DSIO_SLT          ,
                    D3DSIO_SGE          ,
                    D3DSIO_EXP          ,
                    D3DSIO_LOG          ,
                    D3DSIO_LIT          ,
                    D3DSIO_DST          ,
                    D3DSIO_LRP          ,
                    D3DSIO_FRC          ,
                    D3DSIO_M4x4         ,
                    D3DSIO_M4x3         ,
                    D3DSIO_M3x4         ,
                    D3DSIO_M3x3         ,
                    D3DSIO_M3x2         ,
                    D3DSIO_CALL         ,
                    D3DSIO_CALLNZ       ,
                    D3DSIO_LOOP         ,
                    D3DSIO_RET          ,
                    D3DSIO_ENDLOOP      ,
                    D3DSIO_LABEL        ,
                    D3DSIO_DCL          ,
                    D3DSIO_POW          ,
                    D3DSIO_CRS          ,
                    D3DSIO_SGN          ,
                    D3DSIO_ABS          ,
                    D3DSIO_NRM          ,
                    D3DSIO_SINCOS       ,
                    D3DSIO_REP          ,
                    D3DSIO_ENDREP       ,
                    D3DSIO_IF           ,
                    D3DSIO_IFC          ,
                    D3DSIO_ELSE         ,
                    D3DSIO_ENDIF        ,
                    D3DSIO_BREAK        ,
                    D3DSIO_BREAKC       ,
                    D3DSIO_MOVA         ,
                    D3DSIO_DEFB         ,
                    D3DSIO_DEFI         ,
                
                    D3DSIO_TEXCOORD     = 64,
                    D3DSIO_TEXKILL      ,
                    D3DSIO_TEX          ,
                    D3DSIO_TEXBEM       ,
                    D3DSIO_TEXBEML      ,
                    D3DSIO_TEXREG2AR    ,
                    D3DSIO_TEXREG2GB    ,
                    D3DSIO_TEXM3x2PAD   ,
                    D3DSIO_TEXM3x2TEX   ,
                    D3DSIO_TEXM3x3PAD   ,
                    D3DSIO_TEXM3x3TEX   ,
                    D3DSIO_RESERVED0    ,
                    D3DSIO_TEXM3x3SPEC  ,
                    D3DSIO_TEXM3x3VSPEC ,
                    D3DSIO_EXPP         ,
                    D3DSIO_LOGP         ,
                    D3DSIO_CND          ,
                    D3DSIO_DEF          ,
                    D3DSIO_TEXREG2RGB   ,
                    D3DSIO_TEXDP3TEX    ,
                    D3DSIO_TEXM3x2DEPTH ,
                    D3DSIO_TEXDP3       ,
                    D3DSIO_TEXM3x3      ,
                    D3DSIO_TEXDEPTH     ,
                    D3DSIO_CMP          ,
                    D3DSIO_BEM          ,
                    D3DSIO_DP2ADD       ,
                    D3DSIO_DSX          ,
                    D3DSIO_DSY          ,
                    D3DSIO_TEXLDD       ,
                    D3DSIO_SETP         ,
                    D3DSIO_TEXLDL       ,
                    D3DSIO_BREAKP       ,
                
                    D3DSIO_PHASE        = 0xFFFD,
                    D3DSIO_COMMENT      = 0xFFFE,
                    D3DSIO_END          = 0xFFFF,
                
                    D3DSIO_FORCE_DWORD  = 0x7fffffff,   // force 32-bit size enum
                } D3DSHADER_INSTRUCTION_OPCODE_TYPE;
                
                //---------------------------------------------------------------------
                // Use these constants with D3DSIO_SINCOS macro as SRC2, SRC3
                //
                #define D3DSINCOSCONST1 -1.5500992e-006f, -2.1701389e-005f,  0.0026041667f, 0.00026041668f
                #define D3DSINCOSCONST2 -0.020833334f, -0.12500000f, 1.0f, 0.50000000f
                
                //---------------------------------------------------------------------
                // Co-Issue Instruction Modifier - if set then this instruction is to be
                // issued in parallel with the previous instruction(s) for which this bit
                // is not set.
                //
                #define D3DSI_COISSUE           0x40000000
                
                //---------------------------------------------------------------------
                // Opcode specific controls
                
                #define D3DSP_OPCODESPECIFICCONTROL_MASK  0x00ff0000
                #define D3DSP_OPCODESPECIFICCONTROL_SHIFT 16
                
                // ps_2_0 texld controls
                #define D3DSI_TEXLD_PROJECT (0x01 << D3DSP_OPCODESPECIFICCONTROL_SHIFT)
                #define D3DSI_TEXLD_BIAS    (0x02 << D3DSP_OPCODESPECIFICCONTROL_SHIFT)
                
                // Comparison for dynamic conditional instruction opcodes (i.e. if, breakc)
                typedef enum _D3DSHADER_COMPARISON
                {
                                         // < = >
                    D3DSPC_RESERVED0= 0, // 0 0 0
                    D3DSPC_GT       = 1, // 0 0 1
                    D3DSPC_EQ       = 2, // 0 1 0
                    D3DSPC_GE       = 3, // 0 1 1
                    D3DSPC_LT       = 4, // 1 0 0
                    D3DSPC_NE       = 5, // 1 0 1
                    D3DSPC_LE       = 6, // 1 1 0
                    D3DSPC_RESERVED1= 7  // 1 1 1
                } D3DSHADER_COMPARISON;
                
                // Comparison is part of instruction opcode token:
                #define D3DSHADER_COMPARISON_SHIFT D3DSP_OPCODESPECIFICCONTROL_SHIFT
                #define D3DSHADER_COMPARISON_MASK  (0x7<<D3DSHADER_COMPARISON_SHIFT)
                
                //---------------------------------------------------------------------
                // Predication flags on instruction token
                #define D3DSHADER_INSTRUCTION_PREDICATED    (0x1 << 28)
                
                //---------------------------------------------------------------------
                // DCL Info Token Controls
                
                // For dcl info tokens requiring a semantic (usage + index)
                #define D3DSP_DCL_USAGE_SHIFT 0
                #define D3DSP_DCL_USAGE_MASK  0x0000000f
                
                #define D3DSP_DCL_USAGEINDEX_SHIFT 16
                #define D3DSP_DCL_USAGEINDEX_MASK  0x000f0000
                
                // DCL pixel shader sampler info token.
                #define D3DSP_TEXTURETYPE_SHIFT 27
                #define D3DSP_TEXTURETYPE_MASK  0x78000000
                
                typedef enum _D3DSAMPLER_TEXTURE_TYPE
                {
                    D3DSTT_UNKNOWN = 0<<D3DSP_TEXTURETYPE_SHIFT, // uninitialized value
                    D3DSTT_2D      = 2<<D3DSP_TEXTURETYPE_SHIFT, // dcl_2d s# (for declaring a 2-D texture)
                    D3DSTT_CUBE    = 3<<D3DSP_TEXTURETYPE_SHIFT, // dcl_cube s# (for declaring a cube texture)
                    D3DSTT_VOLUME  = 4<<D3DSP_TEXTURETYPE_SHIFT, // dcl_volume s# (for declaring a volume texture)
                    D3DSTT_FORCE_DWORD  = 0x7fffffff,      // force 32-bit size enum
                } D3DSAMPLER_TEXTURE_TYPE;
                
                //---------------------------------------------------------------------
                // Parameter Token Bit Definitions
                //
                #define D3DSP_REGNUM_MASK       0x000007FF
                
                // destination parameter write mask
                #define D3DSP_WRITEMASK_0       0x00010000  // Component 0 (X;Red)
                #define D3DSP_WRITEMASK_1       0x00020000  // Component 1 (Y;Green)
                #define D3DSP_WRITEMASK_2       0x00040000  // Component 2 (Z;Blue)
                #define D3DSP_WRITEMASK_3       0x00080000  // Component 3 (W;Alpha)
                #define D3DSP_WRITEMASK_ALL     0x000F0000  // All Components
                
                // destination parameter modifiers
                #define D3DSP_DSTMOD_SHIFT      20
                #define D3DSP_DSTMOD_MASK       0x00F00000
                
                // Bit masks for destination parameter modifiers
                #define    D3DSPDM_NONE                 (0<<D3DSP_DSTMOD_SHIFT) // nop
                #define    D3DSPDM_SATURATE             (1<<D3DSP_DSTMOD_SHIFT) // clamp to 0. to 1. range
                #define    D3DSPDM_PARTIALPRECISION     (2<<D3DSP_DSTMOD_SHIFT) // Partial precision hint
                #define    D3DSPDM_MSAMPCENTROID        (4<<D3DSP_DSTMOD_SHIFT) // Relevant to multisampling only:
                                                                                //      When the pixel center is not covered, sample
                                                                                //      attribute or compute gradients/LOD
                                                                                //      using multisample "centroid" location.
                                                                                //      "Centroid" is some location within the covered
                                                                                //      region of the pixel.
                
                // destination parameter 
                #define D3DSP_DSTSHIFT_SHIFT    24
                #define D3DSP_DSTSHIFT_MASK     0x0F000000
                
                // destination/source parameter register type
                #define D3DSP_REGTYPE_SHIFT     28
                #define D3DSP_REGTYPE_SHIFT2    8
                #define D3DSP_REGTYPE_MASK      0x70000000
                #define D3DSP_REGTYPE_MASK2     0x00001800
                
                typedef enum _D3DSHADER_PARAM_REGISTER_TYPE
                {
                    D3DSPR_TEMP           =  0, // Temporary Register File
                    D3DSPR_INPUT          =  1, // Input Register File
                    D3DSPR_CONST          =  2, // Constant Register File
                    D3DSPR_ADDR           =  3, // Address Register (VS)
                    D3DSPR_TEXTURE        =  3, // Texture Register File (PS)
                    D3DSPR_RASTOUT        =  4, // Rasterizer Register File
                    D3DSPR_ATTROUT        =  5, // Attribute Output Register File
                    D3DSPR_TEXCRDOUT      =  6, // Texture Coordinate Output Register File
                    D3DSPR_OUTPUT         =  6, // Output register file for VS3.0+
                    D3DSPR_CONSTINT       =  7, // Constant Integer Vector Register File
                    D3DSPR_COLOROUT       =  8, // Color Output Register File
                    D3DSPR_DEPTHOUT       =  9, // Depth Output Register File
                    D3DSPR_SAMPLER        = 10, // Sampler State Register File
                    D3DSPR_CONST2         = 11, // Constant Register File  2048 - 4095
                    D3DSPR_CONST3         = 12, // Constant Register File  4096 - 6143
                    D3DSPR_CONST4         = 13, // Constant Register File  6144 - 8191
                    D3DSPR_CONSTBOOL      = 14, // Constant Boolean register file
                    D3DSPR_LOOP           = 15, // Loop counter register file
                    D3DSPR_TEMPFLOAT16    = 16, // 16-bit float temp register file
                    D3DSPR_MISCTYPE       = 17, // Miscellaneous (single) registers.
                    D3DSPR_LABEL          = 18, // Label
                    D3DSPR_PREDICATE      = 19, // Predicate register
                    D3DSPR_FORCE_DWORD  = 0x7fffffff,         // force 32-bit size enum
                } D3DSHADER_PARAM_REGISTER_TYPE;
                
                // The miscellaneous register file (D3DSPR_MISCTYPES)
                // contains register types for which there is only ever one
                // register (i.e. the register # is not needed).
                // Rather than use up additional register types for such
                // registers, they are defined
                // as particular offsets into the misc. register file:
                typedef enum _D3DSHADER_MISCTYPE_OFFSETS
                {
                    D3DSMO_POSITION   = 0, // Input position x,y,z,rhw (PS)
                    D3DSMO_FACE   = 1, // Floating point primitive area (PS)
                } D3DSHADER_MISCTYPE_OFFSETS;
                
                // Register offsets in the Rasterizer Register File
                //
                typedef enum _D3DVS_RASTOUT_OFFSETS
                {
                    D3DSRO_POSITION = 0,
                    D3DSRO_FOG,
                    D3DSRO_POINT_SIZE,
                    D3DSRO_FORCE_DWORD  = 0x7fffffff,         // force 32-bit size enum
                } D3DVS_RASTOUT_OFFSETS;
                
                // Source operand addressing modes
                
                #define D3DVS_ADDRESSMODE_SHIFT 13
                #define D3DVS_ADDRESSMODE_MASK  (1 << D3DVS_ADDRESSMODE_SHIFT)
                
                typedef enum _D3DVS_ADDRESSMODE_TYPE
                {
                    D3DVS_ADDRMODE_ABSOLUTE  = (0 << D3DVS_ADDRESSMODE_SHIFT),
                    D3DVS_ADDRMODE_RELATIVE  = (1 << D3DVS_ADDRESSMODE_SHIFT),
                    D3DVS_ADDRMODE_FORCE_DWORD = 0x7fffffff, // force 32-bit size enum
                } D3DVS_ADDRESSMODE_TYPE;
                
                #define D3DSHADER_ADDRESSMODE_SHIFT 13
                #define D3DSHADER_ADDRESSMODE_MASK  (1 << D3DSHADER_ADDRESSMODE_SHIFT)
                
                typedef enum _D3DSHADER_ADDRESSMODE_TYPE
                {
                    D3DSHADER_ADDRMODE_ABSOLUTE  = (0 << D3DSHADER_ADDRESSMODE_SHIFT),
                    D3DSHADER_ADDRMODE_RELATIVE  = (1 << D3DSHADER_ADDRESSMODE_SHIFT),
                    D3DSHADER_ADDRMODE_FORCE_DWORD = 0x7fffffff, // force 32-bit size enum
                } D3DSHADER_ADDRESSMODE_TYPE;
                
                // Source operand swizzle definitions
                //
                #define D3DVS_SWIZZLE_SHIFT     16
                #define D3DVS_SWIZZLE_MASK      0x00FF0000
                
                // The following bits define where to take component X from:
                
                #define D3DVS_X_X       (0 << D3DVS_SWIZZLE_SHIFT)
                #define D3DVS_X_Y       (1 << D3DVS_SWIZZLE_SHIFT)
                #define D3DVS_X_Z       (2 << D3DVS_SWIZZLE_SHIFT)
                #define D3DVS_X_W       (3 << D3DVS_SWIZZLE_SHIFT)
                
                // The following bits define where to take component Y from:
                
                #define D3DVS_Y_X       (0 << (D3DVS_SWIZZLE_SHIFT + 2))
                #define D3DVS_Y_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 2))
                #define D3DVS_Y_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 2))
                #define D3DVS_Y_W       (3 << (D3DVS_SWIZZLE_SHIFT + 2))
                
                // The following bits define where to take component Z from:
                
                #define D3DVS_Z_X       (0 << (D3DVS_SWIZZLE_SHIFT + 4))
                #define D3DVS_Z_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 4))
                #define D3DVS_Z_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 4))
                #define D3DVS_Z_W       (3 << (D3DVS_SWIZZLE_SHIFT + 4))
                
                // The following bits define where to take component W from:
                
                #define D3DVS_W_X       (0 << (D3DVS_SWIZZLE_SHIFT + 6))
                #define D3DVS_W_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 6))
                #define D3DVS_W_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 6))
                #define D3DVS_W_W       (3 << (D3DVS_SWIZZLE_SHIFT + 6))
                
                // Value when there is no swizzle (X is taken from X, Y is taken from Y,
                // Z is taken from Z, W is taken from W
                //
                #define D3DVS_NOSWIZZLE (D3DVS_X_X | D3DVS_Y_Y | D3DVS_Z_Z | D3DVS_W_W)
                
                // source parameter swizzle
                #define D3DSP_SWIZZLE_SHIFT     16
                #define D3DSP_SWIZZLE_MASK      0x00FF0000
                
                #define D3DSP_NOSWIZZLE \
                    ( (0 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
                      (1 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
                      (2 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
                      (3 << (D3DSP_SWIZZLE_SHIFT + 6)) )
                
                // pixel-shader swizzle ops
                #define D3DSP_REPLICATERED \
                    ( (0 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
                      (0 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
                      (0 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
                      (0 << (D3DSP_SWIZZLE_SHIFT + 6)) )
                
                #define D3DSP_REPLICATEGREEN \
                    ( (1 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
                      (1 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
                      (1 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
                      (1 << (D3DSP_SWIZZLE_SHIFT + 6)) )
                
                #define D3DSP_REPLICATEBLUE \
                    ( (2 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
                      (2 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
                      (2 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
                      (2 << (D3DSP_SWIZZLE_SHIFT + 6)) )
                
                #define D3DSP_REPLICATEALPHA \
                    ( (3 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
                      (3 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
                      (3 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
                      (3 << (D3DSP_SWIZZLE_SHIFT + 6)) )
                
                // source parameter modifiers
                #define D3DSP_SRCMOD_SHIFT      24
                #define D3DSP_SRCMOD_MASK       0x0F000000
                
                typedef enum _D3DSHADER_PARAM_SRCMOD_TYPE
                {
                    D3DSPSM_NONE    = 0<<D3DSP_SRCMOD_SHIFT, // nop
                    D3DSPSM_NEG     = 1<<D3DSP_SRCMOD_SHIFT, // negate
                    D3DSPSM_BIAS    = 2<<D3DSP_SRCMOD_SHIFT, // bias
                    D3DSPSM_BIASNEG = 3<<D3DSP_SRCMOD_SHIFT, // bias and negate
                    D3DSPSM_SIGN    = 4<<D3DSP_SRCMOD_SHIFT, // sign
                    D3DSPSM_SIGNNEG = 5<<D3DSP_SRCMOD_SHIFT, // sign and negate
                    D3DSPSM_COMP    = 6<<D3DSP_SRCMOD_SHIFT, // complement
                    D3DSPSM_X2      = 7<<D3DSP_SRCMOD_SHIFT, // *2
                    D3DSPSM_X2NEG   = 8<<D3DSP_SRCMOD_SHIFT, // *2 and negate
                    D3DSPSM_DZ      = 9<<D3DSP_SRCMOD_SHIFT, // divide through by z component
                    D3DSPSM_DW      = 10<<D3DSP_SRCMOD_SHIFT, // divide through by w component
                    D3DSPSM_ABS     = 11<<D3DSP_SRCMOD_SHIFT, // abs()
                    D3DSPSM_ABSNEG  = 12<<D3DSP_SRCMOD_SHIFT, // -abs()
                    D3DSPSM_NOT     = 13<<D3DSP_SRCMOD_SHIFT, // for predicate register: "!p0"
                    D3DSPSM_FORCE_DWORD = 0x7fffffff,        // force 32-bit size enum
                } D3DSHADER_PARAM_SRCMOD_TYPE;
                
                // pixel shader version token
                #define D3DPS_VERSION(_Major,_Minor) (0xFFFF0000|((_Major)<<8)|(_Minor))
                
                // vertex shader version token
                #define D3DVS_VERSION(_Major,_Minor) (0xFFFE0000|((_Major)<<8)|(_Minor))
                
                // extract major/minor from version cap
                #define D3DSHADER_VERSION_MAJOR(_Version) (((_Version)>>8)&0xFF)
                #define D3DSHADER_VERSION_MINOR(_Version) (((_Version)>>0)&0xFF)
                
                // destination/source parameter register type
                #define D3DSI_COMMENTSIZE_SHIFT     16
                #define D3DSI_COMMENTSIZE_MASK      0x7FFF0000
                #define D3DSHADER_COMMENT(_DWordSize) \
                    ((((_DWordSize)<<D3DSI_COMMENTSIZE_SHIFT)&D3DSI_COMMENTSIZE_MASK)|D3DSIO_COMMENT)
                
                // pixel/vertex shader end token
                #define D3DPS_END()  0x0000FFFF
                #define D3DVS_END()  0x0000FFFF
                
                
                //---------------------------------------------------------------------
                
                // High order surfaces
                //
                typedef enum _D3DBASISTYPE
                {
                   D3DBASIS_BEZIER      = 0,
                   D3DBASIS_BSPLINE     = 1,
                   D3DBASIS_CATMULL_ROM = 2, /* In D3D8 this used to be D3DBASIS_INTERPOLATE */
                   D3DBASIS_FORCE_DWORD = 0x7fffffff,
                } D3DBASISTYPE;
                
                typedef enum _D3DDEGREETYPE
                {
                   D3DDEGREE_LINEAR      = 1,
                   D3DDEGREE_QUADRATIC   = 2,
                   D3DDEGREE_CUBIC       = 3,
                   D3DDEGREE_QUINTIC     = 5,
                   D3DDEGREE_FORCE_DWORD = 0x7fffffff,
                } D3DDEGREETYPE;
                
                typedef enum _D3DPATCHEDGESTYLE
                {
                   D3DPATCHEDGE_DISCRETE    = 0,
                   D3DPATCHEDGE_CONTINUOUS  = 1,
                   D3DPATCHEDGE_FORCE_DWORD = 0x7fffffff,
                } D3DPATCHEDGESTYLE;
                
                typedef enum _D3DSTATEBLOCKTYPE
                {
                    D3DSBT_ALL           = 1, // capture all state
                    D3DSBT_PIXELSTATE    = 2, // capture pixel state
                    D3DSBT_VERTEXSTATE   = 3, // capture vertex state
                    D3DSBT_FORCE_DWORD   = 0x7fffffff,
                } D3DSTATEBLOCKTYPE;
                
                // The D3DVERTEXBLENDFLAGS type is used with D3DRS_VERTEXBLEND state.
                //
                typedef enum _D3DVERTEXBLENDFLAGS
                {
                    D3DVBF_DISABLE  = 0,     // Disable vertex blending
                    D3DVBF_1WEIGHTS = 1,     // 2 matrix blending
                    D3DVBF_2WEIGHTS = 2,     // 3 matrix blending
                    D3DVBF_3WEIGHTS = 3,     // 4 matrix blending
                    D3DVBF_TWEENING = 255,   // blending using D3DRS_TWEENFACTOR
                    D3DVBF_0WEIGHTS = 256,   // one matrix is used with weight 1.0
                    D3DVBF_FORCE_DWORD = 0x7fffffff, // force 32-bit size enum
                } D3DVERTEXBLENDFLAGS;
                
                typedef enum _D3DTEXTURETRANSFORMFLAGS {
                    D3DTTFF_DISABLE         = 0,    // texture coordinates are passed directly
                    D3DTTFF_COUNT1          = 1,    // rasterizer should expect 1-D texture coords
                    D3DTTFF_COUNT2          = 2,    // rasterizer should expect 2-D texture coords
                    D3DTTFF_COUNT3          = 3,    // rasterizer should expect 3-D texture coords
                    D3DTTFF_COUNT4          = 4,    // rasterizer should expect 4-D texture coords
                    D3DTTFF_PROJECTED       = 256,  // texcoords to be divided by COUNTth element
                    D3DTTFF_FORCE_DWORD     = 0x7fffffff,
                } D3DTEXTURETRANSFORMFLAGS;
                
                // Macros to set texture coordinate format bits in the FVF id
                
                #define D3DFVF_TEXTUREFORMAT2 0         // Two floating point values
                #define D3DFVF_TEXTUREFORMAT1 3         // One floating point value
                #define D3DFVF_TEXTUREFORMAT3 1         // Three floating point values
                #define D3DFVF_TEXTUREFORMAT4 2         // Four floating point values
                
                #define D3DFVF_TEXCOORDSIZE3(CoordIndex) (D3DFVF_TEXTUREFORMAT3 << (CoordIndex*2 + 16))
                #define D3DFVF_TEXCOORDSIZE2(CoordIndex) (D3DFVF_TEXTUREFORMAT2)
                #define D3DFVF_TEXCOORDSIZE4(CoordIndex) (D3DFVF_TEXTUREFORMAT4 << (CoordIndex*2 + 16))
                #define D3DFVF_TEXCOORDSIZE1(CoordIndex) (D3DFVF_TEXTUREFORMAT1 << (CoordIndex*2 + 16))
                
                
                //---------------------------------------------------------------------
                
                /* Direct3D9 Device types */
                typedef enum _D3DDEVTYPE
                {
                    D3DDEVTYPE_HAL         = 1,
                    D3DDEVTYPE_REF         = 2,
                    D3DDEVTYPE_SW          = 3,
                
                    D3DDEVTYPE_NULLREF     = 4,
                
                    D3DDEVTYPE_FORCE_DWORD  = 0x7fffffff
                } D3DDEVTYPE;
                
                /* Multi-Sample buffer types */
                typedef enum _D3DMULTISAMPLE_TYPE
                {
                    D3DMULTISAMPLE_NONE            =  0,
                    D3DMULTISAMPLE_NONMASKABLE     =  1,
                    D3DMULTISAMPLE_2_SAMPLES       =  2,
                    D3DMULTISAMPLE_3_SAMPLES       =  3,
                    D3DMULTISAMPLE_4_SAMPLES       =  4,
                    D3DMULTISAMPLE_5_SAMPLES       =  5,
                    D3DMULTISAMPLE_6_SAMPLES       =  6,
                    D3DMULTISAMPLE_7_SAMPLES       =  7,
                    D3DMULTISAMPLE_8_SAMPLES       =  8,
                    D3DMULTISAMPLE_9_SAMPLES       =  9,
                    D3DMULTISAMPLE_10_SAMPLES      = 10,
                    D3DMULTISAMPLE_11_SAMPLES      = 11,
                    D3DMULTISAMPLE_12_SAMPLES      = 12,
                    D3DMULTISAMPLE_13_SAMPLES      = 13,
                    D3DMULTISAMPLE_14_SAMPLES      = 14,
                    D3DMULTISAMPLE_15_SAMPLES      = 15,
                    D3DMULTISAMPLE_16_SAMPLES      = 16,
                
                    D3DMULTISAMPLE_FORCE_DWORD     = 0x7fffffff
                } D3DMULTISAMPLE_TYPE;
                
                /* Formats
                 * Most of these names have the following convention:
                 *      A = Alpha
                 *      R = Red
                 *      G = Green
                 *      B = Blue
                 *      X = Unused Bits
                 *      P = Palette
                 *      L = Luminance
                 *      U = dU coordinate for BumpMap
                 *      V = dV coordinate for BumpMap
                 *      S = Stencil
                 *      D = Depth (e.g. Z or W buffer)
                 *      C = Computed from other channels (typically on certain read operations)
                 *
                 *      Further, the order of the pieces are from MSB first; hence
                 *      D3DFMT_A8L8 indicates that the high byte of this two byte
                 *      format is alpha.
                 *
                 *      D3DFMT_D16_LOCKABLE indicates:
                 *           - An integer 16-bit value.
                 *           - An app-lockable surface.
                 *
                 *      D3DFMT_D32F_LOCKABLE indicates:
                 *           - An IEEE 754 floating-point value.
                 *           - An app-lockable surface.
                 *
                 *      All Depth/Stencil formats except D3DFMT_D16_LOCKABLE and D3DFMT_D32F_LOCKABLE indicate:
                 *          - no particular bit ordering per pixel, and
                 *          - are not app lockable, and
                 *          - the driver is allowed to consume more than the indicated
                 *            number of bits per Depth channel (but not Stencil channel).
                 */
                #ifndef MAKEFOURCC
                    #define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |       \
                                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))
                #endif /* defined(MAKEFOURCC) */
                
                
                typedef enum _D3DFORMAT
                {
                    D3DFMT_UNKNOWN              =  0,
                
                    D3DFMT_R8G8B8               = 20,
                    D3DFMT_A8R8G8B8             = 21,
                    D3DFMT_X8R8G8B8             = 22,
                    D3DFMT_R5G6B5               = 23,
                    D3DFMT_X1R5G5B5             = 24,
                    D3DFMT_A1R5G5B5             = 25,
                    D3DFMT_A4R4G4B4             = 26,
                    D3DFMT_R3G3B2               = 27,
                    D3DFMT_A8                   = 28,
                    D3DFMT_A8R3G3B2             = 29,
                    D3DFMT_X4R4G4B4             = 30,
                    D3DFMT_A2B10G10R10          = 31,
                    D3DFMT_A8B8G8R8             = 32,
                    D3DFMT_X8B8G8R8             = 33,
                    D3DFMT_G16R16               = 34,
                    D3DFMT_A2R10G10B10          = 35,
                    D3DFMT_A16B16G16R16         = 36,
                
                    D3DFMT_A8P8                 = 40,
                    D3DFMT_P8                   = 41,
                
                    D3DFMT_L8                   = 50,
                    D3DFMT_A8L8                 = 51,
                    D3DFMT_A4L4                 = 52,
                
                    D3DFMT_V8U8                 = 60,
                    D3DFMT_L6V5U5               = 61,
                    D3DFMT_X8L8V8U8             = 62,
                    D3DFMT_Q8W8V8U8             = 63,
                    D3DFMT_V16U16               = 64,
                    D3DFMT_A2W10V10U10          = 67,
                
                    D3DFMT_UYVY                 = MAKEFOURCC('U', 'Y', 'V', 'Y'),
                    D3DFMT_R8G8_B8G8            = MAKEFOURCC('R', 'G', 'B', 'G'),
                    D3DFMT_YUY2                 = MAKEFOURCC('Y', 'U', 'Y', '2'),
                    D3DFMT_G8R8_G8B8            = MAKEFOURCC('G', 'R', 'G', 'B'),
                    D3DFMT_DXT1                 = MAKEFOURCC('D', 'X', 'T', '1'),
                    D3DFMT_DXT2                 = MAKEFOURCC('D', 'X', 'T', '2'),
                    D3DFMT_DXT3                 = MAKEFOURCC('D', 'X', 'T', '3'),
                    D3DFMT_DXT4                 = MAKEFOURCC('D', 'X', 'T', '4'),
                    D3DFMT_DXT5                 = MAKEFOURCC('D', 'X', 'T', '5'),
                
                    D3DFMT_D16_LOCKABLE         = 70,
                    D3DFMT_D32                  = 71,
                    D3DFMT_D15S1                = 73,
                    D3DFMT_D24S8                = 75,
                    D3DFMT_D24X8                = 77,
                    D3DFMT_D24X4S4              = 79,
                    D3DFMT_D16                  = 80,
                
                    D3DFMT_D32F_LOCKABLE        = 82,
                    D3DFMT_D24FS8               = 83,
                
                /* D3D9Ex only -- */
                #if !defined(D3D_DISABLE_9EX)
                
                    /* Z-Stencil formats valid for CPU access */
                    D3DFMT_D32_LOCKABLE         = 84,
                    D3DFMT_S8_LOCKABLE          = 85,
                
                #endif // !D3D_DISABLE_9EX
                /* -- D3D9Ex only */
                
                
                    D3DFMT_L16                  = 81,
                
                    D3DFMT_VERTEXDATA           =100,
                    D3DFMT_INDEX16              =101,
                    D3DFMT_INDEX32              =102,
                
                    D3DFMT_Q16W16V16U16         =110,
                
                    D3DFMT_MULTI2_ARGB8         = MAKEFOURCC('M','E','T','1'),
                
                    // Floating point surface formats
                
                    // s10e5 formats (16-bits per channel)
                    D3DFMT_R16F                 = 111,
                    D3DFMT_G16R16F              = 112,
                    D3DFMT_A16B16G16R16F        = 113,
                
                    // IEEE s23e8 formats (32-bits per channel)
                    D3DFMT_R32F                 = 114,
                    D3DFMT_G32R32F              = 115,
                    D3DFMT_A32B32G32R32F        = 116,
                
                    D3DFMT_CxV8U8               = 117,
                
                /* D3D9Ex only -- */
                #if !defined(D3D_DISABLE_9EX)
                
                    // Monochrome 1 bit per pixel format
                    D3DFMT_A1                   = 118,
                
                    // 2.8 biased fixed point
                    D3DFMT_A2B10G10R10_XR_BIAS  = 119,
                
                
                    // Binary format indicating that the data has no inherent type
                    D3DFMT_BINARYBUFFER         = 199,
                    
                #endif // !D3D_DISABLE_9EX
                /* -- D3D9Ex only */
                
                
                    D3DFMT_FORCE_DWORD          =0x7fffffff
                } D3DFORMAT;
                
                /* Display Modes */
                typedef struct _D3DDISPLAYMODE
                {
                    UINT            Width;
                    UINT            Height;
                    UINT            RefreshRate;
                    D3DFORMAT       Format;
                } D3DDISPLAYMODE;
                
                /* Creation Parameters */
                typedef struct _D3DDEVICE_CREATION_PARAMETERS
                {
                    UINT            AdapterOrdinal;
                    D3DDEVTYPE      DeviceType;
                    HWND            hFocusWindow;
                    DWORD           BehaviorFlags;
                } D3DDEVICE_CREATION_PARAMETERS;
                
                
                /* SwapEffects */
                typedef enum _D3DSWAPEFFECT
                {
                    D3DSWAPEFFECT_DISCARD           = 1,
                    D3DSWAPEFFECT_FLIP              = 2,
                    D3DSWAPEFFECT_COPY              = 3,
                    D3DSWAPEFFECT_OVERLAY           = 4,
                    D3DSWAPEFFECT_FLIPEX            = 5,
                
                    D3DSWAPEFFECT_FORCE_DWORD       = 0x7fffffff
                } D3DSWAPEFFECT;
                
                /* Pool types */
                typedef enum _D3DPOOL {
                    D3DPOOL_DEFAULT                 = 0,
                    D3DPOOL_MANAGED                 = 1,
                    D3DPOOL_SYSTEMMEM               = 2,
                    D3DPOOL_SCRATCH                 = 3,
                
                    D3DPOOL_FORCE_DWORD             = 0x7fffffff
                } D3DPOOL;
                
                
                /* RefreshRate pre-defines */
                #define D3DPRESENT_RATE_DEFAULT         0x00000000
                
                
                /* Resize Optional Parameters */
                typedef struct _D3DPRESENT_PARAMETERS_
                {
                    UINT                BackBufferWidth;
                    UINT                BackBufferHeight;
                    D3DFORMAT           BackBufferFormat;
                    UINT                BackBufferCount;
                
                    D3DMULTISAMPLE_TYPE MultiSampleType;
                    DWORD               MultiSampleQuality;
                
                    D3DSWAPEFFECT       SwapEffect;
                    HWND                hDeviceWindow;
                    BOOL                Windowed;
                    BOOL                EnableAutoDepthStencil;
                    D3DFORMAT           AutoDepthStencilFormat;
                    DWORD               Flags;
                
                    /* FullScreen_RefreshRateInHz must be zero for Windowed mode */
                    UINT                FullScreen_RefreshRateInHz;
                    UINT                PresentationInterval;
                } D3DPRESENT_PARAMETERS;
                
                // Values for D3DPRESENT_PARAMETERS.Flags
                
                #define D3DPRESENTFLAG_LOCKABLE_BACKBUFFER      0x00000001
                #define D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL     0x00000002
                #define D3DPRESENTFLAG_DEVICECLIP               0x00000004
                #define D3DPRESENTFLAG_VIDEO                    0x00000010
                
                /* D3D9Ex only -- */
                #if !defined(D3D_DISABLE_9EX)
                
                #define D3DPRESENTFLAG_NOAUTOROTATE                    0x00000020
                #define D3DPRESENTFLAG_UNPRUNEDMODE                    0x00000040
                #define D3DPRESENTFLAG_OVERLAY_LIMITEDRGB              0x00000080
                #define D3DPRESENTFLAG_OVERLAY_YCbCr_BT709             0x00000100
                #define D3DPRESENTFLAG_OVERLAY_YCbCr_xvYCC             0x00000200
                #define D3DPRESENTFLAG_RESTRICTED_CONTENT              0x00000400
                #define D3DPRESENTFLAG_RESTRICT_SHARED_RESOURCE_DRIVER 0x00000800
                
                #endif // !D3D_DISABLE_9EX
                /* -- D3D9Ex only */
                
                /* Gamma Ramp: Same as DX7 */
                
                typedef struct _D3DGAMMARAMP
                {
                    WORD                red  [256];
                    WORD                green[256];
                    WORD                blue [256];
                } D3DGAMMARAMP;
                
                /* Back buffer types */
                typedef enum _D3DBACKBUFFER_TYPE
                {
                    D3DBACKBUFFER_TYPE_MONO         = 0,
                    D3DBACKBUFFER_TYPE_LEFT         = 1,
                    D3DBACKBUFFER_TYPE_RIGHT        = 2,
                
                    D3DBACKBUFFER_TYPE_FORCE_DWORD  = 0x7fffffff
                } D3DBACKBUFFER_TYPE;
                
                
                /* Types */
                typedef enum _D3DRESOURCETYPE {
                    D3DRTYPE_SURFACE                =  1,
                    D3DRTYPE_VOLUME                 =  2,
                    D3DRTYPE_TEXTURE                =  3,
                    D3DRTYPE_VOLUMETEXTURE          =  4,
                    D3DRTYPE_CUBETEXTURE            =  5,
                    D3DRTYPE_VERTEXBUFFER           =  6,
                    D3DRTYPE_INDEXBUFFER            =  7,           //if this changes, change _D3DDEVINFO_RESOURCEMANAGER definition
                
                
                    D3DRTYPE_FORCE_DWORD            = 0x7fffffff
                } D3DRESOURCETYPE;
                
                /* Usages */
                #define D3DUSAGE_RENDERTARGET       (0x00000001L)
                #define D3DUSAGE_DEPTHSTENCIL       (0x00000002L)
                #define D3DUSAGE_DYNAMIC            (0x00000200L)
                
                /* D3D9Ex only -- */
                #if !defined(D3D_DISABLE_9EX)
                
                #define D3DUSAGE_NONSECURE          (0x00800000L)
                
                #endif // !D3D_DISABLE_9EX
                /* -- D3D9Ex only */
                
                // When passed to CheckDeviceFormat, D3DUSAGE_AUTOGENMIPMAP may return
                // D3DOK_NOAUTOGEN if the device doesn't support autogeneration for that format.
                // D3DOK_NOAUTOGEN is a success code, not a failure code... the SUCCEEDED and FAILED macros
                // will return true and false respectively for this code.
                #define D3DUSAGE_AUTOGENMIPMAP      (0x00000400L)
                #define D3DUSAGE_DMAP               (0x00004000L)
                
                // The following usages are valid only for querying CheckDeviceFormat
                #define D3DUSAGE_QUERY_LEGACYBUMPMAP            (0x00008000L)
                #define D3DUSAGE_QUERY_SRGBREAD                 (0x00010000L)
                #define D3DUSAGE_QUERY_FILTER                   (0x00020000L)
                #define D3DUSAGE_QUERY_SRGBWRITE                (0x00040000L)
                #define D3DUSAGE_QUERY_POSTPIXELSHADER_BLENDING (0x00080000L)
                #define D3DUSAGE_QUERY_VERTEXTEXTURE            (0x00100000L)
                #define D3DUSAGE_QUERY_WRAPANDMIP	            (0x00200000L)
                
                /* Usages for Vertex/Index buffers */
                #define D3DUSAGE_WRITEONLY          (0x00000008L)
                #define D3DUSAGE_SOFTWAREPROCESSING (0x00000010L)
                #define D3DUSAGE_DONOTCLIP          (0x00000020L)
                #define D3DUSAGE_POINTS             (0x00000040L)
                #define D3DUSAGE_RTPATCHES          (0x00000080L)
                #define D3DUSAGE_NPATCHES           (0x00000100L)
                
                /* D3D9Ex only -- */
                #if !defined(D3D_DISABLE_9EX)
                
                #define D3DUSAGE_TEXTAPI                         (0x10000000L)
                #define D3DUSAGE_RESTRICTED_CONTENT              (0x00000800L)
                #define D3DUSAGE_RESTRICT_SHARED_RESOURCE        (0x00002000L)
                #define D3DUSAGE_RESTRICT_SHARED_RESOURCE_DRIVER (0x00001000L) 
                
                #endif // !D3D_DISABLE_9EX
                /* -- D3D9Ex only */
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                /* CubeMap Face identifiers */
                typedef enum _D3DCUBEMAP_FACES
                {
                    D3DCUBEMAP_FACE_POSITIVE_X     = 0,
                    D3DCUBEMAP_FACE_NEGATIVE_X     = 1,
                    D3DCUBEMAP_FACE_POSITIVE_Y     = 2,
                    D3DCUBEMAP_FACE_NEGATIVE_Y     = 3,
                    D3DCUBEMAP_FACE_POSITIVE_Z     = 4,
                    D3DCUBEMAP_FACE_NEGATIVE_Z     = 5,
                
                    D3DCUBEMAP_FACE_FORCE_DWORD    = 0x7fffffff
                } D3DCUBEMAP_FACES;
                
                
                /* Lock flags */
                
                #define D3DLOCK_READONLY           0x00000010L
                #define D3DLOCK_DISCARD            0x00002000L
                #define D3DLOCK_NOOVERWRITE        0x00001000L
                #define D3DLOCK_NOSYSLOCK          0x00000800L
                #define D3DLOCK_DONOTWAIT          0x00004000L                  
                
                #define D3DLOCK_NO_DIRTY_UPDATE     0x00008000L
                
                
                
                
                
                
                
                /* Vertex Buffer Description */
                typedef struct _D3DVERTEXBUFFER_DESC
                {
                    D3DFORMAT           Format;
                    D3DRESOURCETYPE     Type;
                    DWORD               Usage;
                    D3DPOOL             Pool;
                    UINT                Size;
                
                    DWORD               FVF;
                
                } D3DVERTEXBUFFER_DESC;
                
                /* Index Buffer Description */
                typedef struct _D3DINDEXBUFFER_DESC
                {
                    D3DFORMAT           Format;
                    D3DRESOURCETYPE     Type;
                    DWORD               Usage;
                    D3DPOOL             Pool;
                    UINT                Size;
                } D3DINDEXBUFFER_DESC;
                
                
                /* Surface Description */
                typedef struct _D3DSURFACE_DESC
                {
                    D3DFORMAT           Format;
                    D3DRESOURCETYPE     Type;
                    DWORD               Usage;
                    D3DPOOL             Pool;
                
                    D3DMULTISAMPLE_TYPE MultiSampleType;
                    DWORD               MultiSampleQuality;
                    UINT                Width;
                    UINT                Height;
                } D3DSURFACE_DESC;
                
                typedef struct _D3DVOLUME_DESC
                {
                    D3DFORMAT           Format;
                    D3DRESOURCETYPE     Type;
                    DWORD               Usage;
                    D3DPOOL             Pool;
                
                    UINT                Width;
                    UINT                Height;
                    UINT                Depth;
                } D3DVOLUME_DESC;
                
                /* Structure for LockRect */
                typedef struct _D3DLOCKED_RECT
                {
                    INT                 Pitch;
                    void*               pBits;
                } D3DLOCKED_RECT;
                
                /* Structures for LockBox */
                typedef struct _D3DBOX
                {
                    UINT                Left;
                    UINT                Top;
                    UINT                Right;
                    UINT                Bottom;
                    UINT                Front;
                    UINT                Back;
                } D3DBOX;
                
                typedef struct _D3DLOCKED_BOX
                {
                    INT                 RowPitch;
                    INT                 SlicePitch;
                    void*               pBits;
                } D3DLOCKED_BOX;
                
                /* Structures for LockRange */
                typedef struct _D3DRANGE
                {
                    UINT                Offset;
                    UINT                Size;
                } D3DRANGE;
                
                /* Structures for high order primitives */
                typedef struct _D3DRECTPATCH_INFO
                {
                    UINT                StartVertexOffsetWidth;
                    UINT                StartVertexOffsetHeight;
                    UINT                Width;
                    UINT                Height;
                    UINT                Stride;
                    D3DBASISTYPE        Basis;
                    D3DDEGREETYPE       Degree;
                } D3DRECTPATCH_INFO;
                
                typedef struct _D3DTRIPATCH_INFO
                {
                    UINT                StartVertexOffset;
                    UINT                NumVertices;
                    D3DBASISTYPE        Basis;
                    D3DDEGREETYPE       Degree;
                } D3DTRIPATCH_INFO;
                
                /* Adapter Identifier */
                
                #define MAX_DEVICE_IDENTIFIER_STRING        512
                typedef struct _D3DADAPTER_IDENTIFIER9
                {
                    char            Driver[MAX_DEVICE_IDENTIFIER_STRING];
                    char            Description[MAX_DEVICE_IDENTIFIER_STRING];
                    char            DeviceName[32];         /* Device name for GDI (ex. \\.\DISPLAY1) */
                
                #ifdef _WIN32
                    LARGE_INTEGER   DriverVersion;          /* Defined for 32 bit components */
                #else
                    DWORD           DriverVersionLowPart;   /* Defined for 16 bit driver components */
                    DWORD           DriverVersionHighPart;
                #endif
                
                    DWORD           VendorId;
                    DWORD           DeviceId;
                    DWORD           SubSysId;
                    DWORD           Revision;
                
                    GUID            DeviceIdentifier;
                
                    DWORD           WHQLLevel;
                
                } D3DADAPTER_IDENTIFIER9;
                
                
                /* Raster Status structure returned by GetRasterStatus */
                typedef struct _D3DRASTER_STATUS
                {
                    BOOL            InVBlank;
                    UINT            ScanLine;
                } D3DRASTER_STATUS;
                
                
                
                /* Debug monitor tokens (DEBUG only)
                
                   Note that if D3DRS_DEBUGMONITORTOKEN is set, the call is treated as
                   passing a token to the debug monitor.  For example, if, after passing
                   D3DDMT_ENABLE/DISABLE to D3DRS_DEBUGMONITORTOKEN other token values
                   are passed in, the enabled/disabled state of the debug
                   monitor will still persist.
                
                   The debug monitor defaults to enabled.
                
                   Calling GetRenderState on D3DRS_DEBUGMONITORTOKEN is not of any use.
                */
                typedef enum _D3DDEBUGMONITORTOKENS {
                    D3DDMT_ENABLE            = 0,    // enable debug monitor
                    D3DDMT_DISABLE           = 1,    // disable debug monitor
                    D3DDMT_FORCE_DWORD     = 0x7fffffff,
                } D3DDEBUGMONITORTOKENS;
                
                // Async feedback
                
                typedef enum _D3DQUERYTYPE {
                    D3DQUERYTYPE_VCACHE                 = 4, /* D3DISSUE_END */
                    D3DQUERYTYPE_RESOURCEMANAGER        = 5, /* D3DISSUE_END */
                    D3DQUERYTYPE_VERTEXSTATS            = 6, /* D3DISSUE_END */
                    D3DQUERYTYPE_EVENT                  = 8, /* D3DISSUE_END */
                    D3DQUERYTYPE_OCCLUSION              = 9, /* D3DISSUE_BEGIN, D3DISSUE_END */
                    D3DQUERYTYPE_TIMESTAMP              = 10, /* D3DISSUE_END */
                    D3DQUERYTYPE_TIMESTAMPDISJOINT      = 11, /* D3DISSUE_BEGIN, D3DISSUE_END */
                    D3DQUERYTYPE_TIMESTAMPFREQ          = 12, /* D3DISSUE_END */
                    D3DQUERYTYPE_PIPELINETIMINGS        = 13, /* D3DISSUE_BEGIN, D3DISSUE_END */
                    D3DQUERYTYPE_INTERFACETIMINGS       = 14, /* D3DISSUE_BEGIN, D3DISSUE_END */
                    D3DQUERYTYPE_VERTEXTIMINGS          = 15, /* D3DISSUE_BEGIN, D3DISSUE_END */
                    D3DQUERYTYPE_PIXELTIMINGS           = 16, /* D3DISSUE_BEGIN, D3DISSUE_END */
                    D3DQUERYTYPE_BANDWIDTHTIMINGS       = 17, /* D3DISSUE_BEGIN, D3DISSUE_END */
                    D3DQUERYTYPE_CACHEUTILIZATION       = 18, /* D3DISSUE_BEGIN, D3DISSUE_END */
                /* D3D9Ex only -- */
                #if !defined(D3D_DISABLE_9EX)
                    D3DQUERYTYPE_MEMORYPRESSURE         = 19, /* D3DISSUE_BEGIN, D3DISSUE_END */
                #endif // !D3D_DISABLE_9EX
                } D3DQUERYTYPE;
                
                // Flags field for Issue
                #define D3DISSUE_END (1 << 0) // Tells the runtime to issue the end of a query, changing it's state to "non-signaled".
                #define D3DISSUE_BEGIN (1 << 1) // Tells the runtime to issue the beginng of a query.
                
                
                // Flags field for GetData
                #define D3DGETDATA_FLUSH (1 << 0) // Tells the runtime to flush if the query is outstanding.
                
                
                typedef struct _D3DRESOURCESTATS
                {
                // Data collected since last Present()
                    BOOL    bThrashing;             /* indicates if thrashing */
                    DWORD   ApproxBytesDownloaded;  /* Approximate number of bytes downloaded by resource manager */
                    DWORD   NumEvicts;              /* number of objects evicted */
                    DWORD   NumVidCreates;          /* number of objects created in video memory */
                    DWORD   LastPri;                /* priority of last object evicted */
                    DWORD   NumUsed;                /* number of objects set to the device */
                    DWORD   NumUsedInVidMem;        /* number of objects set to the device, which are already in video memory */
                // Persistent data
                    DWORD   WorkingSet;             /* number of objects in video memory */
                    DWORD   WorkingSetBytes;        /* number of bytes in video memory */
                    DWORD   TotalManaged;           /* total number of managed objects */
                    DWORD   TotalBytes;             /* total number of bytes of managed objects */
                } D3DRESOURCESTATS;
                
                #define D3DRTYPECOUNT (D3DRTYPE_INDEXBUFFER+1)
                
                typedef struct _D3DDEVINFO_RESOURCEMANAGER
                {
                #ifndef WOW64_ENUM_WORKAROUND
                    D3DRESOURCESTATS    stats[D3DRTYPECOUNT];
                #else
                    D3DRESOURCESTATS    stats[8];
                #endif
                } D3DDEVINFO_RESOURCEMANAGER, *LPD3DDEVINFO_RESOURCEMANAGER;
                
                typedef struct _D3DDEVINFO_D3DVERTEXSTATS
                {
                    DWORD   NumRenderedTriangles;       /* total number of triangles that are not clipped in this frame */
                    DWORD   NumExtraClippingTriangles;  /* Number of new triangles generated by clipping */
                } D3DDEVINFO_D3DVERTEXSTATS, *LPD3DDEVINFO_D3DVERTEXSTATS;
                
                
                typedef struct _D3DDEVINFO_VCACHE {
                    DWORD   Pattern;                    /* bit pattern, return value must be FOUR_CC('C', 'A', 'C', 'H') */
                    DWORD   OptMethod;                  /* optimization method 0 means longest strips, 1 means vertex cache based */
                    DWORD   CacheSize;                  /* cache size to optimize for  (only required if type is 1) */
                    DWORD   MagicNumber;                /* used to determine when to restart strips (only required if type is 1)*/
                } D3DDEVINFO_VCACHE, *LPD3DDEVINFO_VCACHE;
                
                typedef struct _D3DDEVINFO_D3D9PIPELINETIMINGS
                {
                    FLOAT VertexProcessingTimePercent;
                    FLOAT PixelProcessingTimePercent;
                    FLOAT OtherGPUProcessingTimePercent;
                    FLOAT GPUIdleTimePercent;
                } D3DDEVINFO_D3D9PIPELINETIMINGS;
                
                typedef struct _D3DDEVINFO_D3D9INTERFACETIMINGS
                {
                    FLOAT WaitingForGPUToUseApplicationResourceTimePercent;
                    FLOAT WaitingForGPUToAcceptMoreCommandsTimePercent;
                    FLOAT WaitingForGPUToStayWithinLatencyTimePercent;
                    FLOAT WaitingForGPUExclusiveResourceTimePercent;
                    FLOAT WaitingForGPUOtherTimePercent;
                } D3DDEVINFO_D3D9INTERFACETIMINGS;
                
                typedef struct _D3DDEVINFO_D3D9STAGETIMINGS
                {
                    FLOAT MemoryProcessingPercent;
                    FLOAT ComputationProcessingPercent;
                } D3DDEVINFO_D3D9STAGETIMINGS;
                
                typedef struct _D3DDEVINFO_D3D9BANDWIDTHTIMINGS
                {
                    FLOAT MaxBandwidthUtilized;
                    FLOAT FrontEndUploadMemoryUtilizedPercent;
                    FLOAT VertexRateUtilizedPercent;
                    FLOAT TriangleSetupRateUtilizedPercent;
                    FLOAT FillRateUtilizedPercent;
                } D3DDEVINFO_D3D9BANDWIDTHTIMINGS;
                
                typedef struct _D3DDEVINFO_D3D9CACHEUTILIZATION
                {
                    FLOAT TextureCacheHitRate; // Percentage of cache hits
                    FLOAT PostTransformVertexCacheHitRate;
                } D3DDEVINFO_D3D9CACHEUTILIZATION;
                
                #if !defined(D3D_DISABLE_9EX)
                
                typedef struct _D3DMEMORYPRESSURE
                {
                    UINT64  BytesEvictedFromProcess;
                    UINT64  SizeOfInefficientAllocation;
                    DWORD   LevelOfEfficiency;
                } D3DMEMORYPRESSURE;
                
                #endif
                
                /* D3D9Ex only -- */
                #if !defined(D3D_DISABLE_9EX)
                
                typedef enum _D3DCOMPOSERECTSOP{
                    D3DCOMPOSERECTS_COPY     = 1,
                    D3DCOMPOSERECTS_OR       = 2,
                    D3DCOMPOSERECTS_AND      = 3,
                    D3DCOMPOSERECTS_NEG      = 4,
                    D3DCOMPOSERECTS_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
                } D3DCOMPOSERECTSOP;
                
                typedef struct _D3DCOMPOSERECTDESC
                {
                    USHORT  X, Y;           // Top-left coordinates of a rect in the source surface
                    USHORT  Width, Height;  // Dimensions of the rect
                } D3DCOMPOSERECTDESC;
                
                typedef struct _D3DCOMPOSERECTDESTINATION
                {
                    USHORT SrcRectIndex;    // Index of D3DCOMPOSERECTDESC
                    USHORT Reserved;        // For alignment
                    SHORT  X, Y;            // Top-left coordinates of the rect in the destination surface
                } D3DCOMPOSERECTDESTINATION;
                
                #define D3DCOMPOSERECTS_MAXNUMRECTS 0xFFFF
                #define D3DCONVOLUTIONMONO_MAXWIDTH  7
                #define D3DCONVOLUTIONMONO_MAXHEIGHT D3DCONVOLUTIONMONO_MAXWIDTH
                #define D3DFMT_A1_SURFACE_MAXWIDTH  8192
                #define D3DFMT_A1_SURFACE_MAXHEIGHT 2048
                
                
                typedef struct _D3DPRESENTSTATS {
                    UINT PresentCount;
                    UINT PresentRefreshCount;
                    UINT SyncRefreshCount;
                    LARGE_INTEGER SyncQPCTime;
                    LARGE_INTEGER SyncGPUTime;
                } D3DPRESENTSTATS;
                
                typedef enum D3DSCANLINEORDERING
                {
                    D3DSCANLINEORDERING_UNKNOWN                    = 0, 
                    D3DSCANLINEORDERING_PROGRESSIVE                = 1,
                    D3DSCANLINEORDERING_INTERLACED                 = 2,
                } D3DSCANLINEORDERING;
                
                
                typedef struct D3DDISPLAYMODEEX
                {
                    UINT                    Size;
                    UINT                    Width;
                    UINT                    Height;
                    UINT                    RefreshRate;
                    D3DFORMAT               Format;
                    D3DSCANLINEORDERING     ScanLineOrdering;
                } D3DDISPLAYMODEEX;
                
                typedef struct D3DDISPLAYMODEFILTER
                {
                    UINT                    Size;
                    D3DFORMAT               Format;
                    D3DSCANLINEORDERING     ScanLineOrdering;
                } D3DDISPLAYMODEFILTER;
                
                
                typedef enum D3DDISPLAYROTATION
                {
                    D3DDISPLAYROTATION_IDENTITY = 1, // No rotation.           
                    D3DDISPLAYROTATION_90       = 2, // Rotated 90 degrees.
                    D3DDISPLAYROTATION_180      = 3, // Rotated 180 degrees.
                    D3DDISPLAYROTATION_270      = 4  // Rotated 270 degrees.
                } D3DDISPLAYROTATION;
                
                /* For use in ID3DResource9::SetPriority calls */
                #define D3D9_RESOURCE_PRIORITY_MINIMUM       0x28000000
                #define D3D9_RESOURCE_PRIORITY_LOW           0x50000000
                #define D3D9_RESOURCE_PRIORITY_NORMAL        0x78000000
                #define D3D9_RESOURCE_PRIORITY_HIGH          0xa0000000
                #define D3D9_RESOURCE_PRIORITY_MAXIMUM       0xc8000000
                
                #define D3D_OMAC_SIZE    16
                
                typedef struct _D3D_OMAC
                {
                    BYTE Omac[D3D_OMAC_SIZE];
                } D3D_OMAC;
                
                typedef enum _D3DAUTHENTICATEDCHANNELTYPE
                {
                    D3DAUTHENTICATEDCHANNEL_D3D9            = 1,
                    D3DAUTHENTICATEDCHANNEL_DRIVER_SOFTWARE = 2,
                    D3DAUTHENTICATEDCHANNEL_DRIVER_HARDWARE = 3,
                } D3DAUTHENTICATEDCHANNELTYPE;
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_QUERY_INPUT
                {
                    GUID                               QueryType;
                    HANDLE                             hChannel;
                    UINT                               SequenceNumber;
                } D3DAUTHENTICATEDCHANNEL_QUERY_INPUT;
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT
                {
                    D3D_OMAC                           omac;  
                    GUID                               QueryType;
                    HANDLE                             hChannel;
                    UINT                               SequenceNumber;
                    HRESULT                            ReturnCode;
                } D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT;
                
                DEFINE_GUID(D3DAUTHENTICATEDQUERY_PROTECTION, 
                0xa84eb584, 0xc495, 0x48aa, 0xb9, 0x4d, 0x8b, 0xd2, 0xd6, 0xfb, 0xce, 0x5);
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_PROTECTION_FLAGS
                {
                    union
                    {
                        struct
                        {
                            UINT ProtectionEnabled                       : 1; 
                            UINT OverlayOrFullscreenRequired             : 1;
                            UINT Reserved                                : 30;
                        };
                        UINT  Value;
                    };
                
                } D3DAUTHENTICATEDCHANNEL_PROTECTION_FLAGS;
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYPROTECTION_OUTPUT
                {
                    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
                
                    D3DAUTHENTICATEDCHANNEL_PROTECTION_FLAGS ProtectionFlags;
                
                } D3DAUTHENTICATEDCHANNEL_QUERYPROTECTION_OUTPUT;
                
                
                DEFINE_GUID(D3DAUTHENTICATEDQUERY_CHANNELTYPE, 
                0xbc1b18a5, 0xb1fb, 0x42ab, 0xbd, 0x94, 0xb5, 0x82, 0x8b, 0x4b, 0xf7, 0xbe);
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYCHANNELTYPE_OUTPUT
                {
                    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
                
                    D3DAUTHENTICATEDCHANNELTYPE ChannelType;
                
                } D3DAUTHENTICATEDCHANNEL_QUERYCHANNELTYPE_OUTPUT;
                
                
                DEFINE_GUID(D3DAUTHENTICATEDQUERY_DEVICEHANDLE, 
                0xec1c539d, 0x8cff, 0x4e2a, 0xbc, 0xc4, 0xf5, 0x69, 0x2f, 0x99, 0xf4, 0x80);
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYDEVICEHANDLE_OUTPUT
                {
                    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
                
                    HANDLE   DeviceHandle;
                
                } D3DAUTHENTICATEDCHANNEL_QUERYDEVICEHANDLE_OUTPUT;
                
                
                DEFINE_GUID(D3DAUTHENTICATEDQUERY_CRYPTOSESSION, 
                0x2634499e, 0xd018, 0x4d74, 0xac, 0x17, 0x7f, 0x72, 0x40, 0x59, 0x52, 0x8d);
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYCRYPTOSESSION_INPUT
                {
                    D3DAUTHENTICATEDCHANNEL_QUERY_INPUT Input;
                
                    HANDLE   DXVA2DecodeHandle;
                
                } D3DAUTHENTICATEDCHANNEL_QUERYCRYPTOSESSION_INPUT;
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYCRYPTOSESSION_OUTPUT
                {
                    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
                
                    HANDLE   DXVA2DecodeHandle;
                    HANDLE   CryptoSessionHandle;
                    HANDLE   DeviceHandle;
                
                } D3DAUTHENTICATEDCHANNEL_QUERYCRYPTOSESSION_OUTPUT;
                
                
                DEFINE_GUID(D3DAUTHENTICATEDQUERY_RESTRICTEDSHAREDRESOURCEPROCESSCOUNT, 
                0xdb207b3, 0x9450, 0x46a6, 0x82, 0xde, 0x1b, 0x96, 0xd4, 0x4f, 0x9c, 0xf2);
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYRESTRICTEDSHAREDRESOURCEPROCESSCOUNT_OUTPUT
                {
                    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
                
                    UINT   NumRestrictedSharedResourceProcesses;
                
                } D3DAUTHENTICATEDCHANNEL_QUERYRESTRICTEDSHAREDRESOURCEPROCESSCOUNT_OUTPUT;
                
                
                DEFINE_GUID(D3DAUTHENTICATEDQUERY_RESTRICTEDSHAREDRESOURCEPROCESS, 
                0x649bbadb, 0xf0f4, 0x4639, 0xa1, 0x5b, 0x24, 0x39, 0x3f, 0xc3, 0xab, 0xac);
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYRESTRICTEDSHAREDRESOURCEPROCESS_INPUT
                {
                    D3DAUTHENTICATEDCHANNEL_QUERY_INPUT Input;
                
                    UINT     ProcessIndex;
                
                } D3DAUTHENTICATEDCHANNEL_QUERYRESTRICTEDSHAREDRESOURCEPROCESS_INPUT;
                
                typedef enum _D3DAUTHENTICATEDCHANNEL_PROCESSIDENTIFIERTYPE
                {
                    PROCESSIDTYPE_UNKNOWN  = 0,
                    PROCESSIDTYPE_DWM      = 1,
                    PROCESSIDTYPE_HANDLE   = 2
                } D3DAUTHENTICATEDCHANNEL_PROCESSIDENTIFIERTYPE;
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYRESTRICTEDSHAREDRESOURCEPROCESS_OUTPUT
                {
                    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
                
                    UINT                                          ProcessIndex;
                    D3DAUTHENTICATEDCHANNEL_PROCESSIDENTIFIERTYPE ProcessIdentifer;
                    HANDLE                                        ProcessHandle;
                
                } D3DAUTHENTICATEDCHANNEL_QUERYRESTRICTEDSHAREDRESOURCEPROCESS_OUTPUT;
                
                
                DEFINE_GUID(D3DAUTHENTICATEDQUERY_UNRESTRICTEDPROTECTEDSHAREDRESOURCECOUNT, 
                0x12f0bd6, 0xe662, 0x4474, 0xbe, 0xfd, 0xaa, 0x53, 0xe5, 0x14, 0x3c, 0x6d);
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYUNRESTRICTEDPROTECTEDSHAREDRESOURCECOUNT_OUTPUT
                {
                    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
                
                    UINT   NumUnrestrictedProtectedSharedResources;
                
                } D3DAUTHENTICATEDCHANNEL_QUERYUNRESTRICTEDPROTECTEDSHAREDRESOURCECOUNT_OUTPUT;
                
                
                DEFINE_GUID(D3DAUTHENTICATEDQUERY_OUTPUTIDCOUNT, 
                0x2c042b5e, 0x8c07, 0x46d5, 0xaa, 0xbe, 0x8f, 0x75, 0xcb, 0xad, 0x4c, 0x31);
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTIDCOUNT_INPUT
                {
                    D3DAUTHENTICATEDCHANNEL_QUERY_INPUT Input;
                
                    HANDLE  DeviceHandle;
                    HANDLE  CryptoSessionHandle;	
                
                } D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTIDCOUNT_INPUT;
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTIDCOUNT_OUTPUT
                {
                    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
                
                    HANDLE  DeviceHandle;
                    HANDLE  CryptoSessionHandle;	
                    UINT    NumOutputIDs;
                
                } D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTIDCOUNT_OUTPUT;
                
                
                DEFINE_GUID(D3DAUTHENTICATEDQUERY_OUTPUTID, 
                0x839ddca3, 0x9b4e, 0x41e4, 0xb0, 0x53, 0x89, 0x2b, 0xd2, 0xa1, 0x1e, 0xe7);
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTID_INPUT
                {
                    D3DAUTHENTICATEDCHANNEL_QUERY_INPUT Input;
                
                    HANDLE  DeviceHandle;
                    HANDLE  CryptoSessionHandle;	
                    UINT    OutputIDIndex;
                
                } D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTID_INPUT;
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTID_OUTPUT
                {
                    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
                
                    HANDLE  DeviceHandle;
                    HANDLE  CryptoSessionHandle;	
                    UINT    OutputIDIndex;
                    UINT64  OutputID;
                
                } D3DAUTHENTICATEDCHANNEL_QUERYOUTPUTID_OUTPUT;
                
                
                DEFINE_GUID(D3DAUTHENTICATEDQUERY_ACCESSIBILITYATTRIBUTES, 
                0x6214d9d2, 0x432c, 0x4abb, 0x9f, 0xce, 0x21, 0x6e, 0xea, 0x26, 0x9e, 0x3b);
                
                typedef enum _D3DBUSTYPE
                {
                    D3DBUSTYPE_OTHER                                     = 0x00000000,
                    D3DBUSTYPE_PCI                                       = 0x00000001,
                    D3DBUSTYPE_PCIX                                      = 0x00000002,
                    D3DBUSTYPE_PCIEXPRESS                                = 0x00000003,
                    D3DBUSTYPE_AGP                                       = 0x00000004,
                    D3DBUSIMPL_MODIFIER_INSIDE_OF_CHIPSET                = 0x00010000,
                    D3DBUSIMPL_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_CHIP   = 0x00020000,
                    D3DBUSIMPL_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_SOCKET = 0x00030000,
                    D3DBUSIMPL_MODIFIER_DAUGHTER_BOARD_CONNECTOR         = 0x00040000,
                    D3DBUSIMPL_MODIFIER_DAUGHTER_BOARD_CONNECTOR_INSIDE_OF_NUAE = 0x00050000, 
                    D3DBUSIMPL_MODIFIER_NON_STANDARD                     = 0x80000000,    
                } D3DBUSTYPE;
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYINFOBUSTYPE_OUTPUT
                {
                    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
                
                    D3DBUSTYPE BusType;
                    BOOL bAccessibleInContiguousBlocks;
                    BOOL bAccessibleInNonContiguousBlocks;
                
                } D3DAUTHENTICATEDCHANNEL_QUERYINFOBUSTYPE_OUTPUT;
                
                
                DEFINE_GUID(D3DAUTHENTICATEDQUERY_ENCRYPTIONWHENACCESSIBLEGUIDCOUNT, 
                0xb30f7066, 0x203c, 0x4b07, 0x93, 0xfc, 0xce, 0xaa, 0xfd, 0x61, 0x24, 0x1e);
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYEVICTIONENCRYPTIONGUIDCOUNT_OUTPUT
                {
                    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
                
                    UINT   NumEncryptionGuids;
                
                } D3DAUTHENTICATEDCHANNEL_QUERYEVICTIONENCRYPTIONGUIDCOUNT_OUTPUT;
                
                
                DEFINE_GUID(D3DAUTHENTICATEDQUERY_ENCRYPTIONWHENACCESSIBLEGUID, 
                0xf83a5958, 0xe986, 0x4bda, 0xbe, 0xb0, 0x41, 0x1f, 0x6a, 0x7a, 0x1, 0xb7);
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYEVICTIONENCRYPTIONGUID_INPUT
                {
                    D3DAUTHENTICATEDCHANNEL_QUERY_INPUT Input;
                
                    UINT EncryptionGuidIndex;
                
                } D3DAUTHENTICATEDCHANNEL_QUERYEVICTIONENCRYPTIONGUID_INPUT;
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYEVICTIONENCRYPTIONGUID_OUTPUT
                {
                    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
                
                    UINT       EncryptionGuidIndex;
                    GUID       EncryptionGuid;
                
                } D3DAUTHENTICATEDCHANNEL_QUERYEVICTIONENCRYPTIONGUID_OUTPUT;
                
                
                DEFINE_GUID(D3DAUTHENTICATEDQUERY_CURRENTENCRYPTIONWHENACCESSIBLE, 
                0xec1791c7, 0xdad3, 0x4f15, 0x9e, 0xc3, 0xfa, 0xa9, 0x3d, 0x60, 0xd4, 0xf0);
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_QUERYUNCOMPRESSEDENCRYPTIONLEVEL_OUTPUT
                {
                    D3DAUTHENTICATEDCHANNEL_QUERY_OUTPUT Output;
                
                    GUID       EncryptionGuid;
                
                } D3DAUTHENTICATEDCHANNEL_QUERYUNCOMPRESSEDENCRYPTIONLEVEL_OUTPUT;
                
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT
                {
                    D3D_OMAC                            omac;  
                    GUID                                ConfigureType;      
                    HANDLE                              hChannel;    
                    UINT                                SequenceNumber;     
                
                } D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT;
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT
                {
                    D3D_OMAC                            omac;  
                    GUID                                ConfigureType;          
                    HANDLE                              hChannel;
                    UINT                                SequenceNumber;     
                    HRESULT                             ReturnCode;
                
                } D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT;
                
                DEFINE_GUID(D3DAUTHENTICATEDCONFIGURE_INITIALIZE, 
                0x6114bdb, 0x3523, 0x470a, 0x8d, 0xca, 0xfb, 0xc2, 0x84, 0x51, 0x54, 0xf0);
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_CONFIGUREINITIALIZE
                {
                    D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT   Parameters;
                
                    UINT   StartSequenceQuery;
                    UINT   StartSequenceConfigure;
                
                } D3DAUTHENTICATEDCHANNEL_CONFIGUREINITIALIZE;
                
                
                DEFINE_GUID(D3DAUTHENTICATEDCONFIGURE_PROTECTION, 
                0x50455658, 0x3f47, 0x4362, 0xbf, 0x99, 0xbf, 0xdf, 0xcd, 0xe9, 0xed, 0x29);
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_CONFIGUREPROTECTION
                {
                    D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT   Parameters;
                
                    D3DAUTHENTICATEDCHANNEL_PROTECTION_FLAGS Protections;
                
                } D3DAUTHENTICATEDCHANNEL_CONFIGUREPROTECTION;
                
                
                DEFINE_GUID(D3DAUTHENTICATEDCONFIGURE_CRYPTOSESSION, 
                0x6346cc54, 0x2cfc, 0x4ad4, 0x82, 0x24, 0xd1, 0x58, 0x37, 0xde, 0x77, 0x0);
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_CONFIGURECRYPTOSESSION
                {
                    D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT   Parameters;
                
                    HANDLE      DXVA2DecodeHandle;
                    HANDLE      CryptoSessionHandle;
                    HANDLE      DeviceHandle;
                
                } D3DAUTHENTICATEDCHANNEL_CONFIGURECRYPTOSESSION;
                
                
                DEFINE_GUID(D3DAUTHENTICATEDCONFIGURE_SHAREDRESOURCE, 
                0x772d047, 0x1b40, 0x48e8, 0x9c, 0xa6, 0xb5, 0xf5, 0x10, 0xde, 0x9f, 0x1);
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_CONFIGURESHAREDRESOURCE
                {
                    D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT       Parameters;
                
                    D3DAUTHENTICATEDCHANNEL_PROCESSIDENTIFIERTYPE ProcessIdentiferType;
                    HANDLE                                        ProcessHandle;
                    BOOL                                          AllowAccess;
                
                } D3DAUTHENTICATEDCHANNEL_CONFIGURESHAREDRESOURCE;
                
                
                DEFINE_GUID(D3DAUTHENTICATEDCONFIGURE_ENCRYPTIONWHENACCESSIBLE, 
                0x41fff286, 0x6ae0, 0x4d43, 0x9d, 0x55, 0xa4, 0x6e, 0x9e, 0xfd, 0x15, 0x8a);
                
                typedef struct _D3DAUTHENTICATEDCHANNEL_CONFIGUREUNCOMPRESSEDENCRYPTION
                {
                    D3DAUTHENTICATEDCHANNEL_CONFIGURE_INPUT   Parameters;
                
                    GUID                                      EncryptionGuid;
                
                } D3DAUTHENTICATEDCHANNEL_CONFIGUREUNCOMPRESSEDENCRYPTION;
                
                typedef struct _D3DENCRYPTED_BLOCK_INFO
                {
                    UINT NumEncryptedBytesAtBeginning;    
                    UINT NumBytesInSkipPattern;
                    UINT NumBytesInEncryptPattern;
                } D3DENCRYPTED_BLOCK_INFO;
                
                typedef struct _D3DAES_CTR_IV
                {
                    UINT64   IV;         // Big-Endian IV
                    UINT64   Count;      // Big-Endian Block Count
                } D3DAES_CTR_IV;
                
                
                
                #endif // !D3D_DISABLE_9EX
                /* -- D3D9Ex only */
                
                #pragma pack()
                #if _MSC_VER >= 1200
                #pragma warning(pop)
                #else
                #pragma warning(default:4201)
                #endif
                
                #endif /* (DIRECT3D_VERSION >= 0x0900) */
                #endif /* _d3d9TYPES(P)_H_ */
                


Top 10 Lines:

     Line      Count

       51     221091
       80      14098

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

   235189   Total number of line executions
117594.50   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/my/camera_worker/VamSysCamWorker.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> VamSysCamWorker::VamSysCamWorker(const char* prm_name) : CameraWorker(prm_name) {
                    _class_name = "VamSysCamWorker";
                    _pMyShip = NULL; //MyShipScene
                
                    //J
                    float revise = 0.7; //l|B1.0_hsVBJ
                    _lim_CAM_top     = MyShip::_lim_top     - (GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT)*LEN_UNIT/2)*revise;
                    _lim_CAM_bottom  = MyShip::_lim_bottom  + (GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT)*LEN_UNIT/2)*revise;
                    _lim_CAM_front   = MyShip::_lim_front   - (GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)*LEN_UNIT/2)*revise;
                    _lim_CAM_behaind = MyShip::_lim_behaind + (GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)*LEN_UNIT/2)*revise;
                    _lim_CAM_zleft   = MyShip::_lim_zleft   - (GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)*LEN_UNIT/2)*revise;
                    _lim_CAM_zright  = MyShip::_lim_zright  + (GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)*LEN_UNIT/2)*revise;
                
                    _lim_VP_top     = MyShip::_lim_top     - (GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT)*LEN_UNIT/2)*revise;
                    _lim_VP_bottom  = MyShip::_lim_bottom  + (GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT)*LEN_UNIT/2)*revise;
                    _lim_VP_front   = MyShip::_lim_front   - (GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)*LEN_UNIT/2)*revise;
                    _lim_VP_behaind = MyShip::_lim_behaind + (GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)*LEN_UNIT/2)*revise;
                    _lim_VP_zleft   = MyShip::_lim_zleft   - (GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)*LEN_UNIT/2)*revise;
                    _lim_VP_zright  = MyShip::_lim_zright  + (GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)*LEN_UNIT/2)*revise;
                }
                void VamSysCamWorker::initialize() {
                    GgafDx9Camera* pCam = P_CAM;
                    GgafDx9GeometricActor* pVP = pCam->_pViewPoint;
                
                    //JZu
                    _dZ_camera_init = -1 * pCam->_cameraZ_org * LEN_UNIT * PX_UNIT;
                
                
                    //wp
                    //wZW_dZ_camera_init/2
                    _correction_width = 0;//(GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)*LEN_UNIT/2)/4;
                    _correction_height = 0;//(GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT)*LEN_UNIT/2)/4;
                
                    _pos_camera = VAM_POS_RIGHT;
                
                //    pCam->_X = 0;
                //    pCam->_Y = 0;
                //    pCam->_Z = 0;
                //    pCam->setViewPoint(0,0,0);
                //    pCam->_pKuroko->setMvAng(0,0,0);
                
                    _cam_velo_renge = 30000;
                    pCam->_pKuroko->forceVxMvVeloRange(-_cam_velo_renge, _cam_velo_renge);
                    pCam->_pKuroko->forceVyMvVeloRange(-_cam_velo_renge, _cam_velo_renge);
                    pCam->_pKuroko->forceVzMvVeloRange(-_cam_velo_renge, _cam_velo_renge);
                    pVP->_pKuroko->forceVxMvVeloRange(-_cam_velo_renge, _cam_velo_renge);
                    pVP->_pKuroko->forceVyMvVeloRange(-_cam_velo_renge, _cam_velo_renge);
                    pVP->_pKuroko->forceVzMvVeloRange(-_cam_velo_renge, _cam_velo_renge);
                
                    _stop_renge = 60000;
                    _angXY_nowCamUp = GgafDx9Util::getAngle2D(P_CAM->_pVecCamUp->x, P_CAM->_pVecCamUp->y);
                    _stop_dZ = 0;
                    _stop_dY = 0;
                    _TRACE_("VamSysCamWorker::initialize() this="<<this);
                    dump();
                }
                
                void VamSysCamWorker::processBehavior() {
                
                    //DefaultVamSysCamWorker::processBehavior();
                
                    //Q[J[N
                    if (_pMyShip == NULL) {
                        return; //MyShipSceneV[J[N~
                    }
                
                    GgafDx9Camera* pCam = P_CAM;
                    GgafDx9GeometricActor* pVP = pCam->_pViewPoint;
                
                    //Ju
                    if (VB_PLAY->isPushedDown(VB_VIEW)) {
                        _TRACE_("VB_VIEW!! now _pos_camera="<<_pos_camera);
                        if (_pos_camera < VAM_POS_TO_BEHIND) { //wr[|CgA
                            _pos_camera += VAM_POS_TO_BEHIND;  //wr[|Cg
                        } else if (_pos_camera > VAM_POS_TO_BEHIND) {//wr[|Cg
                            //Vr[|Cg
                            if (VB_PLAY->isBeingPressed(VB_RIGHT)) {
                                _pos_camera = VAM_POS_LEFT;
                            } else if (VB_PLAY->isBeingPressed(VB_LEFT)) {
                                _pos_camera = VAM_POS_RIGHT;
                            } else if (VB_PLAY->isBeingPressed(VB_UP)) {
                                _pos_camera = VAM_POS_BOTTOM;
                            } else if (VB_PLAY->isBeingPressed(VB_DOWN)) {
                                _pos_camera = VAM_POS_TOP;
                            } else {
                                //Ar[|Cg
                                _pos_camera -= VAM_POS_TO_BEHIND;
                            }
                        }
                        _TRACE_("VB_VIEW!!  -> _pos_camera="<<_pos_camera);
                    }
                
                    //JWW
                    int move_target_X_CAM, move_target_Y_CAM, move_target_Z_CAM;
                    //Jr[|CgWW
                    int move_target_X_VP, move_target_Y_VP, move_target_Z_VP;
                    //JWUPAOl
                    angle move_target_XY_CAM_UP;
                
                    //JWWAr[|CgWW
                    static int Dx = (int)((GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)*LEN_UNIT/2)/4*2);
                    static int Ddx_hw = (int)((GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)*LEN_UNIT/2) - (GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT)*LEN_UNIT/2));
                    static int Dd = 30000;
                    if (_pos_camera < VAM_POS_TO_BEHIND) {
                        if (_pos_camera == VAM_POS_RIGHT) {
                //            move_target_X_CAM = 0;
                //            move_target_Y_CAM = 0;
                //            move_target_Z_CAM = -_dZ_camera_init;
                //            move_target_X_VP = 0;
                //            move_target_Y_VP = 0;
                //            move_target_Z_VP = 0;
                
                            move_target_X_CAM = -Dx + (-_pMyShip->_X-200000)*2;
                            // -200000 JuA
                            //   *2 @JpB
                            //   l[JB
                            //   TODO:{Q[IvZBB
                            if (-Dx > move_target_X_CAM) {
                                move_target_X_CAM = -Dx;
                            } else if (move_target_X_CAM > Dx/2) {
                                move_target_X_CAM = Dx/2;
                            }
                            move_target_Y_CAM = _pMyShip->_Y;
                            move_target_Z_CAM = _pMyShip->_Z - _dZ_camera_init;
                            move_target_X_VP = Dx - (-_pMyShip->_X-200000)*2;
                            if (Dx < move_target_X_VP) {
                                move_target_X_VP = Dx;
                            } else if ( move_target_X_VP < -Dx/2) {
                                move_target_X_VP = -Dx/2;
                            }
                            move_target_Y_VP = _pMyShip->_Y;
                            move_target_Z_VP = _pMyShip->_Z-100000;
                            move_target_XY_CAM_UP = ANGLE90;
                        } else if (_pos_camera == VAM_POS_LEFT) {
                            move_target_X_CAM = -Dx + (-_pMyShip->_X-200000)*2;
                            if (-Dx > move_target_X_CAM) {
                                move_target_X_CAM = -Dx;
                            } else if (move_target_X_CAM > Dx/2) {
                                move_target_X_CAM = Dx/2;
                            }
                            move_target_Y_CAM = _pMyShip->_Y;
                            move_target_Z_CAM = _pMyShip->_Z + _dZ_camera_init;
                            move_target_X_VP = Dx - (-_pMyShip->_X-200000)*2;
                            if (Dx < move_target_X_VP) {
                                move_target_X_VP = Dx;
                            } else if ( move_target_X_VP < -Dx/2) {
                                move_target_X_VP = -Dx/2;
                            }
                            move_target_Y_VP = _pMyShip->_Y;
                            move_target_Z_VP = _pMyShip->_Z+100000;
                            move_target_XY_CAM_UP = ANGLE90;
                        } else if (_pos_camera == VAM_POS_TOP) {
                            move_target_X_CAM = -Dx - Ddx_hw + (-_pMyShip->_X-125000)*2;
                            if ((-Dx - Ddx_hw) > move_target_X_CAM) {
                                move_target_X_CAM = -Dx - Ddx_hw;
                            } else if (move_target_X_CAM > (Dx + Ddx_hw)/2) {
                                move_target_X_CAM = (Dx + Ddx_hw)/2;
                            }
                            move_target_Y_CAM = _pMyShip->_Y + _dZ_camera_init + Ddx_hw;
                            move_target_Z_CAM = _pMyShip->_Z;
                            move_target_X_VP = Dx + Ddx_hw - (-_pMyShip->_X-125000)*2;
                            if (Dx + Ddx_hw < move_target_X_VP) {
                                move_target_X_VP = Dx + Ddx_hw;
                            } else if ( move_target_X_VP < -(Dx + Ddx_hw)/2) {
                                move_target_X_VP = -(Dx + Ddx_hw)/2;
                            }
                            move_target_Y_VP = _pMyShip->_Y;
                            move_target_Z_VP = _pMyShip->_Z;
                            if (pCam->_X < pVP->_X) {
                                move_target_XY_CAM_UP = ANGLE45;
                            } else {
                                move_target_XY_CAM_UP = ANGLE315;
                            }
                        } else if (_pos_camera == VAM_POS_BOTTOM) {
                            move_target_X_CAM = -Dx - Ddx_hw + (-_pMyShip->_X-125000)*2;
                            if ((-Dx - Ddx_hw) > move_target_X_CAM) {
                                move_target_X_CAM = -Dx - Ddx_hw;
                            } else if (move_target_X_CAM > (Dx + Ddx_hw)/2) {
                                move_target_X_CAM = (Dx + Ddx_hw)/2;
                            }
                            move_target_Y_CAM = _pMyShip->_Y - _dZ_camera_init - Ddx_hw;
                            move_target_Z_CAM = _pMyShip->_Z;
                            move_target_X_VP = Dx + Ddx_hw - (-_pMyShip->_X-125000)*2;
                            if (Dx + Ddx_hw < move_target_X_VP) {
                                move_target_X_VP = Dx + Ddx_hw;
                            } else if ( move_target_X_VP < -(Dx + Ddx_hw)/2) {
                                move_target_X_VP = -(Dx + Ddx_hw)/2;
                            }
                            move_target_Y_VP = _pMyShip->_Y;
                            move_target_Z_VP = _pMyShip->_Z;
                            if (pCam->_X < pVP->_X) {
                                move_target_XY_CAM_UP = ANGLE135;
                            } else {
                                move_target_XY_CAM_UP = ANGLE225;
                            }
                        }
                    } else if (_pos_camera > VAM_POS_TO_BEHIND) {
                        move_target_X_CAM = _pMyShip->_X - (_dZ_camera_init*0.6);
                        move_target_Y_CAM = _pMyShip->_Y;
                        move_target_Z_CAM = _pMyShip->_Z;
                        move_target_X_VP = _pMyShip->_X + (_dZ_camera_init);
                        move_target_Y_VP = _pMyShip->_Y;
                        move_target_Z_VP = _pMyShip->_Z;
                        move_target_XY_CAM_UP = ANGLE90;
                //        if (_pos_camera == VAM_POS_BEHIND_RIGHT) {
                //            move_target_Z_CAM -= Dd;
                //        } else if (_pos_camera == VAM_POS_BEHIND_LEFT) {
                //            move_target_Z_CAM += Dd;
                //        } else if (_pos_camera == VAM_POS_BEHIND_TOP) {
                //            move_target_Y_CAM += Dd;
                //        } else if (_pos_camera == VAM_POS_BEHIND_BOTTOM) {
                //            move_target_Y_CAM -= Dd;
                //        }
                    } else {
                        throwGgafCriticalException("World::processBehavior() s_pos_camera="<<_pos_camera);
                    }
                    //JWWAr[|CgWWAsBij
                    move_target_Z_CAM -= (_pMyShip->_Z*0.1);
                    move_target_Y_CAM -= (_pMyShip->_Y*0.1);
                
                //
                //    GgafDx9GeoElem* pGeoMyShip = _pMyShip->_pRing_GeoHistory->getCurrent(); //@W
                //    GgafDx9GeoElem* pGeoMyShip_prev= _pMyShip->_pRing_GeoHistory->getPrev(); //Ot[@W
                //    _stop_dZ += (pGeoMyShip_prev->_Z - pGeoMyShip->_Z)*0.1; //@1
                //    _stop_dY += (pGeoMyShip_prev->_Y - pGeoMyShip->_Y)*0.1; //JWWZB
                //    move_target_Z_CAM += _stop_dZ;
                //    move_target_Y_CAM += _stop_dY;
                
                
                    int cam_velo_renge;  //JxA~l
                    //VB_VIEW
                    if (VB_PLAY->isBeingPressed(VB_VIEW)) {
                        //VB_VIEWAx
                        cam_velo_renge = _cam_velo_renge / 100;
                    } else {
                        //Jx
                        cam_velo_renge = _cam_velo_renge;
                    }
                    //VB_VIEW
                    if (VB_PLAY->isReleasedUp(VB_VIEW)) {
                        if (VB_PLAY->isPushedUp(VB_VIEW, 20)) {
                            //`Air[|Cgj
                        } else {
                            //AVB_VIEW
                            if (_pos_camera < VAM_POS_TO_BEHIND) { //wr[|CgA
                                //r[|CgB
                                _pos_camera += VAM_POS_TO_BEHIND;
                            } else if (_pos_camera > VAM_POS_TO_BEHIND) {//wr[|Cg
                                //wr[|CgB
                                _pos_camera -= VAM_POS_TO_BEHIND;
                            }
                        }
                    }
                    //JxA
                    pCam->_pKuroko->forceVxMvVeloRange(-cam_velo_renge, cam_velo_renge);
                    pCam->_pKuroko->forceVyMvVeloRange(-cam_velo_renge, cam_velo_renge);
                    pCam->_pKuroko->forceVzMvVeloRange(-cam_velo_renge, cam_velo_renge);
                    pVP->_pKuroko->forceVxMvVeloRange(-cam_velo_renge, cam_velo_renge);
                    pVP->_pKuroko->forceVyMvVeloRange(-cam_velo_renge, cam_velo_renge);
                    pVP->_pKuroko->forceVzMvVeloRange(-cam_velo_renge, cam_velo_renge);
                
                    //Jr[|CgWB
                    //@A[oB(H)
                    if (_pos_camera < VAM_POS_TO_BEHIND) {
                        if (_pos_camera == VAM_POS_RIGHT) {
                            if (move_target_Y_CAM > _lim_CAM_top) {
                                move_target_Y_CAM = _lim_CAM_top;
                            }
                            if (move_target_Y_CAM < _lim_CAM_bottom ) {
                                move_target_Y_CAM = _lim_CAM_bottom;
                            }
                        } else if (_pos_camera == VAM_POS_LEFT) {
                            if (move_target_Y_CAM > _lim_CAM_top) {
                                move_target_Y_CAM = _lim_CAM_top;
                            }
                            if (move_target_Y_CAM < _lim_CAM_bottom ) {
                                move_target_Y_CAM = _lim_CAM_bottom;
                            }
                        } else if (_pos_camera == VAM_POS_TOP) {
                            if (move_target_Z_CAM > _lim_CAM_zleft) {
                                move_target_Z_CAM = _lim_CAM_zleft;
                            }
                            if (move_target_Z_CAM < _lim_CAM_zright) {
                                move_target_Z_CAM = _lim_CAM_zright;
                            }
                        } else if (_pos_camera == VAM_POS_BOTTOM) {
                            if (move_target_Z_CAM > _lim_CAM_zleft) {
                                move_target_Z_CAM = _lim_CAM_zleft;
                            }
                            if (move_target_Z_CAM < _lim_CAM_zright) {
                                move_target_Z_CAM = _lim_CAM_zright;
                            }
                        }
                    } else if (_pos_camera > VAM_POS_TO_BEHIND) {
                        if (move_target_Y_CAM > _lim_CAM_top - _correction_height) {
                            move_target_Y_CAM = _lim_CAM_top - _correction_height;
                        }
                        if (move_target_Y_CAM < _lim_CAM_bottom + _correction_height) {
                            move_target_Y_CAM = _lim_CAM_bottom + _correction_height;
                        }
                        if (move_target_Z_CAM > _lim_CAM_zleft - _correction_width) {
                            move_target_Z_CAM = _lim_CAM_zleft - _correction_width;
                        }
                        if (move_target_Z_CAM < _lim_CAM_zright + _correction_width) {
                            move_target_Z_CAM = _lim_CAM_zright + _correction_width;
                        }
                    }
                    if (_pos_camera < VAM_POS_TO_BEHIND) {
                        if (_pos_camera == VAM_POS_RIGHT) {
                            if (move_target_Y_VP > _lim_VP_top) {
                                move_target_Y_VP = _lim_VP_top;
                            }
                            if (move_target_Y_VP < _lim_VP_bottom ) {
                                move_target_Y_VP = _lim_VP_bottom;
                            }
                        } else if (_pos_camera == VAM_POS_LEFT) {
                            if (move_target_Y_VP > _lim_VP_top) {
                                move_target_Y_VP = _lim_VP_top;
                            }
                            if (move_target_Y_VP < _lim_VP_bottom ) {
                                move_target_Y_VP = _lim_VP_bottom;
                            }
                        } else if (_pos_camera == VAM_POS_TOP) {
                            if (move_target_Z_VP > _lim_VP_zleft) {
                                move_target_Z_VP = _lim_VP_zleft;
                            }
                            if (move_target_Z_VP < _lim_VP_zright) {
                                move_target_Z_VP = _lim_VP_zright;
                            }
                        } else if (_pos_camera == VAM_POS_BOTTOM) {
                            if (move_target_Z_VP > _lim_VP_zleft) {
                                move_target_Z_VP = _lim_VP_zleft;
                            }
                            if (move_target_Z_VP < _lim_VP_zright) {
                                move_target_Z_VP = _lim_VP_zright;
                            }
                        }
                    } else if (_pos_camera > VAM_POS_TO_BEHIND) {
                        if (move_target_Y_VP > _lim_VP_top - _correction_height) {
                            move_target_Y_VP = _lim_VP_top - _correction_height;
                        }
                        if (move_target_Y_VP < _lim_VP_bottom + _correction_height) {
                            move_target_Y_VP = _lim_VP_bottom + _correction_height;
                        }
                        if (move_target_Z_VP > _lim_VP_zleft - _correction_width) {
                            move_target_Z_VP = _lim_VP_zleft - _correction_width;
                        }
                        if (move_target_Z_VP < _lim_VP_zright + _correction_width) {
                            move_target_Z_VP = _lim_VP_zright + _correction_width;
                        }
                    }
                
                    //JAyr[|CgxB
                
                    //JWWeiWj
                    int dX_CAM = move_target_X_CAM - pCam->_X;
                    int dY_CAM = move_target_Y_CAM - pCam->_Y;
                    int dZ_CAM = move_target_Z_CAM - pCam->_Z;
                    //r[|CgWWeiWj
                    int dX_VP = move_target_X_VP - pVP->_X;
                    int dY_VP = move_target_Y_VP - pVP->_Y;
                    int dZ_VP = move_target_Z_VP - pVP->_Z;
                    velo veloVxRenge = 4000;
                    velo veloVyRenge = 4000;
                    velo veloVzRenge = 4000;
                    if (_pos_camera == VAM_POS_BEHIND_RIGHT || _pos_camera == VAM_POS_BEHIND_LEFT) {
                        if (_pMyShip->_X > -Dx) {
                            //Z
                            veloVzRenge *= 1.8;
                            veloVxRenge *= 0.2;
                        } else {
                            //Zx
                            veloVzRenge *= 0.2;
                            veloVxRenge *= 1.8;
                        }
                    } else if (_pos_camera == VAM_POS_BEHIND_TOP || _pos_camera == VAM_POS_BEHIND_BOTTOM) {
                        if (_pMyShip->_X > -Dx) {
                            //Y
                            veloVyRenge *= 1.8;
                            veloVxRenge *= 0.2;
                        } else {
                            //Yx
                            veloVyRenge *= 0.2;
                            veloVxRenge *= 1.8;
                        }
                    } else if (_pos_camera == VAM_POS_RIGHT || _pos_camera == VAM_POS_LEFT) {
                        if (_pMyShip->_X > -Dx) {
                            //X
                            veloVxRenge *= 1.8;
                            veloVzRenge *= 0.2;
                        } else {
                            //Xx
                            veloVxRenge *= 0.2;
                            veloVzRenge *= 1.8;
                        }
                    } else if (_pos_camera == VAM_POS_TOP || _pos_camera == VAM_POS_BOTTOM) {
                        if (_pMyShip->_X > -Dx) {
                            //X
                            veloVxRenge *= 1.8;
                            veloVyRenge *= 0.2;
                        } else {
                            //Xx
                            veloVxRenge *= 0.2;
                            veloVyRenge *= 1.8;
                        }
                    }
                    velo last_CAM_veloVxMv = pCam->_pKuroko->_veloVxMv;
                    velo  new_CAM_veloVxMv = _pMyShip->_iMoveSpeed*(dX_CAM*1.0 / _stop_renge);
                    if (last_CAM_veloVxMv-veloVxRenge <= new_CAM_veloVxMv && new_CAM_veloVxMv <= last_CAM_veloVxMv+veloVxRenge) {
                        pCam->_pKuroko->setVxMvVelo(new_CAM_veloVxMv);
                    } else {
                        if (last_CAM_veloVxMv-veloVxRenge > new_CAM_veloVxMv) {
                            pCam->_pKuroko->setVxMvVelo(last_CAM_veloVxMv-veloVxRenge);
                        } else if (new_CAM_veloVxMv > last_CAM_veloVxMv+veloVxRenge) {
                            pCam->_pKuroko->setVxMvVelo(last_CAM_veloVxMv+veloVxRenge);
                        }
                    }
                    velo last_VP_veloVxMv = pVP->_pKuroko->_veloVxMv;
                    velo  new_VP_veloVxMv = _pMyShip->_iMoveSpeed*(dX_VP*1.0 / _stop_renge);
                    if (last_VP_veloVxMv-veloVxRenge <= new_VP_veloVxMv && new_VP_veloVxMv <= last_VP_veloVxMv+veloVxRenge) {
                        pVP->_pKuroko->setVxMvVelo(new_VP_veloVxMv);
                    } else {
                        if (last_VP_veloVxMv-veloVxRenge > new_VP_veloVxMv) {
                            pVP->_pKuroko->setVxMvVelo(last_VP_veloVxMv-veloVxRenge);
                        } else if (new_VP_veloVxMv > last_VP_veloVxMv+veloVxRenge) {
                            pVP->_pKuroko->setVxMvVelo(last_VP_veloVxMv+veloVxRenge);
                        }
                    }
                
                    velo last_CAM_veloVyMv = pCam->_pKuroko->_veloVyMv;
                    velo  new_CAM_veloVyMv = _pMyShip->_iMoveSpeed*(dY_CAM*1.0 / _stop_renge);
                    if (last_CAM_veloVyMv-veloVyRenge <= new_CAM_veloVyMv && new_CAM_veloVyMv <= last_CAM_veloVyMv+veloVyRenge) {
                        pCam->_pKuroko->setVyMvVelo(new_CAM_veloVyMv);
                    } else {
                        if (last_CAM_veloVyMv-veloVyRenge > new_CAM_veloVyMv) {
                            pCam->_pKuroko->setVyMvVelo(last_CAM_veloVyMv-veloVyRenge);
                        } else if (new_CAM_veloVyMv > last_CAM_veloVyMv+veloVyRenge) {
                            pCam->_pKuroko->setVyMvVelo(last_CAM_veloVyMv+veloVyRenge);
                        }
                    }
                    velo last_VP_veloVyMv = pVP->_pKuroko->_veloVyMv;
                    velo  new_VP_veloVyMv = _pMyShip->_iMoveSpeed*(dY_VP*1.0 / _stop_renge);
                    if (last_VP_veloVyMv-veloVyRenge <= new_VP_veloVyMv && new_VP_veloVyMv <= last_VP_veloVyMv+veloVyRenge) {
                        pVP->_pKuroko->setVyMvVelo(new_VP_veloVyMv);
                    } else {
                        if (last_VP_veloVyMv-veloVyRenge > new_VP_veloVyMv) {
                            pVP->_pKuroko->setVyMvVelo(last_VP_veloVyMv-veloVyRenge);
                        } else if (new_VP_veloVyMv > last_VP_veloVyMv+veloVyRenge) {
                            pVP->_pKuroko->setVyMvVelo(last_VP_veloVyMv+veloVyRenge);
                        }
                    }
                
                    velo last_CAM_veloVzMv = pCam->_pKuroko->_veloVzMv;
                    velo  new_CAM_veloVzMv = _pMyShip->_iMoveSpeed*(dZ_CAM*1.0 / _stop_renge);
                    if (last_CAM_veloVzMv-veloVzRenge <= new_CAM_veloVzMv && new_CAM_veloVzMv <= last_CAM_veloVzMv+veloVzRenge) {
                        pCam->_pKuroko->setVzMvVelo(new_CAM_veloVzMv);
                    } else {
                        if (last_CAM_veloVzMv-veloVzRenge > new_CAM_veloVzMv) {
                            pCam->_pKuroko->setVzMvVelo(last_CAM_veloVzMv-veloVzRenge);
                        } else if (new_CAM_veloVzMv > last_CAM_veloVzMv+veloVzRenge) {
                            pCam->_pKuroko->setVzMvVelo(last_CAM_veloVzMv+veloVzRenge);
                        }
                    }
                
                    velo last_VP_veloVzMv = pVP->_pKuroko->_veloVzMv;
                    velo  new_VP_veloVzMv = _pMyShip->_iMoveSpeed*(dZ_VP*1.0 / _stop_renge);
                    if (last_VP_veloVzMv-veloVzRenge <= new_VP_veloVzMv && new_VP_veloVzMv <= last_VP_veloVzMv+veloVzRenge) {
                        pVP->_pKuroko->setVzMvVelo(new_VP_veloVzMv);
                    } else {
                        if (last_VP_veloVzMv-veloVzRenge > new_VP_veloVzMv) {
                            pVP->_pKuroko->setVzMvVelo(last_VP_veloVzMv-veloVzRenge);
                        } else if (new_VP_veloVzMv > last_VP_veloVzMv+veloVzRenge) {
                            pVP->_pKuroko->setVzMvVelo(last_VP_veloVzMv+veloVzRenge);
                        }
                    }
                
                    //JUPvZ
                    angvelo angvelo_cam_up = cam_velo_renge/20; //cam_velo_rengeVB_VIEWx
                    if (_angXY_nowCamUp != move_target_XY_CAM_UP) {
                        angle da = GgafDx9Util::getAngDiff(_angXY_nowCamUp, move_target_XY_CAM_UP);
                        if (-angvelo_cam_up < da && da < angvelo_cam_up) {
                            _angXY_nowCamUp = move_target_XY_CAM_UP;
                        } else {
                            _angXY_nowCamUp += (angvelo_cam_up * sgn(da));
                        }
                        _angXY_nowCamUp = GgafDx9Util::simplifyAng(_angXY_nowCamUp);
                        pCam->_pVecCamUp->x = GgafDx9Util::COS[_angXY_nowCamUp/ANGLE_RATE];
                        pCam->_pVecCamUp->y = GgafDx9Util::SIN[_angXY_nowCamUp/ANGLE_RATE];
                        pCam->_pVecCamUp->z = 0.0f;
                    }
                
                    pCam->_pKuroko->behave();
                    pVP->_pKuroko->behave();
                
                }
           2 -> VamSysCamWorker::~VamSysCamWorker() {
                }


Top 10 Lines:

     Line      Count

      503          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/my/option/EffectLockon001.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
          72 -> EffectLockon001::EffectLockon001(const char* prm_name, const char* prm_model_id) : DefaultSpriteSetActor(prm_name, prm_model_id) {
                    _class_name = "EffectLockon001";
                    _pTarget = NULL;
                    inactivateImmediately();
                    defineRotMvWorldMatrix(GgafDx9Util::setWorldMatrix_RzBxyzMv); //[hr{[hRz]
                    changeEffectTechnique("DestBlendOne"); //GtFNgeNjbNZ
                    setZEnable(false);      //Zobt@l
                    setZWriteEnable(false); //Zobt@
                    setSpecialDrawDepth(1); //`O`BbNIGtFNgBB
                    setAlpha(9.9);          //AJOOFFIuWFNgB
                
                    setHitAble(false); //
                    _pSeTransmitter->useSe(1);                                                //gp
                    _pSeTransmitter->set(0, "humei10", GgafRepeatSeq::nextVal("CH_humei10")); //`
                    useProgress(10);
                }
                
                void EffectLockon001::initialize() {
                }
                
                void EffectLockon001::onActive() {
                }
                
                void EffectLockon001::processBehavior() {
                }
                
                void EffectLockon001::processJudgement() {
                }
                
                void EffectLockon001::onInactive() {
                }
                
                
          72 -> EffectLockon001::~EffectLockon001() {
                }
                
                //
                //DEBUG[hAvIc[\A
                //_pTargetsAKvRgOdlB
                //
                //
                //void EffectLockon001::dump() {
                //    _TRACE_("\t\t\t\t\t\t\t\t"<<_class_name<<"("<<this<<")["<<getName()<<"] Target="<<(_pTarget==NULL?"NULL":_pTarget->getName())<<" "<<
                //                                                                               "@"<<_frame_of_behaving_since_onActive<<
                //                                                                               "/"<<
                //                                                                               _frame_of_behaving<<
                //                                                                               "/"<<
                //                                                                               _frame_of_life<<
                //                                                                               ","<<
                //                                                                               _was_initialize_flg<<
                //                                                                               ","<<
                //                                                                               _can_live_flg<<
                //                                                                               _is_active_flg<<
                //                                                                               ","<<
                //                                                                               _will_activate_after_flg<<
                //                                                                               "("<<_frame_of_life_when_activation<<")"<<
                //                                                                               _on_change_to_active_flg<<
                //                                                                               ","<<
                //                                                                               _will_inactivate_after_flg<<
                //                                                                               "("<<_frame_of_life_when_inactivation<<")"<<
                //                                                                               _on_change_to_inactive_flg<<
                //                                                                               ","<<
                //                                                                               _will_end_after_flg<<
                //                                                                               "("<<_frame_of_life_when_end<<")"<<
                //                                                                               ","<<
                //                                                                               _was_paused_flg<<
                //                                                                               _was_paused_flg_in_next_frame<<
                //                                                                               _will_mv_first_in_next_frame_flg<<
                //                                                                               _will_mv_last_in_next_frame_flg
                //                                                                               );
                //
                //    GgafActor* pActor_tmp = _pSubFirst;
                //    if (_pSubFirst) {
                //        while (true) {
                //            pActor_tmp->dump("\t\t\t\t\t\t\t\tb");
                //            if (pActor_tmp->_pNext) {
                //                pActor_tmp = pActor_tmp->_pNext;
                //            } else {
                //                _TRACE_("yxz"<<_class_name<<"("<<this<<")["<<getName()<<"]nextNULL");
                //                break;
                //            }
                //            if (pActor_tmp->_is_first_flg) {
                //                _TRACE_("\t\t\t\t\t\t\t\t");
                //                break;
                //            }
                //        }
                //    }
                //}
                
                
                //void EffectLockon001::dump(string prm_parent) {
                //    _TRACE_(prm_parent << _class_name<<"("<<this<<")["<<getName()<<"] Target="<<(_pTarget==NULL?"NULL":_pTarget->getName())<<" "<<
                //                                                                         "@"<<_frame_of_behaving_since_onActive<<
                //                                                                         "/"<<
                //                                                                         _frame_of_behaving<<
                //                                                                         "/"<<
                //                                                                         _frame_of_life<<
                //                                                                         ","<<
                //                                                                         _was_initialize_flg<<
                //                                                                         ","<<
                //                                                                         _can_live_flg<<
                //                                                                         _is_active_flg<<
                //                                                                         ","<<
                //                                                                         _will_activate_after_flg<<
                //                                                                         "("<<_frame_of_life_when_activation<<")"<<
                //                                                                         _on_change_to_active_flg<<
                //                                                                         ","<<
                //                                                                         _will_inactivate_after_flg<<
                //                                                                         "("<<_frame_of_life_when_inactivation<<")"<<
                //                                                                         _on_change_to_inactive_flg<<
                //                                                                         ","<<
                //                                                                         _will_end_after_flg<<
                //                                                                         "("<<_frame_of_life_when_end<<")"<<
                //                                                                         ","<<
                //                                                                         _was_paused_flg<<
                //                                                                         _was_paused_flg_in_next_frame<<
                //                                                                         _will_mv_first_in_next_frame_flg<<
                //                                                                         _will_mv_last_in_next_frame_flg
                //                                                                         );
                //
                //    GgafActor* pActor_tmp = _pSubFirst;
                //    if (_pSubFirst) {
                //        while (true) {
                //            pActor_tmp->dump(prm_parent + "b");
                //            if (pActor_tmp->_pNext) {
                //                pActor_tmp = pActor_tmp->_pNext;
                //            } else {
                //                _TRACE_("yxz"<<_class_name<<"("<<this<<")["<<getName()<<"]nextNULL");
                //                break;
                //            }
                //            if (pActor_tmp->_is_first_flg) {
                //                _TRACE_(prm_parent+"");
                //                break;
                //            }
                //        }
                //    }
                //}
                


Top 10 Lines:

     Line      Count

        8         72
       41         72

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      144   Total number of line executions
    48.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/my/option/EffectLockon001_Main.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           8 -> EffectLockon001_Main::EffectLockon001_Main(const char* prm_name) : EffectLockon001(prm_name, "8/Lockon001") {
                    _class_name = "EffectLockon001_Main";
                }
                
                void EffectLockon001_Main::initialize() {
                    EffectLockon001::initialize();
                    _pUvFlipper->forcePtnNoRange(0, 3);   //AjO`PT
                    _pUvFlipper->setFlipMethod(FLIP_ORDER_LOOP, 5); //Aj
                    _pScaler->forceScaleRange(60000, 2000); //XP[OE
                }
                
                void EffectLockon001_Main::onActive() {
                    EffectLockon001::onActive();
                    _pUvFlipper->setPtnNoToTop();
                    setAlpha(0.01);
                    _pScaler->forceScaleRange(60000, 2000); //XP[OE
                    _pScaler->setScale(60000); //(6000%)
                    _pScaler->intoTargetScaleLinerUntil(2000, 25);//XP[OE25F2000(200%)k
                    _pKuroko->setFaceAngVelo(AXIS_Z, 1000);        //]
                    _pSeTransmitter->play3D(0); //bNISE
                    locateAs(_pTarget);
                    _pPrg->change(EffectLockon001_SCENE_PROG_FIRST_LOCK);
                }
                
                void EffectLockon001_Main::processBehavior() {
                    EffectLockon001::processBehavior();
                
                
                
                    if (_pPrg->get() == EffectLockon001_SCENE_PROG_LOCK || _pPrg->get() == EffectLockon001_SCENE_PROG_FIRST_LOCK) {
                        if (getAlpha() < 1.0) {
                             addAlpha(0.01);
                         }
                         if (_pScaler->_method[0] == NOSCALE) {
                             //kABeat
                             _pScaler->forceScaleRange(2000, 4000);
                             _pScaler->beat(30, 2, 2, -1); //[v
                             _pPrg->change(EffectLockon001_SCENE_PROG_LOCK);
                         }
                         if (_pTarget) {
                             if (_pTarget->isActiveActor() || _pTarget->_will_activate_after_flg) {
                                 if (abs(_pTarget->_X-_X) <= 200000 &&
                                     abs(_pTarget->_Y-_Y) <= 200000 &&
                                     abs(_pTarget->_Z-_Z) <= 200000) {
                                     locateAs(_pTarget);
                                     _pKuroko->setMvVelo(0);
                                     _pKuroko->_angveloFace[AXIS_Z] = 1000;
                                 } else {
                                     _pKuroko->_angveloFace[AXIS_Z] = 3000; //
                                     _pKuroko->setMvAng(_pTarget);
                                     _pKuroko->setMvVelo(200000);
                                 }
                             } else {
                                 _pPrg->change(EffectLockon001_SCENE_PROG_RELEASE);
                             }
                         } else {
                             _pPrg->change(EffectLockon001_SCENE_PROG_RELEASE);
                         }
                    }
                
                    if (_pPrg->get() == EffectLockon001_SCENE_PROG_RELEASE) {
                        _pTarget = NULL;
                        addAlpha(-0.05);
                        if (_pScaler->_method[0] == NOSCALE || getAlpha() <= 0.0) {
                            _pScaler->setScale(2000);
                            inactivate();
                        }
                    }
                
                    _pUvFlipper->behave();
                    _pKuroko->behave();
                    _pScaler->behave();
                
                }
                
                void EffectLockon001_Main::processJudgement() {
                    EffectLockon001::processJudgement();
                }
                
                void EffectLockon001_Main::onInactive() {
                    EffectLockon001::onInactive();
                }
                
                void EffectLockon001_Main::lockon(GgafDx9GeometricActor* prm_pTarget) {
                    if (prm_pTarget == NULL || _pTarget == prm_pTarget) {
                        return;
                    }
                    _pTarget = prm_pTarget;
                
                    if (_pPrg->get() == EffectLockon001_SCENE_PROG_FIRST_LOCK) {
                
                    } else if (_pPrg->get() == EffectLockon001_SCENE_PROG_LOCK) {
                    } else if (_pPrg->get() == EffectLockon001_SCENE_PROG_RELEASE) {
                        _pScaler->forceScaleRange(60000, 2000); //XP[OE
                        _pScaler->intoTargetScaleLinerUntil(2000, 25);//XP[OE20F2000(200%)k
                        _pKuroko->setFaceAngVelo(AXIS_Z, 1000);   //]
                        _pSeTransmitter->play3D(0); //bNISE
                        _pPrg->change(EffectLockon001_SCENE_PROG_FIRST_LOCK);
                    }
                
                }
                void EffectLockon001_Main::releaseLockon() {
                    if (isActiveActor()) {
                        if (_pPrg->get() == EffectLockon001_SCENE_PROG_FIRST_LOCK) {
                            _pScaler->forceScaleRange(60000, 2000); //XP[OE
                            _pScaler->intoTargetScaleLinerUntil(60000, 60);//XP[O
                            _pKuroko->setFaceAngVelo(AXIS_Z, _pKuroko->_angveloFace[AXIS_Z]*-3); //t]
                            _pPrg->change(EffectLockon001_SCENE_PROG_RELEASE);
                        } else if (_pPrg->get() == EffectLockon001_SCENE_PROG_LOCK) {
                            _pScaler->forceScaleRange(60000, 2000); //XP[OE
                            _pScaler->intoTargetScaleLinerUntil(60000, 60);//XP[O
                            _pKuroko->setFaceAngVelo(AXIS_Z, _pKuroko->_angveloFace[AXIS_Z]*-3); //t]
                            _pPrg->change(EffectLockon001_SCENE_PROG_RELEASE);
                        } else if (_pPrg->get() == EffectLockon001_SCENE_PROG_RELEASE) {
                            //
                        }
                    }
                    _pTarget = NULL;
                }
                
          16 -> EffectLockon001_Main::~EffectLockon001_Main() {
                }
                


Top 10 Lines:

     Line      Count

      128         16
        8          8

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       24   Total number of line executions
     8.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/my/option/EffectLockon001_Sub.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
          64 -> EffectLockon001_Sub::EffectLockon001_Sub(const char* prm_name) : EffectLockon001(prm_name, "8/Lockon001_Sub") {
                    _class_name = "EffectLockon001_Sub";
                    _pPrg->change(EffectLockon001_SCENE_PROG_LOCK);
                }
                
                void EffectLockon001_Sub::initialize() {
                    EffectLockon001::initialize();
                    _pUvFlipper->forcePtnNoRange(0, 3);   //AjO`PT
                    _pUvFlipper->setFlipMethod(FLIP_ORDER_LOOP, 5); //Aj
                }
                
                void EffectLockon001_Sub::onActive() {
                    EffectLockon001::onActive();
                    _pEffectLockon001_Main = (EffectLockon001_Main*)getParent()->getSubFirst();
                    _pUvFlipper->setPtnNoToTop();
                    setAlpha(0.01);
                    _SX = _SY = _SZ = _pEffectLockon001_Main->_SX;
                    _pKuroko->setFaceAngVelo(AXIS_Z, 1000);        //E]
                    //_pSeTransmitter->play3D(0); //bNISE
                    locateAs(_pTarget);
                
                    _pPrg->change(EffectLockon001_SCENE_PROG_LOCK);
                }
                
                void EffectLockon001_Sub::processBehavior() {
                    EffectLockon001::processBehavior();
                
                    if (_pPrg->get() == EffectLockon001_SCENE_PROG_LOCK) {
                        if (getAlpha() < 0.7) {
                            if (_pEffectLockon001_Main->_pPrg->get() == EffectLockon001_SCENE_PROG_LOCK) {
                                addAlpha(0.07);
                            } else if (_pEffectLockon001_Main->_pPrg->get() == EffectLockon001_SCENE_PROG_FIRST_LOCK) {
                                addAlpha(0.01);
                            } else {
                                addAlpha(0.01);
                            }
                         }
                         //kAMainr[g
                         _SX = _SY = _SZ = _pEffectLockon001_Main->_SX;
                         _pKuroko->_angveloFace[AXIS_Z] = _pEffectLockon001_Main->_pKuroko->_angveloFace[AXIS_Z];
                         if (_pTarget) {
                             if (_pTarget->isActiveActor() || _pTarget->_will_activate_after_flg) {
                                 if (abs(_pTarget->_X-_X) <= 200000 &&
                                     abs(_pTarget->_Y-_Y) <= 200000 &&
                                     abs(_pTarget->_Z-_Z) <= 200000) {
                                     locateAs(_pTarget);
                                     _pKuroko->setMvVelo(0);
                                 } else {
                                     _pKuroko->setMvAng(_pTarget);
                                     _pKuroko->setMvVelo(200000);
                                 }
                             } else {
                                 _pPrg->change(EffectLockon001_SCENE_PROG_RELEASE);
                             }
                         } else {
                             _pPrg->change(EffectLockon001_SCENE_PROG_RELEASE);
                         }
                    }
                
                    if (_pPrg->get() == EffectLockon001_SCENE_PROG_RELEASE) {
                        _pTarget = NULL;
                        addAlpha(-0.05);
                        _SX = _SY = _SZ = _pEffectLockon001_Main->_SX;
                        _pKuroko->_angveloFace[AXIS_Z] = _pEffectLockon001_Main->_pKuroko->_angveloFace[AXIS_Z];
                        if (getAlpha() <= 0.0) {
                            inactivate();
                        }
                    }
                
                    _pUvFlipper->behave();
                    _pKuroko->behave();
                }
                
                void EffectLockon001_Sub::processJudgement() {
                    EffectLockon001::processJudgement();
                }
                
                void EffectLockon001_Sub::onInactive() {
                    EffectLockon001::onInactive();
                }
                
                void EffectLockon001_Sub::lockon(GgafDx9GeometricActor* prm_pTarget) {
                    if (prm_pTarget == NULL || _pTarget == prm_pTarget) {
                        return;
                    }
                    _pTarget = prm_pTarget;
                
                    if (_pPrg->get() == EffectLockon001_SCENE_PROG_LOCK) {
                    } else if (_pPrg->get() == EffectLockon001_SCENE_PROG_RELEASE) {
                        _pKuroko->setFaceAngVelo(AXIS_Z, 1000);   //E]
                        _pPrg->change(EffectLockon001_SCENE_PROG_LOCK);
                    }
                
                }
                void EffectLockon001_Sub::releaseLockon() {
                    if (isActiveActor()) {
                        if (_pPrg->get() == EffectLockon001_SCENE_PROG_LOCK) {
                            _pKuroko->setFaceAngVelo(AXIS_Z, _pKuroko->_angveloFace[AXIS_Z]*-3); //t]
                            _pPrg->change(EffectLockon001_SCENE_PROG_RELEASE);
                        } else if (_pPrg->get() == EffectLockon001_SCENE_PROG_RELEASE) {
                            //
                        }
                    }
                    _pTarget = NULL;
                }
                
         128 -> EffectLockon001_Sub::~EffectLockon001_Sub() {
                }
                


Top 10 Lines:

     Line      Count

      114        128
        8         64

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      192   Total number of line executions
    64.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/my/option/MyCurveLaserChip001.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
         720 -> MyCurveLaserChip001::MyCurveLaserChip001(const char* prm_name) :
                        CurveLaserChip(prm_name, "MyCurveLaserChip001") {
                    _class_name = "MyCurveLaserChip001";
                    MyStgUtil::resetMyCurveLaserChip001Status(_pStatus);
                    _default_stamina = _pStatus->get(STAT_Stamina);
                    _pOrg = NULL;
                    _lockon = 0;
                
                }
                
                void MyCurveLaserChip001::initialize() {
                    _pKuroko->relateRzRyFaceAngToMvAng(true);
                    registHitAreaCube(80000);
                    setHitAble(true);
                    _SX = _SY = _SZ = 6 * 1000;
                    _fAlpha = 0.99f;
                    _fBoundingSphereRadius = 60.0f;
                
                }
                
                void MyCurveLaserChip001::onActive() {
                    MyStgUtil::resetMyCurveLaserChip001Status(_pStatus);
                    _default_stamina = _pStatus->get(STAT_Stamina);
                    CurveLaserChip::onActive();
                    GgafDx9GeometricActor* pMainLockOnTarget = _pOrg->_pLockonController->_pRingTarget->getCurrent();
                    _pKuroko->setMvVelo(0);
                    _pKuroko->setVxMvAcce(0);
                    _pKuroko->setVyMvAcce(0);
                    _pKuroko->setVzMvAcce(0);
                    _isLockon = false;
                    if (pMainLockOnTarget && pMainLockOnTarget->isActiveActor()) {
                        if (_pChip_front == NULL) {
                            //[`bv
                            _lockon = 1;
                            _isLockon = true;
                        } else {
                            //[O
                            _lockon = ((MyCurveLaserChip001*) _pChip_front)->_lockon;//ObNIp
                            _isLockon = ((MyCurveLaserChip001*) _pChip_front)->_isLockon;//ObNIp
                        }
                    } else {
                        if (_pChip_front == NULL) {
                            //[`bv
                            _lockon = 0;
                        } else {
                            //[O
                            _lockon = ((MyCurveLaserChip001*) _pChip_front)->_lockon;//ObNIp
                            _isLockon = ((MyCurveLaserChip001*) _pChip_front)->_isLockon;//ObNIp
                        }
                    }
                    _renge = 150000;
                    _pKuroko->forceVxyzMvVeloRange(-_renge, _renge);
                    _maxAcceRange= _renge / 30;
                    _pKuroko->forceVxyzMvAcceRange(-_maxAcceRange, _maxAcceRange);
                
                
                }
                
                void MyCurveLaserChip001::processBehavior() {
                    GgafDx9GeometricActor* pMainLockOnTarget = _pOrg->_pLockonController->_pRingTarget->getCurrent();
                
                    if (_lockon == 1) {
                        if (getActivePartFrame() < 120) {
                            _maxAcceRange+=100;
                            _pKuroko->forceVxyzMvAcceRange(-_maxAcceRange, _maxAcceRange);
                //            if (_pOrg->_pLockonTarget && _pOrg->_pLockonTarget->isActiveActor() && _pOrg->_pLockonTarget->_pStatus->get(STAT_Stamina) > 0) {
                                                                                                 //IvVs
                            if (pMainLockOnTarget) {
                                if (pMainLockOnTarget->isActiveActor()) {
                                    float rate = 8.0 - 0.06*getActivePartFrame(); //0.06 * 120 = 8.0
                                    rate = rate > 0 ? rate : 0;
                                    int fdx = pMainLockOnTarget->_X - (_X + _pKuroko->_veloVxMv*rate);
                                    int fdy = pMainLockOnTarget->_Y - (_Y + _pKuroko->_veloVyMv*rate);
                                    int fdz = pMainLockOnTarget->_Z - (_Z + _pKuroko->_veloVzMv*rate);
                                    _pKuroko->setVxMvAcce(fdx);
                                    _pKuroko->setVyMvAcce(fdy);
                                    _pKuroko->setVzMvAcce(fdz);
                                } else {
                
                
                                }
                            } else {
                                _lockon = 2;
                            }
                        } else {
                            _lockon = 2;
                        }
                    }
                
                
                
                    int dx, dy, dz;
                    if (_lockon == 2) {
                        if (_isLockon) {
                            _isLockon = false;
                            //[AIvVW^[Qbg
                            if (_pChip_front == NULL) {
                                _new_target_X = _X + (_X - _pOrg->_X);
                                _new_target_Y = _Y + (_Y - _pOrg->_Y);
                                _new_target_Z = _Z + (_Z - _pOrg->_Z);
                                dx = _new_target_X - (_X );
                                dy = _new_target_Y - (_Y );
                                dz = _new_target_Z - (_Z );
                                _pKuroko->setVxMvAcce(dx);
                                _pKuroko->setVyMvAcce(dy);
                                _pKuroko->setVzMvAcce(dz);
                            }
                        }
                
                
                
                        _maxAcceRange+=100;
                        _pKuroko->forceVxyzMvAcceRange(-_maxAcceRange, _maxAcceRange);
                        if (_pChip_front == NULL) {
                            _maxAcceRange+=100;
                            //PA _maxAcceRange+=100;
                        } else if (_pChip_front->_pChip_front == NULL) {
                            //V^[Qbg
                            dx = _pChip_front->_X - (_X + _pKuroko->_veloVxMv);
                            dy = _pChip_front->_Y - (_Y + _pKuroko->_veloVyMv);
                            dz = _pChip_front->_Z - (_Z + _pKuroko->_veloVzMv);
                            _pKuroko->setVxMvAcce(dx);
                            _pKuroko->setVyMvAcce(dy);
                            _pKuroko->setVzMvAcce(dz);
                        } else if (_pChip_front->_pChip_front->_pChip_front == NULL) {
                            dx = _pChip_front->_pChip_front->_X - (_X + _pKuroko->_veloVxMv*2);
                            dy = _pChip_front->_pChip_front->_Y - (_Y + _pKuroko->_veloVyMv*2);
                            dz = _pChip_front->_pChip_front->_Z - (_Z + _pKuroko->_veloVzMv*2);
                            _pKuroko->setVxMvAcce(dx);
                            _pKuroko->setVyMvAcce(dy);
                            _pKuroko->setVzMvAcce(dz);
                        } else if (_pChip_front->_pChip_front->_pChip_front->_pChip_front == NULL) {
                            dx = _pChip_front->_pChip_front->_pChip_front->_X - (_X + _pKuroko->_veloVxMv*3);
                            dy = _pChip_front->_pChip_front->_pChip_front->_Y - (_Y + _pKuroko->_veloVyMv*3);
                            dz = _pChip_front->_pChip_front->_pChip_front->_Z - (_Z + _pKuroko->_veloVzMv*3);
                            _pKuroko->setVxMvAcce(dx);
                            _pKuroko->setVyMvAcce(dy);
                            _pKuroko->setVzMvAcce(dz);
                        } else {
                            dx = _pChip_front->_pChip_front->_pChip_front->_pChip_front->_X - (_X + _pKuroko->_veloVxMv*3);
                            dy = _pChip_front->_pChip_front->_pChip_front->_pChip_front->_Y - (_Y + _pKuroko->_veloVyMv*3);
                            dz = _pChip_front->_pChip_front->_pChip_front->_pChip_front->_Z - (_Z + _pKuroko->_veloVzMv*3);
                            _pKuroko->setVxMvAcce(dx);
                            _pKuroko->setVyMvAcce(dy);
                            _pKuroko->setVzMvAcce(dz);
                        }
                    }
                    if (_pChip_front == NULL) {
                        _pSeTransmitter->behave();
                    }
                
                //    if (pMainLockOnTarget && pMainLockOnTarget->isActiveActor()) {
                //        _lockon = 1;
                //        _isLockon = true;
                //    }
                
                //    _pKuroko->_angFace[AXIS_X] =  _pOrg->_pKuroko->_angFace[AXIS_Y];
                    CurveLaserChip::processBehavior();//Wo
                
                    //[U[\IW
                    if (onChangeToActive()) {
                        locateAs(_pOrg);
                        _tmpX = _X;
                        _tmpY = _Y;
                        _tmpZ = _Z;
                    }
                
                }
                
                void MyCurveLaserChip001::executeHitChk_MeAnd(GgafActor* prm_pOtherActor) {
                    if (((GgafMainActor*)prm_pOtherActor)->getKind() & KIND_CHIKEI) {
                        if (_chip_kind != 2 || _can_chikei_hit) {
                            GgafDx9DrawableActor::executeHitChk_MeAnd(prm_pOtherActor);
                        } else {
                            return;
                        }
                    } else {
                        GgafDx9DrawableActor::executeHitChk_MeAnd(prm_pOtherActor);
                    }
                }
                
                void MyCurveLaserChip001::onHit(GgafActor* prm_pOtherActor) {
                    GgafDx9GeometricActor* pOther = (GgafDx9GeometricActor*) prm_pOtherActor;
                    GgafDx9GeometricActor* pMainLockOnTarget = _pOrg->_pLockonController->_pRingTarget->getCurrent();
                    //qbgGtFNg
                    //
                
                    if ((pOther->getKind() & KIND_ENEMY_BODY) ) {
                        if (pMainLockOnTarget) { //IvVbNI
                            if (pOther == pMainLockOnTarget) {
                                //IvVbNI
                
                                _lockon = 2; //bNIBbNIibNIbNIj
                                if (_pChip_front && _pChip_front->_pChip_front == NULL) {
                                    //`bvqbgA[`
                                    ((MyCurveLaserChip001*)_pChip_front)->_lockon = 2;
                                }
                            } else {
                                //IvVbNIOAN^[
                            }
                        } else {
                            //IvVbNI
                        }
                
                        int stamina = MyStgUtil::calcMyStatus(_pStatus, getKind(), pOther->_pStatus, pOther->getKind());
                        if (stamina <= 0) {
                            //`bvU
                
                            //jGtFNg
                            EffectExplosion001* pExplo001 = (EffectExplosion001*)P_COMMON_SCENE->_pDP_EffectExplosion001->employ();
                            if (pExplo001) {
                                pExplo001->locateAs(this);
                                pExplo001->activate();
                            }
                            //bNI\AN^[bNI
                            if (pOther->_pStatus->get(STAT_LockonAble) == 1) {
                                _pOrg->_pLockonController->lockon(pOther);
                            }
                            sayonara();
                        } else {
                            //AAX^~iiU100Gj
                            _pStatus->set(STAT_Stamina, _default_stamina);
                            //bNI\AN^[bNI
                            if (pOther->_pStatus->get(STAT_LockonAble) == 1) {
                                _pOrg->_pLockonController->lockon(pOther);
                            }
                        }
                    } else if (pOther->getKind() & KIND_CHIKEI) {
                        //n`
                
                        //jGtFNg
                        EffectExplosion001* pExplo001 = (EffectExplosion001*)P_COMMON_SCENE->_pDP_EffectExplosion001->employ();
                        if (pExplo001) {
                            pExplo001->locateAs(this);
                            pExplo001->activate();
                        }
                        sayonara();
                    }
                }
                //void MyCurveLaserChip001::processFinal() {
                //    CurveLaserChip::processFinal();
                //    //bNIA
                //    if (_pOrg->_pLockonTarget) {
                //        if (_pOrg->_pLockonTarget->_pStatus->get(STAT_Stamina) <= 0) {
                //            _lockon = 2; //bNIibNIbNIj
                //        }
                //    }
                //}
                
                void MyCurveLaserChip001::onInactive() {
                    CurveLaserChip::onInactive();
                    _lockon = 0;
                }
                
        1440 -> MyCurveLaserChip001::~MyCurveLaserChip001() {
                }
                


Top 10 Lines:

     Line      Count

      262       1440
        8        720

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

     2160   Total number of line executions
   720.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/my/option/MyOption.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
                
                /** PIvV\bNI */
                int MyOption::_max_lockon_num = 9;
                int MyOption::_lockon_num = 8;
                //MyOption::MyOption(const char* prm_name, UINT32 prm_no, MyOptionController* prm_pMyOptionController) : DefaultMorphMeshActor(prm_name, "4/Ceres") {
           8 -> MyOption::MyOption(const char* prm_name, UINT32 prm_no, MyOptionController* prm_pMyOptionController) : DefaultMeshSetActor(prm_name, "8/Core4") {
                //MyOption::MyOption(const char* prm_name, UINT32 prm_no, MyOptionController* prm_pMyOptionController) : CubeMapMeshSetActor(prm_name, "4/Core4_cm") {
                
                
                _TRACE_("MyOption::MyOption("<<prm_name<<","<<prm_no<<")");
                    _class_name = "MyOption";
                    _pMyOptionController = prm_pMyOptionController;
                    _no = prm_no;
                    _angveloMove = 0;//pxiopj
                
                    _angPosition = 0;     //~upxipjij
                    _radiusPosition = 150000;     //aij
                    _veloMv = 5000;     //xij
                    _angExpanse = 0;      //IvVLp]pij
                
                    _angPosition_base = _angPosition;
                    _radiusPosition_base = _radiusPosition;
                    _angExpanse_default = _angExpanse;
                    _veloMv_base = _veloMv;
                
                    _return_to_base_radiusPosition_seq = false;
                    _return_to_base_angExpanse_seq = false;
                
                    _angveloExpanseNomal = 3000;
                    _angveloExpanseSlow = 1000;
                
                    //[U[GtFNg
                //    _pEffect_LaserIrradiate = NEW EffectLockon001_Main("OP_Eff_Ref");
                //    _pEffect_LaserIrradiate->inactivateImmediately();
                //    addSubGroup(_pEffect_LaserIrradiate);
                    _pEffect_LaserIrradiate = NULL;
                
                
                    _pLaserChipDispatcher = NEW LaserChipDispatcher("ROTLaser");
                    MyCurveLaserChip001* pChip;
                    for (int i = 0; i < 90; i++) { //[U[XgbN
                        stringstream name;
                        name <<  getName() << "'s MYS_LaserChip" << i;
                        string name2 = name.str();
                        pChip = NEW MyCurveLaserChip001(name2.c_str());
                        _pLaserChipDispatcher->addSubLast(pChip);
                    }
                    _pLaserChipDispatcher->config(
                                               90, 25, _pEffect_LaserIrradiate
                                           );
                    addSubGroup(_pLaserChipDispatcher);
                
                    _pDispatcher_MyShots001 = NEW GgafActorDispatcher("RotShot001");
                    MyShot001* pShot;
                    for (int i = 0; i < 25; i++) { //eXgbN
                        pShot = NEW MyShot001("MY_MyShot001");
                        pShot->inactivateImmediately();
                        _pDispatcher_MyShots001->addSubLast(pShot);
                    }
                    addSubGroup(_pDispatcher_MyShots001);
                
                    //bNIRg[[
                    _pLockonController = NEW MyOptionLockonController("LockonController");
                    addSubGroup(_pLockonController);
                
                    //tHgRg[[
                    _pTorpedoController = NEW MyOptionTorpedoController("TorpedoController", this);
                    addSubGroup(_pTorpedoController);
                
                
                    _pSeTransmitter->useSe(2);
                    _pSeTransmitter->set(0, "laser001", GgafRepeatSeq::nextVal("CH_laser001"));
                    _pSeTransmitter->set(1, "fire01", GgafRepeatSeq::nextVal("CH_fire01"));
                
                    //prepareSe(0,"bse5", GgafRepeatSeq::nextVal("CH_bse5"));
                }
                
                void MyOption::onCreateModel() {
                    _pGgafDx9Model->_pTextureBlinker->forceBlinkRange(0.3, 2.0);
                    _pGgafDx9Model->_pTextureBlinker->setBlink(1.0);
                    _pGgafDx9Model->_pTextureBlinker->beat(120, 10, 1, -1);
                    _pGgafDx9Model->_fBlinkThreshold = 0.9;
                }
                
                void MyOption::initialize() {
                    _SX=_SY=_SZ=100;
                }
                
                void MyOption::onReset() {
                    _angveloMove = ((1.0f*_veloMv / _radiusPosition)*(double)ANGLE180)/PI;
                    _pKuroko->setMvVelo(_veloMv);
                    _pKuroko->setRzMvAng(_angPosition+ANGLE90);
                    _pKuroko->setRyMvAng(-ANGLE90);
                    _pKuroko->setRzMvAngVelo(_angveloMove);//aqxu^px
                    _pKuroko->setRyMvAngVelo(0);//aqxu^px
                    _Z = GgafDx9Util::COS[_angPosition/ANGLE_RATE]*_radiusPosition; //XS]XYZY
                    _Y = GgafDx9Util::SIN[_angPosition/ANGLE_RATE]*_radiusPosition; //Xvzu
                                                                                    //[hi@jX]t]
                    _X = 0;
                    _pKuroko->setFaceAngVelo(AXIS_X, 4000);
                    _Xorg = _X;
                    _Yorg = _Y;
                    _Zorg = _Z;
                    //P_COMMON_SCENE->getLordActor()->addSubGroup(KIND_MY_SHOT_NOMAL, _pLaserChipDispatcher->extract());
                    _angPosition = _pKuroko->_angRzMv;
                
                    _adjust_angPos_seq_progress = 0;
                    _adjust_angPos_seq_new_angPosition_base = _angPosition;
                    _adjust_angPos_seq_spent_frame = 0;
                    _adjust_angPos_seq_angPosition = 0;
                }
                
                void MyOption::onActive() {
                }
                
                void MyOption::addRadiusPosition(int prm_radius_offset) {
                    //    _X = _Xorg;
                    //    _Y = _Yorg;
                    //    _Z = _Zorg;
                    //
                    //    _Xorg = _X;
                    //    _Yorg = _Y;
                    //    _Zorg = _Z;
                    //O
                    //oB
                
                
                //a@WbNRgO
                //    int radius;
                //    if (_radiusPosition == -1 * prm_radius_offset) { //0
                //        //a0B0Z
                //        if (_radiusPosition > 0) {
                //            radius = -100;
                //        } else {
                //            radius = 100;
                //        }
                //    } else {
                //        radius = _radiusPosition + prm_radius_offset;
                //    }
                //    setRadiusPosition(radius);
                
                    int radius;
                    radius = _radiusPosition + prm_radius_offset;
                    if (_radiusPosition < 30000) {
                        radius = 30000; //IvVa
                    }
                    setRadiusPosition(radius);
                }
                
                
                void MyOption::setRadiusPosition(int prm_radius) {
                //    _X = _Xorg;
                //    _Y = _Yorg;
                //    _Z = _Zorg;
                //
                //    _Xorg = _X;
                //    _Yorg = _Y;
                //    _Zorg = _Z;
                //O
                //oB
                
                    if (_radiusPosition == -1 * prm_radius) {
                        if (_radiusPosition > 0) {
                            _radiusPosition = -100;
                        } else {
                            _radiusPosition = 100;
                        }
                    } else {
                        _radiusPosition += prm_radius;
                    }
                
                    _radiusPosition = prm_radius;
                    angle angZY_ROTANG_X;
                    if (_radiusPosition > 0) {
                        angZY_ROTANG_X = MyStgUtil::getAngle2D(_Z, _Y); //u
                        _Z = _radiusPosition * GgafDx9Util::COS[GgafDx9Util::simplifyAng(angZY_ROTANG_X)/ANGLE_RATE];
                        _Y = _radiusPosition * GgafDx9Util::SIN[GgafDx9Util::simplifyAng(angZY_ROTANG_X)/ANGLE_RATE];
                    } else {
                        angZY_ROTANG_X = MyStgUtil::getAngle2D(-_Z, -_Y); //u
                        _Z = _radiusPosition * GgafDx9Util::COS[GgafDx9Util::simplifyAng(angZY_ROTANG_X)/ANGLE_RATE];
                        _Y = _radiusPosition * GgafDx9Util::SIN[GgafDx9Util::simplifyAng(angZY_ROTANG_X)/ANGLE_RATE];
                    }
                    //prm_len0A_IuA
                    //AuB
                    //ApApxu(_Z,_Y)YB
                    _pKuroko->setRzMvAng(GgafDx9Util::simplifyAng(angZY_ROTANG_X + ANGLE90));
                    _angveloMove = ((1.0*_veloMv / _radiusPosition)*(double)ANGLE180)/PI;
                    _pKuroko->setRzMvAngVelo(_angveloMove);
                }
                
                
                void MyOption::adjustAngPosition(angle prm_new_angPosition_base, frame prm_spent_frame) {
                    _adjust_angPos_seq_progress = 1;
                    _adjust_angPos_seq_new_angPosition_base = MyStgUtil::simplifyAng(prm_new_angPosition_base);
                    _adjust_angPos_seq_spent_frame = prm_spent_frame + 1;
                }
                
                
                
                void MyOption::processBehavior() {
                    MyShip* pMyShip = P_MYSHIP;
                    //C
                    _X = _Xorg;
                    _Y = _Yorg;
                    _Z = _Zorg;
                
                    if (_return_to_base_radiusPosition_seq) {
                        //
                        if (_radiusPosition > _radiusPosition_base) {
                            addRadiusPosition(-10000);
                        }
                        if (_radiusPosition < _radiusPosition_base) {
                            addRadiusPosition(10000);
                        }
                        if (-10000 < _radiusPosition_base-_radiusPosition && _radiusPosition_base-_radiusPosition < 10000) {
                            setRadiusPosition(_radiusPosition_base);
                            _return_to_base_radiusPosition_seq = false;
                        }
                
                    } else {
                
                        //IvV
                        if (VB_PLAY->isBeingPressed(VB_OPTION) && _pMyOptionController->_is_handle_move_mode) {
                            //IvVLpAIvVxAaxxNgB
                            //axB
                            addRadiusPosition(GgafDx9Util::SIN[_angExpanse/ ANGLE_RATE] * _pMyOptionController->_veloOptionsMv);
                            //IvVxMyOptionNXsB
                        }
                    }
                
                    if (_return_to_base_angExpanse_seq) {
                
                        //
                        if (_angExpanse > _angExpanse_default) {
                            _angExpanse -= 3000;
                        }
                        if (_angExpanse < _angExpanse_default) {
                            _angExpanse += 3000;
                        }
                        if (-3000 <= _angExpanse_default-_angExpanse && _angExpanse_default-_angExpanse <= 3000) {
                            _angExpanse = _angExpanse_default;
                            _return_to_base_angExpanse_seq = false;
                        }
                        _angExpanse = GgafDx9Util::simplifyAng(_angExpanse);
                    } else {
                        //IvVL
                        if (VB_PLAY->isBeingPressed(VB_OPTION) && VB_PLAY->isBeingPressed(VB_TURBO)) {
                                if (VB_PLAY->isBeingPressed(VB_RIGHT)) {
                                    _angExpanse += _angveloExpanseNomal;
                                } else if (VB_PLAY->isBeingPressed(VB_LEFT)) {
                                    _angExpanse -= _angveloExpanseNomal;
                                }
                                if (VB_PLAY->isBeingPressed(VB_UP)) {
                                    addRadiusPosition(2000 * (_radiusPosition_base/60000));
                                    //_angExpanse += _angveloExpanseSlow;
                                } else if (VB_PLAY->isBeingPressed(VB_DOWN)) {
                                    addRadiusPosition(-2000 * (_radiusPosition_base/60000));
                                    //_angExpanse -= _angveloExpanseSlow;
                                }
                
                            _angExpanse = GgafDx9Util::simplifyAng(_angExpanse);
                        }
                    }
                
                    if (_adjust_angPos_seq_progress > 0) {
                        if (_adjust_angPos_seq_progress == 1) {
                            //
                            _adjust_angPos_seq_progress = 2;
                        }
                
                
                        if (_adjust_angPos_seq_progress == 2) {
                            //pxu
                            if (_radiusPosition > 0) {
                                _adjust_angPos_seq_angPosition = MyStgUtil::getAngle2D(_Z, _Y);
                            } else {
                                _adjust_angPos_seq_angPosition = MyStgUtil::getAngle2D(-_Z, -_Y);
                            }
                            //p
                            angle ang_diff = MyStgUtil::getAngDiff(_adjust_angPos_seq_angPosition, _adjust_angPos_seq_new_angPosition_base, sgn(_veloMv));
                            //ct[cpKvpx
                            angvelo angvelo_need = ang_diff / (angvelo)_adjust_angPos_seq_spent_frame;
                            //Kvpx
                            angvelo angvelo_offset = angvelo_need - _angveloMove;
                            //Kvpxx
                            velo veloMv_offset =  (2.0*PI*_radiusPosition * angvelo_offset) / ANGLE360;
                            //x
                            _pKuroko->setRzMvAngVelo(_angveloMove + angvelo_offset);
                            _pKuroko->setMvVelo(_veloMv + veloMv_offset);
                            _adjust_angPos_seq_spent_frame --;
                
                            if (_adjust_angPos_seq_spent_frame == 0) {
                                _angPosition_base = _adjust_angPos_seq_new_angPosition_base;
                                //Czu
                                _angveloMove = ((1.0*_veloMv / _radiusPosition)*(double)ANGLE180)/PI;
                                _pKuroko->setMvVelo(_veloMv);
                                _pKuroko->setRzMvAng(GgafDx9Util::simplifyAng(_angPosition_base + ANGLE90));
                                _pKuroko->setRzMvAngVelo(_angveloMove);//aqxu^px
                                _Z = GgafDx9Util::COS[_angPosition_base/ANGLE_RATE]*_radiusPosition; //XS]XYZY
                                _Y = GgafDx9Util::SIN[_angPosition_base/ANGLE_RATE]*_radiusPosition; //Xvzu
                                _X = 0;
                                _adjust_angPos_seq_progress = 0;
                            }
                        }
                    } else {
                         //
                        _pKuroko->setMvVelo(_veloMv);
                    }
                    _angPosition = GgafDx9Util::simplifyAng(_angPosition+_angveloMove);
                
                    _pKuroko->behave();
                
                    _Xorg = _X;
                    _Yorg = _Y;
                    _Zorg = _Z;
                
                    //
                    //AGgafDx9Kuroko@\A
                    //B
                    //(100,0,0) _C[WA_
                    //y  z  ExiOAOj
                    //
                    //
                    //              YZsB
                    //        
                    //
                    //
                    //                    
                    //                
                    //     (0,0,0)      (-50000, 0, _radiusPosition)
                    //
                    //
                    //          
                    //          (-50000, -1*_radiusPosition, 0)
                    //
                    //FX]BvZiZjAW]A]sB
                    //_~[AN^[AAQuaternion giGjB
                    //TODO:KAQuaternionBp
                
                    float sinRZ = GgafDx9Util::SIN[_pMyOptionController->_pKuroko->_angFace[AXIS_Z] / ANGLE_RATE];
                    float cosRZ = GgafDx9Util::COS[_pMyOptionController->_pKuroko->_angFace[AXIS_Z] / ANGLE_RATE];
                    float sinRY = GgafDx9Util::SIN[_pMyOptionController->_pKuroko->_angFace[AXIS_Y] / ANGLE_RATE];
                    float cosRY = GgafDx9Util::COS[_pMyOptionController->_pKuroko->_angFace[AXIS_Y] / ANGLE_RATE];
                    //SIvVOptionControllerSWORLD
                    _X = cosRY*cosRZ*_Xorg + cosRY*-sinRZ*_Yorg + sinRY*_Zorg;
                    _Y = sinRZ*_Xorg + cosRZ*_Yorg;
                    _Z = -sinRY*cosRZ*_Xorg + -sinRY*-sinRZ*_Yorg + cosRY*_Zorg;
                
                
                
                    //dpL]iQuaternionj
                    float vX_axis = cosRY*cosRZ*_pKuroko->_vX + cosRY*-sinRZ*_pKuroko->_vY + sinRY*_pKuroko->_vZ;
                    float vY_axis = sinRZ*_pKuroko->_vX + cosRZ*_pKuroko->_vY;
                    float vZ_axis = -sinRY*cosRZ*_pKuroko->_vX + -sinRY*-sinRZ*_pKuroko->_vY + cosRY*_pKuroko->_vZ;
                    float sinHalf = GgafDx9Util::SIN[_angExpanse/ANGLE_RATE/2]; //_angExpanse=]px
                    float cosHalf = GgafDx9Util::COS[_angExpanse/ANGLE_RATE/2];
                
                    //vZ
                    //W(x, y, z)A](, , )A]
                    //P = (0; x, y, z)
                    //Q = (cos(/2);  sin(/2),  sin(/2),  sin(/2))
                    //R = (cos(/2); - sin(/2), - sin(/2), - sin(/2))
                    //
                    //R P Q = (0; )
                    //
                    //] (vX_axis, vY_axis, vZ_axis) ]p _angExpanse
                    GgafDx9Quaternion Q(cosHalf, -vX_axis*sinHalf, -vY_axis*sinHalf, -vZ_axis*sinHalf);  //R
                    Q.mul(0,
                           _pMyOptionController->_pKuroko->_vX,
                           _pMyOptionController->_pKuroko->_vY,
                           _pMyOptionController->_pKuroko->_vZ); //R*P ]isxNg
                    Q.mul(cosHalf, vX_axis*sinHalf, vY_axis*sinHalf, vZ_axis*sinHalf); //R*P*Q
                    //Q._x, Q._y, Q._z ]W
                    //Z]AY]pxvZ
                    GgafDx9Util::getRzRyAng(
                        Q._x, Q._y, Q._z,
                        _RZ, _RY
                     );
                
                //    _RZ = GgafDx9Util::simplifyAng(_RZ);
                //    _RY = GgafDx9Util::simplifyAng(_RY);
                    _X += _pMyOptionController->_X;
                    _Y += _pMyOptionController->_Y;
                    _Z += _pMyOptionController->_Z;
                
                    //TODO
                    //K
                    _pKuroko->_veloVxMv = 0;
                    _pKuroko->_veloVyMv = 0;
                    _pKuroko->_veloVzMv = 0;
                    if (pMyShip->_is_shooting_laser && VB_PLAY->isBeingPressed(VB_SHOT1)) {
                
                
                        MyCurveLaserChip001* pLaserChip = (MyCurveLaserChip001*)_pLaserChipDispatcher->employ();
                        if (pLaserChip) {
                            if (_pLaserChipDispatcher->_pEffectActor_Irradiate) {
                                _pLaserChipDispatcher->_pEffectActor_Irradiate->locateAs(this);
                            }
                            pLaserChip->_pKuroko->_vX = Q._x;
                            pLaserChip->_pKuroko->_vY = Q._y;
                            pLaserChip->_pKuroko->_vZ = Q._z;
                            pLaserChip->_pKuroko->_angRzMv = _RZ;
                            pLaserChip->_pKuroko->_angRyMv = _RY;
                //            pLaserChip->_pKuroko->_angFace[AXIS_X] = _pKuroko->_angFace[AXIS_X];
                            pLaserChip->_pKuroko->_angFace[AXIS_Z] = _RZ;
                            pLaserChip->_pKuroko->_angFace[AXIS_Y] = _RY;
                            pLaserChip->_pKuroko->setVxMvVelo(Q._x*150000);
                            pLaserChip->_pKuroko->setVyMvVelo(Q._y*150000);
                            pLaserChip->_pKuroko->setVzMvVelo(Q._z*150000);
                            pLaserChip->_pKuroko->setVxMvAcce(0);
                            pLaserChip->_pKuroko->setVyMvAcce(0);
                            pLaserChip->_pKuroko->setVzMvAcce(0);
                            pLaserChip->_pKuroko->behave();
                            pLaserChip->_X = _X;
                            pLaserChip->_Y = _Y;
                            pLaserChip->_Z = _Z;
                            pLaserChip->_pOrg = this;
                            pLaserChip->activate();
                            if (pLaserChip->_pChip_front == NULL) {
                                _pSeTransmitter->play3D(0);
                            }
                        }
                    } else {
                        _pLockonController->releaseAllLockon();
                    }
                    if (pMyShip->_just_shot) {
                        MyShot001* pShot = (MyShot001*)_pDispatcher_MyShots001->employ();
                        if (pShot) {
                            _pSeTransmitter->play3D(1);
                            pShot->locateAs(this);
                            pShot->_pKuroko->_angFace[AXIS_X] = _RX;
                            pShot->_pKuroko->_angFace[AXIS_Z] = _RZ;
                            pShot->_pKuroko->_angFace[AXIS_Y] = _RY;
                            pShot->_pKuroko->setRzRyMvAng(_RZ, _RY);
                            pShot->activate();
                        }
                    }
                
                
                
                    _pSeTransmitter->behave();
                
                }
                
                void MyOption::processJudgement() {
                }
                
                void MyOption::onHit(GgafActor* prm_pOtherActor) {
                    sayonara();
                }
                
                void MyOption::processFinal() {
                //    //bNIA
                //    if (_pLockonTarget) {
                //        if (_pLockonTarget->_pStatus->get(STAT_Stamina) <= 0) {
                //            _pLockonController->releaseLockon();
                //            _pLockonTarget = NULL;
                //        }
                //    }
                }
          16 -> MyOption::~MyOption() {
                }
                


Top 10 Lines:

     Line      Count

      468         16
       13          8

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       24   Total number of line executions
     8.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9Core/include/jp/ggaf/dx9core/util/GgafDx9Quaternion.h:
                #ifndef GGAFDX9QUATERNION_H_
                #define GGAFDX9QUATERNION_H_
                namespace GgafDx9Core {
                
                /**
                 * NH[^jINX .
                 * TODO:p
                 * @version 1.00
                 * @since 2009/04/07
                 * @author Masatoshi Tsuge
                 */
                class GgafDx9Quaternion : public GgafCore::GgafObject {
                public:
                    double   _t; //
                    double   _x;
                    double   _y;
                    double   _z;
                
           8 ->     GgafDx9Quaternion() : GgafObject() {
                        _t = 0;
                        _x = 0;
                        _y = 0;
                        _z = 0;
                    }
                
                //    GgafDx9Quaternion(double prm_t, double prm_x, double prm_y, double prm_z);
                
       ##### ->     GgafDx9Quaternion(double prm_t, double prm_x, double prm_y, double prm_z) : GgafObject(),
                        _t(prm_t),
                        _x(prm_x),
                        _y(prm_y),
                        _z(prm_z) {
                    }
                
                
                    inline void set(double prm_t, double prm_x, double prm_y, double prm_z) {
                        _t = prm_t;
                        _x = prm_x;
                        _y = prm_y;
                        _z = prm_z;
                    }
                    inline void mul(double t2, double x2, double y2, double z2) {
                        double t1 = _t;
                        double x1 = _x;
                        double y1 = _y;
                        double z1 = _z;
                        _t = t1*t2 - x1*x2 - y1*y2 - z1*z2;
                        _x = t1*x2 + t2*x1 + y1*z2 - z1*y2;
                        _y = t1*y2 + t2*y1 + z1*x2 - x1*z2;
                        _z = t1*z2 + t2*z1 + x1*y2 - y1*x2;
                    }
                    virtual ~GgafDx9Quaternion();
                };
                
                }
                #endif /*GGAFDX9QUATERNION_H_*/
                


Top 10 Lines:

     Line      Count

       19          8

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        8   Total number of line executions
     4.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/my/option/MyOptionLockonController.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
                
           8 -> MyOptionLockonController::MyOptionLockonController(const char* prm_name) : GgafDummyActor(prm_name) {
                    _class_name = "MyOptionLockonController";
                    _pRingTarget = NEW GgafLinkedListRing<GgafDx9Core::GgafDx9GeometricActor>();
                    _pMainLockonEffect = NEW EffectLockon001_Main("MAIN");
                    _pMainLockonEffect->inactivateImmediately();
                    addSubLast(_pMainLockonEffect);
                    for (int i = 1; i < MyOption::_max_lockon_num; i++) {
                        stringstream name;
                        name <<  "SUB["<<i<<"]";
                        EffectLockon001_Sub* pSubLockon = NEW EffectLockon001_Sub(name.str().c_str());
                        pSubLockon->inactivateImmediately();
                        addSubLast(pSubLockon);
                    }
                }
                
                void MyOptionLockonController::initialize() {
                }
                
                
                void MyOptionLockonController::processBehavior() {
                    //bNI^[QbgmF
                    GgafDx9GeometricActor* pMainLockonTarget = _pRingTarget->getCurrent(); //CbNI^[Qbg
                    GgafDx9GeometricActor* pTarget = _pRingTarget->getCurrent(); //^[QbgJ[\
                    GgafMainActor* pLockonEffect_Active = getSubFirst();         //bNIGtFNgJ[\
                    int n = _pRingTarget->length();
                    for (int i = 0; i < n; i++) {
                        if (pTarget->isActiveActor() && pTarget->_pStatus->get(STAT_Stamina) > 0) {
                            //^[Qbg
                            //GtFNgAN^[^[QbgXVAGtFNgY
                            ((EffectLockon001*)pLockonEffect_Active)->lockon(pTarget);
                            if (!pLockonEffect_Active->isActiveActor()) {
                                pLockonEffect_Active->activate();
                            }
                            pLockonEffect_Active = pLockonEffect_Active->getNext(); //bNIGtFNgAN^[
                            pTarget = _pRingTarget->next();                         //^[Qbg
                        } else {
                            //^[QbgS
                            if (pTarget == pMainLockonTarget) {
                                //S^[QbgCbNI^[Qbg
                                if (_pRingTarget->length() == 1) {
                                    //S^[QbgCbNI^[QbgO
                                    _pRingTarget->remove();                                    //^[Qbgo
                                    ((EffectLockon001*)pLockonEffect_Active)->releaseLockon(); //bNIGtFNg[Xs
                                    pTarget = NULL;
                                    break;
                                } else {
                                    //S^[QbgCbNI^[QbgO
                                    _pRingTarget->remove();               //^[Qbgo
                                    pTarget = _pRingTarget->getCurrent(); //^[Qbgiremove()^[QbggetCurrent()j
                                    pMainLockonTarget = pTarget;          //CbNI^[QbgXV
                                    //CbNIGtFNgbNI
                                    //CbNIGtFNgGtFNg
                                    ((EffectLockon001*)pLockonEffect_Active->getNext())->releaseLockon(); //bNIGtFNg[Xs
                                    pLockonEffect_Active->getNext()->moveLastImmediately();               //bNIGtFNg
                                    //ubNIGtFNgAN^[vsvBbNIGtFNgAN^[B
                                }
                            } else {
                                //S^[QbgTubNI^[Qbg
                                _pRingTarget->remove();               //^[Qbgo
                                pTarget = _pRingTarget->getCurrent(); //^[Qbgiremove()^[QbggetCurrent()j
                                ((EffectLockon001*)pLockonEffect_Active)->releaseLockon(); //bNIGtFNg[Xs
                                pLockonEffect_Active = pLockonEffect_Active->getNext();    //bNIGtFNgAN^[
                                pLockonEffect_Active->getPrev()->moveLastImmediately();    //bNIGtFNgAN^[
                            }
                        }
                    }
                
                    if (GgafDx9Input::isBeingPressedKey(DIK_I)) {
                        dumpTarget(_pRingTarget->getCurrent());
                        dump();
                    }
                
                
                }
                
                void MyOptionLockonController::processJudgement() {
                }
                
                
                void MyOptionLockonController::lockon(GgafDx9GeometricActor* prm_pTarget) {
                    if (_pRingTarget->indexOf(prm_pTarget) == -1) { //bNI
                
                        if (_pRingTarget->length() >= MyOption::_lockon_num) {
                            //^[QbgXg
                            //bNI^[Qbg[e[g
                            _pRingTarget->prev();
                            _pRingTarget->set(prm_pTarget);
                            //bNIGtFNgAN^[
                            //AprocessBehavior() ^[Qbg
                            //YbB
                        } else {
                            //^[QbgXgi\j
                            //^[Qbg[e[g
                            _pRingTarget->addPrev(prm_pTarget, false);
                            _pRingTarget->prev();
                            //bNIGtFNg
                            if (_pRingTarget->length() == 1) {
                                //bNI^[QbgiCbNI^[Qbgj
                                GgafMainActor* pLockonEffect = getSubFirst(); //CbNIGtFNg
                                pLockonEffect->activate();
                                ((EffectLockon001*)pLockonEffect)->lockon(prm_pTarget);
                                //bNI^[QbgOiTubNI^[Qbgj
                            } else if (_pRingTarget->length() > 1) {
                                //SubbNI
                                if (_pRingTarget->length() >= 3) {
                                    //R~^[QbgiQ~TubNI^[Qbgj
                                    //bNIGtFNg[e[gsBiRgQj
                                    //Lasto
                                    GgafMainActor* pLockonEffect = getSubFirst()->getPrev(); //Last
                                    GgafMainActor* pLockonEffect_Next = pLockonEffect->getNext(); //MainbNI
                                    GgafMainActor* pLockonEffect_Prev = pLockonEffect->getPrev();
                                    pLockonEffect_Prev->_pNext = pLockonEffect_Next;
                                    pLockonEffect_Next->_pPrev = pLockonEffect_Prev;
                                    pLockonEffect_Prev->_is_last_flg = true;
                                    pLockonEffect->_is_last_flg = false;
                                    //First->Next 
                                    GgafMainActor* pMainLockonEffect = getSubFirst();
                                    GgafMainActor* pMainLockonEffect_Next = getSubFirst()->getNext();
                                    pMainLockonEffect->_pNext = pLockonEffect;
                                    pLockonEffect->_pPrev = pMainLockonEffect;
                                    pLockonEffect->_pNext = pMainLockonEffect_Next;
                                    pMainLockonEffect_Next->_pPrev = pLockonEffect;
                                    pLockonEffect->activate(); //TubNIL
                                    //TubNIGtFNgbNII
                                    ((EffectLockon001*)pLockonEffect)->lockon(_pRingTarget->getNext());
                                } else {
                                    //Q^[QbgiTubNI^[Qbgj
                                    GgafMainActor* pLockonEffect = getSubFirst()->getPrev(); //QNextu
                                    pLockonEffect->activate(); //TubNIL
                                    ((EffectLockon001*)pLockonEffect)->lockon(_pRingTarget->getNext());
                                }
                            }
                        }
                    }
                }
                
                void MyOptionLockonController::releaseAllLockon() {
                    while (_pRingTarget->length() > 0) {
                        _pRingTarget->remove();
                    }
                    //bNIGtFNgCANeBu
                    GgafMainActor* pLockonEffect = getSubFirst();
                    while (true) {
                        ((EffectLockon001*)pLockonEffect)->releaseLockon();
                        if (pLockonEffect->isLast()) {
                            break;
                        } else {
                            pLockonEffect = pLockonEffect->getNext();
                        }
                    }
                }
                
                
          16 -> MyOptionLockonController::~MyOptionLockonController() {
                    DELETE_IMPOSSIBLE_NULL(_pRingTarget);
                }
                
                
                void MyOptionLockonController::dumpTarget(GgafDx9GeometricActor* pMain) {
                
                    if (_pRingTarget->getNextFromFirst(0) == NULL) {
                        _TEXT_("NULL\n");
                        return;
                    } else {
                        _TEXT_("");
                    }
                    for (int i = 0; i < _pRingTarget->length(); i++) {
                        if (_pRingTarget->getNextFromFirst(i) == pMain) {
                            _TEXT_("I");
                        }
                        _TEXT_(_pRingTarget->getNextFromFirst(i)->getName()<<"["<<i<<"]");
                    }
                    _TEXT_(" ... avtive="<<_pRingTarget->getCurrent()->getName()<<"\n");
                }
                
                //yY^z
                //ubNI^[QbgbNIGtFNgWv(2010/09/14)
                //
                //bNIAbNI[X
                //bNI^[QbgbNIGtFNgWcB
                //
                //l      c CbNIGtFNg
                //S0`S3  c TubNIGtFNg
                //t1`t5  c bNI^[Qbg
                //
                //CbNIGtFNg(l)ubNI^[Qbg
                //uCbNI^[Qbgv
                //TubNIGtFNg(S0`S3)ubNI^[Qbg
                //uTubNI^[Qbgv
                //B
                
                //
                // lS0S1S2S3    EEEGtFNgAN^[
                //                      t1
                // t1
                // GtFNgAN^[
                //                      t2
                // t2t1
                // lS3S0S1S2
                //                      t3
                // t3t2t1
                // lS2S3S0S1
                //                      t4
                // t4t3t2t1
                // lS1S2S3S0
                //                      t5
                // t5t4t3t2t1
                // lS0S1S2S3
                
                // 
                // lS0S1S2S3    EEEGtFNgAN^[sv
                //
                // t5t4t3t2t1
                // t6t5t4t3t2   Y
                // t7t6t5t4t3   Y
                // t8t7t6t5t4   Y
                // t9t8t7t6t5   Y
                
                //S
                // lS0S1S2S3    EEEGtFNgAN^[
                // t5t4t3t2t1
                //              remove(t1)
                // t5t4t3t2
                // lS0S1S2S3    EEEiS3jlockonRelase()
                
                // lS0S1S2S3    EEEGtFNgAN^[
                // t5t4t3t2t1
                //              remove(t2)
                // t5t4t3t1
                // lS0S1S3S2    EEES2lockonRelase()
                
                // lS0S1S2S3    EEEGtFNgAN^[
                // t5t4t3t2t1
                //              remove(t3)
                // t5t4t2t1
                // lS0S2S3S1    EEES1lockonRelase()
                
                // lS0S1S2S3    EEEGtFNgAN^[
                // t5t4t3t2t1
                //              remove(t4)
                // t5t3t2t1
                // lS2S3S1S0    EEES0lockonRelase()
                
                // lS0S1S2S3    EEEGtFNgAN^[
                // t5t4t3t2t1
                //              remove(t5)
                // t4t3t2t1
                // lS1S2S3S0    EEE S0ijlockonRelase()
                
                
                
                //2
                // lS0S1S2S3    EEEGtFNgAN^[
                // t4t3t2t1
                //              remove(t1)
                // t4t3t1
                // lS0S1S3S2    EEES2iHjlockonRelase()
                
                // lS0S1S2S3    EEEGtFNgAN^[
                // t4t3t2t1
                //              remove(t2)
                // t4t3t1
                // lS0S2S3S1    EEES1lockonRelase()
                
                // lS0S1S2S3    EEEGtFNgAN^[
                // t4t3t2t1
                //              remove(t3)
                // t4t2t1
                // lS1S2S3S0    EEES0lockonRelase()
                
                // lS0S1S2S3    EEEGtFNgAN^[
                // t4t3t2t1
                //              remove(t4)
                // t3t2t1
                // lS1S2S3S0    EEES0ijlockonRelase()
                
                
                
                //3
                // lS0S1S2S3    EEEGtFNgAN^[
                // t3t2t1
                //              remove(t1)
                // t3t2
                // lS0S2S3S1    EEES1iHjlockonRelase()
                
                // lS0S1S2S3    EEEGtFNgAN^[
                // t3t2t1
                //              remove(t2)
                // t3t1
                // lS1S2S3S0    EEES0lockonRelase()
                
                // lS0S1S2S3    EEEGtFNgAN^[
                // t3t2t1
                //              remove(t3)
                // t2t1
                // lS1S2S3S0    EEES0lockonRelase()
                
                
                
                //4
                // lS0S1S2S3    EEEGtFNgAN^[
                // t2t1
                //              remove(t1)
                // t2
                // lS1S2S3S0    EEES0iHjlockonRelase()
                
                // lS0S1S2S3    EEEGtFNgAN^[
                // t2t1
                //              remove(t2)
                // t2t1
                // lS1S2S3S0    EEES0wlockonRelase()
                
                
                //5
                // lS0S1S2S3    EEEGtFNgAN^[
                // t1
                //              remove(t1)
                //
                // lS1S2S3S0    EEEMlockonRelase()


Top 10 Lines:

     Line      Count

      162         16
        9          8

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       24   Total number of line executions
     8.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/my/option/MyOptionTorpedoController.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
                
           8 -> MyOptionTorpedoController::MyOptionTorpedoController(const char* prm_name, MyOption* prm_pMyOption)
                                                                                                  : GgafDummyActor(prm_name) {
                    _class_name = "MyOptionTorpedoController";
                    _firing_num = 0;
                    _in_firing = false;
                    _pMyOption = prm_pMyOption;
                
                    _papMyTorpedo = NEW MyTorpedo*[MyOption::_max_lockon_num];
                    for (int i = 0; i < MyOption::_max_lockon_num; i++) {
                        stringstream name;
                        name <<  "MYOPTION"<<(prm_pMyOption->_no)<<"'s Torpedo["<<i<<"]";
                        _papMyTorpedo[i] = NEW MyTorpedo(name.str().c_str(), this);
                        _papMyTorpedo[i]->inactivateImmediately();
                        addSubGroup(_papMyTorpedo[i]);
                    }
                
                    _pDispatcher_TorpedoBlast = NEW GgafActorDispatcher("DP_TorpedoBlast");
                    for (int i = 0; i < MyOption::_max_lockon_num*2; i++) {
                        MyTorpedoBlast* pTorpedoBlast = NEW MyTorpedoBlast("TorpedoBlast");
                        pTorpedoBlast->inactivateImmediately();
                        _pDispatcher_TorpedoBlast->addSubLast(pTorpedoBlast);
                    }
                    addSubGroup(_pDispatcher_TorpedoBlast);
                
                }
                
                void MyOptionTorpedoController::initialize() {
                }
                
                void MyOptionTorpedoController::processBehavior() {
                    if (_in_firing) {
                        _in_firing = false;
                        for (int i = 0; i < _firing_num; i++) {
                            if (_papMyTorpedo[i]->isActiveActor()) {
                                _in_firing = true;
                                break;
                            }
                        }
                    }
                }
                
                void MyOptionTorpedoController::processJudgement() {
                }
                
                void MyOptionTorpedoController::fire() {
                    if (!_in_firing) {
                        _in_firing = true;
                        int target_num = _pMyOption->_pLockonController->_pRingTarget->length();
                        _firing_num = target_num == 0 ? 1 : target_num;
                                 // = MyOption::_max_lockon_num;
                                 // = target_num == 0 ? MyOption::_max_lockon_num : target_num;
                        angle angBegin = ANGLE90;
                        angle angRenge  = ANGLE360 / _pMyOption->_pMyOptionController->_now_option_num;
                        angle angFireCenter = angBegin + (ANGLE360*(_pMyOption->_no-1) / _pMyOption->_pMyOptionController->_now_option_num);
                        angle out_rz,out_ry,out_dz,out_dy;
                        angle* pa_angWay = NEW angle[ _firing_num+2];
                        GgafDx9Util::getWayAngle2D(angFireCenter, _firing_num+1, angRenge / _firing_num, pa_angWay);
                        for (int i = 0; i < _firing_num; i++) { //[sv
                            _papMyTorpedo[i]->locateAs(P_MYSHIP);
                            if (target_num == 0) {
                                _papMyTorpedo[i]->_pTarget = NULL;
                            } else {
                                _papMyTorpedo[i]->_pTarget = _pMyOption->_pLockonController->_pRingTarget->getNext(i);
                            }
                            _papMyTorpedo[i]->_pKuroko->setRzRyMvAng(0, 0);
                            _papMyTorpedo[i]->_pKuroko->getRzRyMvAngDistance(TURN_CLOSE_TO,
                                                                             pa_angWay[i], ANGLE90,
                                                                             out_dz, out_dy,
                                                                             out_rz, out_ry
                                                                            );
                            _papMyTorpedo[i]->_pKuroko->setRzRyMvAng(out_rz, out_ry);
                            _papMyTorpedo[i]->activate();
                        }
                        DELETEARR_IMPOSSIBLE_NULL(pa_angWay);
                    }
                }
                
                
          16 -> MyOptionTorpedoController::~MyOptionTorpedoController() {
                    DELETEARR_IMPOSSIBLE_NULL(_papMyTorpedo);
                }


Top 10 Lines:

     Line      Count

       87         16
        9          8

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       24   Total number of line executions
     8.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/my/option/MyTorpedo.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
          72 -> MyTorpedo::MyTorpedo(const char* prm_name,MyOptionTorpedoController* prm_pMyOptionTorpedoController)
                               : DefaultMeshSetActor(prm_name, "EffectLaserRefraction001") {
                    _class_name = "MyTorpedo";
                    MyStgUtil::resetMyTorpedoStatus(_pStatus);
                    _pMyOptionTorpedoController = prm_pMyOptionTorpedoController;
                    _length_TailEffect = 4;
                
                    _pTailEffectDispatcher = NEW LaserChipDispatcher("DP_TailEffect");
                    _pTailEffectDispatcher->config(_length_TailEffect, 0, NULL);
                    for (int i = 0; i < _length_TailEffect; i++) {
                        stringstream name;
                        name <<  "MYOPTION"<<(_pMyOptionTorpedoController->_pMyOption->_no)<<"'s Torpedo's TailEffect["<<i<<"]";
                        MyTorpedoTail* pChip = NEW MyTorpedoTail(name.str().c_str(), this);
                
                        pChip->inactivateImmediately();
                        _pTailEffectDispatcher->addSubLast(pChip);
                    }
                    addSubGroup(_pTailEffectDispatcher);
                    changeEffectTechnique("DestBlendOne"); //ZTechniquew
                    setZEnable(true);        //Zobt@lL
                    setZWriteEnable(false);  //Zobt@
                    _pTarget = NULL;
                    useProgress(10);
                }
                
                void MyTorpedo::initialize() {
                    _pCollisionChecker->makeCollision(1);
                    _pCollisionChecker->setColliAAB_Cube(0, 70000);
                }
                
                void MyTorpedo::onActive() {
                    MyStgUtil::resetMyTorpedoStatus(_pStatus);
                    setAlpha(0.3);
                    _SX = _SY = _SZ = 100;
                    _pScaler->setScale(100);
                    _pScaler->intoTargetScaleLinerStep(7000, 500);
                    _pKuroko->setFaceAngVelo(AXIS_X, 3*1000);
                    _pKuroko->setFaceAngVelo(AXIS_Y, 5*1000);
                    _pKuroko->setFaceAngVelo(AXIS_Z, 7*1000);
                    _pKuroko->setMvVelo(20000);
                    _pKuroko->setMvAcce(-1000);
                    _pKuroko->setRzMvAngVelo(0);
                    _pKuroko->setRyMvAngVelo(0);
                    _pKuroko->setRzMvAngAcce(0);
                    _pKuroko->setRyMvAngAcce(0);
                    _pKuroko->forceMvVeloRange(200, 80000);
                    _pKuroko->forceRzMvAngVeloRange(-40000, 40000);
                    _pKuroko->forceRyMvAngVeloRange(-40000, 40000);
                    _pKuroko->stopTagettingMvAngSequence();
                    _begin_X = _X;
                    _begin_Y = _Y;
                    _begin_Z = _Z;
                    setHitAble(true);
                    _pPrg->set(MyTorpedo_IN_FIRE);
                    _move_section = 0;
                }
                
                void MyTorpedo::processBehavior() {
                    if (_pPrg->get() == MyTorpedo_RELEASE) {
                        if (_pTailEffectDispatcher->_num_chip_active == 0) {
                            //OGtFNgS
                            inactivate(); //ginactivate()
                        } else {
                            addAlpha(-0.05);
                        }
                    }
                
                    if (_pPrg->get() == MyTorpedo_IN_FIRE) {
                        //GtFNg
                        if (_pTailEffectDispatcher->_num_chip_active < _length_TailEffect) {
                            MyTorpedoTail* pTailEffect = (MyTorpedoTail*)_pTailEffectDispatcher->employ();
                            if (pTailEffect) {
                                pTailEffect->locate(_begin_X,_begin_Y,_begin_Z);
                                pTailEffect->activate();
                            }
                        }
                        //[u
                        if (_move_section == 0) {
                            if (_pKuroko->_veloMv == _pKuroko->_veloBottomMv) {
                                //I
                                _pKuroko->setMvAcce(500);
                                if (_pTarget) {
                                    _pKuroko->orderTagettingMvAngSequence(
                                                _pTarget,
                                                2000, 200,
                                                TURN_CLOSE_TO, false);
                                } else {
                                    _pKuroko->orderTagettingMvAngSequence(
                                                GgafDx9Universe::_X_goneRight, P_MYSHIP->_Y, P_MYSHIP->_Z,
                                                2000, 200,
                                                TURN_CLOSE_TO, false);
                                }
                                _move_section++;
                            }
                        }
                
                        //[uP
                        if (_move_section == 1) {
                            if (_pKuroko->isTagettingMvAng()) {
                                //^[Qbg
                            } else {
                                //^[Qbg
                                _move_section++;
                            }
                
                        }
                        //[uQ
                        if (_move_section == 2) {
                            if (getActivePartFrame() < 120) {
                                if (getActivePartFrame() % 10 == 0) {
                                    if (_pTarget) {
                                        if (_pTarget->isActiveActor())  {
                                            _pKuroko->orderTagettingMvAngSequence(
                                                        _pTarget,
                                                        1000, 200,
                                                        TURN_CLOSE_TO, false);
                                        } else {
                                            //
                                            _pKuroko->setRzMvAngVelo(0);
                                            _pKuroko->setRyMvAngVelo(0);
                                            _pKuroko->setRzMvAngAcce(0);
                                            _pKuroko->setRyMvAngAcce(0);
                                        }
                                    } else {
                                            _pKuroko->orderTagettingMvAngSequence(
                                                        GgafDx9Universe::_X_goneRight, _Y, _Z,
                                                        1000, 200,
                                                        TURN_CLOSE_TO, false);
                                    }
                                } else {
                                   //
                                }
                            } else {
                                _move_section++;
                            }
                        }
                        //[uR
                        if (_move_section == 3) {
                            if (getActivePartFrame() < 300) {
                                if (getActivePartFrame() % 20 == 0) {
                                    if (_pTarget) {
                                        if (_pTarget->isActiveActor())  {
                                            _pKuroko->orderTagettingMvAngSequence(
                                                        _pTarget,
                                                        300, 0,
                                                        TURN_CLOSE_TO, false);
                                        } else {
                                            //
                                            _pKuroko->setRzMvAngVelo(0);
                                            _pKuroko->setRyMvAngVelo(0);
                                            _pKuroko->setRzMvAngAcce(0);
                                            _pKuroko->setRyMvAngAcce(0);
                                        }
                                    } else {
                                            _pKuroko->orderTagettingMvAngSequence(
                                                        GgafDx9Universe::_X_goneRight, _Y, _Z,
                                                        300, 0,
                                                        TURN_CLOSE_TO, false);
                                    }
                                } else {
                                   //
                                }
                            } else {
                                _move_section++;
                            }
                        }
                        //[uS
                        if (_move_section == 4) {
                            _pKuroko->setRzMvAngVelo(0);
                            _pKuroko->setRyMvAngVelo(0);
                            _pKuroko->setRzMvAngAcce(0);
                            _pKuroko->setRyMvAngAcce(0);
                        }
                
                        _pKuroko->behave();
                        _pScaler->behave();
                    }
                }
                
                void MyTorpedo::processJudgement() {
                    if (isOutOfUniverse() && _pPrg->get() == MyTorpedo_IN_FIRE) {
                        setHitAble(false);
                        _pPrg->change(MyTorpedo_RELEASE);
                        GgafMainActor* pTailEffect = _pTailEffectDispatcher->getSubFirst();
                        for (int i = 0; i < _length_TailEffect; i++) {
                            pTailEffect->inactivateDelay(i+1); //OGtFNgX\
                            pTailEffect = pTailEffect->getNext();
                        }
                        _pKuroko->setMvVelo(0);
                        //ginactive()processBehavior()s
                        //GtFNgSinactive()ginactive()
                    }
                
                }
                
                void MyTorpedo::onInactive() {
                }
                
                
                void MyTorpedo::onHit(GgafActor* prm_pOtherActor) {
                    GgafDx9GeometricActor* pOther = (GgafDx9GeometricActor*)prm_pOtherActor;
                    //qbg
                    int sta = MyStgUtil::calcMyStatus(_pStatus, getKind(), pOther->_pStatus, pOther->getKind());
                    setHitAble(false);
                    _pPrg->change(MyTorpedo_RELEASE);
                    GgafMainActor* pTailEffect = _pTailEffectDispatcher->getSubFirst();
                    for (int i = 0; i < _length_TailEffect; i++) {
                        pTailEffect->inactivateDelay(i+1); //OGtFNgX\
                        pTailEffect = pTailEffect->getNext();
                    }
                    _pKuroko->setMvVelo(0);
                    //ginactive()processBehavior()s
                    //GtFNgSinactive()ginactive()
                
                    //
                    MyTorpedoBlast* pBlast = (MyTorpedoBlast*)_pMyOptionTorpedoController->_pDispatcher_TorpedoBlast->employ();
                    if (pBlast) {
                        pBlast->locateAs(this);
                        pBlast->reset();
                        pBlast->activate();
                    }
                
                }
                
         144 -> MyTorpedo::~MyTorpedo() {
                }


Top 10 Lines:

     Line      Count

      232        144
        8         72

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      216   Total number of line executions
    72.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/my/option/MyTorpedoBlast.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
         144 -> MyTorpedoBlast::MyTorpedoBlast(const char* prm_name)
                               : DefaultMeshSetActor(prm_name, "MyTorpedoBlast") {
                    _class_name = "MyTorpedoBlast";
                    MyStgUtil::resetMyTorpedoBlastStatus(_pStatus);
                    changeEffectTechnique("DestBlendOne"); //ZTechniquew
                    setAlpha(0.2);
                    setZEnable(true);        //Zobt@lL
                    setZWriteEnable(false);  //Zobt@
                }
                
                void MyTorpedoBlast::initialize() {
                    _pCollisionChecker->makeCollision(1);
                    _pKuroko->setFaceAngVelo(AXIS_X, 27*1000);
                    _pKuroko->setFaceAngVelo(AXIS_Y, 33*1000);
                    _pKuroko->setFaceAngVelo(AXIS_Z, 17*1000);
                    setHitAble(true);
                }
                
                void MyTorpedoBlast::onReset() {
                    MyStgUtil::resetMyTorpedoBlastStatus(_pStatus);
                    _pCollisionChecker->setColliSphere(0, 1000);
                    _pKuroko->setMvVelo(0);
                    _pScaler->setScale(1000);
                    _pScaler->forceScaleRange(1000, 400*1000);
                
                }
                
                void MyTorpedoBlast::onActive() {
                    _pScaler->beat(120, 120/2, 0, 1); //1c
                }
                
                void MyTorpedoBlast::processBehavior() {
                    if (_pScaler->_method[AXIS_X] == NOSCALE) {
                        sayonara();//cI
                    } else {
                        _pCollisionChecker->setColliSphere(0, _pScaler->_scale[AXIS_X]); //
                        _pKuroko->behave();
                        _pScaler->behave();
                    }
                }
                
                void MyTorpedoBlast::processJudgement() {
                }
                
                void MyTorpedoBlast::onInactive() {
                }
                
                
                void MyTorpedoBlast::onHit(GgafActor* prm_pOtherActor) {
                    GgafDx9GeometricActor* pOther = (GgafDx9GeometricActor*)prm_pOtherActor;
                    //qbg
                    int sta = MyStgUtil::calcMyStatus(_pStatus, getKind(), pOther->_pStatus, pOther->getKind());
                }
                
         288 -> MyTorpedoBlast::~MyTorpedoBlast() {
                }


Top 10 Lines:

     Line      Count

       62        288
        8        144

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      432   Total number of line executions
   144.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/my/option/MyTorpedoTail.cpp:
                
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
                
         288 -> MyTorpedoTail::MyTorpedoTail(const char* prm_name, MyTorpedo* prm_pMyTorpedo) :
                        HomingLaserChip(prm_name, "AstraeaLaserChip001") {
                    _class_name = "MyTorpedoTail";
                    _pMyTorpedo = prm_pMyTorpedo;
                }
                
                void MyTorpedoTail::initialize() {
                    setHitAble(false); //
                    _SX = _SY = _SZ = 6*1000;
                    setAlpha(0.3);
                    _fBoundingSphereRadius = 5.0f;
                
                }
                
                void MyTorpedoTail::onActive() {
                    HomingLaserChip::onActive();
                }
                void MyTorpedoTail::onInactive() {
                    HomingLaserChip::onInactive();
                }
                void MyTorpedoTail::processBehaviorHeadChip() {
                
                    locateAs(_pMyTorpedo);
                    rotateWith(_pMyTorpedo);
                }
                
         576 -> MyTorpedoTail::~MyTorpedoTail() {
                
                }
                


Top 10 Lines:

     Line      Count

       36        576
       10        288

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

      864   Total number of line executions
   288.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/system/instrument/EnagyBar.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> EnagyBar::EnagyBar(const char* prm_name) : DefaultBoardActor(prm_name, "TurboMeter") {
                    _class_name = "EnagyBar";
                    //_z = 0.99;//w i0 <= _z < 1.0jZ=(0`+1)
                    //_z = 0.9999999f;
                    _z = 0.00000001f;
                    _fSize_BoardModelWidthPx = _pBoardModel->_fSize_BoardModelWidthPx;
                }
                
                void EnagyBar::initialize() {
                    _pUvFlipper->forcePtnNoRange(0, 10);
                    _pUvFlipper->setFlipMethod(FLIP_ORDER_LOOP, 10); //Aj
                
                    onReset();
                }
                
                void EnagyBar::onReset() {
                    _amount.config(600, 10000); //l 10000 \400pxB
                    _amount.set(10000);           //l5000
                    _sx = _amount._val_px / _fSize_BoardModelWidthPx;
                }
                
                void EnagyBar::onActive() {
                }
                
                void EnagyBar::processBehavior() {
                //    _amount.set(_value);
                    _sx = _amount._val_px / _fSize_BoardModelWidthPx;
                    _pUvFlipper->behave();
                }
                
                
                void EnagyBar::processJudgement() {
                }
                
                void EnagyBar::onInactive() {
                }
                
           2 -> EnagyBar::~EnagyBar() {
                }


Top 10 Lines:

     Line      Count

       45          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafDx9LibStg/include/jp/ggaf/dx9libstg/util/AmountGraph.h:
                #ifndef AMOUNTGRAPH_H_
                #define AMOUNTGRAPH_H_
                
                namespace GgafDx9LibStg {
                
                /**
                 * o[i .
                 * @version 1.00
                 * @since 2011/02/02
                 * @author Masatoshi Tsuge
                 */
                class AmountGraph : public GgafCore::GgafObject {
                
                public:
                    /** 100%[^[l(0) */
                    int _max_val;
                    /** [^[l */
                    int _val;
                    /** 100%[^[(px) */
                    float _max_val_px;
                    /** [^[(px) */
                    float _val_px;
                    /** [^[l */
                    float _rate_val;
                
                    /**
                     * RXgN^ .
                     * @return
                     */
           1 ->     AmountGraph() : GgafCore::GgafObject() {
                        _max_val_px = 100.0f;
                        _max_val = 100;
                        _val_px = 100.0f;
                        _val = 100;
                        _rate_val = 1.0;
                    }
                
                //    /**
                //     * RXgN^ .
                //     * @param prm_max_val_px  [^[l100%sNZ
                //     * @param prm_max_val     [^[l100%l([^[l)
                //     */
                //    AmountGraph(float prm_max_val_px, float prm_max_val);
                
                    /**
                     * [^[` .
                     * @param prm_max_val_px  [^[l100%sNZ
                     * @param prm_max_val     [^[l100%l([^[l)
                     */
                    void config(float prm_max_val_px, int prm_max_val) {
                        _max_val_px = prm_max_val_px;
                        _max_val = prm_max_val;
                    }
                
                    /**
                     * [^[l .
                     * A[^[(_val_px) yA
                     * [^[l(_rate_val) XV
                     * @param prm_val [^[l
                     */
                    void set(int prm_val) {
                        _val = prm_val;
                        _rate_val = (float)_val /  _max_val;
                        _val_px = _max_val_px * _rate_val;
                    }
                
                    int get() {
                        return _val;
                    }
                
                
                    /**
                     * [^[lZ .
                     * A[^[(_val_px) yA
                     * [^[l(_rate_val) XV
                     * @param prm_val [^[Zl
                     */
                    void inc(int prm_val) {
                        _val += prm_val;
                        _rate_val = (float)_val /  _max_val;
                        _val_px = _max_val_px * _rate_val;
                    }
                
                    void dec(int prm_val) {
                        _val -= prm_val;
                        _rate_val = (float)_val /  _max_val;
                        _val_px = _max_val_px * _rate_val;
                    }
                
           1 ->     virtual ~AmountGraph() {
                    }
                };
                
                }
                #endif /*AMOUNTGRAPH_H_*/
                


Top 10 Lines:

     Line      Count

       30          1
       90          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     1.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafCore/include/jp/ggaf/core/GgafLinkedListRing.hpp:
                #ifndef GGAFLINKEDLISTRING_H_
                #define GGAFLINKEDLISTRING_H_
                namespace GgafCore {
                
                /**
                 * vfi^CX^X|C^joAXg\zev[gB.
                 * <B>yz</B><BR>
                 * AXgqAwx\B<BR>
                 *
                 * AR[h`
                 * <pre><code>
                 * Object* A = new Object();
                 * Object* B = new Object();
                 * Object* C = new Object();
                 * Object* D = new Object();
                 * Object* E = new Object();
                 * GgafLinkedListRing<Object> ring_list = GgafLinkedListRing<Object>();
                 * ring_list.addLast(A);
                 * ring_list.addLast(B);
                 * ring_list.addLast(C);
                 * ring_list.addLast(D);
                 * ring_list.addLast(E);
                 * </code></pre>
                 *
                 * Tvf}\oB<BR>
                 * <pre>
                 * --------------------------------
                 * (E)A!BCDE(A!)
                 * --------------------------------
                 * </pre>
                 * ev[g|C^^wB<BR>
                 * AuGgafLinkedListRing<Object*>();vuGgafLinkedListRing<Object>();vB<BR>
                 * }wxAvfimvfjm|C^wB<BR>
                 * "!" Jgvf(J[\w)A{ev[g\bh@\vfB<BR>
                 * [u(E)vu(A!)v\LAAXgAAB<BR>
                 * I[Ai next  prev \B<BR>
                 * I[AtOvfAvfB<BR>
                 * }AA vfAE vfAAXgg\B<BR>
                 * <BR>
                 * @version 1.00
                 * @since 2008/12/19
                 * @author Masatoshi Tsuge
                 */
                template<class T>
                class GgafLinkedListRing : public GgafObject {
                
                public:
                
                    /**
                     * pvflbvNX .
                     * vflbsOAO|C^
                     */
                    class Elem {
                    public:
                        /** vfl */
                        T* _pValue;
                        /** vf */
                        Elem* _pNext;
                        /** Ovf */
                        Elem* _pPrev;
                        /** vftO (vfvf true)*/
                        bool _is_first_flg;
                        /** vftO (vfvf true)*/
                        bool _is_last_flg;
                        /** delete_pValuedeletetO */
                        bool _is_delete_value;
                
                        /**
                         * RXgN^
                         * @param prm_pValue li|C^j
                         * @param prm_is_delete_value true  : GgafLinkedListRingCX^XdeleteAvf(_pValue)deleteB
                         *                            false : vf(_pValue)deleteB
                         */
         446 ->         Elem(T* prm_pValue, bool prm_is_delete_value = true) {
                            _pValue = prm_pValue;
                            _pNext = _pPrev = NULL;
                            _is_first_flg = _is_last_flg = false;
                            _is_delete_value = prm_is_delete_value;
                        }
                
                        /**
                         * fXgN^.
                         * vfldeleteB<BR>
                         */
         446 ->         ~Elem() {
                            if (_is_delete_value) {
                                DELETE_IMPOSSIBLE_NULL(_pValue);
                            }
                        }
                    };
                
                    /** [r]vf */
                    Elem* _pElemFirst;
                
                    /** [r]Jgvf */
                    Elem* _pElemActive;
                
                    /** [r]vf */
                    int _num_elem;
                
                    /**
                     * RXgN^
                     */
                    GgafLinkedListRing();
                
                    /**
                     * fXgN^.
                     * vflANULLA delete B<BR>
                     * TODO:delete[] @
                     */
                    virtual ~GgafLinkedListRing();
                
                    Elem* getElemFirst() {
                        return _pElemFirst;
                    }
                
                    Elem* getElemActive() {
                        return _pElemActive;
                    }
                
                    /**
                     * Jgvfliej .
                     *<pre>
                     * ---usOv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     *                CQbg
                     * ---usv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     * </pre>
                     * @return	Jgvfl
                     */
                    virtual T* getCurrent();
                
                    /**
                     * JgvfiB .
                     *<pre>
                     * ---usOv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     *                next()sBJgvfuviDQbg
                     * ---usv-------------
                     * (E)ABCD!E(A)
                     * --------------------------
                     * </pre>
                     * <BR>
                     * Jgvf{\bhsA<BR>
                     * JgvfB<BR>
                     * <pre>
                     * ---usOv-------------
                     * (E!)ABCDE!(A)
                     * --------------------------
                     *                 next()sBJgvfuijviAQbg
                     * ---usv-------------
                     * (E)A!BCDE(A!)
                     * --------------------------
                     * </pre>
                     * @return JgvfiAvflB
                     */
                    virtual T* next();
                
                    /**
                     * JgvfvflBJgvf .
                     *<pre>
                     * ---usOv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     *                getNext()sBDQbg
                     * ---usv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     * </pre>
                     * Jgvf{\bhsA<BR>
                     * vflB<BR>
                     * <pre>
                     * ---usOv-------------
                     * (E!)ABCDE!(A)
                     * --------------------------
                     *                 getNext()sBAQbg
                     * ---usv-------------
                     * (!E)ABCDE!(A)
                     * --------------------------
                     * </pre>
                     * @return vfl
                     */
                    virtual T* getNext();
                
                    /**
                     * JgvfvflBJgvf .
                     * getNext(1) AgetNext() BgetNext(0)  getCurrent()B
                     *<pre>
                     * ---usOv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     *                getNext(2) c EQbg
                     * ---usv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     * </pre>
                     * @param n CfbNX
                     * @return Jgvfvf
                     */
                    virtual T* getNext(int n);
                
                    virtual T* getNextFromFirst(int n);
                
                    /**
                     * JgvfB .
                     *<pre>
                     * ---usOv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     *                BQbg
                     * ---usv-------------
                     * (E)AB!CDE(A)
                     * --------------------------
                     * </pre>
                     * @return JgvfAvfl
                     */
                    virtual T* prev();
                
                    /**
                     * JgvfPOvflBJgvf .
                     *<pre>
                     * ---usOv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     *                BQbg
                     * ---usv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     * </pre>
                     * @return Ovfl
                     */
                    virtual T* getPrev();
                
                    /**
                     * JgvfOvflBJgvf .
                     * getPrev(1) AgetPrev() BgetPrev(0)  get()B
                     *<pre>
                     * ---usOv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     *                getPrev(2) c AQbg
                     * ---usv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     * </pre>
                     * @param n CfbNX
                     * @return JgvfOvf
                     */
                    virtual T* getPrev(int n);
                
                
                
                
                    /**
                     * JgvfB .
                     *<pre>
                     * ---usOv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     *                JgAQbg
                     * ---usv-------------
                     * (E)A!BCDE(A)
                     * --------------------------
                     * </pre>
                     * @return JgvfAvfl
                     */
                    virtual T* first();
                
                    /**
                     * vflBJgvf .
                     *<pre>
                     * ---usOv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     *                AQbg
                     * ---usv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     * </pre>
                     * @return vfl
                     */
                    virtual T* getFirst();
                
                    /**
                     * JgvfB .
                     *<pre>
                     * ---usOv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     *                JgEQbg
                     * ---usv-------------
                     * (E)ABCDE!(A)
                     * --------------------------
                     * </pre>
                     * @return JgvfAvfl
                     */
                    virtual T* last();
                
                    /**
                     * vflBJgvf .
                     *<pre>
                     * ---usOv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     *                EQbg
                     * ---usv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     * </pre>
                     * @return vfl
                     */
                    virtual T* getLast();
                
                    /**
                     * JgvfXg .
                     *<pre>
                     * --------------------------
                     * (E)ABCDE!(A)
                     * --------------------------
                     * }true
                     * </pre>
                     * @return true:^false:
                     */
                    virtual bool isLast();
                
                    /**
                     * JgvfXg .
                     *<pre>
                     * --------------------------
                     * (E)A!BCDE(A)
                     * --------------------------
                     * }true
                     * </pre>
                     * @return true:^false:
                     */
                    virtual bool isFirst();
                
                    /**
                     * JgvflB .
                     *<pre>
                     * ---usOv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     *                set(X) c XCQbg
                     * ---usv-------------
                     * (E)ABX!DE(A)
                     * --------------------------
                     * </pre>
                     * vflAlgpsB
                     * @return Ovfl
                     */
                    virtual T* set(T* prm_pVal);
                
                    /**
                     * Jgvf .
                     * VJgvf next vfB
                     * <pre>
                     * ---usOv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     *                remove() c CoQbg
                     * ---usv-------------
                     * (E)ABD!E(A)
                     * --------------------------
                     * </pre>
                     *
                     * <BR>
                     * Jgvf<BR>
                     * VJgvfvfB
                     * <pre>
                     * ---usOv-------------
                     * (E!)ABCDE!(A)
                     * --------------------------
                     *                remove() c EoQbg
                     * ---usv-------------
                     * (D)A!BCD(A!)
                     * --------------------------
                     * </pre>
                     *
                     * lKvAlgpsB
                     * @return OJgvfvfl
                     */
                    virtual T* remove();
                
                    /**
                     * B
                     * vfl|C^Alr|C^(AhX)v
                     * CfbNXBCfbNX0lB
                     * <pre><code>
                     * Object* A = new Object();
                     * Object* B = new Object();
                     * Object* C = new Object();
                     * Object* D = new Object();
                     * Object* E = new Object();
                     * GgafLinkedListRing<Object> ring_list = GgafLinkedListRing<Object>();
                     * ring_list.addLast(A);
                     * ring_list.addLast(B);
                     * ring_list.addLast(C);
                     * ring_list.addLast(D);
                     *
                     * int a = ring_list.indexOf(A);   // a = 0 
                     * int b = ring_list.indexOf(B);   // b = 1 
                     * int c = ring_list.indexOf(C);   // c = 2 
                     * int d = ring_list.indexOf(D);   // d = 3 
                     * int e = ring_list.indexOf(E);   // e = -1 (l)
                     * </code></pre>
                     * @param prm_pVal CfbNXvf
                     * @return ACfbNX(0`)A -1 B
                     */
                    virtual int indexOf(T* prm_pVal);
                
                    /**
                     * vfA(_is_last_flg  true) .
                     * }B
                     *<pre>
                     * ---usOv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     *                addLast(X)
                     * ---usv-------------
                     * (X)ABC!DEX(A)
                     * --------------------------
                     * </pre>
                     * <BR>
                     * AaddLastAvfJgvfA<BR>
                     * Q~addLastsJgvfeB<BR>
                     * <pre>
                     * ---usOv-------------
                     * NULL(vf)
                     * --------------------------
                     *                addLast(A)
                     * --------------------------
                     * (A!)A!(A!)
                     * --------------------------
                     *                addLast(B)
                     * --------------------------
                     * (B)A!B(A!)
                     * --------------------------
                     *                addLast(C)
                     * --------------------------
                     * (C)A!BC(A!)
                     * --------------------------
                     * </pre>
                     * @param prm_pNew CX^Xvf|C^
                     * @param prm_is_delete_value true  : XgCX^XdeleteAvfdeletesB
                     *                            false : XgCX^XdeleteAvfsB
                     */
                    virtual void addLast(T* prm_pNew, bool prm_is_delete_value = true);
                
                    /**
                     * vfA(_is_first_flg  true) .
                     * }B
                     *<pre>
                     * ---usOv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     *                addFirst(X)
                     * ---usv-------------
                     * (E)XABC!DE(X)
                     * --------------------------
                     * </pre>
                     * <BR>
                     * AaddFirstAvfJgvfA<BR>
                     * Q~addFirstsJgvfeB<BR>
                     * <pre>
                     * ---usOv-------------
                     * NULL(vf)
                     * --------------------------
                     *                addFirst(A)
                     * --------------------------
                     * (A!)A!(A!)
                     * --------------------------
                     *                addFirst(B)
                     * --------------------------
                     * (A!)BA!(B)
                     * --------------------------
                     *                addFirst(C)
                     * --------------------------
                     * (A!)CBA!(C)
                     * --------------------------
                     * </pre>
                     * @param prm_pNew CX^Xvf|C^
                     * @param prm_is_delete_value true  : XgdeleteAvfdeletesB
                     *                            false : XgdeleteAvfsB
                     */
                    virtual void addFirst(T* prm_pNew, bool prm_is_delete_value = true);
                
                    /**
                     * vfAJgvfuv .
                     * }B
                     * <pre>
                     * ---usOv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     *                addNext(X)
                     * ---usv-------------
                     * (E)ABC!XDE(A)
                     * --------------------------
                     * </pre>
                     * <BR>
                     *  addNext AvfJgvfA<BR>
                     * Q~ addNext AJgvfeB<BR>
                     * <pre>
                     * ---usOv-------------
                     * NULL(vf)
                     * --------------------------
                     *                addNext(A)
                     * --------------------------
                     * (A!)A!(A!)
                     * --------------------------
                     *                addNext(B)
                     * --------------------------
                     * (B)A!B(A!)
                     * --------------------------
                     *                addNext(C)
                     * --------------------------
                     * (B)A!CB(A!)
                     * --------------------------
                     * </pre>
                     * <BR>
                     * Jgvf{\bhsA<BR>
                     * vfBivfj<BR>
                     * <pre>
                     * ---usOv-------------
                     * (E!)ABCDE!(A)
                     * --------------------------
                     *                addNext(X)
                     * ---usv-------------
                     * (X)ABCDE!X(A)
                     * --------------------------
                     * </pre>
                     * @param prm_pNew CX^Xvf|C^
                     * @param prm_is_delete_value true  : XgdeleteAvfdeletesB
                     *                            false : XgdeleteAvfsB
                     */
                    virtual void addNext(T* prm_pNew, bool prm_is_delete_value = true);
                
                
                    /**
                     * vfAJgvfuOv .
                     * }B
                     * <pre>
                     * ---usOv-------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     *                addPrev(X)
                     * ---usv-------------
                     * (E)ABXC!DE(A)
                     * --------------------------
                     * </pre>
                     * <BR>
                     *  addPrev AvfJgvfA<BR>
                     * Q~ addPrev AJgvfeB<BR>
                     * <pre>
                     * ---usOv-------------
                     * NULL(vf)
                     * --------------------------
                     *                addPrev(A)
                     * --------------------------
                     * (A!)A!(A!)
                     * --------------------------
                     *                addPrev(B)
                     * --------------------------
                     * (A!)BA!(B)
                     * --------------------------
                     *                addPrev(C)
                     * --------------------------
                     * (A!)BCA!(B)
                     * --------------------------
                     * </pre>
                     * <BR>
                     * Jgvf{\bhsA<BR>
                     * vfBivfj<BR>
                     * <pre>
                     * ---usOv-------------
                     * (E)A!BCDE(A!)
                     * --------------------------
                     *                addPrev(X)
                     * ---usv-------------
                     * (E)XA!BCDE(X)
                     * --------------------------
                     * </pre>
                     * @param prm_pNew CX^Xvf|C^
                     * @param prm_is_delete_value true  : XgdeleteAvfdeletesB
                     *                            false : XgdeleteAvfsB
                     */
                    virtual void addPrev(T* prm_pNew, bool prm_is_delete_value = true);
                
                
                    /**
                     * vf .
                     *<pre>
                     * --------------------------
                     * (E)ABC!DE(A)
                     * --------------------------
                     * </pre>
                     * }Alength()5
                     * Avf 0 B
                     * @return vf
                     */
                    virtual int length();
                };
                
                //////////////////////////////////////////////////////////////////
                
                /**
                 * 
                 */
                
                template<class T>
          12 -> GgafLinkedListRing<T>::GgafLinkedListRing() :
                    GgafObject() {
                    _num_elem = 0;
                    _pElemActive = NULL;
                    _pElemFirst = NULL;
                }
                
                template<class T>
                T* GgafLinkedListRing<T>::getCurrent() {
                    if (_pElemActive == NULL) {
                        return NULL;
                    } else {
                        return _pElemActive->_pValue;
                    }
                }
                
                template<class T>
                T* GgafLinkedListRing<T>::next() {
                    _pElemActive = _pElemActive->_pNext;
                    return _pElemActive->_pValue;
                }
                
                template<class T>
                T* GgafLinkedListRing<T>::getNext() {
                    return _pElemActive->_pNext->_pValue;
                }
                
                template<class T>
                T* GgafLinkedListRing<T>::getNext(int n) {
                    Elem* pElem_return = _pElemActive;
                    for (int i = 0; i < n; i++) {
                        pElem_return = pElem_return->_pNext;
                    }
                    return pElem_return->_pValue;
                }
                
                template<class T>
                T* GgafLinkedListRing<T>::getNextFromFirst(int n) {
                    if (_pElemFirst == NULL) {
                        return NULL;
                    }
                    Elem* pElem_return = _pElemFirst;
                    for (int i = 0; i < n; i++) {
                        pElem_return = pElem_return->_pNext;
                    }
                    return pElem_return->_pValue;
                }
                
                
                
                
                template<class T>
                T* GgafLinkedListRing<T>::prev() {
                    _pElemActive = _pElemActive->_pPrev;
                    return _pElemActive->_pValue;
                }
                
                template<class T>
                T* GgafLinkedListRing<T>::getPrev() {
                    return _pElemActive->_pPrev->_pValue;
                }
                
                template<class T>
                T* GgafLinkedListRing<T>::getPrev(int n) {
                    Elem* pElem_return = _pElemActive;
                    for (int i = 0; i < n; i++) {
                        pElem_return = pElem_return->_pPrev;
                    }
                    return pElem_return->_pValue;
                }
                
                template<class T>
                T* GgafLinkedListRing<T>::first() {
                    _pElemActive = _pElemFirst;
                    return _pElemActive->_pValue;
                }
                
                template<class T>
                T* GgafLinkedListRing<T>::getFirst() {
                    return _pElemFirst->_pValue;
                }
                
                template<class T>
                T* GgafLinkedListRing<T>::last() {
                    _pElemActive = _pElemFirst->_pPrev; //AO
                    return _pElemActive->_pValue;
                }
                
                template<class T>
                T* GgafLinkedListRing<T>::getLast() {
                    return _pElemFirst->_pPrev->_pValue; //AO
                }
                
                
                template<class T>
                bool GgafLinkedListRing<T>::isLast() {
                    return _pElemActive->_is_last_flg;
                }
                
                template<class T>
                bool GgafLinkedListRing<T>::isFirst() {
                    return _pElemActive->_is_first_flg;
                }
                
                template<class T>
                T* GgafLinkedListRing<T>::set(T* prm_pVal) {
                    T* ret = _pElemActive->_pValue;
                    _pElemActive->_pValue = prm_pVal;
                    return ret;
                }
                
                template<class T>
                T* GgafLinkedListRing<T>::remove() {
                    Elem* pMy = _pElemActive;
                    _num_elem--;
                    if (pMy->_is_first_flg && pMy->_is_last_flg) {
                        //vfP
                        _pElemActive = NULL;
                        _pElemFirst = NULL;
                        T* r = pMy->_pValue;
                        DELETE_IMPOSSIBLE_NULL(pMy);
                        return r;
                    } else {
                        //AO
                        Elem* pMyNext = _pElemActive->_pNext;
                        Elem* pMyPrev = _pElemActive->_pPrev;
                        //m[hmqAwB
                        pMyPrev->_pNext = pMyNext;
                        pMyNext->_pPrev = pMyPrev;
                        if (pMy->_is_last_flg) { //vf
                            pMyPrev->_is_last_flg = true; //OvfV
                        }
                        if (pMy->_is_first_flg) { //vf
                            _pElemFirst = pMyNext;
                            pMyNext->_is_first_flg = true; //vfV
                        }
                        _pElemActive = pMyNext; //Jgvf next XVB
                        T* r = pMy->_pValue;
                        DELETE_IMPOSSIBLE_NULL(pMy);
                        return r;
                    }
                }
                
                
                template<class T>
                int GgafLinkedListRing<T>::indexOf(T* prm_pVal) {
                    if (_pElemFirst == NULL) {
                        return -1;
                    }
                    int r = 0;
                    Elem* pElem = _pElemFirst;
                    while (true) {
                        if (pElem->_pValue == prm_pVal) {
                            return r;
                        } else {
                            if (pElem->_is_last_flg) {
                                break;
                            } else {
                                pElem = pElem -> _pNext;
                                r++;
                            }
                        }
                    }
                    return -1;
                }
                
                template<class T>
                void GgafLinkedListRing<T>::addLast(T* prm_pNew, bool prm_is_delete_value) {
                    if (prm_pNew == NULL) {
                        throwGgafCriticalException("[GgafLinkedListRing::addLast()] Error! NULL");
                    }
                    Elem* pElem = NEW Elem(prm_pNew, prm_is_delete_value);
                
                    if (_pElemFirst == NULL) {
                        //P
                        pElem->_is_first_flg = true;
                        pElem->_is_last_flg = true;
                        pElem->_pNext = pElem;
                        pElem->_pPrev = pElem;
                        _pElemActive = pElem;
                        _pElemFirst = pElem;
                    } else {
                        //Q~
                        pElem->_is_first_flg = false;
                        pElem->_is_last_flg = true;
                        Elem* pLastElem = _pElemFirst->_pPrev;
                        pLastElem->_is_last_flg = false;
                        pLastElem->_pNext = pElem;
                        pElem->_pPrev = pLastElem;
                        pElem->_pNext = _pElemFirst;
                        _pElemFirst->_pPrev = pElem;
                    }
                    _num_elem++;
                }
                
                
                template<class T>
                void GgafLinkedListRing<T>::addFirst(T* prm_pNew, bool prm_is_delete_value) {
                    if (prm_pNew == NULL) {
                        throwGgafCriticalException("[GgafLinkedListRing::addLast()] Error! NULL");
                    }
                    Elem* pElem = NEW Elem(prm_pNew, prm_is_delete_value);
                    if (_pElemFirst == NULL) {
                        //P
                        pElem->_is_first_flg = true;
                        pElem->_is_last_flg = true;
                        pElem->_pNext = pElem;
                        pElem->_pPrev = pElem;
                        _pElemActive = pElem;
                        _pElemFirst = pElem;
                    } else {
                        Elem* pFirstElem = _pElemFirst;
                        Elem* pLastElem = _pElemFirst->_pPrev;
                        pLastElem->_pNext = pElem;
                        pElem->_pPrev = pLastElem;
                        pElem->_pNext = pFirstElem;
                        pFirstElem->_pPrev = pElem;
                        pFirstElem->_is_first_flg = false;
                
                        pElem->_is_first_flg = true;
                        pElem->_is_last_flg = false;
                        _pElemFirst = pElem;
                    }
                    _num_elem++;
                }
                
                
                template<class T>
                void GgafLinkedListRing<T>::addNext(T* prm_pNew, bool prm_is_delete_value) {
                    if (prm_pNew == NULL) {
                        throwGgafCriticalException("[GgafLinkedListRing::addLast()] Error! NULL");
                    }
                    Elem* pElem = NEW Elem(prm_pNew, prm_is_delete_value);
                    if (_pElemFirst == NULL) {
                        //P
                        pElem->_is_last_flg = true;
                        pElem->_is_first_flg = true;
                        pElem->_pNext = pElem;
                        pElem->_pPrev = pElem;
                        _pElemActive = pElem;
                        _pElemFirst = pElem;
                    } else {
                        Elem* pMy = _pElemActive;
                        if (pMy->_is_last_flg) {
                            pMy->_is_last_flg = false;
                            pElem->_is_last_flg = true;
                            pElem->_is_first_flg = false;
                        }
                        Elem* pMyNext = _pElemActive->_pNext;
                        pMy->_pNext = pElem;
                        pElem->_pPrev = pMy;
                        pElem->_pNext = pMyNext;
                        pMyNext->_pPrev = pElem;
                    }
                    _num_elem++;
                }
                
                template<class T>
                void GgafLinkedListRing<T>::addPrev(T* prm_pNew, bool prm_is_delete_value) {
                    if (prm_pNew == NULL) {
                        throwGgafCriticalException("[GgafLinkedListRing::addLast()] Error! NULL");
                    }
                    Elem* pElem = NEW Elem(prm_pNew, prm_is_delete_value);
                    if (_pElemFirst == NULL) {
                        //P
                        pElem->_is_last_flg = true;
                        pElem->_is_first_flg = true;
                        pElem->_pNext = pElem;
                        pElem->_pPrev = pElem;
                        _pElemActive = pElem;
                        _pElemFirst = pElem;
                    } else {
                        Elem* pMy = _pElemActive;
                        if (pMy->_is_first_flg) {
                            pMy->_is_first_flg = false;
                            pElem->_is_first_flg = true;
                            pElem->_is_last_flg = false;
                            _pElemFirst = pElem;
                        }
                        Elem* pMyPrev = _pElemActive->_pPrev;
                        pMyPrev->_pNext = pElem;
                        pElem->_pPrev = pMyPrev;
                        pElem->_pNext = pMy;
                        pMy->_pPrev = pElem;
                    }
                    _num_elem++;
                }
                
                
                template<class T>
                int GgafLinkedListRing<T>::length() {
                    return _num_elem;
                }
                
                template<class T>
          23 -> GgafLinkedListRing<T>::~GgafLinkedListRing() {
                    _TRACE_("GgafLinkedListRing<T>::~GgafLinkedListRing() BEGIN _num_elem="<<_num_elem);
                    //q
                    if (_pElemFirst) {
                        //qdelete
                        if (_num_elem == 1) {
                            //qvfP
                            DELETE_IMPOSSIBLE_NULL(_pElemFirst);
                            _pElemFirst = NULL;
                            _pElemActive = NULL;
                            _num_elem = 0;
                
                        } else {
                            //qvfQ
                            Elem* pLast = _pElemFirst->_pPrev;
                            Elem* pLastPrev = pLast->_pPrev;
                            while (true) {
                                DELETE_IMPOSSIBLE_NULL(pLast); //delete
                                if (pLastPrev->_is_first_flg) {
                                    DELETE_IMPOSSIBLE_NULL(_pElemFirst); //pSubLastPrev == _pSubFirst 
                                    _pElemFirst = NULL;
                                    _pElemActive = NULL;
                                    _num_elem = 0;
                                    break;
                                }
                                pLast = pLastPrev;
                                pLastPrev = pLastPrev->_pPrev;
                            }
                        }
                    }
                }
                
                }
                #endif /*GGAFLINKEDLISTRING_H_*/


Top 10 Lines:

     Line      Count

       74        446
       85        446
      910         23
      615         12

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

      927   Total number of line executions
   231.75   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/system/instrument/MagicMeter.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
                
           1 -> MagicMeter::MagicMeter(const char* prm_name)
                : DefaultBoardSetActor(prm_name, "MagicMeter") {
                    _class_name = "MagicMeter";
                    _width = _pBoardSetModel->_fSize_BoardSetModelWidthPx + 1.0f;
                    _height = _pBoardSetModel->_fSize_BoardSetModelHeightPx + 1.0f;
                    _x = 100;
                    _y = Properties::VIEW_SCREEN_HEIGHT - (_height*2);
                //    AmountGraph _qu;
                //    _qu.set(1.0);
                //    _qu.config(400.0, 1.0);
                //    float _value = 1000;
                //    _qu.config(400.0f, _value);
                //    AmountGraph _qu();
                //    [0][0]  [1][0]  [2][0]  [3][0]
                //    [0][1]  [1][1]  [2][1]  [3][1]
                //    [0][2]  [1][2]  [2][2]  [3][2]
                //    [0][3]  [1][3]  [2][3]  [3][3]
                //    [0][4]  [1][4]  [2][4]  [3][4]
                //    [0][5]  [1][5]  [2][5]  [3][5]
                //    [0][6]  [1][6]  [2][6]  [3][6]
                //    [0][7]  [1][7]  [2][7]  [3][7]
                //
                //    [4][0]  [5][0]  [6][0]  [7][0]
                //    [4][1]  [5][1]  [6][1]  [7][1]
                //    [4][2]  [5][2]  [6][2]  [7][2]
                //    [4][3]  [5][3]  [6][3]  [7][3]
                //    [4][4]  [5][4]  [6][4]  [7][4]
                //    [4][5]  [5][5]  [6][5]  [7][5]
                //    [4][6]  [5][6]  [6][6]  [7][6]
                //    [4][7]  [5][7]  [6][7]  [7][7]
                //
                    _ringMagics.addLast(NEW TractorMagic("TRACTOR"));
                    _ringMagics.addLast(NEW SpeedMagic("SPEED"));
                    _ringMagics.addLast(NEW LockonMagic("LOCKON"));
                    _ringMagics.addLast(NEW TorpedoMagic("TORPEDO"));
                    _ringMagics.addLast(NEW LaserMagic("LASER"));
                    _ringMagics.addLast(NEW OptionMagic("OPTION"));
                    for (int i = 0; i < _ringMagics.length(); i++) {
                        addSubGroup(_ringMagics.getNext(i));
                    }
                
                
                    _paLevelCursor = NEW int[_ringMagics.length()];
                    for (int i = 0; i < _ringMagics.length(); i++) {
                        _paLevelCursor[i] = _ringMagics.getNextFromFirst(i)->_level;
                    }
                    _pSeTransmitter->useSe(4);
                    _pSeTransmitter->set(0, "click07_2"); //[^[
                    _pSeTransmitter->set(1, "G_EFC5");  //x
                    _pSeTransmitter->set(2, "warp");  //
                    _pSeTransmitter->set(3, "SwingA@11"); //LZ
                }
                
                void MagicMeter::initialize() {
                    _pUvFlipper->setFlipMethod(FLIP_ORDER_LOOP, 10); //Aj
                }
                
                void MagicMeter::onActive() {
                }
                
                void MagicMeter::processBehavior() {
                    //_pUvFlipper->behave();
                    GgafLinkedListRing<Magic>::Elem* pElem = _ringMagics.getElemFirst();
                    for (int i = 0; i < _ringMagics.length(); i++) {
                        pElem->_pValue->behave();
                        pElem = pElem->_pNext;
                    }
                    //updatePanVolume3D  _pSeTransmitter->behave(); sv
                }
                
                void MagicMeter::processJudgement() {
                
                
                    if (VB_PLAY->isBeingPressed(VB_POWERUP)) {
                        Magic* pActiveMagic = _ringMagics.getCurrent();
                        int i = _ringMagics.indexOf(pActiveMagic);
                        if (VB_PLAY->isPushedDown(VB_POWERUP)) {
                            pActiveMagic->rollOpen();
                        }
                
                        if (VB_PLAY->isAutoRepeat(VB_RIGHT)) {
                            _paLevelCursor[i] = pActiveMagic->_level;
                            _pSeTransmitter->playImmediately(0);
                            pActiveMagic->rollClose();
                            _ringMagics.next();
                            _ringMagics.getCurrent()->rollOpen();
                        } else if (VB_PLAY->isAutoRepeat(VB_LEFT)) {
                            _paLevelCursor[i] = pActiveMagic->_level;
                            _pSeTransmitter->playImmediately(0);
                            pActiveMagic->rollClose();
                            _ringMagics.prev();
                            _ringMagics.getCurrent()->rollOpen();
                        } else if (VB_PLAY->isAutoRepeat(VB_UP)) {
                            if (pActiveMagic->_max_level > _paLevelCursor[i]) {
                                _pSeTransmitter->playImmediately(0);
                                _paLevelCursor[i] ++;
                            }
                        } else if (VB_PLAY->isAutoRepeat(VB_DOWN)) {
                            if (0 < _paLevelCursor[i]) {
                                _pSeTransmitter->playImmediately(0);
                                _paLevelCursor[i] --;
                            }
                        }
                    } else if (VB_PLAY->isReleasedUp(VB_POWERUP)) {
                        Magic* pActiveMagic = _ringMagics.getCurrent();
                        int i = _ringMagics.indexOf(pActiveMagic);
                        if (pActiveMagic->_level < _paLevelCursor[i]) {
                            _pSeTransmitter->playImmediately(2);
                            pActiveMagic->execute(_paLevelCursor[i]);
                                 //xAbv@sI
                
                        } else if (pActiveMagic->_level > _paLevelCursor[i]) {
                            _pSeTransmitter->playImmediately(3);
                            pActiveMagic->execute(_paLevelCursor[i]);
                                //x_E@sI
                
                        } else if (pActiveMagic->_level == _paLevelCursor[i]) {
                            //xs
                        }
                        pActiveMagic->rollClose();
                    }
                }
                
                void MagicMeter::onInactive() {
                }
                
                void MagicMeter::processDraw() {
                    ID3DXEffect* pID3DXEffect = _pBoardSetEffect->_pID3DXEffect;
                    GgafDx9RectUV* pRectUV_Active;
                    HRESULT hr;
                    //p[[^[
                    //[====]P [====][====][====]
                    GgafLinkedListRing<Magic>::Elem* pElem = _ringMagics.getElemFirst();
                    Magic* pMagic;
                    int len_magics = _ringMagics.length();
                    int n = 0;
                    for (int i = 0; i < len_magics; i++) {
                        pMagic = pElem->_pValue;//ANeBu
                        //e}WbNvf
                        n = 0;
                        if (pMagic->_rr > 0.1) {
                            for (int j = 0; j < pMagic->_max_level+1; j++) {
                                n++;
                                hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahTransformedX[n], _x + _width*i);
                                checkDxException(hr, D3D_OK, "MagicMeter::processDraw SetFloat(_ahTransformedX) sB");
                                hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahTransformedY[n], _y - (_height*(j+1)*pMagic->_rr));
                                checkDxException(hr, D3D_OK, "MagicMeter::processDraw SetFloat(_ahTransformedY) sB");
                                hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahDepthZ[n], 0.00000002f);
                                checkDxException(hr, D3D_OK, "MagicMeter::processDraw SetFloat(_ahDepthZ) sB");
                                hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahAlpha[n], pMagic->_rr); //ANeBuZ
                                checkDxException(hr, D3D_OK, "MagicMeter::processDraw SetFloat(_ahAlpha) sB");
                                pRectUV_Active = _pBoardSetModel->_paRectUV + pMagic->_lvinfo[j]._pno;
                                hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahOffsetU[n], pRectUV_Active->_aUV[0].tu);
                                checkDxException(hr, D3D_OK, "MagicMeter::processDraw() SetFloat(_hOffsetU) sB");
                                hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahOffsetV[n], pRectUV_Active->_aUV[0].tv);
                                checkDxException(hr, D3D_OK, "MagicMeter::processDraw() SetFloat(_hOffsetV) sB");
                            }
                
                            //e}WbNJ[\
                            n++;
                            hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahTransformedX[n], _x + _width*i);
                            checkDxException(hr, D3D_OK, "MagicMeter::processDraw SetFloat(_ahTransformedX) sB");
                            hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahTransformedY[n], _y - ((_height*(_paLevelCursor[i]+1))*pMagic->_rr));
                            checkDxException(hr, D3D_OK, "MagicMeter::processDraw SetFloat(_ahTransformedY) sB");
                            hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahDepthZ[n], 0.00000001f);
                            checkDxException(hr, D3D_OK, "MagicMeter::processDraw SetFloat(_ahDepthZ) sB");
                            hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahAlpha[n], pMagic->_rr*2);
                            checkDxException(hr, D3D_OK, "MagicMeter::processDraw SetFloat(_ahAlpha) sB");
                            pRectUV_Active = _pBoardSetModel->_paRectUV + 1; //p^[1[^[vfANeBu
                            hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahOffsetU[n], pRectUV_Active->_aUV[0].tu);
                            checkDxException(hr, D3D_OK, "MagicMeter::processDraw() SetFloat(_hOffsetU) sB");
                            hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahOffsetV[n], pRectUV_Active->_aUV[0].tv);
                            checkDxException(hr, D3D_OK, "MagicMeter::processDraw() SetFloat(_hOffsetV) sB");
                
                        }
                
                
                        //}WbN[^[wi
                        n++;
                        hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahTransformedX[n], _x +_width*i);
                        checkDxException(hr, D3D_OK, "MagicMeter::processDraw SetFloat(_ahTransformedX) sB");
                        hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahTransformedY[n], _y) ;
                        checkDxException(hr, D3D_OK, "MagicMeter::processDraw SetFloat(_ahTransformedY) sB");
                        hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahDepthZ[n], _z);
                        checkDxException(hr, D3D_OK, "MagicMeter::processDraw SetFloat(_ahDepthZ) sB");
                        hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahAlpha[n], _fAlpha);
                        checkDxException(hr, D3D_OK, "MagicMeter::processDraw SetFloat(_ahAlpha) sB");
                        pRectUV_Active = _pBoardSetModel->_paRectUV + 2; //3p^[I
                        hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahOffsetU[n], pRectUV_Active->_aUV[0].tu);
                        checkDxException(hr, D3D_OK, "MagicMeter::processDraw() SetFloat(_hOffsetU) sB");
                        hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahOffsetV[n], pRectUV_Active->_aUV[0].tv);
                        checkDxException(hr, D3D_OK, "MagicMeter::processDraw() SetFloat(_hOffsetV) sB");
                
                        //}WbNx\
                        n++;
                        hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahTransformedX[n], _x + _width*i);
                        checkDxException(hr, D3D_OK, "MagicMeter::processDraw SetFloat(_ahTransformedX) sB");
                        hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahTransformedY[n], _y);
                        checkDxException(hr, D3D_OK, "MagicMeter::processDraw SetFloat(_ahTransformedY) sB");
                        hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahDepthZ[n], 0.00000001f);
                        checkDxException(hr, D3D_OK, "MagicMeter::processDraw SetFloat(_ahDepthZ) sB");
                        hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahAlpha[n], _fAlpha);
                        checkDxException(hr, D3D_OK, "MagicMeter::processDraw SetFloat(_ahAlpha) sB");
                        pRectUV_Active = _pBoardSetModel->_paRectUV + pMagic->_lvinfo[pMagic->_level]._pno;
                        hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahOffsetU[n], pRectUV_Active->_aUV[0].tu);
                        checkDxException(hr, D3D_OK, "MagicMeter::processDraw() SetFloat(_hOffsetU) sB");
                        hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahOffsetV[n], pRectUV_Active->_aUV[0].tv);
                        checkDxException(hr, D3D_OK, "MagicMeter::processDraw() SetFloat(_hOffsetV) sB");
                
                        _pBoardSetModel->draw(this, n+1);
                        pElem = pElem->_pNext;
                    }
                
                
                
                
                    //p[[^[ANeBuJ[\
                    n = 0;
                    hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahTransformedX[n], _x+_width*_ringMagics.indexOf(_ringMagics.getCurrent()));
                    checkDxException(hr, D3D_OK, "MagicMeter::processDraw SetFloat(_ahTransformedX) sB");
                    hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahTransformedY[n], _y) ;
                    checkDxException(hr, D3D_OK, "MagicMeter::processDraw SetFloat(_ahTransformedY) sB");
                    hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahDepthZ[n], _z);
                    checkDxException(hr, D3D_OK, "MagicMeter::processDraw SetFloat(_ahDepthZ) sB");
                    hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahAlpha[n], _fAlpha);
                    checkDxException(hr, D3D_OK, "MagicMeter::processDraw SetFloat(_ahAlpha) sB");
                    pRectUV_Active = _pBoardSetModel->_paRectUV + 0; //p^[0
                    hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahOffsetU[n], pRectUV_Active->_aUV[0].tu);
                    checkDxException(hr, D3D_OK, "MagicMeter::processDraw() SetFloat(_hOffsetU) sB");
                    hr = pID3DXEffect->SetFloat(_pBoardSetEffect->_ahOffsetV[n], pRectUV_Active->_aUV[0].tv);
                    checkDxException(hr, D3D_OK, "MagicMeter::processDraw() SetFloat(_hOffsetV) sB");
                    _pBoardSetModel->draw(this, n+1);
                }
                
           2 -> MagicMeter::~MagicMeter() {
                    DELETEARR_IMPOSSIBLE_NULL(_paLevelCursor);
                }


Top 10 Lines:

     Line      Count

      243          2
        9          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/system/magic/EffecMagic001.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           8 -> EffectMagic001::EffectMagic001(const char* prm_name)
                               : DefaultMeshSetActor(prm_name, "EffectMagic001") {
                    _class_name = "EffectMagic001";
                    changeEffectTechnique("DestBlendOne"); //ZTechniquew
                    setZEnable(true);        //Zobt@lL
                    setZWriteEnable(false);  //Zobt@
                    setAlpha(0.9);
                }
                
                void EffectMagic001::initialize() {
                //    _pUvFlipper->forcePtnNoRange(0, 63);
                    setHitAble(false);
                
                }
                
                void EffectMagic001::onActive() {
                    _pKuroko->setFaceAngVelo(AXIS_X, 3*1000);
                    _pKuroko->setFaceAngVelo(AXIS_Y, 5*1000);
                    _pKuroko->setFaceAngVelo(AXIS_Z, 7*1000);
                }
                
                void EffectMagic001::processBehavior() {
                    _pKuroko->behave();
                }
                
                void EffectMagic001::processJudgement() {
                //    if (_fAlpha < 0) {
                //        sayonara();
                //    }
                }
                
                void EffectMagic001::onInactive() {
                }
                
          16 -> EffectMagic001::~EffectMagic001() {
                }


Top 10 Lines:

     Line      Count

       42         16
        8          8

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       24   Total number of line executions
     8.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/system/magic/LaserMagic.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> LaserMagic::LaserMagic(const char* prm_name)
                    : Magic(prm_name,
                    2,          //max_level
                    1000*4  , 0.9,   //{@RXg , x rate
                    60*3    , 0.9,   //{r   , x rate
                    60*2    , 0.9,   //{   , x rate
                    60*60*10,    0.0,   //{, ex
                    1.0     , 0.0 ) {    //{RXg , ex rate
                
                    //    |  0,   1,   2,   3 |
                    //    |  4,   5,   6,   7 |
                    //    |  8,   9,  10,  11 |
                    //    | 12,  13,  14,  15 |
                    //    | 16,  17,  18,  19 |
                    //    | 20,  21,  22,  23 |
                    //    | 24,  25,  26,  27 |
                    //    | 28,  29,  30,  31 |
                    //    | 32,  33,  34,  35 |
                    //    | 36,  37,  38,  39 |
                    //    | 40,  41,  42,  43 |
                    //    | 44,  45,  46,  47 |
                    //    | 48,  49,  50,  51 |
                    //    | 52,  53,  54,  55 |
                    //    | 56,  57,  58,  59 |
                    //    | 60,  61,  62,  63 |
                    _lvinfo[0]._pno = 3;
                    _lvinfo[1]._pno = 62;
                    _lvinfo[2]._pno = 58;
                }
                
           2 -> LaserMagic::~LaserMagic() {
                }


Top 10 Lines:

     Line      Count

       38          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/system/magic/LockonMagic.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> LockonMagic::LockonMagic(const char* prm_name)
                : Magic(prm_name,
                        5,          //max_level
                        1000*4  , 0.9,   //{@RXg , x rate
                        60*3    , 0.9,   //{r   , x rate
                        60*2    , 0.9,   //{   , x rate
                        60*60*10,    0.0,   //{, ex
                        1.0     , 0.0    //{RXg , ex rate
                       ) {
                
                    //    |  0,   1,   2,   3 |
                    //    |  4,   5,   6,   7 |
                    //    |  8,   9,  10,  11 |
                    //    | 12,  13,  14,  15 |
                    //    | 16,  17,  18,  19 |
                    //    | 20,  21,  22,  23 |
                    //    | 24,  25,  26,  27 |
                    //    | 28,  29,  30,  31 |
                    //    | 32,  33,  34,  35 |
                    //    | 36,  37,  38,  39 |
                    //    | 40,  41,  42,  43 |
                    //    | 44,  45,  46,  47 |
                    //    | 48,  49,  50,  51 |
                    //    | 52,  53,  54,  55 |
                    //    | 56,  57,  58,  59 |
                    //    | 60,  61,  62,  63 |
                    _lvinfo[0]._pno = 3;
                    _lvinfo[1]._pno = 54;
                    _lvinfo[2]._pno = 50;
                    _lvinfo[3]._pno = 46;
                    _lvinfo[4]._pno = 42;
                    _lvinfo[5]._pno = 38;
                }
                
           2 -> LockonMagic::~LockonMagic() {
                }


Top 10 Lines:

     Line      Count

       42          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/system/magic/Magic.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           6 -> Magic::Magic(const char*  prm_name,
                             int          prm_max_level,
                             magic_point  prm_cost_base            , float prm_fRate_cost             ,
                             magic_time   prm_time_of_casting_base , float prm_fRate_time_of_casting  ,
                             magic_time   prm_time_of_invoking_base, float prm_fRate_time_of_invoking ,
                             magic_time   prm_time_of_effect_base  , float prm_fRate_time_of_effecting,
                             magic_point  prm_keep_cost_base       , float prm_fRate_keep_cost
                                ) : GgafMainActor(prm_name) {
                //    GgafDx9GeometricActor* prm_pCaster,
                //     GgafDx9GeometricActor* prm_pReceiver) : GgafDx9BoardSetActor(prm_name, "magic") {
                    _pMP = NULL; //initialize()B
                    _new_level = 0;
                    _last_level = 0;
                    _level = 0;
                    _max_level = prm_max_level;
                
                //    _cost = _cost_base;
                
                //    _time_of_casting = _time_of_casting_base;
                //    _cast_speed = 100;
                
                //    _left_time_to_expire =  _time_of_invoking;
                
                    _cost_base             = prm_cost_base;
                    _time_of_casting_base  = prm_time_of_casting_base;
                    _time_of_invoking_base = prm_time_of_invoking_base;
                    _time_of_effect_base   = prm_time_of_effect_base;
                    _keep_cost_base        = prm_keep_cost_base;
                
                    _fRate_cost               = prm_fRate_cost;
                    _fRate_time_of_casting    = prm_fRate_time_of_casting;
                    _fRate_time_of_invoking   = prm_fRate_time_of_invoking;
                    _fRate_time_of_effecting  = prm_fRate_time_of_effecting;
                    _fRate_keep_cost          = prm_fRate_keep_cost;
                
                    //x
                    _interest_cost[0] = 0;
                    _interest_time_of_casting[0] = 0;
                    _interest_time_of_invoking[0] = 0;
                    for (int i = 1; i <= _max_level; i++) {
                        _interest_cost[i]             = (_cost_base * i) * _fRate_cost;
                        _interest_time_of_casting[i]  = (_time_of_casting_base * i) *  _fRate_time_of_casting;
                        _interest_time_of_invoking[i] = (_time_of_invoking_base * i) *  _fRate_time_of_invoking;
                    }
                
                    //exyARXg\
                    _lvinfo[0]._is_working = false;
                    _lvinfo[0]._keep_cost = 0;
                    _lvinfo[0]._time_of_effect = 0;
                    _lvinfo[0]._keep_cost = 0;
                    for (int i = 1; i <= _max_level; i++) {
                        _lvinfo[i]._is_working = false;
                        _lvinfo[i]._remaining_time_of_effect = 0;
                        _lvinfo[i]._time_of_effect = _time_of_effect_base + ((i-1) * _time_of_effect_base * _fRate_time_of_effecting);
                        _lvinfo[i]._keep_cost      = _keep_cost_base      + ((i-1) * _keep_cost_base * _fRate_keep_cost);
                    }
                
                //    for (int i = 1; i <= _max_level; i++) {
                //        _TRACE_(getName()<<":_lvinfo["<<i<<"]._is_working ="<<_lvinfo[i]._is_working);
                //        _TRACE_(getName()<<":_lvinfo["<<i<<"]._remaining_time_of_effect ="<<_lvinfo[i]._remaining_time_of_effect);
                //        _TRACE_(getName()<<":_lvinfo["<<i<<"]._time_of_effect ="<<_lvinfo[i]._time_of_effect);
                //        _TRACE_(getName()<<":_lvinfo["<<i<<"]._keep_cost ="<<_lvinfo[i]._keep_cost);
                //    }
                
                    _time_of_next_state = 0;
                
                    _is_working = false;
                    _pCaster = NULL;
                    _pReceiver = NULL;
                    _rr = 0.0f;
                    _velo_rr = 0.0f;
                
                    useProgress();
                    _pPrg->set(MAGIC_NOTHING);
                }
                
                void Magic::initialize()  {
                    _pMP = &(P_MYSHIP_SCENE->_pEnagyBar->_amount); //MPAmountGraph
                }
                
                
                void Magic::rollOpen() {
                    _velo_rr = 0.1;
                }
                void Magic::rollClose() {
                    _velo_rr = -0.02;
                }
                
                int Magic::chkExecuteAble(int prm_new_level) {
                    if (_pPrg->get() == MAGIC_INVOKING) {
                        //ss
                        return MAGIC_EXECUTE_NG_INVOKING;
                    } else {
                        if (_level > prm_new_level) {
                            return MAGIC_EXECUTE_OK_LEVELDOWN;
                        } else if (_level < prm_new_level) {
                            if (_interest_cost[prm_new_level-_level] < _pMP->get()) {
                                return MAGIC_EXECUTE_OK_LEVELUP;
                            } else {
                                return MAGIC_EXECUTE_NG_MP_IS_SHORT;
                            }
                        } else {
                            return MAGIC_EXECUTE_THE_SAME_LEVEL;
                        }
                    }
                }
                void Magic::execute(int prm_new_level) {
                    int r = chkExecuteAble(prm_new_level);
                    if (r > 0) {
                        _new_level = prm_new_level;
                
                        _is_working = true;
                        if (r == MAGIC_EXECUTE_OK_LEVELUP) {
                            //xAbv
                            _pPrg->change(MAGIC_STAND_BY);
                        } else if (r == MAGIC_EXECUTE_OK_LEVELDOWN) {
                            //x_E
                            //TODO:MP
                            //~
                            _lvinfo[_level]._is_working = false;
                            _lvinfo[_level]._remaining_time_of_effect = 0;
                            //z
                            for (int i = _level-1; i >= prm_new_level+1; i--) {
                                _lvinfo[i]._is_working = false; //~
                                _lvinfo[i]._remaining_time_of_effect = 0;
                            }
                            //Vx
                            _lvinfo[prm_new_level]._is_working = true;
                            processOnLevelDown(_level, prm_new_level); //s
                
                            _pPrg->change(MAGIC_EFFECTING);
                        }
                    }
                }
                
                
                
                void Magic::cancel() {
                    _new_level = _level;
                    _is_working = false;
                    _pPrg->change(MAGIC_NOTHING);
                }
                
                //void Magic::commit() {
                //    if (_is_working) {
                //        _level = _new_level;
                //        _is_working = false;
                //        _lvinfo[_level]._is_working = true;
                ////        _lvinfo[_level]._working_time = 0;
                //        _pPrg->change(MAGIC_NOTHING);
                //    }
                //}
                
                
                
                void Magic::processBehavior() {
                    _rr += _velo_rr;
                    if (_rr < 0.0f) {
                        _rr = 0.0f;
                        _velo_rr = 0.0f;
                    }
                    if (_rr > 1.0f) {
                        _rr = 1.0f;
                        _velo_rr = 0.0f;
                    }
                ////    for (int i = 0; i < _max_level; i++) {
                //        if (_lvinfo[_level]._is_working) {
                //            _lvinfo[_level]._remaining_time_of_effect --;
                ////            _lvinfo[i]._working_time ++;
                //            if (_lvinfo[_level]._remaining_time_of_effect <= 0) {
                //                abandon(_level);
                //            }
                //        }
                ////    }
                    if (_is_working) {
                
                        switch (_pPrg->get()) {
                            /////////////////////////////////////// @
                            case MAGIC_STAND_BY:
                                _pPrg->change(MAGIC_CASTING);
                                break;
                
                            /////////////////////////////////////// r
                            case MAGIC_CASTING:
                                if (_pPrg->isJustChanged()) {
                                    //rJnArIvZ
                                    _time_of_next_state = _interest_time_of_casting[_new_level- _level];
                                    processCastBegin(_level, _new_level);
                                }
                                //r
                                processCastingBehavior(_level, _new_level);
                
                                if (_pPrg->getFrameInProgress() >= _time_of_next_state) {
                                    //rI
                                    processCastFinish(_level, _new_level);
                                    _pPrg->change(MAGIC_INVOKING);
                                }
                                break;
                
                            /////////////////////////////////////// 
                            case MAGIC_INVOKING:
                                if (_pPrg->isJustChanged()) {
                                    //JnA
                                    //I
                                    _time_of_next_state = _interest_time_of_invoking[_new_level- _level];
                
                                    processInvokeBegin(_level, _new_level);
                                }
                                //
                                processInvokeingBehavior(_level, _new_level);
                
                                if (_pPrg->getFrameInProgress() >= _time_of_next_state) {
                                    //I
                                    //xXKp
                                    _last_level = _level;
                                    _level = _new_level;
                
                                    //O~
                                    _lvinfo[_last_level]._is_working = false;
                                    //z^
                                    for (int i = _last_level+1; i <= _level-1; i++) {
                                        _lvinfo[i]._is_working = false; //~
                                        _lvinfo[i]._remaining_time_of_effect = _lvinfo[i]._time_of_effect; //^
                                    }
                                    //x
                                    _lvinfo[_level]._is_working = true;
                                    _lvinfo[_level]._remaining_time_of_effect = _lvinfo[_level]._time_of_effect; //^
                                    _pMP->dec(_interest_cost[_new_level-_level]); //MP
                
                                    processInvokeFinish(_last_level, _level);
                                    _pPrg->change(MAGIC_EFFECTING);
                                }
                                break;
                
                            /////////////////////////////////////// 
                            case MAGIC_EFFECTING:
                                if (_pPrg->isJustChanged()) {
                                    //Jn
                                    processEffectBegin(_level);
                                }
                                //
                //                _TRACE_("_lvinfo["<<_level<<"]._remaining_time_of_effect="<<_lvinfo[_level]._remaining_time_of_effect);
                                _lvinfo[_level]._remaining_time_of_effect --;     //c
                                _pMP->inc(-1*_lvinfo[_level]._keep_cost); //RXg
                                processEffectingBehavior(_level);
                
                                if (_lvinfo[_level]._remaining_time_of_effect <= 0) { // || _pEnagyBar->_value <= 0.0) {
                                    processEffectFinish(_level);
                                    _lvinfo[_level]._is_working = false;
                                    if (_level > 0) {
                                        execute(_level-1);
                                    } else {
                                        _pPrg->change(MAGIC_NOTHING);
                                    }
                                }
                                break;
                
                            default :
                                break;
                        }
                    }
                
                }
           6 -> Magic::~Magic() {
                }


Top 10 Lines:

     Line      Count

        8          6
      271          6

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       12   Total number of line executions
     4.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/MyStg2nd/src/gecchi/actor/system/magic/Magic.h:
                #ifndef MAGIC_H_
                #define MAGIC_H_
                namespace MyStg2nd {
                
                #define MAGIC_NOTHING 0
                #define MAGIC_STAND_BY 1
                #define MAGIC_CASTING 2
                #define MAGIC_INVOKING 3
                #define MAGIC_EFFECTING 4
                #define MAGIC_ABANDONING 9
                
                #define MAGIC_EXECUTE_NG_INVOKING    (-2)
                #define MAGIC_EXECUTE_NG_MP_IS_SHORT (-1)
                #define MAGIC_EXECUTE_NG             (-1)
                #define MAGIC_EXECUTE_THE_SAME_LEVEL 0
                #define MAGIC_EXECUTE_OK             1
                #define MAGIC_EXECUTE_OK_LEVELUP     1
                #define MAGIC_EXECUTE_OK_LEVELDOWN   2
                
                typedef int magic_point;
                typedef frame magic_time;
                /**
                 * @NX .
                 * @{NX{IB
                 * @XebvB
                 * a) rF@rJn ` @rI
                 * b) F@JnE@RXg ` @I
                 * c) F@Jn ` @I
                 * AxTOB
                 * xAa)b)c)  "`"Ay@RXgB
                 * A@\
                 * Ea) r@ji~j\
                 * Er{rArx\
                 * E@RXg{@RXgARXg\
                 * @version 1.00
                 * @since 2009/05/19
                 * @author Masatoshi Tsuge
                 */
                class Magic : public GgafCore::GgafMainActor {
                    /** Vx */
                    int _new_level;
                    /** Ox */
                    int _last_level;
                
                
                public:
                    /**
                     * ex .
                     */
                    class LevelInfo {
                    public:
                        /** Yx@Kp(Jn`Itrue) */
                        bool _is_working;
                        /** @Ic */
                        magic_time _remaining_time_of_effect;
                        /** @ */
                        magic_time _time_of_effect;
                        /** @RXg  */
                        magic_point _keep_cost;
                        /** Ajp^[ */
                        int _pno;
          54 ->         LevelInfo() : _is_working(false),
                                      _remaining_time_of_effect(0),
                                      _keep_cost(0),
                                      _pno(0) {
                        }
                    };
                    GgafDx9Core::GgafDx9GeometricActor* _pCaster;
                    GgafDx9Core::GgafDx9GeometricActor* _pReceiver;
                
                    char* _name;
                    /** x */
                    int _level;
                    /** x */
                    int _max_level;
                    /** }WbN|Cgo[ */
                    GgafDx9LibStg::AmountGraph* _pMP;
                    MagicMeter* _pMagicMeter;
                
                    /** ex 0`MMETER_MAX_LEVEL */
                    LevelInfo _lvinfo[MMETER_MAX_LEVEL+1];
                    /** x@RXg 0`MMETER_MAX_LEVEL */
                    magic_point _interest_cost[MMETER_MAX_LEVEL+1];
                    /** xr 0`MMETER_MAX_LEVEL */
                    magic_time  _interest_time_of_casting[MMETER_MAX_LEVEL+1];
                    /** x 0`MMETER_MAX_LEVEL */
                    magic_time  _interest_time_of_invoking[MMETER_MAX_LEVEL+1];
                
                    /** {@KvRXg{P */
                    magic_point _cost_base;
                    /** {@rJn ` @rI{P  */
                    magic_time _time_of_casting_base;
                    /** {@Jn ` @I{P */
                    magic_time _time_of_invoking_base;
                    /** {@Jn ` @I{P  */
                    magic_time _time_of_effect_base;
                    /** {@RXg{P  */
                    magic_point _keep_cost_base;
                
                    float _fRate_cost;
                    float _fRate_time_of_casting;
                    float _fRate_time_of_invoking;
                    float _fRate_time_of_effecting;
                    float _fRate_keep_cost;
                
                    magic_time _time_of_next_state;
                
                //    /**  */
                //    int _state;
                    /** xAbv */
                    bool _is_working;
                
                    float _discount_rate;
                
                    float _rr;
                    float _velo_rr;
                
                public:
                    /**
                     *
                     * xxP(xQ)wB
                     * @param prm_name @
                     * @param prm_max_level {@x 1`MMETER_MAX_LEVEL
                     * @param prm_cost_base {@RXg
                     * @param prm_fRate_cost x@RXg 0.0`1.0 (1.0:xA0.8:xQA@RXgQ)
                     * @param prm_time_of_casting_base {@r
                     * @param prm_fRate_time_of_casting xr0.0`1.0 (1.0:x, 0.8:xQArQ)
                     * @param prm_time_of_invoking_base {@
                     * @param prm_fRate_time_of_invoking x0.0`1.0 (1.0:x, 0.8:xQAQ)
                     * @param prm_time_of_effect {@
                     * @param prm_fRate_keep_cost ex  0.0`1.0
                     *                            (1.0:x,
                     *                            (0.8:x1 prm_time_of_effect
                     *                                 x2 prm_time_of_effect * 0.8
                     *                                 x3 prm_time_of_effect * 0.8 * 0.8
                     *                                 x4 prm_time_of_effect * 0.8 * 0.8 * 0.8  )
                     * @param prm_keep_cost_base {@RXg
                     * @param prm_fRate_keep_cost exRXg  1.0`
                     *                            (1.0:xRXg,
                     *                            (1.2:x1 prm_keep_cost_base
                     *                                 x2 prm_keep_cost_base * 1.2
                     *                                 x3 prm_keep_cost_base * 1.2 * 1.2
                     *                                 x4 prm_keep_cost_base * 1.2 * 1.2 * 1.2  RXg)
                     * @return
                     */
                    Magic(const char* prm_name,
                          int   prm_max_level,
                          magic_point prm_cost_base, float prm_fRate_cost,
                          magic_time  prm_time_of_casting_base , float prm_fRate_time_of_casting,
                          magic_time  prm_time_of_invoking_base, float prm_fRate_time_of_invoking,
                          magic_time  prm_time_of_effect_base  , float prm_fRate_time_of_effecting,
                          magic_point prm_keep_cost_base       , float prm_fRate_keep_cost_base);
                
                
                //          GgafDx9Core::GgafDx9GeometricActor* prm_pCaster,
                //          GgafDx9Core::GgafDx9GeometricActor* prm_pReceiver);
                    void initialize() override;
                
                    void onReset() override {
                    }
                
                    void processBehavior() override;
                
                    void processJudgement() override {
                    }
                    void processDraw() override {
                    }
                    void processFinal()  override {
                    }
                    void onCatchEvent(UINT32 prm_no, void* prm_pSource) override {
                    }
                
                
                
                    void rollOpen();
                    void rollClose();
                
                    /**
                     * x@s
                     * @param prm_new_level
                     * @return
                     */
                    int chkExecuteAble(int prm_new_level);
                    /**
                     * s .
                     * @param prm_new_level
                     */
                    void execute(int prm_new_level);
                
                
                    /**
                     * rJnR[obN(PR[obN) .
                     */
                    virtual void processCastBegin(int prm_now_level, int prm_new_level) {};
                
                    /**
                     * rR[obN .
                     */
                    virtual void processCastingBehavior(int prm_now_level, int prm_new_level) {};
                
                    /**
                     * rIR[obN .
                     */
                    virtual void processCastFinish(int prm_now_level, int prm_new_level) {};
                
                    /**
                     * @JnR[obNBrLZsB(PR[obN) .
                     */
                    virtual void processInvokeBegin(int prm_now_level, int prm_new_level) {};
                
                    /**
                     * @R[obN .
                     */
                    virtual void processInvokeingBehavior(int prm_now_level, int prm_new_level) {};
                
                    virtual void processInvokeFinish(int prm_last_level, int prm_now_level) {};
                    /**
                     * @JnR[obN(PR[obN) .
                     */
                    virtual void processEffectBegin(int prm_now_level) {};
                
                    /**
                     * @R[obN .
                     */
                    virtual void processEffectingBehavior(int prm_now_level) {};
                
                    virtual void processEffectFinish(int prm_now_level) {};
                
                    /**
                     * @jR[obN .
                     */
                    virtual void processOnLevelDown(int prm_last_high_level, int prm_new_low_level) {};
                
                
                    /**
                     * @ .
                     */
                //    virtual void commit();
                    /**
                     * @LZ .
                     */
                    virtual void cancel();
                
                    virtual ~Magic();
                };
                
                }
                #endif /*MAGIC_H_*/


Top 10 Lines:

     Line      Count

       62         54

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       54   Total number of line executions
    54.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/system/magic/OptionMagic.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> OptionMagic::OptionMagic(const char* prm_name)
                : Magic(prm_name,
                    8,          //max_level
                    1000    , 0.9,   //{@RXg , x rate
                    60*2    , 0.9,   //{r   , x rate
                    60*1    , 0.9,   //{   , x rate
                    60*60*10, 0.0,   //{, ex
                    1.0     , 0.0    //{RXg , ex rate
                ) {
                //    |  0,   1,   2,   3 |
                //    |  4,   5,   6,   7 |
                //    |  8,   9,  10,  11 |
                //    | 12,  13,  14,  15 |
                //    | 16,  17,  18,  19 |
                //    | 20,  21,  22,  23 |
                //    | 24,  25,  26,  27 |
                //    | 28,  29,  30,  31 |
                //    | 32,  33,  34,  35 |
                //    | 36,  37,  38,  39 |
                //    | 40,  41,  42,  43 |
                //    | 44,  45,  46,  47 |
                //    | 48,  49,  50,  51 |
                //    | 52,  53,  54,  55 |
                //    | 56,  57,  58,  59 |
                //    | 60,  61,  62,  63 |
                    _lvinfo[0]._pno = 3;
                    _lvinfo[1]._pno = 61;
                    _lvinfo[2]._pno = 57;
                    _lvinfo[3]._pno = 53;
                    _lvinfo[4]._pno = 49;
                    _lvinfo[5]._pno = 45;
                    _lvinfo[6]._pno = 49;
                    _lvinfo[7]._pno = 45;
                    _lvinfo[8]._pno = 41;
                
                    _papEffect = NEW GgafDx9DrawableActor*[8];
                    for (int i = 0; i < 8; i++) {
                        _papEffect[i] = NEW EffectMagic001("EF");
                        _papEffect[i]->inactivateImmediately();
                        addSubGroup(_papEffect[i]);
                    }
                }
                void OptionMagic::processCastBegin(int prm_now_level, int prm_new_level) {
                    angle* paAngWay = NEW angle[prm_new_level-prm_now_level];
                    GgafDx9Util::getRadialAngle2D(0, prm_new_level-prm_now_level, paAngWay);
                    for (int i = prm_now_level; i < prm_new_level; i++) {
                        _papEffect[i]->locateAs(P_MYSHIP);
                        _papEffect[i]->_pKuroko->setRzRyMvAng(paAngWay[i], ANGLE90);
                        _papEffect[i]->_pKuroko->setMvVelo(2000);
                        _papEffect[i]->_pKuroko->setMvAcce(0);
                        _papEffect[i]->setAlpha(0.9);
                        _papEffect[i]->setScaleRate(2.0f);
                        _papEffect[i]->activate();
                    }
                    DELETEARR_IMPOSSIBLE_NULL(paAngWay);
                    _r_effect = 1;
                
                }
                
                void OptionMagic::processCastingBehavior(int prm_now_level, int prm_new_level){
                    _r_effect += 0.02;
                    for (int i = prm_now_level; i < prm_new_level; i++) {
                        _papEffect[i]->setScaleRate(_r_effect);
                    }
                }
                
                void OptionMagic::processInvokeBegin(int prm_now_level, int prm_new_level) {
                
                    for (int i = prm_now_level; i < prm_new_level; i++) {
                        _papEffect[i]->_pKuroko->setMvVelo(0);
                        _papEffect[i]->_pKuroko->setMvAcce(0);
                        _papEffect[i]->_pKuroko->orderGravitationVxyzMvSequence(
                               P_MYOPTIONCON->_X + P_MYOPTIONCON->_papMyOption[i]->_Xorg,
                               P_MYOPTIONCON->_Y + P_MYOPTIONCON->_papMyOption[i]->_Yorg,
                               P_MYOPTIONCON->_Z + P_MYOPTIONCON->_papMyOption[i]->_Zorg,
                               20000, 1000, 50000);
                //
                //        _papEffect[i]->_pKuroko->setMvVelo(1000);
                //        _papEffect[i]->_pKuroko->setMvAcce(100);
                //        _papEffect[i]->_pKuroko->orderTagettingMvAngSequence(P_MYOPTIONCON->_X + P_MYOPTIONCON->_papMyOption[i]->_Xorg,
                //                                                           P_MYOPTIONCON->_Y + P_MYOPTIONCON->_papMyOption[i]->_Yorg,
                //                                                           P_MYOPTIONCON->_Z + P_MYOPTIONCON->_papMyOption[i]->_Zorg,
                //                                                           3000,
                //                                                           0,TURN_CLOSE_TO,true);
                //
                //
                //
                //        _papEffect[i]->_pKuroko->forceMvVeloRange(P_MYOPTIONCON->_papMyOption[i]->_veloMv*5.0);
                ////                                SmoothMvVeloSequence2(2000, 0, _time_of_casting, true);
                    }
                
                }
                
                void OptionMagic::processInvokeingBehavior(int prm_now_level, int prm_new_level)  {
                //    if ((_time_of_invoking - _left_time_to_expire) < (ANGLE180/3000)) {
                //        return;
                //    }
                //    int targetX,targetY,targetZ;
                //    int ok = 0;
                //    for (int i = _old_level; i < _new_level; i++) {
                //        targetX = P_MYOPTIONCON->_X + P_MYOPTIONCON->_papMyOption[i]->_Xorg;
                //        targetY = P_MYOPTIONCON->_Y + P_MYOPTIONCON->_papMyOption[i]->_Yorg;
                //        targetZ = P_MYOPTIONCON->_Z + P_MYOPTIONCON->_papMyOption[i]->_Zorg;
                //        if (GgafUtil::abs(_papEffect[i]->_X - targetX) + GgafUtil::abs(_papEffect[i]->_Y - targetY) + GgafUtil::abs(_papEffect[i]->_Z - targetZ)/3  < GgafUtil::abs(P_MYOPTIONCON->_papMyOption[i]->_veloMv)*5) {
                //            ok++;
                //            _papEffect[i]->_pKuroko->setMvVelo(500);
                //        }
                //        _papEffect[i]->_pKuroko->orderTagettingMvAngSequence(targetX,
                //                                                           targetY,
                //                                                           targetZ,
                //                                                           40000,
                //                                                           0,TURN_CLOSE_TO,true);
                //    }
                //    if (ok == (_new_level - _old_level)) {
                //        effect();
                //    }
                }
                
                void OptionMagic::processCastFinish(int prm_now_level, int prm_new_level) {
                    //IvVLB
                    //(processEffectBegin A option xbehave()WvZj
                    P_MYOPTIONCON->setNumOption(prm_new_level);
                    P_MYOPTIONCON->adjustDefaltAngPosition(60);
                    for (int i = prm_now_level; i < prm_new_level; i++) {
                        _papEffect[i]->inactivateDelay(120);
                    }
                }
                
                void OptionMagic::processEffectBegin(int prm_now_level)  {
                    _r_effect = 1.0f;
                    for (int i = 0; i < prm_now_level; i++) {
                        if (_papEffect[i]->isActiveActor()) {
                            _papEffect[i]->_pKuroko->_gravitation_mv_seq_pActor_target = P_MYOPTIONCON->_papMyOption[i];
                        }
                    }
                
                }
                
                void OptionMagic::processEffectingBehavior(int prm_now_level) {
                //    _r_effect -= 0.01f;
                //    for (int i = _old_level; i < _new_level; i++) {
                //        _papEffect[i]->setAlpha(_r_effect);
                //        _papEffect[i]->setScaleRate(3.0f+(1.0f-_r_effect)*4.0);
                //        _papEffect[i]->locateAs(P_MYOPTIONCON->_papMyOption[i]);
                //        P_MYOPTIONCON->_papMyOption[i]->setAlpha(1.0f-_r_effect);
                //    }
                //    if (_r_effect < 0) {
                //        for (int i = _old_level; i < _new_level; i++) {
                //            _papEffect[i]->inactivate();
                //            P_MYOPTIONCON->_papMyOption[i]->setAlpha(1.0);
                //        }
                //    }
                }
                
                void OptionMagic::processOnLevelDown(int prm_last_high_level, int prm_new_low_level) {
                    //x_EA
                    P_MYOPTIONCON->setNumOption(prm_new_low_level);
                    P_MYOPTIONCON->adjustDefaltAngPosition(60);
                }
                
           2 -> OptionMagic::~OptionMagic() {
                    DELETEARR_IMPOSSIBLE_NULL(_papEffect);
                
                }


Top 10 Lines:

     Line      Count

      168          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/system/magic/SpeedMagic.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> SpeedMagic::SpeedMagic(const char* prm_name)
                : Magic(prm_name,
                    5,          //max_level
                    1000*4  , 0.9,   //{@RXg , x rate
                    60*3    , 0.9,   //{r   , x rate
                    60*2    , 0.9,   //{   , x rate
                    60*60*10,    0.0,   //{, ex
                    1.0     , 0.0    //{RXg , ex rate
                ) {
                    //    |  0,   1,   2,   3 |
                    //    |  4,   5,   6,   7 |
                    //    |  8,   9,  10,  11 |
                    //    | 12,  13,  14,  15 |
                    //    | 16,  17,  18,  19 |
                    //    | 20,  21,  22,  23 |
                    //    | 24,  25,  26,  27 |
                    //    | 28,  29,  30,  31 |
                    //    | 32,  33,  34,  35 |
                    //    | 36,  37,  38,  39 |
                    //    | 40,  41,  42,  43 |
                    //    | 44,  45,  46,  47 |
                    //    | 48,  49,  50,  51 |
                    //    | 52,  53,  54,  55 |
                    //    | 56,  57,  58,  59 |
                    //    | 60,  61,  62,  63 |
                    _lvinfo[0]._pno = 3;
                    _lvinfo[1]._pno = 60;
                    _lvinfo[2]._pno = 56;
                    _lvinfo[3]._pno = 52;
                    _lvinfo[4]._pno = 48;
                    _lvinfo[5]._pno = 44;
                }
                
           2 -> SpeedMagic::~SpeedMagic() {
                }


Top 10 Lines:

     Line      Count

       41          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/system/magic/TorpedoMagic.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> TorpedoMagic::TorpedoMagic(const char* prm_name)
                : Magic(prm_name,
                            2,          //max_level
                            1000*4  , 0.9,   //{@RXg , x rate
                            60*3    , 0.9,   //{r   , x rate
                            60*2    , 0.9,   //{   , x rate
                            60*60*10,    0.0,   //{, ex
                            1.0     , 0.0    //{RXg , ex rate
                        ) {
                    //    |  0,   1,   2,   3 |
                    //    |  4,   5,   6,   7 |
                    //    |  8,   9,  10,  11 |
                    //    | 12,  13,  14,  15 |
                    //    | 16,  17,  18,  19 |
                    //    | 20,  21,  22,  23 |
                    //    | 24,  25,  26,  27 |
                    //    | 28,  29,  30,  31 |
                    //    | 32,  33,  34,  35 |
                    //    | 36,  37,  38,  39 |
                    //    | 40,  41,  42,  43 |
                    //    | 44,  45,  46,  47 |
                    //    | 48,  49,  50,  51 |
                    //    | 52,  53,  54,  55 |
                    //    | 56,  57,  58,  59 |
                    //    | 60,  61,  62,  63 |
                    _lvinfo[0]._pno = 3;
                    _lvinfo[1]._pno = 36;
                    _lvinfo[2]._pno = 32;
                }
                
           2 -> TorpedoMagic::~TorpedoMagic() {
                }


Top 10 Lines:

     Line      Count

       38          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/system/magic/TractorMagic.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> TractorMagic::TractorMagic(const char* prm_name)
                        : Magic(prm_name,
                            2,          //max_level
                            1000*4  , 0.9,   //{@RXg , x rate
                            60*3    , 0.9,   //{r   , x rate
                            60*2    , 0.9,   //{   , x rate
                            60*60*10,    0.0,   //{, ex
                            1.0     , 0.0    //{RXg , ex rate
                        ) {
                    //    |  0,   1,   2,   3 |
                    //    |  4,   5,   6,   7 |
                    //    |  8,   9,  10,  11 |
                    //    | 12,  13,  14,  15 |
                    //    | 16,  17,  18,  19 |
                    //    | 20,  21,  22,  23 |
                    //    | 24,  25,  26,  27 |
                    //    | 28,  29,  30,  31 |
                    //    | 32,  33,  34,  35 |
                    //    | 36,  37,  38,  39 |
                    //    | 40,  41,  42,  43 |
                    //    | 44,  45,  46,  47 |
                    //    | 48,  49,  50,  51 |
                    //    | 52,  53,  54,  55 |
                    //    | 56,  57,  58,  59 |
                    //    | 60,  61,  62,  63 |
                    _lvinfo[0]._pno = 3;
                    _lvinfo[1]._pno = 28;
                    _lvinfo[2]._pno = 24;
                }
                
           2 -> TractorMagic::~TractorMagic() {
                }


Top 10 Lines:

     Line      Count

       38          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/title/Cursor001.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
                
           1 -> Cursor001::Cursor001(const char* prm_name) : DefaultBoardActor(prm_name, "LockOn001") {
                    _class_name = "Cursor001";
                }
                void Cursor001::initialize() {
                }
                
                void Cursor001::onActive() {
                }
                
                void Cursor001::processBehavior() {
                }
                
                void Cursor001::processJudgement() {
                }
                
                
           2 -> Cursor001::~Cursor001() {
                }


Top 10 Lines:

     Line      Count

       25          2
        9          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/actor/title/TitleBoard.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
                
           2 -> TitleBoard::TitleBoard(const char* prm_name) : DefaultBoardSetActor(prm_name, "title") {
                    _class_name = "TitleBoard";
                    //_z = 0.9999999f;  //w i0 <= _z < 1.0jZ=(0`+1)
                    useProgress(10);
                }
                void TitleBoard::initialize() {
                }
                
                void TitleBoard::onActive() {
                //    _pPrg->change(TITLEBOARD_PROG_INIT);
                }
                
                void TitleBoard::processBehavior() {
                //    if (_pPrg->get() == TITLEBOARD_PROG_INIT) {
                //        _pPrg->change(TITLEBOARD_PROG_ENTRANCE);
                //    }
                //
                //    //^Cg\ANV TITLEBOARD_PROG_ENTRANCE 
                //    if (_pPrg->wasChangedTo(TITLEBOARD_PROG_ENTRANCE)) {
                //        locate(200, 1000);
                //    }
                //    if (_pPrg->get() == TITLEBOARD_PROG_ENTRANCE) {
                //        _y -= 1;
                //        if (_y <= 150) {
                //            _pPrg->change(TITLEBOARD_PROG_DISP);
                //        }
                //    }
                //    if (_pPrg->wasChangedFrom(TITLEBOARD_PROG_ENTRANCE)) {
                //    }
                //
                //    //^Cg\~ TITLEBOARD_PROG_DISP 
                //    if (_pPrg->wasChangedTo(TITLEBOARD_PROG_DISP)) {
                //        locate(200, 150);
                //    }
                //    if (_pPrg->get() == TITLEBOARD_PROG_DISP) {
                //    }
                //    if (_pPrg->wasChangedFrom(TITLEBOARD_PROG_DISP)) {
                //    }
                
                
                }
                
                void TitleBoard::processJudgement() {
                }
                
                
           4 -> TitleBoard::~TitleBoard() {
                }


Top 10 Lines:

     Line      Count

       55          4
        9          2

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        6   Total number of line executions
     2.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/manager/CameraWorkerConnection.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           3 -> CameraWorkerConnection::CameraWorkerConnection(char* prm_idstr, CameraWorker* prm_pResource) :
                    GgafResourceConnection<CameraWorker> (prm_idstr, prm_pResource) {
                }
                
                void CameraWorkerConnection::processReleaseResource(CameraWorker* prm_pResource) {
                    prm_pResource->end();
                }
                


Top 10 Lines:

     Line      Count

        8          3

Execution Summary:

        2   Executable lines in this file
        1   Lines executed
    50.00   Percent of the file executed

        3   Total number of line executions
     1.50   Average executions per line


*** File C:/cygwin/workspace/_git_repos/MyStg2nd/src/gecchi/manager/CameraWorkerConnection.h:
                #ifndef CAMERAWORKERCONNECTION_H_
                #define CAMERAWORKERCONNECTION_H_
                namespace MyStg2nd {
                
                /**
                 * CameraWorkerRlNV.
                 * @version 1.00
                 * @since 2009/01/30
                 * @author Masatoshi Tsuge
                 */
                class CameraWorkerConnection : public GgafCore::GgafResourceConnection<CameraWorker> {
                
                public:
                
                    /**
                     * RXgN^<BR>
                     * @param prm_idstr 
                     * @param prm_pCameraWorker fBXpb`[
                     */
                    CameraWorkerConnection(char* prm_idstr, CameraWorker* prm_pCameraWorker);
                
                    void processReleaseResource(CameraWorker* prm_pResource);
                
           6 ->     virtual ~CameraWorkerConnection() {
                    }
                };
                
                }
                #endif /*DISPATCHERCONNECTION_H_*/


Top 10 Lines:

     Line      Count

       24          6

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        6   Total number of line executions
     6.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/manager/CameraWorkerManager.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> CameraWorkerManager::CameraWorkerManager(const char* prm_manager_name) :
                    GgafResourceManager<CameraWorker> (prm_manager_name) {
                }
                
                CameraWorker* CameraWorkerManager::processCreateResource(char* prm_idstr, void* prm_p) {
                    CameraWorker* pResource = NULL;
                
                    if (GgafUtil::strcmp_ascii("DefaultCamWorker", prm_idstr) == 0) {
                        pResource = NEW DefaultCamWorker("DefaultCamWorker");
                    }
                
                    if (GgafUtil::strcmp_ascii("VamSysCamWorker", prm_idstr) == 0) {
                        pResource = NEW VamSysCamWorker("VamSysCamWorker");
                    }
                
                    if (GgafUtil::strcmp_ascii("PauseCamWorker", prm_idstr) == 0) {
                        pResource = NEW PauseCamWorker("PauseCamWorker");
                    }
                
                    if (GgafUtil::strcmp_ascii("TestCamWorker", prm_idstr) == 0) {
                        pResource = NEW TestCamWorker("TestCamWorker");
                    }
                
                    if (GgafUtil::strcmp_ascii("MyShipDivingCamWorker", prm_idstr) == 0) {
                        pResource = NEW MyShipDivingCamWorker("MyShipDivingCamWorker");
                    }
                
                    if (pResource == NULL) {
                        throwGgafCriticalException("CameraWorkerManager::processCreateResource("<<prm_idstr<<") zOIDBCameraWorkerB");
                    } else {
                        pResource->inactivateImmediately();
                        return pResource;
                    }
                }
                
                GgafResourceConnection<CameraWorker>* CameraWorkerManager::processCreateConnection(char* prm_idstr, CameraWorker* prm_pResource) {
                    TRACE3(" CameraWorkerManager::processCreateConnection "<<prm_idstr<<" JnB");
                    CameraWorkerConnection* pConnection = NEW CameraWorkerConnection(prm_idstr, prm_pResource);
                    TRACE3(" CameraWorkerManager::processCreateConnection "<<prm_idstr<<" IB");
                    return pConnection;
                }


Top 10 Lines:

     Line      Count

        8          1

Execution Summary:

        2   Executable lines in this file
        1   Lines executed
    50.00   Percent of the file executed

        1   Total number of line executions
     0.50   Average executions per line


*** File C:/cygwin/workspace/_git_repos/MyStg2nd/src/gecchi/manager/CameraWorkerManager.h:
                #ifndef CAMERAWORKERMANAGER_H_
                #define CAMERAWORKERMANAGER_H_
                namespace MyStg2nd {
                
                /**
                 * CameraWorker NX .
                 *  CameraWorker IuWFNgo^AgB
                 * @version 1.00
                 * @since 2008/09/08
                 * @author Masatoshi Tsuge
                 */
                class CameraWorkerManager : public GgafCore::GgafResourceManager<CameraWorker> {
                
                public:
                
                    /**
                     * RXgN^
                     * @param prm_manager_name }l[W(eK{)
                     */
                    CameraWorkerManager(const char* prm_manager_name);
                
                    /**
                     * CameraWorker B
                     * {AvCameraWorker RRWvB
                     * @param prm_idstr
                     * @return CameraWorker
                     */
                    CameraWorker* processCreateResource(char* prm_idstr, void* prm_p);
                
                    GgafCore::GgafResourceConnection<CameraWorker>* processCreateConnection(char* prm_idstr, CameraWorker* prm_pResource);
                
           2 ->     virtual ~CameraWorkerManager() {
                    }
                };
                
                }
                #endif /*GGAFDX9BGMMANAGER_H_*/


Top 10 Lines:

     Line      Count

       32          2

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     2.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/manager/DispatcherConnection.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           2 -> DispatcherConnection::DispatcherConnection(char* prm_idstr, GgafActorDispatcher* prm_pResource) :
                    GgafResourceConnection<GgafActorDispatcher> (prm_idstr, prm_pResource) {
                }
                
                void DispatcherConnection::processReleaseResource(GgafActorDispatcher* prm_pResource) {
                    _TRACE_("DispatcherConnection::processReleaseResourceJ(close()R\)");
                    prm_pResource->end(); //GgafActorDispatcherS~s
                    //TODO:
                    //EnemyAstraea::~EnemyAstraea() {
                    //    _pDispatcherCon_DpEnemyAstraeaLaserChip->close();
                    //Rg
                    // DELETE_IMPOSSIBLE_NULL(prm_pResource);
                }
                


Top 10 Lines:

     Line      Count

        8          2

Execution Summary:

        2   Executable lines in this file
        1   Lines executed
    50.00   Percent of the file executed

        2   Total number of line executions
     1.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/MyStg2nd/src/gecchi/manager/DispatcherConnection.h:
                #ifndef DISPATCHERCONNECTION_H_
                #define DISPATCHERCONNECTION_H_
                namespace MyStg2nd {
                
                /**
                 * DispatcherRlNV.
                 * @version 1.00
                 * @since 2009/01/30
                 * @author Masatoshi Tsuge
                 */
                class DispatcherConnection : public GgafCore::GgafResourceConnection<GgafCore::GgafActorDispatcher> {
                
                public:
                
                    /**
                     * RXgN^<BR>
                     * @param prm_idstr 
                     * @param prm_pDispatcher fBXpb`[
                     */
                    DispatcherConnection(char* prm_idstr, GgafCore::GgafActorDispatcher* prm_pDispatcher);
                
                    void processReleaseResource(GgafCore::GgafActorDispatcher* prm_pResource);
                
           4 ->     virtual ~DispatcherConnection() {
                    }
                };
                
                }
                #endif /*DISPATCHERCONNECTION_H_*/


Top 10 Lines:

     Line      Count

       24          4

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        4   Total number of line executions
     4.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/manager/DispatcherManager.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> DispatcherManager::DispatcherManager(const char* prm_manager_name) :
                    GgafResourceManager<GgafActorDispatcher> (prm_manager_name) {
                }
                
                GgafActorDispatcher* DispatcherManager::processCreateResource(char* prm_idstr, void* prm_p) {
                    GgafActorDispatcher* pResource = NULL;
                
                    if (GgafUtil::strcmp_ascii("DpCon_Shot001", prm_idstr) == 0) {
                        pResource = NEW GgafActorDispatcher("DP_Shot001_Stock");
                        Shot001* pShot001;
                        for (int i = 0; i < 100; i++) { //XgbN100
                            pShot001 = NEW Shot001("Shot001");
                            pShot001->inactivateImmediately();
                            pResource->addSubLast(pShot001);
                        }
                        P_COMMON_SCENE->getLordActor()->addSubGroup(pResource); //addSubGroupij
                    }
                
                    if (GgafUtil::strcmp_ascii("DpCon_Shot002", prm_idstr) == 0) {
                        pResource = NEW GgafActorDispatcher("DP_Shot002_Stock");
                        Shot002* pShot002;
                        for (int i = 0; i < 100; i++) { //XgbN100
                            pShot002 = NEW Shot002("Shot002");
                            pShot002->inactivateImmediately();
                            pResource->addSubLast(pShot002);
                        }
                        P_COMMON_SCENE->getLordActor()->addSubGroup(pResource);
                    }
                
                    if (GgafUtil::strcmp_ascii("DpCon_Shot003", prm_idstr) == 0) {
                        pResource = NEW GgafActorDispatcher("DP_Shot003_Stock");
                        Shot003* pShot003;
                        for (int i = 0; i < 300; i++) {
                            pShot003 = NEW Shot003("Shot003");
                            pShot003->inactivateImmediately();
                            pResource->addSubLast(pShot003);
                            if (i % 20 == 0) { Sleep(1); }
                        }
                        P_COMMON_SCENE->getLordActor()->addSubGroup(pResource);
                    }
                
                    if (GgafUtil::strcmp_ascii("DpCon_Shot004", prm_idstr) == 0) {
                        pResource = NEW GgafActorDispatcher("DP_Shot004_Stock");
                        Shot004* pShot004;
                        for (int i = 0; i < 800; i++) {
                            pShot004 = NEW Shot004("Shot004");
                            pShot004->inactivateImmediately();
                            pResource->addSubLast(pShot004);
                            if (i % 20 == 0) { Sleep(1); }
                        }
                        P_COMMON_SCENE->getLordActor()->addSubGroup(pResource);
                    }
                
                    if (GgafUtil::strcmp_ascii("DpCon_EffRefraction001", prm_idstr) == 0) {
                        pResource = NEW GgafActorDispatcher("DP_EffRefraction001");
                        EffectLaserRefraction001* p;
                        for (int i = 0; i < 100; i++) {
                            p = NEW EffectLaserRefraction001("EffRefraction001");
                            p->inactivateImmediately();
                            pResource->addSubLast(p);
                        }
                        P_COMMON_SCENE->getLordActor()->addSubGroup(pResource);
                    }
                
                    if (GgafUtil::strcmp_ascii("DpCon_DpEnemyAstraeaLaserChip001", prm_idstr) == 0) {
                        pResource = NEW GgafActorDispatcher("LCDD");
                        LaserChipDispatcher* pLaserChipDispatcher;
                        EnemyAstraeaLaserChip001* pChip;
                        for (int nLaser = 0; nLaser < 27; nLaser++) {
                            stringstream name;
                            name <<  "LaserChipDispatcher["<<nLaser<<"]";
                            pLaserChipDispatcher = NEW LaserChipDispatcher(name.str().c_str());
                            for (int nChip = 0; nChip < 50; nChip++) {
                                stringstream name;
                                name <<  "EnemyAstraeaLaserChip001["<<nLaser<<"]["<<nChip<<"]";
                                pChip = NEW EnemyAstraeaLaserChip001(name.str().c_str());
                //                pChip->config(50, 10, 5, (GgafActorDispatcher*)prm_p);
                                pChip->inactivateImmediately();
                                pLaserChipDispatcher->addSubLast(pChip);
                            }
                            pLaserChipDispatcher->inactivateImmediately();
                            pResource->addSubLast(pLaserChipDispatcher);
                        }
                        P_COMMON_SCENE->getLordActor()->addSubGroup(pResource);
                    }
                
                
                
                    if (GgafUtil::strcmp_ascii("DpCon_DpEnemyAstraeaLaserChip002", prm_idstr) == 0) {
                        pResource = NEW GgafActorDispatcher("LCDD");
                        LaserChipDispatcher* pLaserChipDispatcher;
                        EnemyAstraeaLaserChip002* pChip;
                        for (int nLaser = 0; nLaser < 27; nLaser++) {
                            stringstream name;
                            name <<  "LaserChipDispatcher["<<nLaser<<"]";
                            pLaserChipDispatcher = NEW LaserChipDispatcher(name.str().c_str());
                            for (int nChip = 0; nChip < 50; nChip++) {
                                stringstream name;
                                name <<  "EnemyAstraeaLaserChip002["<<nLaser<<"]["<<nChip<<"]";
                                pChip = NEW EnemyAstraeaLaserChip002(name.str().c_str());
                                pChip->config(50, 10, 5, (GgafActorDispatcher*)prm_p);
                                pChip->inactivateImmediately();
                                pLaserChipDispatcher->addSubLast(pChip);
                            }
                            pLaserChipDispatcher->inactivateImmediately();
                            pResource->addSubLast(pLaserChipDispatcher);
                        }
                        P_COMMON_SCENE->getLordActor()->addSubGroup(pResource);
                    }
                
                
                
                    //GJ[u[U[01gpBc
                    /*
                    if (GgafUtil::strcmp_ascii("DpCon_EneCurveLaser001Dp", prm_idstr) == 0) {
                        pResource = NEW LaserChipDispatcherDispatcher("DPDP_EneCurveLaser001");
                        LaserChipDispatcher* pLaserChipDispatcher;
                        EnemyCurveLaserChip001* pChip;
                        for (int set = 0; set < 20; set++) {
                            stringstream name;
                            name <<  "EneCurveLaser001Dp["<<set<<"]";
                            pLaserChipDispatcher = NEW LaserChipDispatcher(name.str().c_str());
                            for (int n = 0; n < 50; n++) {
                                stringstream name;
                                name <<  "EneCurveLaser001["<<set<<"]["<<n<<"]";
                                pChip = NEW EnemyCurveLaserChip001(name.str().c_str());
                                pChip->inactivateImmediately();
                                pLaserChipDispatcher->addSubLast(pChip);
                                if (n % 20 == 0) { Sleep(1); }
                            }
                            pLaserChipDispatcher->inactivateImmediately();
                            pResource->addSubLast(pLaserChipDispatcher);
                
                        }
                        P_COMMON_SCENE->getLordActor()->addSubGroup(pResource);
                    }
                */
                
                    if (pResource == NULL) {
                        throwGgafCriticalException("DispatcherManager::processCreateResource("<<prm_idstr<<") zOIDBDispatcherB");
                    } else {
                        return pResource;
                    }
                }
                
                GgafResourceConnection<GgafActorDispatcher>* DispatcherManager::processCreateConnection(char* prm_idstr, GgafActorDispatcher* prm_pResource) {
                    TRACE3(" DispatcherManager::processCreateConnection "<<prm_idstr<<" JnB");
                    DispatcherConnection* pConnection = NEW DispatcherConnection(prm_idstr, prm_pResource);
                    TRACE3(" DispatcherManager::processCreateConnection "<<prm_idstr<<" IB");
                    return pConnection;
                }


Top 10 Lines:

     Line      Count

        8          1

Execution Summary:

        2   Executable lines in this file
        1   Lines executed
    50.00   Percent of the file executed

        1   Total number of line executions
     0.50   Average executions per line


*** File C:/cygwin/workspace/_git_repos/MyStg2nd/src/gecchi/manager/DispatcherManager.h:
                #ifndef DISPATCHERMANAGER_H_
                #define DISPATCHERMANAGER_H_
                namespace MyStg2nd {
                
                /**
                 * Dispatcher NX .
                 *  Dispatcher IuWFNgo^AgB
                 * @version 1.00
                 * @since 2008/09/08
                 * @author Masatoshi Tsuge
                 */
                class DispatcherManager : public GgafCore::GgafResourceManager<GgafCore::GgafActorDispatcher> {
                
                public:
                
                    /**
                     * RXgN^
                     * @param prm_manager_name }l[W(eK{)
                     */
                    DispatcherManager(const char* prm_manager_name);
                
                    /**
                     * fBXpb`[B
                     * {AvfBXpb`[RRWvB
                     * @param prm_idstr
                     * @return fBXpb`[
                     */
                    GgafCore::GgafActorDispatcher* processCreateResource(char* prm_idstr, void* prm_p);
                
                    GgafCore::GgafResourceConnection<GgafCore::GgafActorDispatcher>* processCreateConnection(char* prm_idstr, GgafCore::GgafActorDispatcher* prm_pResource);
                
           2 ->     virtual ~DispatcherManager() {
                    }
                };
                
                }
                #endif /*GGAFDX9BGMMANAGER_H_*/


Top 10 Lines:

     Line      Count

       32          2

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     2.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/manager/Spline3DManager.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> Spline3DManager::Spline3DManager(const char* prm_manager_name) :
                    GgafResourceManager<GgafDx9Core::GgafDx9Spline3D> (prm_manager_name) {
                }
                
                GgafDx9Spline3D* Spline3DManager::processCreateResource(char* prm_idstr, void* prm_p) {
                    GgafDx9Spline3D* pResource = NULL;
                
                    if (GgafUtil::strcmp_ascii("SpCon_001", prm_idstr) == 0) {
                        double p[][3] = { //        X ,        Y ,       Z
                                          { -1024000 ,  -300000 ,  680000 },
                                          {  -800000 ,   300000 ,  480000 },
                                          {  -200000 ,  -300000 ,  200000 },
                                          {   200000 ,   300000 ,  100000 },
                                          {   400000 ,        0 ,       0 },
                                          {   300000 ,        0 ,       0 },
                                          {   200000 ,   200000 ,       0 },
                                          {   100000 ,        0 ,  200000 },
                                          {        0 ,  -200000 ,       0 },
                                          {  -100000 ,        0 , -200000 },
                                          {   300000 ,        0 ,       0 },
                                          {        0 ,   300000 ,       0 },
                                          {        0 ,        0 ,  300000 },
                                          {  -300000 ,        0 ,       0 },
                                          {        0 ,  -300000 ,       0 },
                                          {        0 ,        0 , -300000 },
                                          {  -800000 ,        0 ,       0 }
                                        };
                        pResource = NEW GgafDx9Spline3D(p, 17, 0.2);//x 0.2
                    }
                
                    if (GgafUtil::strcmp_ascii("SpCon_002_01", prm_idstr) == 0) {
                        //
                        double p[][3] = { //           X  ,                       Y ,                         Z
                           { MyShip::_lim_behaind - 500000.0 ,                    0.0 ,  MyShip::_lim_zleft * 0.8 },
                           {                       3000000 , MyShip::_lim_top * 0.2 ,                       0.0 },
                           {                       3000000 , MyShip::_lim_top * 0.5 , MyShip::_lim_zright * 0.3 },
                           {                       3000000 , MyShip::_lim_top * 1.0 ,                       0.0 },
                           {                       3000000 ,                    0.0 ,                       0.0 }
                        };
                        pResource = NEW GgafDx9Spline3D(p, 5, 0.2); //x 0.2
                    }
                
                    if (GgafUtil::strcmp_ascii("SpCon_002_02", prm_idstr) == 0) {
                        //
                        double p[][3] = { //           X  ,                          Y ,                         Z
                           { MyShip::_lim_behaind - 500000.0 ,                       0.0 , MyShip::_lim_zright * 0.8 },
                           {      MyShip::_lim_front * 1.5 , MyShip::_lim_bottom * 0.2 ,                       0.0 },
                           {      MyShip::_lim_front * 2.5 , MyShip::_lim_bottom * 0.5 ,  MyShip::_lim_zleft * 0.3 },
                           {      MyShip::_lim_front * 2.2 , MyShip::_lim_bottom * 1.0 ,                       0.0 },
                           {      MyShip::_lim_front * 2.0 ,                       0.0 ,                       0.0 }
                        };
                        pResource = NEW GgafDx9Spline3D(p, 5, 0.2); //x 0.2
                    }
                
                    if (GgafUtil::strcmp_ascii("SpCon_HAN", prm_idstr) == 0) {
                        double p[][3] = { //     X  ,       Y ,       Z
                                          {  200000 ,     0.0 ,     0.0 },
                                          {  250000 ,  200000 ,     0.0 },
                                          {  300000 ,     0.0 ,  200000 },
                                          {  350000 , -200000 ,     0.0 },
                                          {  400000 ,     0.0 , -200000 },
                                          {  450000 ,  200000 ,     0.0 },
                                          {  500000 ,     0.0 ,  200000 },
                                          {  550000 , -200000 ,     0.0 },
                                          {  600000 ,     0.0 , -200000 },
                                          {  750000 ,  200000 ,     0.0 },
                                          {  800000 ,     0.0 ,  200000 },
                                          {  850000 , -200000 ,     0.0 },
                                          {  900000 ,     0.0 , -200000 },
                                          {  950000 ,  200000 ,     0.0 },
                                          { 1000000 ,     0.0 ,  200000 },
                                          { 1050000 , -200000 ,     0.0 },
                                          { 1200000 ,     0.0 , -200000 },
                                          {     0.0 ,     0.0 ,     0.0 }
                        };
                        pResource = NEW GgafDx9Spline3D(p, 18, 0.2); //x 0.2
                    }
                
                    if (GgafUtil::strcmp_ascii("SpCon_Pallas01", prm_idstr) == 0) {
                        double p[][3] = { //     X  ,       Y ,       Z
                                          { -1.724577 ,  0.000000 ,  0.000000 },
                                          { -0.964337 , -0.088378 , -0.344892 },
                                          { -0.501305 , -0.055518 , -0.298879 },
                                          { -0.179336 , -0.031628 , -0.240141 },
                                          {  0.123544 , -0.016126 , -0.165195 },
                                          {  0.362343 ,  0.000000 ,  0.000000 },
                                          {  0.545634 ,  0.038709 ,  0.176104 },
                                          {  0.704048 ,  0.173192 ,  0.372772 },
                                          {  0.864812 ,  0.444651 ,  0.516556 },
                                          {  1.055714 ,  0.626849 ,  0.569336 },
                                          {  1.246407 ,  0.655359 ,  0.547772 },
                                          {  1.365876 ,  0.590994 ,  0.453279 },
                                          {  1.388259 ,  0.465998 ,  0.332581 },
                                          {  1.362117 ,  0.328636 ,  0.211183 },
                                          {  1.242692 ,  0.226675 ,  0.087900 },
                                          {  1.064405 ,  0.202917 ,  0.000000 },
                                          {  0.920421 ,  0.202917 ,  0.000000 }
                        };
                        for (int i = 0; i < 17; i++) {
                            //X
                            p[i][0] = p[i][0] * MyShip::_lim_front;
                            //Y
                            p[i][1] = p[i][1] * MyShip::_lim_top;
                            //Z
                            p[i][2] = p[i][2] * MyShip::_lim_zleft;
                
                        }
                        pResource = NEW GgafDx9Spline3D(p, 17, 0.2); //x 0.2
                    }
                
                    return pResource;
                }
                
                //MyShip::_lim_top     = GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT)*5*LEN_UNIT / 2;      //T
                //MyShip::_lim_bottom  = -(GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT)*5*LEN_UNIT / 2);
                //MyShip::_lim_front   = GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)*4*LEN_UNIT / 2 ;    //OS
                //MyShip::_lim_behaind = -(GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)*0.5*LEN_UNIT / 2 );
                //MyShip::_lim_zleft   = GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)*5*LEN_UNIT / 2;       //OT
                //MyShip::_lim_zright  = -(GGAFDX9_PROPERTY(GAME_BUFFER_WIDTH)*5*LEN_UNIT / 2);
                //GgafDx9Universe::_X_goneLeft   = GgafDx9Camera::_X_ScreenLeft - 3000*LEN_UNIT; //3000pxIuWFNgz
                //GgafDx9Universe::_X_goneRight  = +_pCamera->_zf*PX_UNIT*LEN_UNIT + (abs(_pCamera->_cameraZ)*PX_UNIT*LEN_UNIT);
                //GgafDx9Universe::_Y_goneTop    = +_pCamera->_zf*PX_UNIT*LEN_UNIT + (abs(_pCamera->_cameraZ)*PX_UNIT*LEN_UNIT);
                //GgafDx9Universe::_Y_goneBottom = -_pCamera->_zf*PX_UNIT*LEN_UNIT - (abs(_pCamera->_cameraZ)*PX_UNIT*LEN_UNIT);
                //GgafDx9Universe::_Z_goneFar   = +_pCamera->_zf*PX_UNIT*LEN_UNIT + (abs(_pCamera->_cameraZ)*PX_UNIT*LEN_UNIT);
                //GgafDx9Universe::_Z_goneNear  = -_pCamera->_zf*PX_UNIT*LEN_UNIT - (abs(_pCamera->_cameraZ)*PX_UNIT*LEN_UNIT);
                
                GgafResourceConnection<GgafDx9Core::GgafDx9Spline3D>* Spline3DManager::processCreateConnection(char* prm_idstr, GgafDx9Spline3D* prm_pResource) {
                    TRACE3(" Spline3DManager::processCreateConnection "<<prm_idstr<<" JnB");
                    Spline3DConnection* pConnection = NEW Spline3DConnection(prm_idstr, prm_pResource);
                    TRACE3(" Spline3DManager::processCreateConnection "<<prm_idstr<<" IB");
                    return pConnection;
                }
                


Top 10 Lines:

     Line      Count

        8          1

Execution Summary:

        2   Executable lines in this file
        1   Lines executed
    50.00   Percent of the file executed

        1   Total number of line executions
     0.50   Average executions per line


*** File C:/cygwin/workspace/_git_repos/MyStg2nd/src/gecchi/manager/Spline3DManager.h:
                #ifndef SPLINE3DMANAGER_H_
                #define SPLINE3DMANAGER_H_
                namespace MyStg2nd {
                
                /**
                 * Spline NX .
                 *  GgafDx9Spline3D IuWFNgo^AgB
                 * @version 1.00
                 * @since 2010/05/31
                 * @author Masatoshi Tsuge
                 */
                class Spline3DManager : public GgafCore::GgafResourceManager<GgafDx9Core::GgafDx9Spline3D> {
                
                public:
                
                    /**
                     * RXgN^
                     * @param prm_manager_name }l[W(eK{)
                     */
                    Spline3DManager(const char* prm_manager_name);
                
                    GgafDx9Core::GgafDx9Spline3D* processCreateResource(char* prm_idstr, void* prm_p);
                
                    GgafCore::GgafResourceConnection<GgafDx9Core::GgafDx9Spline3D>* processCreateConnection(char* prm_idstr, GgafDx9Core::GgafDx9Spline3D* prm_pResource);
                
                
           2 ->     virtual ~Spline3DManager() {
                    }
                };
                
                }
                #endif /*SPLINE3DMANAGER_H_*/


Top 10 Lines:

     Line      Count

       27          2

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     2.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafCore/include/jp/ggaf/core/GgafResourceConnection.hpp:
                #ifndef GGAFRESOURCECONNECTION_H_
                #define GGAFRESOURCECONNECTION_H_
                namespace GgafCore {
                
                /**
                 * NX .
                 * (Resource)sAQgB new B<BR>
                 * gNXB<BR>
                 * GgafResourceManager : (Resource) : GgafResourceConnection  = 1 : N : N
                 * WAZbgBGgafResourceConnection  (Resource)bp[NXB
                 * GgafResourceConnectionNXCX^XA}l[W[NX(GgafResourceManagerNX)
                 * (getConnection \bh)B<BR>
                 * }l[W[ GgafResourceManager<T>::getConnection uJEgv+1A
                 * {NXclose()uJEgv-1B<BR>
                 * close() oAuJEgv{fB<BR>
                 * JEg0A(Resource)B
                 * T ^wB<BR>
                 * @version 1.00
                 * @since 2008/01/28
                 * @author Masatoshi Tsuge
                 */
                template<class T>
                class GgafResourceConnection : public GgafObject {
                    friend class GgafResourceManager<T>;
                
                private:
                    /** (50) */
                    char* _idstr;
                    /** }lW[|C^ */
                    int _num_connection;
                    /** g */
                    T* _pResource;
                    /** closetruertO */
                    static volatile bool _is_closing_resource;
                
                protected:
                    /** [r]}lW[ */
                    GgafResourceManager<T>* _pManager;
                    /** [r]GgafResourceConnection|C^BI[NULL */
                    GgafResourceConnection<T>* _pNext;
                
                    /**
                     * RXgN^<BR>
                     * protected RA}lW[(GgafResourceManager<T>) B<BR>
                     * @param prm_idstr (29)
                     * @param prm_pResource g
                     */
                    GgafResourceConnection(char* prm_idstr, T* prm_pResource);
                
                    /**
                     * fXgN^<BR>
                     * protected RAnew  delete BJ close() gp<BR>
                     */
         171 ->     virtual ~GgafResourceConnection() {
                    }
                
                    /**
                     * B
                     * delete  Release AB
                     * @param prm_pResource
                     */
                    virtual void processReleaseResource(T* prm_pResource)= 0;
                
                public:
                
                    /**
                     *  .
                     * @return 
                     */
                    char* getIdStr();
                
                    /**
                     * XgAIuWFNg .
                     * I[ NULL B
                     * @return IuWFNg ANULL
                     */
                    GgafResourceConnection<T>* getNext();
                
                    /**
                     * QB .
                     * JE^<BR>
                     * @return |C^
                     */
                    virtual T* refer();
                
                
                    int getNumConnection();
                
                
                
                    /**
                     *  .
                     * }l[WJE^1B<BR>
                     * AAJE^ 0 AprocessReleaseResourceoA{B<BR>
                     * @return AJE^
                     */
                    int close();
                };
                
                ///////////////////////////////////  /////
                template<class T>
                volatile bool GgafResourceConnection<T>::_is_closing_resource = false;
                
                template<class T>
                char* GgafResourceConnection<T>::getIdStr() {
                    return _idstr;
                }
                
                template<class T>
                GgafResourceConnection<T>* GgafResourceConnection<T>::getNext() {
                    return _pNext;
                }
                
                template<class T>
         171 -> GgafResourceConnection<T>::GgafResourceConnection(char* prm_idstr, T* prm_pResource) : GgafObject() {
                    TRACE3("GgafResourceConnection::GgafResourceConnection(prm_idstr = " <<  prm_idstr << ")");
                    _is_closing_resource = false;
                    _pResource = prm_pResource;
                    _pNext = NULL;
                    _pManager = NULL;
                    _num_connection = 0;
                    _idstr = NEW char[51];
                    strcpy(_idstr, prm_idstr);
                }
                
                template<class T>
                T* GgafResourceConnection<T>::refer() {
                    return _pResource;
                }
                template<class T>
                int GgafResourceConnection<T>::getNumConnection() {
                    return _num_connection;
                }
                
                
                template<class T>
                int GgafResourceConnection<T>::close() {
                    if (_is_closing_resource == true) {
                        //close() XbhtdlB
                        throwGgafCriticalException("GgafResourceConnection<T>::close() [" << _pManager->_manager_name << "." << _idstr << "][" << _idstr << "" << _num_connection << "Connection]\n"<<
                                                   "close()Aclose()BconnectXbhP{B")
                    }
                
                    if (_num_connection <= 0) {
                        TRACE3("GgafResourceManager::close() [" << _pManager->_manager_name << "." << _idstr << "][" << _idstr << "" << _num_connection << "Connection] xRlNVAclose() B");
                        TRACE3("sreturnA}IB[N\BI");
                        return _num_connection;
                    }
                
                
                
                
                    GgafResourceConnection<T>* pCurrent;
                    GgafResourceConnection<T>* pPrev;
                
                    //TODO:SB
                    for(int i = 0; GgafResourceManager<T>::_is_connecting_resource; i++) {
                        Sleep(1);
                        if (i > 1000*60) {
                            //P
                            _TRACE_("GgafResourceConnection<T>::close() _idstr="<<getIdStr()<<" close()AP@EEE");
                            throwGgafCriticalException("GgafResourceConnection<T>::close() ^CAEgB_idstr="<<getIdStr()<<" close()AP@BrAxB")
                        }
                    }
                    _is_closing_resource = true;
                
                
                    pCurrent = _pManager->_pFirstConnection;
                    pPrev = NULL;
                    while (pCurrent) {
                        if (pCurrent == this) {
                            //
                            int rnum = _num_connection;
                            TRACE3("GgafResourceManager::releaseResourceConnection[" << _pManager->_manager_name << "." << _idstr << "][" << _idstr << "" << rnum << "Connection] Jn");
                            if (rnum == 1) {//
                                //shAXgEs
                                if (pCurrent->_pNext == NULL) {
                                    //
                                    if (pPrev == NULL) {
                                        //ij
                                        _pManager->_pFirstConnection = NULL;
                                    } else {
                                        //
                                        pPrev->_pNext = NULL;
                                    }
                                } else {
                                    //
                                    if (pPrev == NULL) {
                                        //
                                        _pManager->_pFirstConnection = pCurrent->_pNext; //
                                    } else {
                                        //ij
                                        pPrev->_pNext = pCurrent->_pNext; //q
                                    }
                                }
                                TRACE3("GgafResourceManager::releaseResourceConnection[" << _pManager->_manager_name << "." << _idstr << "][" << _idstr << "" << rnum << "Connection] QB");
                                _num_connection = 0;
                            } else if (rnum > 0) {
                                TRACE3("GgafResourceManager::releaseResourceConnection[" << _pManager->_manager_name << "." << _idstr << "][" << _idstr << "" << rnum << "Connection] c");
                                _num_connection--;
                            } else if (rnum < 0) {
                                //RR
                                _TRACE_("GgafResourceManager::releaseResourceConnection[" << _pManager->_manager_name << "." << _idstr << "][" << _idstr << "" << rnum
                                        << "Connection] IBBBAz[(>_<)BX[B");
                                _num_connection = 0; //
                            }
                            break;
                        } else {
                            //
                            pPrev = pCurrent;
                            pCurrent = pCurrent->_pNext;
                        }
                    }
                
                
                    if (_num_connection == 0) {
                        T* r = pCurrent->refer();
                        if (r) {
                            TRACE3("GgafResourceManager::releaseResourceConnection[" << _pManager->_manager_name << "." << _idstr << "] //{ processReleaseResource[" << _idstr << "" << _num_connection <<"]");
                            pCurrent->processReleaseResource(r); //{
                        }
                
                
                        if (GgafResourceManager<T>::_is_waiting_to_connect) {
                            //Xbhconnet()JB
                            //Au new mAdelete s}B
                            //Au|C^Aconnet()ivjB
                            _is_closing_resource = false;
                            return 0;
                        } else {
                            //Xbhconnet()SJB
                            _is_closing_resource = false; //this|C^gp\
                            delete[] _idstr;
                            delete this;
                //            if (GgafResourceManager<T>::_is_waiting_to_connect) {
                //                //Aconnet()AB
                //                //rSlA
                //                //TODO:SAgetConnection()p@\B
                //                _TRACE_("xGgafResourceConnection<T>::close() delete this  getConnection() BvBEEEI");
                //            }
                //            _is_closing_resource = false; //this|C^gp\
                            return 0;
                        }
                    } else {
                        _is_closing_resource = false;
                        return _num_connection;
                    }
                }
                
                }
                
                #endif /*GGAFRESOURCECONNECTION_H_*/


Top 10 Lines:

     Line      Count

       54        171
      115        171

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

      342   Total number of line executions
   171.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/manager/SplineConnection.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           6 -> SplineConnection::SplineConnection(char* prm_idstr, SplineSource* prm_pResource) :
                    GgafResourceConnection<SplineSource> (prm_idstr, prm_pResource) {
                }
                
                void SplineConnection::processReleaseResource(SplineSource* prm_pResource) {
                    _TRACE_("SplineConnection::processReleaseResourceJ(close()R\)");
                    DELETE_IMPOSSIBLE_NULL(prm_pResource);
                }
                


Top 10 Lines:

     Line      Count

        8          6

Execution Summary:

        2   Executable lines in this file
        1   Lines executed
    50.00   Percent of the file executed

        6   Total number of line executions
     3.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/MyStg2nd/src/gecchi/manager/SplineConnection.h:
                #ifndef SPLINEPROGRAMCONNECTION_H_
                #define SPLINEPROGRAMCONNECTION_H_
                namespace MyStg2nd {
                
                /**
                 * SplineSourceRlNV.
                 * @version 1.00
                 * @since 2010/12/14
                 * @author Masatoshi Tsuge
                 */
                class SplineConnection : public GgafCore::GgafResourceConnection<SplineSource> {
                
                public:
                
                    /**
                     * RXgN^<BR>
                     * @param prm_idstr 
                     * @param prm_pSplineProgram SplineSourceIuWFNg
                     */
                    SplineConnection(char* prm_idstr, SplineSource* prm_pSplineProgram);
                
                    void processReleaseResource(SplineSource* prm_pResource);
                
          12 ->     virtual ~SplineConnection() {
                    }
                };
                
                }
                #endif /*SPLINEPROGRAMCONNECTION_H_*/


Top 10 Lines:

     Line      Count

       24         12

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       12   Total number of line executions
    12.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/GgafCore/include/jp/ggaf/core/GgafResourceManager.hpp:
                #ifndef GGAFRESOURCEMANAGER_H_
                #define GGAFRESOURCEMANAGER_H_
                namespace GgafCore {
                
                /**
                 * NXB .
                 * NXAbsOwIuWFNg(GgafResourceConnection)xB<BR>
                 * (Resource)sAQgB new B<BR>
                 * gNXB<BR>
                 * GgafResourceManager : Resource : GgafResourceConnection  = 1 : N : N <BR>
                 * WAZbgB<BR>
                 * NX@\ANXCX^Xi|C^jXgAvA
                 * AAXgB
                 * (GdxfwActorManagerp)
                 * @version 1.00
                 * @since 2007/11/16
                 * @author Masatoshi Tsuge
                 */
                template<class T>
                class GgafResourceManager : public GgafObject {
                    friend class GgafResourceConnection<T>;
                
                private:
                    /** connecttruertO */
                    static volatile bool _is_connecting_resource;
                    /** connecttO */
                    static volatile bool _is_waiting_to_connect;
                
                    /**
                     * GgafResourceConnectionIuWFNgXgB<BR>
                     * @param prm_pNew GgafResourceConnectionIuWFNg|C^
                     */
                    virtual void add(GgafResourceConnection<T>* prm_pNew);
                
                    /**
                     * GgafResourceConnectionIuWFNgXgB<BR>
                     * @param prm_idstr 
                     * @return  ]GgafResourceConnectionIuWFNg|C^BXg NULL
                     */
                    virtual GgafResourceConnection<T>* find(char* prm_idstr);
                
                    /**
                     * B.
                     * @param prm_idstr 
                     */
                    T* createResource(char* prm_idstr, void* prm_p);
                
                    /**
                     * IuWFNg.
                     * @param prm_idstr 
                     */
                
                    /**
                     * IuWFNg.
                     * @param prm_idstr 
                     * @param prm_pResource IuWFNgValueBCX^XB
                     * @return IuWFNg
                     */
                    GgafResourceConnection<T>* createResourceConnection(char* prm_idstr, T* prm_pResource);
                
                protected:
                    /** [r]}l[W */
                    const char* _manager_name;
                    /** [r]GgafResourceConnectionIuWFNgXg|C^BI[NULL */
                    GgafResourceConnection<T>* _pFirstConnection;
                
                
                    /**
                     * IuWFNgB.
                     * \bh createResourceConnection oA{ev[gpKvB<BR>
                     * prm_idstr  IuWFNgWbNB<BR>
                     * AGgafResourceConnection NX new AOKBBR>
                     * @param prm_idstr  nAIuWFNgH 
                     * @param prm_pResource |C^
                     * @return GgafResourceConnection IuWFNgCX^XiGgafResourceConnection NXCX^Xj
                     */
                    virtual GgafResourceConnection<T>* processCreateConnection(char* prm_idstr, T* prm_pResource) = 0;
                
                    /**
                     * B.
                     * \bh createResource oA{ev[gpKvB<BR>
                     * prm_idstr  WbNB<BR>
                     * @param prm_idstr nA(new)H 
                     * @return CX^X|C^
                     */
                    virtual T* processCreateResource(char* prm_idstr, void* prm_p) = 0;
                
                
                public:
                    /**
                     * RXgN^
                     */
                    GgafResourceManager(const char* prm_manager_name);
                
                    /**
                     * fXgN^BXgB .
                     * SXg GgafResourceConnectionAGgafResourceConnectionrelease()PxsA<BR>
                     * GgafResourceConnectionJE^0Adelete B<BR>
                     * GgafResourceConnectionJE^0AgpWbNR
                     *  delete B<BR>
                     */
                    virtual ~GgafResourceManager();
                
                    /**
                     * GgafResourceConnectionIuWFNgB<BR>
                     * XgA new B<BR>
                     * XgAJE^B<BR>
                     * new AJE^1B<BR>
                     * @param prm_idstr 
                     * @param prm_p 
                     */
                    virtual GgafResourceConnection<T>* getConnection(char* prm_idstr, void* prm_p);
                
                    virtual GgafResourceConnection<T>* getConnection(char* prm_idstr) {
                        return this->getConnection(prm_idstr, NULL);
                    }
                    virtual GgafResourceConnection<T>* getConnection(const char* prm_idstr) {
                        return this->getConnection((char*)prm_idstr, NULL);
                    }
                    virtual GgafResourceConnection<T>* getConnection(const char* prm_idstr, void* prm_p) {
                        return this->getConnection((char*)prm_idstr, prm_p);
                    }
                
                
                
                
                    /**
                     * }lW[XgoBifobOpj .
                     */
                    virtual void dump();
                };
                
                // ---------------------------------------------------------------------//
                
                
                template<class T>
                volatile bool GgafResourceManager<T>::_is_connecting_resource = false;
                
                template<class T>
                volatile bool GgafResourceManager<T>::_is_waiting_to_connect = false;
                
                template<class T>
           9 -> GgafResourceManager<T>::GgafResourceManager(const char* prm_manager_name) : GgafObject(),
                      _manager_name(prm_manager_name) {
                    TRACE3("GgafResourceManager<T>::GgafResourceManager(" << prm_manager_name << ")");
                    _pFirstConnection = NULL;
                    _is_connecting_resource = false;
                    _is_waiting_to_connect = false;
                }
                
                template<class T>
                GgafResourceConnection<T>* GgafResourceManager<T>::find(char* prm_idstr) {
                    GgafResourceConnection<T>* pCurrent = _pFirstConnection;
                
                    while (pCurrent) {
                        //_TRACE_("pCurrent->_idstr -> "<<(pCurrent->_idstr)<<" prm_idstr="<<prm_idstr);
                        if (GgafUtil::strcmp_ascii(pCurrent->_idstr, prm_idstr) == 0) {
                            return pCurrent;
                        }
                        pCurrent = pCurrent->_pNext;
                    }
                    return NULL;
                }
                
                template<class T>
                void GgafResourceManager<T>::add(GgafResourceConnection<T>* prm_pResource_New) {
                    if (_pFirstConnection == NULL) {
                        _pFirstConnection = prm_pResource_New;
                        return;
                    } else {
                        GgafResourceConnection<T>* pCurrent = _pFirstConnection;
                        while (pCurrent->_pNext) {
                            pCurrent = pCurrent->_pNext;
                        }
                        pCurrent->_pNext = prm_pResource_New;
                        return;
                    }
                }
                
                template<class T>
                GgafResourceConnection<T>* GgafResourceManager<T>::getConnection(char* prm_idstr, void* prm_p) {
                    if (prm_idstr == NULL) {
                        TRACE3("x GgafResourceManager<T>::getConnection(NULL) [" << _manager_name << "]");
                    }
                    if (_is_waiting_to_connect == true || _is_connecting_resource == true) {
                        //getConnection() XbhtdlB
                        throwGgafCriticalException("GgafResourceManager<T>::getConnection() getConnection()AgetConnection("<<prm_idstr<<")BconnectXbhP{B");
                    }
                
                    //TODO:IrBSB
                    GgafResourceConnection<T>* pObj = NULL;
                    for(int i = 0; GgafResourceConnection<T>::_is_closing_resource; i++) {
                        _is_waiting_to_connect = true;
                        Sleep(1);
                        if (i > 1000*60) {
                            //P
                            _TRACE_("GgafResourceManager<T>::getConnection() prm_idstr="<<prm_idstr<<" getConnection()AP@EEE");
                            throwGgafCriticalException("GgafResourceManager<T>::getConnection() prm_idstr="<<prm_idstr<<" getConnection()AP@BrAxB");
                        }
                    }
                    //TODO:
                    //close()AXbhgetConnection()B
                    //VrA^C~OjcIXXvvB
                    //XbhZ[tSAB
                    //S getConnection() o getConnection() s`B
                    //templatesGivoid*jB
                    //BB
                    _is_waiting_to_connect = false;
                    _is_connecting_resource = true;
                    pObj = find(prm_idstr);
                    if (pObj == NULL) {
                        //BJE^P
                        T* pResource = createResource(prm_idstr, prm_p);
                        pObj = createResourceConnection(prm_idstr, pResource);
                        pObj->_num_connection = 1;
                        add(pObj);
                        TRACE3("GgafResourceManager<T>::connect [" << _manager_name << "]" << prm_idstr << "AVK");
                        _is_connecting_resource = false;
                        return pObj;
                    } else {
                        //BJE^{P
                        pObj->_num_connection++;
                        TRACE3("GgafResourceManager<T>::connect [" << _manager_name << "]" << prm_idstr << "JEg{P." << pObj->_num_connection);
                        _is_connecting_resource = false;
                        return pObj;
                    }
                }
                
                template<class T>
                T* GgafResourceManager<T>::createResource(char* prm_idstr, void* prm_p) {
                    TRACE3("GgafResourceManager<T>::createResource [" << _manager_name << "]" << prm_idstr << "");
                    T* p = processCreateResource(prm_idstr, prm_p);
                    return p;
                }
                
                template<class T>
                GgafResourceConnection<T>* GgafResourceManager<T>::createResourceConnection(char* prm_idstr, T* prm_pResource) {
                    TRACE3("GgafResourceManager<T>::createResourceConnection [" << _manager_name << "]" << prm_idstr << "");
                    GgafResourceConnection<T>* p = processCreateConnection(prm_idstr, prm_pResource);
                    p->_pManager = this; //}l[Wo^
                    return p;
                }
                
                template<class T>
                void GgafResourceManager<T>::dump() {
                    GgafResourceConnection<T>* pCurrent = _pFirstConnection;
                    if (_pFirstConnection == NULL) {
                        _TRACE_("GgafResourceManager::dump[" << _manager_name << "] XgB");
                    } else {
                        GgafResourceConnection<T>* pCurrent_Next;
                        while (pCurrent) {
                            _TRACE_("GgafResourceManager::dump[" << _manager_name << "] [" << pCurrent->_idstr << "" << pCurrent->_num_connection << "Connection]");
                            pCurrent_Next = pCurrent->_pNext;
                            if (pCurrent_Next == NULL) {
                                pCurrent = NULL;
                                break;
                            } else {
                                pCurrent = pCurrent_Next;
                            }
                        }
                    }
                }
                
                template<class T>
           9 -> GgafResourceManager<T>::~GgafResourceManager() {
                    TRACE3("GgafResourceManager<T>::~GgafResourceManager[" << _manager_name << "] " << _manager_name << " ");
                #ifdef MY_DEBUG
                    _TRACE_("GgafResourceManager<T>::~GgafResourceManager()["<<_manager_name<<"] begin --->");
                    _TRACE_("ODumping");
                    dump();
                #endif
                    GgafResourceConnection<T>* pCurrent = _pFirstConnection;
                    if (_pFirstConnection == NULL) {
                        TRACE3("GgafResourceManager::~GgafResourceManager[" << _manager_name << "] XgB");
                    } else {
                        GgafResourceConnection<T>* pCurrent_Next;
                        while (pCurrent) {
                            int rnum = pCurrent->_num_connection;
                            TRACE3("GgafResourceManager::~GgafResourceManager[" << _manager_name << "] Xg[" << pCurrent->_idstr << "" << rnum
                                    << "Connection]cBA{B" << rnum << " close()s");
                //            T* r = pCurrent->refer();
                            pCurrent_Next = pCurrent->_pNext;
                //            if (r) {
                //                pCurrent->processReleaseResource(r); //\[X
                //            }
                            for (int i = 0; i < rnum; i++) {
                                pCurrent->close(); //E
                            }
                            if (pCurrent_Next == NULL) {
                                //
                                break;
                            } else {
                                pCurrent = pCurrent_Next;
                            }
                        }
                    }
                #ifdef MY_DEBUG
                    _TRACE_("<--- GgafResourceManager<T>::~GgafResourceManager() ["<<_manager_name<<"] end");
                #endif
                }
                
                }
                #endif /*GGAFRESOURCEMANAGER_H_*/


Top 10 Lines:

     Line      Count

      143          9
      265          9

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

       18   Total number of line executions
     9.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/manager/SplineManager.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> SplineManager::SplineManager(const char* prm_manager_name) :
                    GgafResourceManager<SplineSource> (prm_manager_name) {
                }
                
                SplineSource* SplineManager::processCreateResource(char* prm_idstr, void* prm_p) {
                
                    SplineSource* pResource = NEW SplineSource(prm_idstr);
                
                    return pResource;
                }
                
                GgafResourceConnection<SplineSource>* SplineManager::processCreateConnection(char* prm_idstr, SplineSource* prm_pResource) {
                    TRACE3(" SplineManager::processCreateConnection "<<prm_idstr<<" JnB");
                    SplineConnection* pConnection = NEW SplineConnection(prm_idstr, prm_pResource);
                    TRACE3(" SplineManager::processCreateConnection "<<prm_idstr<<" IB");
                    return pConnection;
                }


Top 10 Lines:

     Line      Count

        8          1

Execution Summary:

        2   Executable lines in this file
        1   Lines executed
    50.00   Percent of the file executed

        1   Total number of line executions
     0.50   Average executions per line


*** File C:/cygwin/workspace/_git_repos/MyStg2nd/src/gecchi/manager/SplineManager.h:
                #ifndef SPLINEPROGRAMMANAGER_H_
                #define SPLINEPROGRAMMANAGER_H_
                namespace MyStg2nd {
                
                /**
                 * Spline NX .
                 *  SplineSource IuWFNgo^AgB
                 * @version 1.00
                 * @since 2010/12/14
                 * @author Masatoshi Tsuge
                 */
                class SplineManager : public GgafCore::GgafResourceManager<SplineSource> {
                
                public:
                
                    /**
                     * RXgN^
                     * @param prm_manager_name }l[W(eK{)
                     */
                    SplineManager(const char* prm_manager_name);
                
                    /**
                     * fBXpb`[B
                     * {AvXvCWZbgRRWvB
                     * @param prm_idstr
                     * @return SplineSourceIuWFNg
                     */
                    SplineSource* processCreateResource(char* prm_idstr, void* prm_p);
                
                    GgafCore::GgafResourceConnection<SplineSource>* processCreateConnection(char* prm_idstr, SplineSource* prm_pResource);
                
           2 ->     virtual ~SplineManager() {
                    }
                };
                
                }
                #endif /*SPLINEPROGRAMMANAGER_H_*/


Top 10 Lines:

     Line      Count

       32          2

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     2.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/scene/Universe/World/GameScene/CommonScene.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
                
           1 -> CommonScene::CommonScene(const char* prm_name) : DefaultScene(prm_name) {
                    _class_name = "CommonScene";
                
                    //SV[ngppIAN^[
                    //RRfBXpb`[B
                
                    //pGtFNg EffectExplosion001
                    {
                        _pDP_EffectExplosion001 = NEW GgafActorDispatcher("DpExplo001");
                        EffectExplosion001* pEffectExplosion;
                        for (int i = 0; i < 100; i++) { //XgbN100
                            pEffectExplosion = NEW EffectExplosion001("EffectExplosion001");
                            pEffectExplosion->inactivateTreeImmediately(); //\
                            _pDP_EffectExplosion001->addSubLast(pEffectExplosion);
                        }
                        getLordActor()->addSubGroup(_pDP_EffectExplosion001);
                    }
                
                    //ACe
                    { //_pDP_MagicPointItem001
                        _pDP_MagicPointItem001 = NEW GgafActorDispatcher("DpMpItem001");
                        MagicPointItem001* pMpItem001;
                        for (int i = 0; i < 500; i++) { //XgbN100
                            pMpItem001 = NEW MagicPointItem001("MP001");
                            pMpItem001->inactivateTreeImmediately(); //\
                            _pDP_MagicPointItem001->addSubLast(pMpItem001);
                        }
                        getLordActor()->addSubGroup(_pDP_MagicPointItem001);
                    }
                
                    { //Effect EffectTurbo002 ^[{
                        _pDispatcher_EffectTurbo002 = NEW GgafActorDispatcher("RotExplo002");
                        EffectTurbo002* pEffectTurbo;
                        for (int i = 0; i < 10; i++) { //XgbN100
                            pEffectTurbo = NEW EffectTurbo002("EffectTurbo002");
                            pEffectTurbo->inactivateTreeImmediately(); //\
                            _pDispatcher_EffectTurbo002->addSubLast(pEffectTurbo);
                        }
                        getLordActor()->addSubGroup(_pDispatcher_EffectTurbo002);
                    }
                
                    //    { //EnemyShot001
                    //        _pDispatcher_EnemyShots001 = NEW GgafActorDispatcher("TAMAS001");
                    //        EnemyCeresShot001* pEnemyShot;
                    //        for (int i = 0; i < 36*7; i++) { //XgbN256
                    //            pEnemyShot = NEW EnemyCeresShot001("EnemyCeresShot001");
                    //            pEnemyShot->inactivateTreeImmediately(); //\
                    //            _pDispatcher_EnemyShots001->addSubLast(pEnemyShot);
                    //        }
                    //        getLordActor()->addSubGroup(_pDispatcher_EnemyShots001);
                    //    }
                
                
                
                    //    { //Effect EffectExplosion001
                    //        _pDispatcher_EffectExplosion003 = NEW GgafActorDispatcher("RotExplo003");
                    //        EffectExplosion003* pEffectExplosion;
                    //        for (int i = 0; i < 50; i++) { //XgbN100
                    //            pEffectExplosion = NEW EffectExplosion003("EffectExplosion003");
                    //            pEffectExplosion->inactivateTreeImmediately(); //\
                    //            _pDispatcher_EffectExplosion003->addSubLast(pEffectExplosion);
                    //        }
                    //        getLordActor()->addSubGroup(_pDispatcher_EffectExplosion003);
                    //    }
                
                //
                //    {
                //        _pDispatcher_LaserChipDispatcher = NEW GgafActorDispatcher("LCDD");
                //        LaserChipDispatcher* pLaserChipDispatcher;
                //        EnemyAstraeaLaserChip002* pChip;
                //        for (int nLaser = 0; nLaser < 27; nLaser++) {
                //            stringstream name;
                //            name <<  "LaserChipDispatcher["<<nLaser<<"]";
                //            pLaserChipDispatcher = NEW LaserChipDispatcher(name.str().c_str());
                //            for (int nChip = 0; nChip < 50; nChip++) {
                //                stringstream name;
                //                name <<  "EnemyAstraeaLaserChip002["<<nLaser<<"]["<<nChip<<"]";
                //                pChip = NEW EnemyAstraeaLaserChip002(name.str().c_str());
                //                pChip->inactivateImmediately();
                //                pLaserChipDispatcher->addSubLast(pChip);
                //            }
                //            pLaserChipDispatcher->inactivateImmediately();
                //            _pDispatcher_LaserChipDispatcher->addSubLast(pLaserChipDispatcher);
                //        }
                //        getLordActor()->addSubGroup(_pDispatcher_LaserChipDispatcher);
                //    }
                }
                
                void CommonScene::initialize() {
                }
                
                void CommonScene::processBehavior() {
                
                
                }
                
           2 -> CommonScene::~CommonScene() {
                }


Top 10 Lines:

     Line      Count

      105          2
        9          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/scene/Universe/World/GameScene/GameBeginningScene.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> GameBeginningScene::GameBeginningScene(const char* prm_name) : DefaultScene(prm_name) {
                    _class_name = "GameBeginningScene";
                
                    _pStringBoard01 = NEW LabelGecchi16Font("STR01");
                    getLordActor()->addSubGroup(KIND_EFFECT, _pStringBoard01);
                    _pStringBoard02 = NEW LabelGecchi16Font("STR02");
                    getLordActor()->addSubGroup(KIND_EFFECT, _pStringBoard02);
                    _selected_stage = 0;
                    useProgress(10);
                }
                
                
                void GameBeginningScene::onReset() {
                    _TRACE_("GamePreTitleScene::onReset()");
                    _pPrg->change(GAMEBEGINNING_SCENE_PROG_INIT);
                    unblindScene();
                    _pStringBoard01->update("");
                    _pStringBoard02->update("");
                }
                //void GameBeginningScene::ready() {
                //    _TRACE_("GameBeginningScene::ready()");
                //}
                void GameBeginningScene::onActive() {
                }
                
                void GameBeginningScene::initialize() {
                }
                
                void GameBeginningScene::processBehavior() {
                
                    switch (_pPrg->get()) {
                        case GAMEBEGINNING_SCENE_PROG_INIT: {
                            _pPrg->change(GAMEBEGINNING_SCENE_PROG_SELECT_MODE);
                            break;
                        }
                
                        case GAMEBEGINNING_SCENE_PROG_SELECT_MODE: {
                            if (_pPrg->isJustChanged()) {
                                _pStringBoard01->update(200, 200, "GAME_BEGINNING_SCENE BEGIN");
                                _pStringBoard02->update(200, 250, "SELECT MODE!");
                            }
                            if (_pPrg->get() == GAMEBEGINNING_SCENE_PROG_SELECT_MODE) {
                                if (VB->isPushedDown(VB_UI_EXECUTE) || _pPrg->getFrameInProgress() == 300) {
                                    _pPrg->change(GAMEBEGINNING_SCENE_PROG_DECIDE);
                                }
                            }
                            break;
                        }
                
                        case GAMEBEGINNING_SCENE_PROG_DECIDE: {
                            if (_pPrg->isJustChanged()) {
                                fadeoutScene(FADE_FRAME);
                                throwEventToUpperTree(EVENT_GAMEMODE_DECIDE);
                            }
                            if (_pPrg->getFrameInProgress() % 10 < 5 ) {
                                _pStringBoard02->update(400, 500, "OK OK OK");
                            } else {
                                _pStringBoard02->update(400, 500, "");
                            }
                            if (_pPrg->getFrameInProgress() == FADE_FRAME) {
                                _pPrg->change(GAMEBEGINNING_SCENE_PROG_FINISH);
                            }
                            break;
                        }
                
                        case GAMEBEGINNING_SCENE_PROG_FINISH: {
                            if (_pPrg->isJustChanged()) {
                                inactivate();
                            }
                            break;
                        }
                
                        default:
                            break;
                    }
                
                }
                
                void GameBeginningScene::processFinal() {
                }
                
           2 -> GameBeginningScene::~GameBeginningScene() {
                }


Top 10 Lines:

     Line      Count

       89          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/scene/Universe/World/GameScene/GameDemoScene.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> GameDemoScene::GameDemoScene(const char* prm_name) : DefaultScene(prm_name) {
                    _class_name = "GameDemoScene";
                    useProgress(10);
                    _pStringBoard01 = NEW LabelGecchi16Font("STR01");
                    getLordActor()->addSubGroup(KIND_EFFECT, _pStringBoard01);
                    _pStringBoard02 = NEW LabelGecchi16Font("STR02");
                    getLordActor()->addSubGroup(KIND_EFFECT, _pStringBoard02);
                    _pBgmPerformer->useBgm(1);
                    _pBgmPerformer->set(0, "BGM_DEMO");
                
                }
                void GameDemoScene::onReset() {
                    _pPrg->set(GAMEDEMO_SCENE_PROG_INIT);
                    _pStringBoard01->update("");
                    _pStringBoard02->update("");
                    unblindScene();
                }
                
                void GameDemoScene::onActive() {
                }
                
                void GameDemoScene::initialize() {
                }
                
                void GameDemoScene::processBehavior() {
                
                    switch (_pPrg->get()) {
                        case GAMEDEMO_SCENE_PROG_INIT: {
                            _pPrg->change(GAMEDEMO_SCENE_PROG_DEMOPLAY);
                            break;
                        }
                
                        case GAMEDEMO_SCENE_PROG_DEMOPLAY: {
                            if (_pPrg->isJustChanged()) {
                                _pStringBoard01->update(100, 100, "DEMOPLAY NOW");
                                _pStringBoard02->update(100, 150, "GAME OVER");
                            }
                            if (_pPrg->getFrameInProgress() == 180) {
                                _pPrg->change(GAMEDEMO_SCENE_PROG_RANKING);
                            }
                            break;
                        }
                
                        case GAMEDEMO_SCENE_PROG_RANKING: {
                            if (_pPrg->isJustChanged()) {
                                _pStringBoard01->update(100, 100, "RANKING NOW");
                                _pStringBoard02->update(100, 150, "GAME OVER");
                            }
                            if (_pPrg->getFrameInProgress() == 180) {
                                _pPrg->change(GAMEDEMO_SCENE_PROG_FINISH);
                            }
                            break;
                        }
                
                        case GAMEDEMO_SCENE_PROG_FINISH: {
                            if (_pPrg->isJustChanged()) {
                                fadeoutSceneTree(FADE_FRAME);
                                inactivateDelay(FADE_FRAME);
                                throwEventToUpperTree(EVENT_GAMEDEMO_SCENE_FINISH); //ICxg
                            }
                            break;
                        }
                
                        default:
                            break;
                    }
                
                }
                
                void GameDemoScene::processFinal() {
                
                }
                
           2 -> GameDemoScene::~GameDemoScene() {
                }


Top 10 Lines:

     Line      Count

       81          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/scene/Universe/World/GameScene/GameEndingScene.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> GameEndingScene::GameEndingScene(const char* prm_name) : DefaultScene(prm_name) {
                    _class_name = "GameEndingScene";
                    useProgress(10);
                }
                
                void GameEndingScene::onReset() {
                    //_pPrg->change(GAMEENDING_SCENE_PROG_INIT);
                }
                void GameEndingScene::ready() {
                    _TRACE_("GameEndingScene::ready()");
                }
                
                void GameEndingScene::initialize() {
                    _TRACE_("GameEndingScene::initialize()");
                }
                
                void GameEndingScene::processBehavior() {
                }
                
                void GameEndingScene::processFinal() {
                }
                
           2 -> GameEndingScene::~GameEndingScene() {
                }


Top 10 Lines:

     Line      Count

       30          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/scene/Universe/World/GameScene/GameMainScene/Stage01Scene/Stage01Controller.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> Stage01Controller::Stage01Controller(const char* prm_name) : DefaultScene(prm_name) {
                    _class_name = "Stage01Controller";
                
                    _pBgmPerformer->useBgm(3);
                    _pBgmPerformer->set(0, "BGM_01_01");
                    _pBgmPerformer->set(1, "BGM_01_02");
                    _pBgmPerformer->set(2, "BGM_01_03");
                    //  gen01 start ` end Excel}NR[hB
                    // R[hXuV[Creater.xlsvsimjB
                    // gen01 start
                	frame f[] = {1,100,2200,4000};
                	_paFrame_NextEvent = new frame[4];
                	memcpy(_paFrame_NextEvent, f, sizeof(f));
                	_event_num = 4;
                	orderSceneToFactory(10000000, Stage01_01, "Stage01_01");
                    // gen01 end
                    useProgress(10);
                }
                
                void Stage01Controller::initialize() {
                    _pPrg->set(STAGE01CONTROLLER_SCENE_PROG_INIT);
                }
                
                void Stage01Controller::processBehavior() {
                    //  gen02 start ` end Excel}NR[hB
                    // R[hXuV[Creater.xlsvsimjB
                    // gen02 start
                	if (getActivePartFrame() == _paFrame_NextEvent[_iCnt_Event]) {
                		switch (getActivePartFrame()) {
                			case 1: {
                				break;
                			}
                			case 100: {
                				Stage01_01* pScene = (Stage01_01*)obtainSceneFromFactory(10000000);
                				addSubLast(pScene);
                				_pPrg->change(STAGE01CONTROLLER_SCENE_PROG_STG01_01_BEGIN);
                				break;
                			}
                			case 2200: {
                				orderSceneToFactory(10000001, Stage01_02, "Stage01_02");
                				break;
                			}
                			case 4000: {
                				Stage01_02* pScene = (Stage01_02*)obtainSceneFromFactory(10000001);
                				addSubLast(pScene);
                				_pPrg->change(STAGE01CONTROLLER_SCENE_PROG_STG01_02_BEGIN);
                				break;
                			}
                			default :
                				break;
                		}
                		_iCnt_Event = (_iCnt_Event < 4-1 ? _iCnt_Event+1 : _iCnt_Event);
                	}
                    // gen02 end
                
                
                    switch (_pPrg->get()) {
                        case STAGE01CONTROLLER_SCENE_PROG_INIT: {
                            _TRACE_("Stage01Controller::processBehavior DemoAN");
                            //iXV
                            break;
                        }
                
                        //Stage01_01
                        case STAGE01CONTROLLER_SCENE_PROG_STG01_01_BEGIN: {
                            //BGMPtF[hC
                            _pBgmPerformer->play(0, 0, true);
                            _pBgmPerformer->fadein(0, 420);
                            _pPrg->changeNext();
                            break;
                        }
                        case STAGE01CONTROLLER_SCENE_PROG_STG01_01_PLAYING: {
                            //iXV
                            break;
                        }
                
                        //Stage01_02
                        case STAGE01CONTROLLER_SCENE_PROG_STG01_02_BEGIN: {
                            //BGMOtF[hAEg
                            _pBgmPerformer->fadeout_stop(0, 420);
                            //BGMPtF[hC
                            _pBgmPerformer->play(1, GGAF_MIN_VOLUME, true);
                            _pBgmPerformer->fadein(1, 420);
                            _pPrg->changeNext();
                            break;
                        }
                        case STAGE01CONTROLLER_SCENE_PROG_STG01_02_PLAYING: {
                            //iXV
                            break;
                        }
                
                        //Stage01_03
                        case STAGE01CONTROLLER_SCENE_PROG_STG01_03_BEGIN: {
                            _pPrg->changeNext();
                            break;
                        }
                        case STAGE01CONTROLLER_SCENE_PROG_STG01_03_PLAYING: {
                            //iXV
                            break;
                        }
                
                        //Stage01_Climax
                        case STAGE01CONTROLLER_SCENE_PROG_STG01_CLIMAX_BEGIN: {
                            //BGMPtF[hAEg
                            _pBgmPerformer->fadeout_stop(1, 420);
                            //BGMQtF[hC
                            _pBgmPerformer->play(2, GGAF_MIN_VOLUME, true);
                            _pBgmPerformer->fadein(2, 420);
                            _pPrg->changeNext();
                            break;
                        }
                        case STAGE01CONTROLLER_SCENE_PROG_STG01_CLIMAX_PLAYING: {
                            //iXV
                            break;
                        }
                
                        //Stage01_Climax 
                        case STAGE01CONTROLLER_SCENE_PROG_FAINAL: {
                            if (_pPrg->isJustChanged()) {
                                //STG01_ClimaxI
                                _TRACE_("STG01_ClimaxISTAGE01CONTROLLER_SCENE_PROG_FAINAL");
                                _pBgmPerformer->fadeout_stop(2, 420); //BGMPtF[hAEg
                                _frame_prog_fainal = 0;
                            }
                            _frame_prog_fainal++;
                            if (_frame_prog_fainal == 420) { //BGMtF[hAEgB
                                throwEventToUpperTree(EVENT_STAGE01CONTROLLER_WAS_END); //Xe[WGh`
                            }
                            //Cxg
                            break;
                        }
                        default :
                            break;
                    }
                }
                
                void Stage01Controller::processFinal() {
                }
                
                void Stage01Controller::onCatchEvent(UINT32 prm_no, void* prm_pSource) {
                    if (prm_no == EVENT_STG01_01_WAS_BROKEN) {
                        _TRACE_("Stage01Controller::onCatchEvent() EVENT_STG01_01_WAS_BROKEN");
                        ((Stage01_01*)prm_pSource)->end(3000*60);
                    } else if (prm_no == EVENT_STG01_02_WAS_BROKEN) {
                        _TRACE_("Stage01Controller::onCatchEvent() EVENT_STG01_02_WAS_BROKEN");
                        ((Stage01_02*)prm_pSource)->end(30*60);
                    } else if (prm_no == EVENT_STG01_03_WAS_BROKEN) {
                        _TRACE_("Stage01Controller::onCatchEvent() EVENT_STG01_03_WAS_BROKEN");
                        ((Stage01_03*)prm_pSource)->end(30*60);
                    } else if (prm_no == EVENT_STG01_CLIMAX_WAS_BROKEN) {
                        _TRACE_("Stage01Controller::onCatchEvent() EVENT_STG01_CLIMAX_WAS_BROKENLb`BSTAGE01CONTROLLER_ENDING");
                        ((Stage01_Climax*)prm_pSource)->end(30*60);
                        _pPrg->change(STAGE01CONTROLLER_SCENE_PROG_FAINAL); //iSTAGE01CONTROLLER_SCENE_PROG_FAINAL
                    } else {
                
                    }
                
                }
                
           2 -> Stage01Controller::~Stage01Controller() {
                
                }


Top 10 Lines:

     Line      Count

      167          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/scene/Universe/World/GameScene/GameMainScene/Stage01Scene/part/Stage01_01.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> Stage01_01::Stage01_01(const char* prm_name) : DefaultScene(prm_name) {
                    _class_name = "Stage01_01";
                
                    //  gen01 start ` end Excel}NR[hB
                    // R[hXuV[Creater.xlsvsimjB
                    // gen01 start
                	frame f[] = {1,10,40,70,100,130,160,190,200,220,250,280,310,340,370,400,430,460,490,520,550,560,580,610,640,670,700,730,760,790,800,820,850,880,910,940,970,1000,1030,1040,1060,1090,1120,1150,1180,1210,1240,1270,1280,1300,1330,1360,1390,1420,1450,1480,1510,1520,1540,1570,1600,1630,1660,1690,1720,1750,1760,1780,1810,1840,1870,1900,1930,1960,1990,2000,2020,2050,2080,2110,2140,2170,2200,2230,2260,2290,2320,2350,2380,2410,2440,2470,2500,2530,2560,2590,2620,2650,2680,2710,2740,2770,2800,2830,2860,2890,2920,2950,2980,3010,3040,3070,3100,3130,3160,3190,3220,3250,3280,3310,3340,3370,3400,3430,3460,3490,3520,3550,3580,3610,3640,3670,3700,3730,3760,3790,3820,3850,3880,3910,3940,3970,4000,23200,23560,23800,24040,24280,24520,24760,25000,25360,25600,25840,26080,26320,26560,26800};
                	_paFrame_NextEvent = new frame[158];
                	memcpy(_paFrame_NextEvent, f, sizeof(f));
                	_event_num = 158;
                	orderActorToFactory(30000000, EnemyMetis, "Metis_1");
                	orderActorToFactory(30000001, EnemyMetis, "Metis_2");
                	orderActorToFactory(30000002, EnemyMetis, "Metis_3");
                	orderActorToFactory(30000003, EnemyMetis, "Metis_4");
                	orderActorToFactory(30000004, EnemyMetis, "Metis_5");
                	orderActorToFactory(30000005, EnemyMetis, "Metis_6");
                	orderActorToFactory(30000006, EnemyMetis, "Metis_7");
                	orderActorToFactory(30000007, EnemyMetis, "Metis_8");
                	orderActorToFactory(30000008, EnemyMetis, "Metis_9");
                	orderActorToFactory(30000009, EnemyMetis, "Metis_10");
                	orderActorToFactory(30000010, EnemyMetis, "Metis_11");
                	orderActorToFactory(30000011, EnemyMetis, "Metis_12");
                	orderActorToFactory(30000012, EnemyMetis, "Metis_13");
                	orderActorToFactory(30000013, EnemyMetis, "Metis_14");
                	orderActorToFactory(30000014, EnemyMetis, "Metis_15");
                	orderActorToFactory(30000015, EnemyMetis, "Metis_16");
                	orderActorToFactory(30000016, EnemyMetis, "Metis_17");
                	orderActorToFactory(30000017, EnemyMetis, "Metis_18");
                	orderActorToFactory(30000018, EnemyMetis, "Metis_19");
                	orderActorToFactory(30000019, EnemyMetis, "Metis_20");
                	orderActorToFactory(30000020, EnemyMetis, "Metis_21");
                	orderActorToFactory(30000021, EnemyMetis, "Metis_22");
                	orderActorToFactory(30000022, EnemyMetis, "Metis_23");
                	orderActorToFactory(30000023, EnemyMetis, "Metis_24");
                	orderActorToFactory(30000024, EnemyMetis, "Metis_25");
                	orderActorToFactory(30000025, EnemyMetis, "Metis_26");
                	orderActorToFactory(30000026, EnemyMetis, "Metis_27");
                	orderActorToFactory(30000101, FormationEunomia001a, "F001a_Eunomia_28");
                	orderActorToFactory(30000102, FormationEunomia001b, "F001b_Eunomia_29");
                	orderActorToFactory(30000103, FormationEunomia001a, "F001a_Eunomia_30");
                	orderActorToFactory(30000104, FormationEunomia001b, "F001b_Eunomia_31");
                	orderActorToFactory(30000105, FormationEunomia001a, "F001a_Eunomia_32");
                	orderActorToFactory(30000106, FormationEunomia001b, "F001b_Eunomia_33");
                	orderActorToFactory(30000107, FormationEunomia001a, "F001a_Eunomia_34");
                    // gen01 end
                }
                
                void Stage01_01::initialize() {
                
                }
                
                void Stage01_01::processBehavior() {
                    //  gen02 start ` end Excel}NR[hB
                    // R[hXuV[Creater.xlsvsimjB
                    // gen02 start
                	if (getActivePartFrame() == _paFrame_NextEvent[_iCnt_Event]) {
                		switch (getActivePartFrame()) {
                			case 1: {
                				break;
                			}
                			case 10: {
                				orderActorToFactory(30000027, EnemyMetis, "Metis_35");
                				break;
                			}
                			case 40: {
                				orderActorToFactory(30000028, EnemyMetis, "Metis_36");
                				break;
                			}
                			case 70: {
                				orderActorToFactory(30000029, EnemyMetis, "Metis_37");
                				break;
                			}
                			case 100: {
                				orderActorToFactory(30000030, EnemyMetis, "Metis_38");
                				break;
                			}
                			case 130: {
                				orderActorToFactory(30000031, EnemyMetis, "Metis_39");
                				break;
                			}
                			case 160: {
                				orderActorToFactory(30000032, EnemyMetis, "Metis_40");
                				break;
                			}
                			case 190: {
                				orderActorToFactory(30000033, EnemyMetis, "Metis_41");
                				break;
                			}
                			case 200: {
                				FormationEunomia001a* pFormation = (FormationEunomia001a*)obtainActorFromFactory(30000101);
                				getLordActor()->addSubGroup(pFormation);
                				orderActorToFactory(30000108, FormationEunomia001b, "F001b_Eunomia_42");
                				break;
                			}
                			case 220: {
                				orderActorToFactory(30000034, EnemyMetis, "Metis_43");
                				break;
                			}
                			case 250: {
                				orderActorToFactory(30000035, EnemyMetis, "Metis_44");
                				break;
                			}
                			case 280: {
                				orderActorToFactory(30000036, EnemyMetis, "Metis_45");
                				break;
                			}
                			case 310: {
                				orderActorToFactory(30000037, EnemyMetis, "Metis_46");
                				break;
                			}
                			case 340: {
                				orderActorToFactory(30000038, EnemyMetis, "Metis_47");
                				break;
                			}
                			case 370: {
                				orderActorToFactory(30000039, EnemyMetis, "Metis_48");
                				break;
                			}
                			case 400: {
                				orderActorToFactory(30000040, EnemyMetis, "Metis_49");
                				break;
                			}
                			case 430: {
                				orderActorToFactory(30000041, EnemyMetis, "Metis_50");
                				break;
                			}
                			case 460: {
                				orderActorToFactory(30000042, EnemyMetis, "Metis_51");
                				break;
                			}
                			case 490: {
                				orderActorToFactory(30000043, EnemyMetis, "Metis_52");
                				break;
                			}
                			case 520: {
                				orderActorToFactory(30000044, EnemyMetis, "Metis_53");
                				break;
                			}
                			case 550: {
                				orderActorToFactory(30000045, EnemyMetis, "Metis_54");
                				break;
                			}
                			case 560: {
                				FormationEunomia001b* pFormation = (FormationEunomia001b*)obtainActorFromFactory(30000102);
                				getLordActor()->addSubGroup(pFormation);
                				break;
                			}
                			case 580: {
                				orderActorToFactory(30000046, EnemyMetis, "Metis_55");
                				break;
                			}
                			case 610: {
                				orderActorToFactory(30000047, EnemyMetis, "Metis_56");
                				break;
                			}
                			case 640: {
                				orderActorToFactory(30000048, EnemyMetis, "Metis_57");
                				break;
                			}
                			case 670: {
                				orderActorToFactory(30000049, EnemyMetis, "Metis_58");
                				break;
                			}
                			case 700: {
                				orderActorToFactory(30000050, EnemyMetis, "Metis_59");
                				break;
                			}
                			case 730: {
                				orderActorToFactory(30000051, EnemyMetis, "Metis_60");
                				break;
                			}
                			case 760: {
                				orderActorToFactory(30000052, EnemyMetis, "Metis_61");
                				break;
                			}
                			case 790: {
                				orderActorToFactory(30000053, EnemyMetis, "Metis_62");
                				break;
                			}
                			case 800: {
                				FormationEunomia001a* pFormation = (FormationEunomia001a*)obtainActorFromFactory(30000103);
                				getLordActor()->addSubGroup(pFormation);
                				break;
                			}
                			case 820: {
                				orderActorToFactory(30000054, EnemyMetis, "Metis_63");
                				break;
                			}
                			case 850: {
                				orderActorToFactory(30000055, EnemyMetis, "Metis_64");
                				break;
                			}
                			case 880: {
                				orderActorToFactory(30000056, EnemyMetis, "Metis_65");
                				break;
                			}
                			case 910: {
                				orderActorToFactory(30000057, EnemyMetis, "Metis_66");
                				break;
                			}
                			case 940: {
                				orderActorToFactory(30000058, EnemyMetis, "Metis_67");
                				break;
                			}
                			case 970: {
                				orderActorToFactory(30000059, EnemyMetis, "Metis_68");
                				break;
                			}
                			case 1000: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000000);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000060, EnemyMetis, "Metis_69");
                				break;
                			}
                			case 1030: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000001);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000061, EnemyMetis, "Metis_70");
                				break;
                			}
                			case 1040: {
                				FormationEunomia001b* pFormation = (FormationEunomia001b*)obtainActorFromFactory(30000104);
                				getLordActor()->addSubGroup(pFormation);
                				break;
                			}
                			case 1060: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000002);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000062, EnemyMetis, "Metis_71");
                				break;
                			}
                			case 1090: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000003);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000063, EnemyMetis, "Metis_72");
                				break;
                			}
                			case 1120: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000004);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000064, EnemyMetis, "Metis_73");
                				break;
                			}
                			case 1150: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000005);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000065, EnemyMetis, "Metis_74");
                				break;
                			}
                			case 1180: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000006);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000066, EnemyMetis, "Metis_75");
                				break;
                			}
                			case 1210: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000007);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000067, EnemyMetis, "Metis_76");
                				break;
                			}
                			case 1240: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000008);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000068, EnemyMetis, "Metis_77");
                				break;
                			}
                			case 1270: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000009);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000069, EnemyMetis, "Metis_78");
                				break;
                			}
                			case 1280: {
                				FormationEunomia001a* pFormation = (FormationEunomia001a*)obtainActorFromFactory(30000105);
                				getLordActor()->addSubGroup(pFormation);
                				break;
                			}
                			case 1300: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000010);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000070, EnemyMetis, "Metis_79");
                				break;
                			}
                			case 1330: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000011);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000071, EnemyMetis, "Metis_80");
                				break;
                			}
                			case 1360: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000012);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000072, EnemyMetis, "Metis_81");
                				break;
                			}
                			case 1390: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000013);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000073, EnemyMetis, "Metis_82");
                				break;
                			}
                			case 1420: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000014);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000074, EnemyMetis, "Metis_83");
                				break;
                			}
                			case 1450: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000015);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000075, EnemyMetis, "Metis_84");
                				break;
                			}
                			case 1480: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000016);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000076, EnemyMetis, "Metis_85");
                				break;
                			}
                			case 1510: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000017);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000077, EnemyMetis, "Metis_86");
                				break;
                			}
                			case 1520: {
                				FormationEunomia001b* pFormation = (FormationEunomia001b*)obtainActorFromFactory(30000106);
                				getLordActor()->addSubGroup(pFormation);
                				break;
                			}
                			case 1540: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000018);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000078, EnemyMetis, "Metis_87");
                				break;
                			}
                			case 1570: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000019);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000079, EnemyMetis, "Metis_88");
                				break;
                			}
                			case 1600: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000020);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000080, EnemyMetis, "Metis_89");
                				break;
                			}
                			case 1630: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000021);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000081, EnemyMetis, "Metis_90");
                				break;
                			}
                			case 1660: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000022);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000082, EnemyMetis, "Metis_91");
                				break;
                			}
                			case 1690: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000023);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000083, EnemyMetis, "Metis_92");
                				break;
                			}
                			case 1720: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000024);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000084, EnemyMetis, "Metis_93");
                				break;
                			}
                			case 1750: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000025);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000085, EnemyMetis, "Metis_94");
                				break;
                			}
                			case 1760: {
                				FormationEunomia001a* pFormation = (FormationEunomia001a*)obtainActorFromFactory(30000107);
                				getLordActor()->addSubGroup(pFormation);
                				break;
                			}
                			case 1780: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000026);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000086, EnemyMetis, "Metis_95");
                				break;
                			}
                			case 1810: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000027);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000087, EnemyMetis, "Metis_96");
                				break;
                			}
                			case 1840: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000028);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000088, EnemyMetis, "Metis_97");
                				break;
                			}
                			case 1870: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000029);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000089, EnemyMetis, "Metis_98");
                				break;
                			}
                			case 1900: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000030);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000090, EnemyMetis, "Metis_99");
                				break;
                			}
                			case 1930: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000031);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000091, EnemyMetis, "Metis_100");
                				break;
                			}
                			case 1960: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000032);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000092, EnemyMetis, "Metis_101");
                				break;
                			}
                			case 1990: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000033);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000093, EnemyMetis, "Metis_102");
                				break;
                			}
                			case 2000: {
                				FormationEunomia001b* pFormation = (FormationEunomia001b*)obtainActorFromFactory(30000108);
                				getLordActor()->addSubGroup(pFormation);
                				break;
                			}
                			case 2020: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000034);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000094, EnemyMetis, "Metis_103");
                				break;
                			}
                			case 2050: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000035);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000095, EnemyMetis, "Metis_104");
                				break;
                			}
                			case 2080: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000036);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000096, EnemyMetis, "Metis_105");
                				break;
                			}
                			case 2110: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000037);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000097, EnemyMetis, "Metis_106");
                				break;
                			}
                			case 2140: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000038);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000098, EnemyMetis, "Metis_107");
                				break;
                			}
                			case 2170: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000039);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000099, EnemyMetis, "Metis_108");
                				break;
                			}
                			case 2200: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000040);
                				getLordActor()->addSubGroup(pMetis);
                				orderActorToFactory(30000100, EnemyMetis, "Metis_109");
                				break;
                			}
                			case 2230: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000041);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2260: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000042);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2290: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000043);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2320: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000044);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2350: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000045);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2380: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000046);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2410: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000047);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2440: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000048);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2470: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000049);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2500: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000050);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2530: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000051);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2560: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000052);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2590: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000053);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2620: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000054);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2650: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000055);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2680: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000056);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2710: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000057);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2740: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000058);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2770: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000059);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2800: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000060);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2830: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000061);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2860: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000062);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2890: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000063);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2920: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000064);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2950: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000065);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 2980: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000066);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3010: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000067);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3040: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000068);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3070: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000069);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3100: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000070);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3130: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000071);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3160: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000072);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3190: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000073);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3220: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000074);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3250: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000075);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3280: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000076);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3310: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000077);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3340: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000078);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3370: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000079);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3400: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000080);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3430: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000081);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3460: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000082);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3490: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000083);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3520: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000084);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3550: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000085);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3580: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000086);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3610: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000087);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3640: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000088);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3670: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000089);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3700: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000090);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3730: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000091);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3760: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000092);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3790: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000093);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3820: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000094);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3850: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000095);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3880: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000096);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3910: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000097);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3940: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000098);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 3970: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000099);
                				getLordActor()->addSubGroup(pMetis);
                				break;
                			}
                			case 4000: {
                				EnemyMetis* pMetis = (EnemyMetis*)obtainActorFromFactory(30000100);
                				getLordActor()->addSubGroup(pMetis);
                				throwEventToUpperTree(EVENT_STG01_01_WAS_BROKEN,this);
                				break;
                			}
                			case 23200: {
                				orderActorToFactory(30000109, FormationEunomia001a, "F001a_Eunomia_110");
                				break;
                			}
                			case 23560: {
                				orderActorToFactory(30000110, FormationEunomia001b, "F001b_Eunomia_111");
                				break;
                			}
                			case 23800: {
                				orderActorToFactory(30000111, FormationEunomia001a, "F001a_Eunomia_112");
                				break;
                			}
                			case 24040: {
                				orderActorToFactory(30000112, FormationEunomia001b, "F001b_Eunomia_113");
                				break;
                			}
                			case 24280: {
                				orderActorToFactory(30000113, FormationEunomia001a, "F001a_Eunomia_114");
                				break;
                			}
                			case 24520: {
                				orderActorToFactory(30000114, FormationEunomia001b, "F001b_Eunomia_115");
                				break;
                			}
                			case 24760: {
                				orderActorToFactory(30000115, FormationEunomia001a, "F001a_Eunomia_116");
                				break;
                			}
                			case 25000: {
                				FormationEunomia001a* pFormation = (FormationEunomia001a*)obtainActorFromFactory(30000109);
                				getLordActor()->addSubGroup(pFormation);
                				orderActorToFactory(30000116, FormationEunomia001b, "F001b_Eunomia_117");
                				break;
                			}
                			case 25360: {
                				FormationEunomia001b* pFormation = (FormationEunomia001b*)obtainActorFromFactory(30000110);
                				getLordActor()->addSubGroup(pFormation);
                				break;
                			}
                			case 25600: {
                				FormationEunomia001a* pFormation = (FormationEunomia001a*)obtainActorFromFactory(30000111);
                				getLordActor()->addSubGroup(pFormation);
                				break;
                			}
                			case 25840: {
                				FormationEunomia001b* pFormation = (FormationEunomia001b*)obtainActorFromFactory(30000112);
                				getLordActor()->addSubGroup(pFormation);
                				break;
                			}
                			case 26080: {
                				FormationEunomia001a* pFormation = (FormationEunomia001a*)obtainActorFromFactory(30000113);
                				getLordActor()->addSubGroup(pFormation);
                				break;
                			}
                			case 26320: {
                				FormationEunomia001b* pFormation = (FormationEunomia001b*)obtainActorFromFactory(30000114);
                				getLordActor()->addSubGroup(pFormation);
                				break;
                			}
                			case 26560: {
                				FormationEunomia001a* pFormation = (FormationEunomia001a*)obtainActorFromFactory(30000115);
                				getLordActor()->addSubGroup(pFormation);
                				break;
                			}
                			case 26800: {
                				FormationEunomia001b* pFormation = (FormationEunomia001b*)obtainActorFromFactory(30000116);
                				getLordActor()->addSubGroup(pFormation);
                				break;
                			}
                			default :
                				break;
                		}
                		_iCnt_Event = (_iCnt_Event < 158-1 ? _iCnt_Event+1 : _iCnt_Event);
                	}
                    // gen02 end
                
                }
                
                void Stage01_01::processFinal() {
                }
                
           2 -> Stage01_01::~Stage01_01() {
                
                }


Top 10 Lines:

     Line      Count

      869          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/scene/Universe/World/GameScene/GameMainScene/Stage01Scene/part/Stage01_02.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> Stage01_02::Stage01_02(const char* prm_name) : DefaultScene(prm_name) {
                    _class_name = "Stage01_02";
                    //  gen01 start ` end Excel}NR[hB
                    // R[hXuV[Creater.xlsvsimjB
                    // gen01 start
                	frame f[] = {1,100,200,500,700,1000,1200,1500,1700,2000,2200,2500,2700,3000,3200,3500,3700,4000,4200,4500,4700,5000,5200,5500,5700,6000,6200,6500,6700,7000,7200,7500,7700,8000,8200,8500,8700,9000,9200,9500,9700,10000,10200,10500,10700,11000,11200,11500,11700,12000,12200,12500,12700,13000,13200,13500,13700,14000,14200,14500,14700,15000,15200,15500,15700,16000,16200,16500,16700,17000,17200,17500,17700,18000,18200,18500,18700,19000,19200,19500,19700,20000,20200,20500,20700,21000,21200,21500,21700,22000,22200,22230,22260,22290,22320,22350,22380,22410,22440,22470,22500,22530,22560,22590,22620,22650,22680,22710,22740,22770,22800,22830,22860,22890,22920,22950,22980,23000,23010,23040,23070,23100,23130,23160,23190,23220,23250,23280,23310,23340,23370,23400,23430,23460,23490,23500,23520,23550,23580,23610,23640,23670,23700,23730,23760,23790,23820,23850,23880,23910,23940,23970,24000,24030,24060,24090,24120,24150,24180,24210,24240,24270,24300,24330,24360,24390,24420,24450,24480,24510,24540,24570,24600,24630,24660,24690,24720,24750,24780,24810,24840,24870,24900,24930,24960,24990,25020,25050,25080,25110,25140,25170,25200,25230,25260,25290,25320,25350,25380,25410,25440,25470,25500,25530,25560,25590,25620,25650,25680,25710,25740,25770,25800,25830,25860,25890,25920,25950,25980,26010,26040,26070,26100,26130,26160,26190,26220,26250,26280,26310,26340,26370,26400,26430,26460,26490,26520,26550,26580,26610,26640,26670,26700,26730,26760,26790,26820,26850,26880,26910,26940,26970,27000,27030,27060,27090,27120,27150,27180,27210,27240,27270,27300,27330,27360,27390,27420,27450,27480,27510,27540,27570,27600,27630,27660,27690,27720,27750,27780,27810,27840,27870,27900,27930,27960,27990,28020,28050,28080,28110,28140,28170,28200,28230,28260,28290,28320,28350,28380,28410,28440,28470,28500,28530,28560,28590,28620,28650,28680,28710,28740,28770,28800,28830,28860,28890,28920,28950,28980,29010,29040,29070,29100,29130,29160,29190,29220,29250,29280,29310,29340,29370,29400,29430,29460,29490,29520,29550,29580,29610,29640,29670,29700,29730,29760,29790,29820,29850,29880,29910,29940,29970,30000,30030,30060,30090,30120,30150,30180,30210,30240,30270,30300,30330,30360,30390,30420,30450,30480,30510,30540,30570,30600,30630,30660,30690,30720,30750,30780,30810,30840,30870,30900,30930,30960,30990,31020,31050,31080,31110,31140,31170,31200,31230,31260,31290,31320,31350,31380,31410,31440,31470,31500,31530,31560,31590,31620,31650,31680,31710,31740,31770,31800,31830,31860,31890,31920,31950,31980,32010,32040,32070,32100,32130,32160,32190,32220,32250,32280,32310,32340,32370,32400,32430,32460,32490,32520,32550,32580,32610,32640,32670,32700,32730,32760,32790,32820,32850,32880,32910,32940,32970,33000,33030,33060,33090,33120,33150,33180,33210,33240,33270,33300,33330,33360,33390,33420,33450,33480,33510,33540,33570,33600,33630,33660,33690,33720,33750,33780,33810,33840,33870,33900,33930,33960,33990,34020,34050,34080,34110,34140,34170,34200,34230,34260,34290,34320,34350,34380,34410,34440,34470,34500,34530,34560,34590,34620,34650,34680,34710,34740,34770,34800,34830,34860,34890,34920,34950,34980,35010,35040,35070,35100,35130,35160,35190,35220,35250,35280,35310,35340,35370,35400,35430,35460,35490,35520,35550,35580,35610,35640,35670,35700,35730,35760,35790,35820,35850,35880,35910,35940,35970,36000,36030,36060,36090,36120,36150,36180,36210,36240,36270,36300,36330,36360,36390,36420,36450,36480,36510,36540,36570,36600,36630,36660,36690,36720,36750,36780,36810,36840,36870,36900,36930,36960,36990,37020,37050,37080,37110,37140,37170,37200,37230,37260,37290,37320,37350,37380,37410,37440,37470,37500,37530,37560,37590,37620,37650,37680,37710,37740,37770,37800,37830,37860,37890,37920,37950,37980,38010,38040,38070,38100,38130,38160,38190,38220,38250,38280,38310,38340,38370,38400,38430,38460,38490,38520,38550,38580,38610,38640,38670,38700,38730,38760,38790,38820,38850,38880,38910,38940,38970,39000,39030,39060,39090,39120,39150,39180,39210,39240,39270,39300,39330,39360,39390,39420,39450,39480,39510,39540,39570,39600,39630,39660,39690,39720,39750,39780,39810,39840,39870,39900,39930,39960,39990,40020,40050,40080,40110,40140,40170,40200,40230,40260,40290,40320,40350,40380,40410,40440,40470,40500,40530,40560,40590,40620,40650,40680,40710,40740,40770,40800,40830,40860,40890,40920,40950,40980,41010,41040,41070,41100,41130,41160,41190,41220,41250,41280,41310,41340,41370,41400,41430,41460,41490,41520,41550,41580,41610,41640,41670,41700,41730,41760,41790,41820,41850,41880,41910,41940,41970,42000,42030,42060,42090,42120,42150,42180,42210,42240,42270,42300,42330,42360,42390,42420,42450,42480,42510,42540,42570,42600,42630,42660,42690,42720,42750,42780,42810,42840,42870,42900,42930,42960,42990,43020,43050,43080,43110,43140,43170,43200,43230,43260,43290,43320,43350,43380,43410,43440,43470,43500,43530,43560,43590,43620,43650,43680,43710,43740,43770,43800,43830,43860,43890,43920,43950,43980,44010,44040,44070,44100,44130,44160,44190,44220,44250,44280,44310,44340,44370,44400,44430,44460,44490,44520,44550,44580,44610,44640,44670,44700,44730,44760,44790,44820,44850,44880,44910,44940,44970,45000,45030,45060,45090,45120,45150,45180,45210,45240,45270,45300,45330,45360,45390,45420,45450,45480,45510,45540,45570,45600,45630,45660,45690,45720,45750,45780,45810,45840,45870,45900,45930,45960,45990,46020,46050,46080,46110,46140,46170,46200,46230,46260,46290,46320,46350,46380,46410,46440,46470,46500,46530,46560,46590,46620,46650,46680,46710,46740,46770,46800,46830,46860,46890,46920,46950,46980,47010,47040,47070,47100,47130,47160,47190,47220,47250,47280,47310,47340,47370,47400,47430,47460,47490,47520,47550,47580,47610,47640,47670,47700,47730,47760,47790,47820,47850,47880,47910,47940,47970,48000,48030,48060,48090,48120,48150,48180,48210,48240,48270,48300,48330,48360,48390,48420,48450,48480,48510,48540,48570,48600,48630,48660,48690,48720,48750,48780,48810,48840,48870,48900,48930,48960,48990,49020,49050,49080,49110,49140,49170,49200,49230,49260,49290,49320,49350,49380,49410,49440,49470,49500,49530,49560,49590,49620,49650,49680,49710,49740,49770,49800,49830,49860,49890,49920,49950,49980,50010,50040,50070,50100,50130,50160,50190,50220,50250,50280,50310,50340,50370,50400,50430,50460,50490,50520,50550,50580,50610,50640,50670,50700,50730,50760,50790,50820,50850,50880,50910,50940,50970,51000,51030,51060,51090,51120,51150,51180,51210,51240,51270,51300,51330,51360,51390,51420,51450,51480,51510,51540,51570,51600,51630,51660,51690,51720,51750,51780,51810,51840,51870,51900,51930,51960,51990,52020,52050,52080,52110,52140,52170,52200,52230,52260,52290,52320,52350,52380,52410,52440,52470,52500,52530,52560,52590,52620,52650,52680,52710,52740,52770,52800,52830,52860,52890,52920,52950,52980,53010,53040,53070,53100,53130,53160,53190,53220,53250,53280,53310,53340,53370,53400,53430,53460,53490,53520,53550,53580,53610,53640,53670,53700,53730,53760,53790,53820,53850,53880,53910,53940,53970,54000,54030,54060,54090,54120,54150,54180,54210,54240,54270,54300,54330,54360,54390,54420,54450,54480,54510,54540,54570,54600,54630,54660,54690,54720,54750,54780,54810,54840,54870,54900,54930,54960,54990,55020,55050,55080,55110,55140,55170,55200,55230,55260,55290,55320,55350,55380,55410,55440,55470,55500,55530,55560,55590,55620,55650,55680,55710,55740,55770,55800,55830,55860,55890,55920,55950,55980,56010,56040,56070,56100,56130,56160,56190,56220,56250,56280,56310,56340,56370,56400,56430,56460,56490,56520,56550,56580,56610,56640,56670,56700,56730,56760,56790,56820,56850,56880,56910,56940,56970,57000,57030,57060,57090,57120,57150,57180,57210,57240,57270,57300,57330,57360,57390,57420,57450,57480,57510,57540,57570,57600,57630,57660,57690,57720,57750,57780,57810,57840,57870,57900,57930,57960,57990,58020,58050,58080,58110,58140,58170,58200,58230,58260,58290,58320,58350,58380,58410,58440,58470,58500,58530,58560,58590,58620,58650,58680,58710,58740,58770,58800,58830,58860,58890,58920,58950,58980,59010,59040,59070,59100,59130,59160,59190,59220,59250,59280,59310,59340,59370,59400,59430,59460,59490,59520,59550,59580,59610,59640,59670,59700,59730,59760,59790,59820,59850,59880,59910,59940,59970,60000,60030,60060,60090,60120,60150,60180,60210,60240,60270,60300,60330,60360,60390,60420,60450,60480,60510,60540,60570,60600,60630,60660,60690,60720,60750,60780,60810,60840,60870,60900,60930,60960,60990,61020,61050,61080,61110,61140,61170,61200,61230,61260,61290,61320,61350,61380,61410,61440,61470,61500,61530,61560,61590,61620,61650,61680,61710,61740,61770,61800,61830,61860,61890,61920,61950,61980};
                	_paFrame_NextEvent = new frame[1419];
                	memcpy(_paFrame_NextEvent, f, sizeof(f));
                	_event_num = 1419;
                	orderActorToFactory(40000000, EnemyAstraea, "Astraea_1");
                	
                	orderActorToFactory(40000002, FormationPallas001a, "F001a_Pallas_2");
                	orderActorToFactory(40000003, FormationPallas001b, "F001b_Pallas_3");
                	orderActorToFactory(40000004, FormationPallas001c, "F001c_Pallas_4");
                	orderActorToFactory(40000005, FormationPallas001d, "F001d_Pallas_5");
                	orderActorToFactory(40000006, FormationPallas001a, "F001a_Pallas_6");
                	orderActorToFactory(40000007, FormationPallas001d, "F001d_Pallas_7");
                	orderActorToFactory(40000008, FormationPallas001b, "F001b_Pallas_8");
                	orderActorToFactory(40000009, FormationPallas001c, "F001c_Pallas_9");
                	orderActorToFactory(40000010, FormationPallas001a, "F001a_Pallas_10");
                	orderActorToFactory(40000011, FormationPallas001d, "F001d_Pallas_11");
                	orderActorToFactory(40000012, FormationPallas001b, "F001b_Pallas_12");
                	orderActorToFactory(40000013, FormationPallas001c, "F001c_Pallas_13");
                	orderActorToFactory(40000014, EnemyAstraea, "Astraea_14");
                	orderActorToFactory(40000015, EnemyAstraea, "Astraea_15");
                	orderActorToFactory(40000021, EnemyMetis, "Metis_16");
                	orderActorToFactory(40000022, EnemyMetis, "Metis_17");
                    // gen01 end
                }
                
                void Stage01_02::initialize() {
                
                }
                
                void Stage01_02::processBehavior() {
                    //  gen02 start ` end Excel}NR[hB
                    // R[hXuV[Creater.xlsvsimjB
                    // gen02 start
                	if (getActivePartFrame() == _paFrame_NextEvent[_iCnt_Event]) {
                		switch (getActivePartFrame()) {
                			case 1: {
                				break;
                			}
                			case 100: {
                				EnemyAstraea* pAstraea = (EnemyAstraea*)obtainActorFromFactory(40000000);
                				getLordActor()->addSubGroup(pAstraea);
                				pAstraea->_Z = -1800000;
                				pAstraea->_Y = -100000;
                				{
                				ActorTableScene* ta = NEW ActorTableScene("TableScene_40000001");
                				ta->setMaxPerformFrame(2500);
                				addSubLast(ta);
                				ta->addToTable(((FormationPallas001a*)obtainActorFromFactory(40000002)), 400);
                				ta->addToTable(((FormationPallas001b*)obtainActorFromFactory(40000003)), 400);
                				ta->addToTable(((FormationPallas001c*)obtainActorFromFactory(40000004)), 400);
                				ta->addToTable(((FormationPallas001d*)obtainActorFromFactory(40000005)), 400);
                				ta->addToTable(((FormationPallas001a*)obtainActorFromFactory(40000006)), 1);
                				ta->addToTable(((FormationPallas001d*)obtainActorFromFactory(40000007)), 400);
                				ta->addToTable(((FormationPallas001b*)obtainActorFromFactory(40000008)), 1);
                				ta->addToTable(((FormationPallas001c*)obtainActorFromFactory(40000009)), 400);
                				ta->addToTable(((FormationPallas001a*)obtainActorFromFactory(40000010)), 1);
                				ta->addToTable(((FormationPallas001d*)obtainActorFromFactory(40000011)), 1);
                				ta->addToTable(((FormationPallas001b*)obtainActorFromFactory(40000012)), 1);
                				ta->addToTable(((FormationPallas001c*)obtainActorFromFactory(40000013)), 400);
                				}
                				break;
                			}
                			case 200: {
                				orderActorToFactory(40000023, EnemyMetis, "Metis_18");
                				orderActorToFactory(40001339, FormationThalia, "FormationThalia_19");
                				break;
                			}
                			case 500: {
                				EnemyAstraea* pAstraea2 = (EnemyAstraea*)obtainActorFromFactory(40000014);
                				getLordActor()->addSubGroup(pAstraea2);
                				pAstraea2->_Z = -1800000;
                				pAstraea2->_Y = -100000;
                				break;
                			}
                			case 700: {
                				orderActorToFactory(40000016, EnemyAstraea, "Astraea_20");
                				orderActorToFactory(40000024, EnemyMetis, "Metis_21");
                				break;
                			}
                			case 1000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000021);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 1200: {
                				orderActorToFactory(40000017, VarietyTorus001, "VarietyTorus001_22");
                				orderActorToFactory(40000025, EnemyMetis, "Metis_23");
                				break;
                			}
                			case 1500: {
                				EnemyAstraea* pAstraea2 = (EnemyAstraea*)obtainActorFromFactory(40000015);
                				getLordActor()->addSubGroup(pAstraea2);
                				pAstraea2->_Z = -1800000;
                				pAstraea2->_Y = -100000;
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000022);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 1700: {
                				orderActorToFactory(40000026, EnemyMetis, "Metis_24");
                				break;
                			}
                			case 2000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000023);
                				getLordActor()->addSubGroup(pMetis1);
                				FormationThalia* pF = (FormationThalia*)obtainActorFromFactory(40001339);
                				getLordActor()->addSubGroup(pF);
                				break;
                			}
                			case 2200: {
                				orderActorToFactory(40000027, EnemyMetis, "Metis_25");
                				orderActorToFactory(40001337, FormationIris002, "F002_Iris_26");
                				break;
                			}
                			case 2500: {
                				EnemyAstraea* pAstraea2 = (EnemyAstraea*)obtainActorFromFactory(40000016);
                				getLordActor()->addSubGroup(pAstraea2);
                				pAstraea2->_Z = -1800000;
                				pAstraea2->_Y = -100000;
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000024);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 2700: {
                				orderActorToFactory(40000028, EnemyMetis, "Metis_27");
                				orderActorToFactory(40001338, FormationIris002, "F002_Iris_28");
                				break;
                			}
                			case 3000: {
                				VarietyTorus001* pTorus = (VarietyTorus001*)obtainActorFromFactory(40000017);
                				getLordActor()->addSubGroup(pTorus);
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000025);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 3200: {
                				orderActorToFactory(40000029, EnemyMetis, "Metis_29");
                				orderActorToFactory(40001335, FormationJuno001, "F002_Juno_30");
                				break;
                			}
                			case 3500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000026);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 3700: {
                				orderActorToFactory(40000030, EnemyMetis, "Metis_31");
                				break;
                			}
                			case 4000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000027);
                				getLordActor()->addSubGroup(pMetis1);
                				FormationIris002* pF1 = (FormationIris002*)obtainActorFromFactory(40001337);
                				getLordActor()->addSubGroup(pF1);
                				break;
                			}
                			case 4200: {
                				orderActorToFactory(40000031, EnemyMetis, "Metis_32");
                				break;
                			}
                			case 4500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000028);
                				getLordActor()->addSubGroup(pMetis1);
                				FormationIris002* pF2 = (FormationIris002*)obtainActorFromFactory(40001338);
                				getLordActor()->addSubGroup(pF2);
                				break;
                			}
                			case 4700: {
                				orderActorToFactory(40000032, EnemyMetis, "Metis_33");
                				break;
                			}
                			case 5000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000029);
                				getLordActor()->addSubGroup(pMetis1);
                				FormationJuno001* pF = (FormationJuno001*)obtainActorFromFactory(40001335);
                				getLordActor()->addSubGroup(pF);
                				break;
                			}
                			case 5200: {
                				orderActorToFactory(40000033, EnemyMetis, "Metis_34");
                				break;
                			}
                			case 5500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000030);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 5700: {
                				orderActorToFactory(40000034, EnemyMetis, "Metis_35");
                				break;
                			}
                			case 6000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000031);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 6200: {
                				orderActorToFactory(40000035, EnemyMetis, "Metis_36");
                				break;
                			}
                			case 6500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000032);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 6700: {
                				orderActorToFactory(40000036, EnemyMetis, "Metis_37");
                				break;
                			}
                			case 7000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000033);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 7200: {
                				orderActorToFactory(40000037, EnemyMetis, "Metis_38");
                				break;
                			}
                			case 7500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000034);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 7700: {
                				orderActorToFactory(40000038, EnemyMetis, "Metis_39");
                				break;
                			}
                			case 8000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000035);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 8200: {
                				orderActorToFactory(40000018, VarietyTorus002, "VarietyTorus002_40");
                				orderActorToFactory(40000019, VarietyTorus003, "VarietyTorus003_41");
                				orderActorToFactory(40000039, EnemyMetis, "Metis_42");
                				break;
                			}
                			case 8500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000036);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 8700: {
                				orderActorToFactory(40000040, EnemyMetis, "Metis_43");
                				break;
                			}
                			case 9000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000037);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 9200: {
                				orderActorToFactory(40000041, EnemyMetis, "Metis_44");
                				break;
                			}
                			case 9500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000038);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 9700: {
                				orderActorToFactory(40000042, EnemyMetis, "Metis_45");
                				break;
                			}
                			case 10000: {
                				VarietyTorus002* pTorusA = (VarietyTorus002*)obtainActorFromFactory(40000018);
                				getLordActor()->addSubGroup(pTorusA);
                				VarietyTorus003* pTorusB = (VarietyTorus003*)obtainActorFromFactory(40000019);
                				getLordActor()->addSubGroup(pTorusB);
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000039);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 10200: {
                				orderActorToFactory(40000043, EnemyMetis, "Metis_46");
                				break;
                			}
                			case 10500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000040);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 10700: {
                				orderActorToFactory(40000044, EnemyMetis, "Metis_47");
                				break;
                			}
                			case 11000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000041);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 11200: {
                				orderActorToFactory(40000045, EnemyMetis, "Metis_48");
                				orderActorToFactory(40001336, FormationJuno001, "F002_Juno_49");
                				break;
                			}
                			case 11500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000042);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 11700: {
                				orderActorToFactory(40000046, EnemyMetis, "Metis_50");
                				break;
                			}
                			case 12000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000043);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 12200: {
                				orderActorToFactory(40000047, EnemyMetis, "Metis_51");
                				break;
                			}
                			case 12500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000044);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 12700: {
                				orderActorToFactory(40000048, EnemyMetis, "Metis_52");
                				break;
                			}
                			case 13000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000045);
                				getLordActor()->addSubGroup(pMetis1);
                				FormationJuno001* pF = (FormationJuno001*)obtainActorFromFactory(40001336);
                				getLordActor()->addSubGroup(pF);
                				break;
                			}
                			case 13200: {
                				orderActorToFactory(40000049, EnemyMetis, "Metis_53");
                				break;
                			}
                			case 13500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000046);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 13700: {
                				orderActorToFactory(40000050, EnemyMetis, "Metis_54");
                				break;
                			}
                			case 14000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000047);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 14200: {
                				orderActorToFactory(40000051, EnemyMetis, "Metis_55");
                				break;
                			}
                			case 14500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000048);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 14700: {
                				orderActorToFactory(40000052, EnemyMetis, "Metis_56");
                				break;
                			}
                			case 15000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000049);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 15200: {
                				orderActorToFactory(40000053, EnemyMetis, "Metis_57");
                				orderActorToFactory(40001340, FormationThalia, "FormationThalia_58");
                				break;
                			}
                			case 15500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000050);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 15700: {
                				orderActorToFactory(40000054, EnemyMetis, "Metis_59");
                				break;
                			}
                			case 16000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000051);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 16200: {
                				orderActorToFactory(40000055, EnemyMetis, "Metis_60");
                				break;
                			}
                			case 16500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000052);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 16700: {
                				orderActorToFactory(40000056, EnemyMetis, "Metis_61");
                				break;
                			}
                			case 17000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000053);
                				getLordActor()->addSubGroup(pMetis1);
                				FormationThalia* pF = (FormationThalia*)obtainActorFromFactory(40001340);
                				getLordActor()->addSubGroup(pF);
                				break;
                			}
                			case 17200: {
                				orderActorToFactory(40000057, EnemyMetis, "Metis_62");
                				orderActorToFactory(40001341, FormationThalia, "FormationThalia_63");
                				break;
                			}
                			case 17500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000054);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 17700: {
                				orderActorToFactory(40000058, EnemyMetis, "Metis_64");
                				break;
                			}
                			case 18000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000055);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 18200: {
                				orderActorToFactory(40000020, VarietyTorus004, "VarietyTorus004_65");
                				orderActorToFactory(40000059, EnemyMetis, "Metis_66");
                				break;
                			}
                			case 18500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000056);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 18700: {
                				orderActorToFactory(40000060, EnemyMetis, "Metis_67");
                				break;
                			}
                			case 19000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000057);
                				getLordActor()->addSubGroup(pMetis1);
                				FormationThalia* pF = (FormationThalia*)obtainActorFromFactory(40001341);
                				getLordActor()->addSubGroup(pF);
                				break;
                			}
                			case 19200: {
                				orderActorToFactory(40000061, EnemyMetis, "Metis_68");
                				break;
                			}
                			case 19500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000058);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 19700: {
                				orderActorToFactory(40000062, EnemyMetis, "Metis_69");
                				break;
                			}
                			case 20000: {
                				VarietyTorus004* pTorus = (VarietyTorus004*)obtainActorFromFactory(40000020);
                				getLordActor()->addSubGroup(pTorus);
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000059);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 20200: {
                				orderActorToFactory(40000063, EnemyMetis, "Metis_70");
                				break;
                			}
                			case 20500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000060);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 20700: {
                				orderActorToFactory(40000064, EnemyMetis, "Metis_71");
                				break;
                			}
                			case 21000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000061);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 21200: {
                				orderActorToFactory(40000065, EnemyMetis, "Metis_72");
                				break;
                			}
                			case 21500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000062);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 21700: {
                				orderActorToFactory(40000066, EnemyMetis, "Metis_73");
                				break;
                			}
                			case 22000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000063);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 22200: {
                				orderActorToFactory(40000067, EnemyMetis, "Metis_74");
                				orderActorToFactory(40000068, EnemyMetis, "Metis_75");
                				break;
                			}
                			case 22230: {
                				orderActorToFactory(40000069, EnemyMetis, "Metis_76");
                				break;
                			}
                			case 22260: {
                				orderActorToFactory(40000070, EnemyMetis, "Metis_77");
                				break;
                			}
                			case 22290: {
                				orderActorToFactory(40000071, EnemyMetis, "Metis_78");
                				break;
                			}
                			case 22320: {
                				orderActorToFactory(40000072, EnemyMetis, "Metis_79");
                				break;
                			}
                			case 22350: {
                				orderActorToFactory(40000073, EnemyMetis, "Metis_80");
                				break;
                			}
                			case 22380: {
                				orderActorToFactory(40000074, EnemyMetis, "Metis_81");
                				break;
                			}
                			case 22410: {
                				orderActorToFactory(40000075, EnemyMetis, "Metis_82");
                				break;
                			}
                			case 22440: {
                				orderActorToFactory(40000076, EnemyMetis, "Metis_83");
                				break;
                			}
                			case 22470: {
                				orderActorToFactory(40000077, EnemyMetis, "Metis_84");
                				break;
                			}
                			case 22500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000064);
                				getLordActor()->addSubGroup(pMetis1);
                				orderActorToFactory(40000078, EnemyMetis, "Metis_85");
                				break;
                			}
                			case 22530: {
                				orderActorToFactory(40000079, EnemyMetis, "Metis_86");
                				break;
                			}
                			case 22560: {
                				orderActorToFactory(40000080, EnemyMetis, "Metis_87");
                				break;
                			}
                			case 22590: {
                				orderActorToFactory(40000081, EnemyMetis, "Metis_88");
                				break;
                			}
                			case 22620: {
                				orderActorToFactory(40000082, EnemyMetis, "Metis_89");
                				break;
                			}
                			case 22650: {
                				orderActorToFactory(40000083, EnemyMetis, "Metis_90");
                				break;
                			}
                			case 22680: {
                				orderActorToFactory(40000084, EnemyMetis, "Metis_91");
                				break;
                			}
                			case 22710: {
                				orderActorToFactory(40000085, EnemyMetis, "Metis_92");
                				break;
                			}
                			case 22740: {
                				orderActorToFactory(40000086, EnemyMetis, "Metis_93");
                				break;
                			}
                			case 22770: {
                				orderActorToFactory(40000087, EnemyMetis, "Metis_94");
                				break;
                			}
                			case 22800: {
                				orderActorToFactory(40000088, EnemyMetis, "Metis_95");
                				break;
                			}
                			case 22830: {
                				orderActorToFactory(40000089, EnemyMetis, "Metis_96");
                				break;
                			}
                			case 22860: {
                				orderActorToFactory(40000090, EnemyMetis, "Metis_97");
                				break;
                			}
                			case 22890: {
                				orderActorToFactory(40000091, EnemyMetis, "Metis_98");
                				break;
                			}
                			case 22920: {
                				orderActorToFactory(40000092, EnemyMetis, "Metis_99");
                				break;
                			}
                			case 22950: {
                				orderActorToFactory(40000093, EnemyMetis, "Metis_100");
                				break;
                			}
                			case 22980: {
                				orderActorToFactory(40000094, EnemyMetis, "Metis_101");
                				break;
                			}
                			case 23000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000065);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 23010: {
                				orderActorToFactory(40000095, EnemyMetis, "Metis_102");
                				break;
                			}
                			case 23040: {
                				orderActorToFactory(40000096, EnemyMetis, "Metis_103");
                				break;
                			}
                			case 23070: {
                				orderActorToFactory(40000097, EnemyMetis, "Metis_104");
                				break;
                			}
                			case 23100: {
                				orderActorToFactory(40000098, EnemyMetis, "Metis_105");
                				break;
                			}
                			case 23130: {
                				orderActorToFactory(40000099, EnemyMetis, "Metis_106");
                				break;
                			}
                			case 23160: {
                				orderActorToFactory(40000100, EnemyMetis, "Metis_107");
                				break;
                			}
                			case 23190: {
                				orderActorToFactory(40000101, EnemyMetis, "Metis_108");
                				break;
                			}
                			case 23220: {
                				orderActorToFactory(40000102, EnemyMetis, "Metis_109");
                				break;
                			}
                			case 23250: {
                				orderActorToFactory(40000103, EnemyMetis, "Metis_110");
                				break;
                			}
                			case 23280: {
                				orderActorToFactory(40000104, EnemyMetis, "Metis_111");
                				break;
                			}
                			case 23310: {
                				orderActorToFactory(40000105, EnemyMetis, "Metis_112");
                				break;
                			}
                			case 23340: {
                				orderActorToFactory(40000106, EnemyMetis, "Metis_113");
                				break;
                			}
                			case 23370: {
                				orderActorToFactory(40000107, EnemyMetis, "Metis_114");
                				break;
                			}
                			case 23400: {
                				orderActorToFactory(40000108, EnemyMetis, "Metis_115");
                				break;
                			}
                			case 23430: {
                				orderActorToFactory(40000109, EnemyMetis, "Metis_116");
                				break;
                			}
                			case 23460: {
                				orderActorToFactory(40000110, EnemyMetis, "Metis_117");
                				break;
                			}
                			case 23490: {
                				orderActorToFactory(40000111, EnemyMetis, "Metis_118");
                				break;
                			}
                			case 23500: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000066);
                				getLordActor()->addSubGroup(pMetis1);
                				break;
                			}
                			case 23520: {
                				orderActorToFactory(40000112, EnemyMetis, "Metis_119");
                				break;
                			}
                			case 23550: {
                				orderActorToFactory(40000113, EnemyMetis, "Metis_120");
                				break;
                			}
                			case 23580: {
                				orderActorToFactory(40000114, EnemyMetis, "Metis_121");
                				break;
                			}
                			case 23610: {
                				orderActorToFactory(40000115, EnemyMetis, "Metis_122");
                				break;
                			}
                			case 23640: {
                				orderActorToFactory(40000116, EnemyMetis, "Metis_123");
                				break;
                			}
                			case 23670: {
                				orderActorToFactory(40000117, EnemyMetis, "Metis_124");
                				break;
                			}
                			case 23700: {
                				orderActorToFactory(40000118, EnemyMetis, "Metis_125");
                				break;
                			}
                			case 23730: {
                				orderActorToFactory(40000119, EnemyMetis, "Metis_126");
                				break;
                			}
                			case 23760: {
                				orderActorToFactory(40000120, EnemyMetis, "Metis_127");
                				break;
                			}
                			case 23790: {
                				orderActorToFactory(40000121, EnemyMetis, "Metis_128");
                				break;
                			}
                			case 23820: {
                				orderActorToFactory(40000122, EnemyMetis, "Metis_129");
                				break;
                			}
                			case 23850: {
                				orderActorToFactory(40000123, EnemyMetis, "Metis_130");
                				break;
                			}
                			case 23880: {
                				orderActorToFactory(40000124, EnemyMetis, "Metis_131");
                				break;
                			}
                			case 23910: {
                				orderActorToFactory(40000125, EnemyMetis, "Metis_132");
                				break;
                			}
                			case 23940: {
                				orderActorToFactory(40000126, EnemyMetis, "Metis_133");
                				break;
                			}
                			case 23970: {
                				orderActorToFactory(40000127, EnemyMetis, "Metis_134");
                				break;
                			}
                			case 24000: {
                				EnemyMetis* pMetis1 = (EnemyMetis*)obtainActorFromFactory(40000067);
                				getLordActor()->addSubGroup(pMetis1);
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000068);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000128, EnemyMetis, "Metis_135");
                				break;
                			}
                			case 24030: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000069);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000129, EnemyMetis, "Metis_136");
                				break;
                			}
                			case 24060: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000070);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000130, EnemyMetis, "Metis_137");
                				break;
                			}
                			case 24090: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000071);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000131, EnemyMetis, "Metis_138");
                				break;
                			}
                			case 24120: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000072);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000132, EnemyMetis, "Metis_139");
                				break;
                			}
                			case 24150: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000073);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000133, EnemyMetis, "Metis_140");
                				break;
                			}
                			case 24180: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000074);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000134, EnemyMetis, "Metis_141");
                				break;
                			}
                			case 24210: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000075);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000135, EnemyMetis, "Metis_142");
                				break;
                			}
                			case 24240: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000076);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000136, EnemyMetis, "Metis_143");
                				break;
                			}
                			case 24270: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000077);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000137, EnemyMetis, "Metis_144");
                				break;
                			}
                			case 24300: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000078);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000138, EnemyMetis, "Metis_145");
                				break;
                			}
                			case 24330: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000079);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000139, EnemyMetis, "Metis_146");
                				break;
                			}
                			case 24360: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000080);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000140, EnemyMetis, "Metis_147");
                				break;
                			}
                			case 24390: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000081);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000141, EnemyMetis, "Metis_148");
                				break;
                			}
                			case 24420: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000082);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000142, EnemyMetis, "Metis_149");
                				break;
                			}
                			case 24450: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000083);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000143, EnemyMetis, "Metis_150");
                				break;
                			}
                			case 24480: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000084);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000144, EnemyMetis, "Metis_151");
                				break;
                			}
                			case 24510: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000085);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000145, EnemyMetis, "Metis_152");
                				break;
                			}
                			case 24540: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000086);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000146, EnemyMetis, "Metis_153");
                				break;
                			}
                			case 24570: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000087);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000147, EnemyMetis, "Metis_154");
                				break;
                			}
                			case 24600: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000088);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000148, EnemyMetis, "Metis_155");
                				break;
                			}
                			case 24630: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000089);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000149, EnemyMetis, "Metis_156");
                				break;
                			}
                			case 24660: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000090);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000150, EnemyMetis, "Metis_157");
                				break;
                			}
                			case 24690: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000091);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000151, EnemyMetis, "Metis_158");
                				break;
                			}
                			case 24720: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000092);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000152, EnemyMetis, "Metis_159");
                				break;
                			}
                			case 24750: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000093);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000153, EnemyMetis, "Metis_160");
                				break;
                			}
                			case 24780: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000094);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000154, EnemyMetis, "Metis_161");
                				break;
                			}
                			case 24810: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000095);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000155, EnemyMetis, "Metis_162");
                				break;
                			}
                			case 24840: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000096);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000156, EnemyMetis, "Metis_163");
                				break;
                			}
                			case 24870: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000097);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000157, EnemyMetis, "Metis_164");
                				break;
                			}
                			case 24900: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000098);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000158, EnemyMetis, "Metis_165");
                				break;
                			}
                			case 24930: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000099);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000159, EnemyMetis, "Metis_166");
                				break;
                			}
                			case 24960: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000100);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000160, EnemyMetis, "Metis_167");
                				break;
                			}
                			case 24990: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000101);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000161, EnemyMetis, "Metis_168");
                				break;
                			}
                			case 25020: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000102);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000162, EnemyMetis, "Metis_169");
                				break;
                			}
                			case 25050: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000103);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000163, EnemyMetis, "Metis_170");
                				break;
                			}
                			case 25080: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000104);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000164, EnemyMetis, "Metis_171");
                				break;
                			}
                			case 25110: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000105);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000165, EnemyMetis, "Metis_172");
                				break;
                			}
                			case 25140: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000106);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000166, EnemyMetis, "Metis_173");
                				break;
                			}
                			case 25170: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000107);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000167, EnemyMetis, "Metis_174");
                				break;
                			}
                			case 25200: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000108);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000168, EnemyMetis, "Metis_175");
                				break;
                			}
                			case 25230: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000109);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000169, EnemyMetis, "Metis_176");
                				break;
                			}
                			case 25260: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000110);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000170, EnemyMetis, "Metis_177");
                				break;
                			}
                			case 25290: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000111);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000171, EnemyMetis, "Metis_178");
                				break;
                			}
                			case 25320: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000112);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000172, EnemyMetis, "Metis_179");
                				break;
                			}
                			case 25350: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000113);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000173, EnemyMetis, "Metis_180");
                				break;
                			}
                			case 25380: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000114);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000174, EnemyMetis, "Metis_181");
                				break;
                			}
                			case 25410: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000115);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000175, EnemyMetis, "Metis_182");
                				break;
                			}
                			case 25440: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000116);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000176, EnemyMetis, "Metis_183");
                				break;
                			}
                			case 25470: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000117);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000177, EnemyMetis, "Metis_184");
                				break;
                			}
                			case 25500: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000118);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000178, EnemyMetis, "Metis_185");
                				break;
                			}
                			case 25530: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000119);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000179, EnemyMetis, "Metis_186");
                				break;
                			}
                			case 25560: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000120);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000180, EnemyMetis, "Metis_187");
                				break;
                			}
                			case 25590: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000121);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000181, EnemyMetis, "Metis_188");
                				break;
                			}
                			case 25620: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000122);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000182, EnemyMetis, "Metis_189");
                				break;
                			}
                			case 25650: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000123);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000183, EnemyMetis, "Metis_190");
                				break;
                			}
                			case 25680: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000124);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000184, EnemyMetis, "Metis_191");
                				break;
                			}
                			case 25710: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000125);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000185, EnemyMetis, "Metis_192");
                				break;
                			}
                			case 25740: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000126);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000186, EnemyMetis, "Metis_193");
                				break;
                			}
                			case 25770: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000127);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000187, EnemyMetis, "Metis_194");
                				break;
                			}
                			case 25800: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000128);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000188, EnemyMetis, "Metis_195");
                				break;
                			}
                			case 25830: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000129);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000189, EnemyMetis, "Metis_196");
                				break;
                			}
                			case 25860: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000130);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000190, EnemyMetis, "Metis_197");
                				break;
                			}
                			case 25890: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000131);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000191, EnemyMetis, "Metis_198");
                				break;
                			}
                			case 25920: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000132);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000192, EnemyMetis, "Metis_199");
                				break;
                			}
                			case 25950: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000133);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000193, EnemyMetis, "Metis_200");
                				break;
                			}
                			case 25980: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000134);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000194, EnemyMetis, "Metis_201");
                				break;
                			}
                			case 26010: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000135);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000195, EnemyMetis, "Metis_202");
                				break;
                			}
                			case 26040: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000136);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000196, EnemyMetis, "Metis_203");
                				break;
                			}
                			case 26070: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000137);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000197, EnemyMetis, "Metis_204");
                				break;
                			}
                			case 26100: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000138);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000198, EnemyMetis, "Metis_205");
                				break;
                			}
                			case 26130: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000139);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000199, EnemyMetis, "Metis_206");
                				break;
                			}
                			case 26160: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000140);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000200, EnemyMetis, "Metis_207");
                				break;
                			}
                			case 26190: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000141);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000201, EnemyMetis, "Metis_208");
                				break;
                			}
                			case 26220: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000142);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000202, EnemyMetis, "Metis_209");
                				break;
                			}
                			case 26250: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000143);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000203, EnemyMetis, "Metis_210");
                				break;
                			}
                			case 26280: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000144);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000204, EnemyMetis, "Metis_211");
                				break;
                			}
                			case 26310: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000145);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000205, EnemyMetis, "Metis_212");
                				break;
                			}
                			case 26340: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000146);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000206, EnemyMetis, "Metis_213");
                				break;
                			}
                			case 26370: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000147);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000207, EnemyMetis, "Metis_214");
                				break;
                			}
                			case 26400: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000148);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000208, EnemyMetis, "Metis_215");
                				break;
                			}
                			case 26430: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000149);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000209, EnemyMetis, "Metis_216");
                				break;
                			}
                			case 26460: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000150);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000210, EnemyMetis, "Metis_217");
                				break;
                			}
                			case 26490: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000151);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000211, EnemyMetis, "Metis_218");
                				break;
                			}
                			case 26520: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000152);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000212, EnemyMetis, "Metis_219");
                				break;
                			}
                			case 26550: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000153);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000213, EnemyMetis, "Metis_220");
                				break;
                			}
                			case 26580: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000154);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000214, EnemyMetis, "Metis_221");
                				break;
                			}
                			case 26610: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000155);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000215, EnemyMetis, "Metis_222");
                				break;
                			}
                			case 26640: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000156);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000216, EnemyMetis, "Metis_223");
                				break;
                			}
                			case 26670: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000157);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000217, EnemyMetis, "Metis_224");
                				break;
                			}
                			case 26700: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000158);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000218, EnemyMetis, "Metis_225");
                				break;
                			}
                			case 26730: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000159);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000219, EnemyMetis, "Metis_226");
                				break;
                			}
                			case 26760: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000160);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000220, EnemyMetis, "Metis_227");
                				break;
                			}
                			case 26790: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000161);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000221, EnemyMetis, "Metis_228");
                				break;
                			}
                			case 26820: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000162);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000222, EnemyMetis, "Metis_229");
                				break;
                			}
                			case 26850: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000163);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000223, EnemyMetis, "Metis_230");
                				break;
                			}
                			case 26880: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000164);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000224, EnemyMetis, "Metis_231");
                				break;
                			}
                			case 26910: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000165);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000225, EnemyMetis, "Metis_232");
                				break;
                			}
                			case 26940: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000166);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000226, EnemyMetis, "Metis_233");
                				break;
                			}
                			case 26970: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000167);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000227, EnemyMetis, "Metis_234");
                				break;
                			}
                			case 27000: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000168);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000228, EnemyMetis, "Metis_235");
                				break;
                			}
                			case 27030: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000169);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000229, EnemyMetis, "Metis_236");
                				break;
                			}
                			case 27060: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000170);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000230, EnemyMetis, "Metis_237");
                				break;
                			}
                			case 27090: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000171);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000231, EnemyMetis, "Metis_238");
                				break;
                			}
                			case 27120: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000172);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000232, EnemyMetis, "Metis_239");
                				break;
                			}
                			case 27150: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000173);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000233, EnemyMetis, "Metis_240");
                				break;
                			}
                			case 27180: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000174);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000234, EnemyMetis, "Metis_241");
                				break;
                			}
                			case 27210: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000175);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000235, EnemyMetis, "Metis_242");
                				break;
                			}
                			case 27240: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000176);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000236, EnemyMetis, "Metis_243");
                				break;
                			}
                			case 27270: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000177);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000237, EnemyMetis, "Metis_244");
                				break;
                			}
                			case 27300: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000178);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000238, EnemyMetis, "Metis_245");
                				break;
                			}
                			case 27330: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000179);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000239, EnemyMetis, "Metis_246");
                				break;
                			}
                			case 27360: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000180);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000240, EnemyMetis, "Metis_247");
                				break;
                			}
                			case 27390: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000181);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000241, EnemyMetis, "Metis_248");
                				break;
                			}
                			case 27420: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000182);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000242, EnemyMetis, "Metis_249");
                				break;
                			}
                			case 27450: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000183);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000243, EnemyMetis, "Metis_250");
                				break;
                			}
                			case 27480: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000184);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000244, EnemyMetis, "Metis_251");
                				break;
                			}
                			case 27510: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000185);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000245, EnemyMetis, "Metis_252");
                				break;
                			}
                			case 27540: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000186);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000246, EnemyMetis, "Metis_253");
                				break;
                			}
                			case 27570: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000187);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000247, EnemyMetis, "Metis_254");
                				break;
                			}
                			case 27600: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000188);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000248, EnemyMetis, "Metis_255");
                				break;
                			}
                			case 27630: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000189);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000249, EnemyMetis, "Metis_256");
                				break;
                			}
                			case 27660: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000190);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000250, EnemyMetis, "Metis_257");
                				break;
                			}
                			case 27690: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000191);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000251, EnemyMetis, "Metis_258");
                				break;
                			}
                			case 27720: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000192);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000252, EnemyMetis, "Metis_259");
                				break;
                			}
                			case 27750: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000193);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000253, EnemyMetis, "Metis_260");
                				break;
                			}
                			case 27780: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000194);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000254, EnemyMetis, "Metis_261");
                				break;
                			}
                			case 27810: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000195);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000255, EnemyMetis, "Metis_262");
                				break;
                			}
                			case 27840: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000196);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000256, EnemyMetis, "Metis_263");
                				break;
                			}
                			case 27870: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000197);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000257, EnemyMetis, "Metis_264");
                				break;
                			}
                			case 27900: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000198);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000258, EnemyMetis, "Metis_265");
                				break;
                			}
                			case 27930: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000199);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000259, EnemyMetis, "Metis_266");
                				break;
                			}
                			case 27960: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000200);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000260, EnemyMetis, "Metis_267");
                				break;
                			}
                			case 27990: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000201);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000261, EnemyMetis, "Metis_268");
                				break;
                			}
                			case 28020: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000202);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000262, EnemyMetis, "Metis_269");
                				break;
                			}
                			case 28050: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000203);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000263, EnemyMetis, "Metis_270");
                				break;
                			}
                			case 28080: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000204);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000264, EnemyMetis, "Metis_271");
                				break;
                			}
                			case 28110: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000205);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000265, EnemyMetis, "Metis_272");
                				break;
                			}
                			case 28140: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000206);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000266, EnemyMetis, "Metis_273");
                				break;
                			}
                			case 28170: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000207);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000267, EnemyMetis, "Metis_274");
                				break;
                			}
                			case 28200: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000208);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000268, EnemyMetis, "Metis_275");
                				break;
                			}
                			case 28230: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000209);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000269, EnemyMetis, "Metis_276");
                				break;
                			}
                			case 28260: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000210);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000270, EnemyMetis, "Metis_277");
                				break;
                			}
                			case 28290: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000211);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000271, EnemyMetis, "Metis_278");
                				break;
                			}
                			case 28320: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000212);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000272, EnemyMetis, "Metis_279");
                				break;
                			}
                			case 28350: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000213);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000273, EnemyMetis, "Metis_280");
                				break;
                			}
                			case 28380: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000214);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000274, EnemyMetis, "Metis_281");
                				break;
                			}
                			case 28410: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000215);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000275, EnemyMetis, "Metis_282");
                				break;
                			}
                			case 28440: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000216);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000276, EnemyMetis, "Metis_283");
                				break;
                			}
                			case 28470: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000217);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000277, EnemyMetis, "Metis_284");
                				break;
                			}
                			case 28500: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000218);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000278, EnemyMetis, "Metis_285");
                				break;
                			}
                			case 28530: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000219);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000279, EnemyMetis, "Metis_286");
                				break;
                			}
                			case 28560: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000220);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000280, EnemyMetis, "Metis_287");
                				break;
                			}
                			case 28590: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000221);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000281, EnemyMetis, "Metis_288");
                				break;
                			}
                			case 28620: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000222);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000282, EnemyMetis, "Metis_289");
                				break;
                			}
                			case 28650: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000223);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000283, EnemyMetis, "Metis_290");
                				break;
                			}
                			case 28680: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000224);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000284, EnemyMetis, "Metis_291");
                				break;
                			}
                			case 28710: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000225);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000285, EnemyMetis, "Metis_292");
                				break;
                			}
                			case 28740: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000226);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000286, EnemyMetis, "Metis_293");
                				break;
                			}
                			case 28770: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000227);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000287, EnemyMetis, "Metis_294");
                				break;
                			}
                			case 28800: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000228);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000288, EnemyMetis, "Metis_295");
                				break;
                			}
                			case 28830: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000229);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000289, EnemyMetis, "Metis_296");
                				break;
                			}
                			case 28860: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000230);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000290, EnemyMetis, "Metis_297");
                				break;
                			}
                			case 28890: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000231);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000291, EnemyMetis, "Metis_298");
                				break;
                			}
                			case 28920: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000232);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000292, EnemyMetis, "Metis_299");
                				break;
                			}
                			case 28950: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000233);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000293, EnemyMetis, "Metis_300");
                				break;
                			}
                			case 28980: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000234);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000294, EnemyMetis, "Metis_301");
                				break;
                			}
                			case 29010: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000235);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000295, EnemyMetis, "Metis_302");
                				break;
                			}
                			case 29040: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000236);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000296, EnemyMetis, "Metis_303");
                				break;
                			}
                			case 29070: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000237);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000297, EnemyMetis, "Metis_304");
                				break;
                			}
                			case 29100: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000238);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000298, EnemyMetis, "Metis_305");
                				break;
                			}
                			case 29130: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000239);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000299, EnemyMetis, "Metis_306");
                				break;
                			}
                			case 29160: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000240);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000300, EnemyMetis, "Metis_307");
                				break;
                			}
                			case 29190: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000241);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000301, EnemyMetis, "Metis_308");
                				break;
                			}
                			case 29220: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000242);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000302, EnemyMetis, "Metis_309");
                				break;
                			}
                			case 29250: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000243);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000303, EnemyMetis, "Metis_310");
                				break;
                			}
                			case 29280: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000244);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000304, EnemyMetis, "Metis_311");
                				break;
                			}
                			case 29310: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000245);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000305, EnemyMetis, "Metis_312");
                				break;
                			}
                			case 29340: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000246);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000306, EnemyMetis, "Metis_313");
                				break;
                			}
                			case 29370: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000247);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000307, EnemyMetis, "Metis_314");
                				break;
                			}
                			case 29400: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000248);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000308, EnemyMetis, "Metis_315");
                				break;
                			}
                			case 29430: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000249);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000309, EnemyMetis, "Metis_316");
                				break;
                			}
                			case 29460: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000250);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000310, EnemyMetis, "Metis_317");
                				break;
                			}
                			case 29490: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000251);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000311, EnemyMetis, "Metis_318");
                				break;
                			}
                			case 29520: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000252);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000312, EnemyMetis, "Metis_319");
                				break;
                			}
                			case 29550: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000253);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000313, EnemyMetis, "Metis_320");
                				break;
                			}
                			case 29580: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000254);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000314, EnemyMetis, "Metis_321");
                				break;
                			}
                			case 29610: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000255);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000315, EnemyMetis, "Metis_322");
                				break;
                			}
                			case 29640: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000256);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000316, EnemyMetis, "Metis_323");
                				break;
                			}
                			case 29670: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000257);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000317, EnemyMetis, "Metis_324");
                				break;
                			}
                			case 29700: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000258);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000318, EnemyMetis, "Metis_325");
                				break;
                			}
                			case 29730: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000259);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000319, EnemyMetis, "Metis_326");
                				break;
                			}
                			case 29760: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000260);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000320, EnemyMetis, "Metis_327");
                				break;
                			}
                			case 29790: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000261);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000321, EnemyMetis, "Metis_328");
                				break;
                			}
                			case 29820: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000262);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000322, EnemyMetis, "Metis_329");
                				break;
                			}
                			case 29850: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000263);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000323, EnemyMetis, "Metis_330");
                				break;
                			}
                			case 29880: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000264);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000324, EnemyMetis, "Metis_331");
                				break;
                			}
                			case 29910: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000265);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000325, EnemyMetis, "Metis_332");
                				break;
                			}
                			case 29940: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000266);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000326, EnemyMetis, "Metis_333");
                				break;
                			}
                			case 29970: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000267);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000327, EnemyMetis, "Metis_334");
                				break;
                			}
                			case 30000: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000268);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000328, EnemyMetis, "Metis_335");
                				break;
                			}
                			case 30030: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000269);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000329, EnemyMetis, "Metis_336");
                				break;
                			}
                			case 30060: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000270);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000330, EnemyMetis, "Metis_337");
                				break;
                			}
                			case 30090: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000271);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000331, EnemyMetis, "Metis_338");
                				break;
                			}
                			case 30120: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000272);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000332, EnemyMetis, "Metis_339");
                				break;
                			}
                			case 30150: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000273);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000333, EnemyMetis, "Metis_340");
                				break;
                			}
                			case 30180: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000274);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000334, EnemyMetis, "Metis_341");
                				break;
                			}
                			case 30210: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000275);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000335, EnemyMetis, "Metis_342");
                				break;
                			}
                			case 30240: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000276);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000336, EnemyMetis, "Metis_343");
                				break;
                			}
                			case 30270: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000277);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000337, EnemyMetis, "Metis_344");
                				break;
                			}
                			case 30300: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000278);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000338, EnemyMetis, "Metis_345");
                				break;
                			}
                			case 30330: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000279);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000339, EnemyMetis, "Metis_346");
                				break;
                			}
                			case 30360: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000280);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000340, EnemyMetis, "Metis_347");
                				break;
                			}
                			case 30390: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000281);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000341, EnemyMetis, "Metis_348");
                				break;
                			}
                			case 30420: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000282);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000342, EnemyMetis, "Metis_349");
                				break;
                			}
                			case 30450: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000283);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000343, EnemyMetis, "Metis_350");
                				break;
                			}
                			case 30480: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000284);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000344, EnemyMetis, "Metis_351");
                				break;
                			}
                			case 30510: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000285);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000345, EnemyMetis, "Metis_352");
                				break;
                			}
                			case 30540: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000286);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000346, EnemyMetis, "Metis_353");
                				break;
                			}
                			case 30570: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000287);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000347, EnemyMetis, "Metis_354");
                				break;
                			}
                			case 30600: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000288);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000348, EnemyMetis, "Metis_355");
                				break;
                			}
                			case 30630: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000289);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000349, EnemyMetis, "Metis_356");
                				break;
                			}
                			case 30660: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000290);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000350, EnemyMetis, "Metis_357");
                				break;
                			}
                			case 30690: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000291);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000351, EnemyMetis, "Metis_358");
                				break;
                			}
                			case 30720: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000292);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000352, EnemyMetis, "Metis_359");
                				break;
                			}
                			case 30750: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000293);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000353, EnemyMetis, "Metis_360");
                				break;
                			}
                			case 30780: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000294);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000354, EnemyMetis, "Metis_361");
                				break;
                			}
                			case 30810: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000295);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000355, EnemyMetis, "Metis_362");
                				break;
                			}
                			case 30840: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000296);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000356, EnemyMetis, "Metis_363");
                				break;
                			}
                			case 30870: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000297);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000357, EnemyMetis, "Metis_364");
                				break;
                			}
                			case 30900: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000298);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000358, EnemyMetis, "Metis_365");
                				break;
                			}
                			case 30930: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000299);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000359, EnemyMetis, "Metis_366");
                				break;
                			}
                			case 30960: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000300);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000360, EnemyMetis, "Metis_367");
                				break;
                			}
                			case 30990: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000301);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000361, EnemyMetis, "Metis_368");
                				break;
                			}
                			case 31020: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000302);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000362, EnemyMetis, "Metis_369");
                				break;
                			}
                			case 31050: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000303);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000363, EnemyMetis, "Metis_370");
                				break;
                			}
                			case 31080: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000304);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000364, EnemyMetis, "Metis_371");
                				break;
                			}
                			case 31110: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000305);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000365, EnemyMetis, "Metis_372");
                				break;
                			}
                			case 31140: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000306);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000366, EnemyMetis, "Metis_373");
                				break;
                			}
                			case 31170: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000307);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000367, EnemyMetis, "Metis_374");
                				break;
                			}
                			case 31200: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000308);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000368, EnemyMetis, "Metis_375");
                				break;
                			}
                			case 31230: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000309);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000369, EnemyMetis, "Metis_376");
                				break;
                			}
                			case 31260: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000310);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000370, EnemyMetis, "Metis_377");
                				break;
                			}
                			case 31290: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000311);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000371, EnemyMetis, "Metis_378");
                				break;
                			}
                			case 31320: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000312);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000372, EnemyMetis, "Metis_379");
                				break;
                			}
                			case 31350: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000313);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000373, EnemyMetis, "Metis_380");
                				break;
                			}
                			case 31380: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000314);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000374, EnemyMetis, "Metis_381");
                				break;
                			}
                			case 31410: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000315);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000375, EnemyMetis, "Metis_382");
                				break;
                			}
                			case 31440: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000316);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000376, EnemyMetis, "Metis_383");
                				break;
                			}
                			case 31470: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000317);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000377, EnemyMetis, "Metis_384");
                				break;
                			}
                			case 31500: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000318);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000378, EnemyMetis, "Metis_385");
                				break;
                			}
                			case 31530: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000319);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000379, EnemyMetis, "Metis_386");
                				break;
                			}
                			case 31560: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000320);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000380, EnemyMetis, "Metis_387");
                				break;
                			}
                			case 31590: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000321);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000381, EnemyMetis, "Metis_388");
                				break;
                			}
                			case 31620: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000322);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000382, EnemyMetis, "Metis_389");
                				break;
                			}
                			case 31650: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000323);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000383, EnemyMetis, "Metis_390");
                				break;
                			}
                			case 31680: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000324);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000384, EnemyMetis, "Metis_391");
                				break;
                			}
                			case 31710: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000325);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000385, EnemyMetis, "Metis_392");
                				break;
                			}
                			case 31740: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000326);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000386, EnemyMetis, "Metis_393");
                				break;
                			}
                			case 31770: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000327);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000387, EnemyMetis, "Metis_394");
                				break;
                			}
                			case 31800: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000328);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000388, EnemyMetis, "Metis_395");
                				break;
                			}
                			case 31830: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000329);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000389, EnemyMetis, "Metis_396");
                				break;
                			}
                			case 31860: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000330);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000390, EnemyMetis, "Metis_397");
                				break;
                			}
                			case 31890: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000331);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000391, EnemyMetis, "Metis_398");
                				break;
                			}
                			case 31920: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000332);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000392, EnemyMetis, "Metis_399");
                				break;
                			}
                			case 31950: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000333);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000393, EnemyMetis, "Metis_400");
                				break;
                			}
                			case 31980: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000334);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000394, EnemyMetis, "Metis_401");
                				break;
                			}
                			case 32010: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000335);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000395, EnemyMetis, "Metis_402");
                				break;
                			}
                			case 32040: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000336);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000396, EnemyMetis, "Metis_403");
                				break;
                			}
                			case 32070: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000337);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000397, EnemyMetis, "Metis_404");
                				break;
                			}
                			case 32100: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000338);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000398, EnemyMetis, "Metis_405");
                				break;
                			}
                			case 32130: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000339);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000399, EnemyMetis, "Metis_406");
                				break;
                			}
                			case 32160: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000340);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000400, EnemyMetis, "Metis_407");
                				break;
                			}
                			case 32190: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000341);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000401, EnemyMetis, "Metis_408");
                				break;
                			}
                			case 32220: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000342);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000402, EnemyMetis, "Metis_409");
                				break;
                			}
                			case 32250: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000343);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000403, EnemyMetis, "Metis_410");
                				break;
                			}
                			case 32280: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000344);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000404, EnemyMetis, "Metis_411");
                				break;
                			}
                			case 32310: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000345);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000405, EnemyMetis, "Metis_412");
                				break;
                			}
                			case 32340: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000346);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000406, EnemyMetis, "Metis_413");
                				break;
                			}
                			case 32370: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000347);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000407, EnemyMetis, "Metis_414");
                				break;
                			}
                			case 32400: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000348);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000408, EnemyMetis, "Metis_415");
                				break;
                			}
                			case 32430: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000349);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000409, EnemyMetis, "Metis_416");
                				break;
                			}
                			case 32460: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000350);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000410, EnemyMetis, "Metis_417");
                				break;
                			}
                			case 32490: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000351);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000411, EnemyMetis, "Metis_418");
                				break;
                			}
                			case 32520: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000352);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000412, EnemyMetis, "Metis_419");
                				break;
                			}
                			case 32550: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000353);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000413, EnemyMetis, "Metis_420");
                				break;
                			}
                			case 32580: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000354);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000414, EnemyMetis, "Metis_421");
                				break;
                			}
                			case 32610: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000355);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000415, EnemyMetis, "Metis_422");
                				break;
                			}
                			case 32640: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000356);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000416, EnemyMetis, "Metis_423");
                				break;
                			}
                			case 32670: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000357);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000417, EnemyMetis, "Metis_424");
                				break;
                			}
                			case 32700: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000358);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000418, EnemyMetis, "Metis_425");
                				break;
                			}
                			case 32730: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000359);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000419, EnemyMetis, "Metis_426");
                				break;
                			}
                			case 32760: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000360);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000420, EnemyMetis, "Metis_427");
                				break;
                			}
                			case 32790: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000361);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000421, EnemyMetis, "Metis_428");
                				break;
                			}
                			case 32820: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000362);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000422, EnemyMetis, "Metis_429");
                				break;
                			}
                			case 32850: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000363);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000423, EnemyMetis, "Metis_430");
                				break;
                			}
                			case 32880: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000364);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000424, EnemyMetis, "Metis_431");
                				break;
                			}
                			case 32910: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000365);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000425, EnemyMetis, "Metis_432");
                				break;
                			}
                			case 32940: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000366);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000426, EnemyMetis, "Metis_433");
                				break;
                			}
                			case 32970: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000367);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000427, EnemyMetis, "Metis_434");
                				break;
                			}
                			case 33000: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000368);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000428, EnemyMetis, "Metis_435");
                				break;
                			}
                			case 33030: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000369);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000429, EnemyMetis, "Metis_436");
                				break;
                			}
                			case 33060: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000370);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000430, EnemyMetis, "Metis_437");
                				break;
                			}
                			case 33090: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000371);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000431, EnemyMetis, "Metis_438");
                				break;
                			}
                			case 33120: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000372);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000432, EnemyMetis, "Metis_439");
                				break;
                			}
                			case 33150: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000373);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000433, EnemyMetis, "Metis_440");
                				break;
                			}
                			case 33180: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000374);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000434, EnemyMetis, "Metis_441");
                				break;
                			}
                			case 33210: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000375);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000435, EnemyMetis, "Metis_442");
                				break;
                			}
                			case 33240: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000376);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000436, EnemyMetis, "Metis_443");
                				break;
                			}
                			case 33270: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000377);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000437, EnemyMetis, "Metis_444");
                				break;
                			}
                			case 33300: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000378);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000438, EnemyMetis, "Metis_445");
                				break;
                			}
                			case 33330: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000379);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000439, EnemyMetis, "Metis_446");
                				break;
                			}
                			case 33360: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000380);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000440, EnemyMetis, "Metis_447");
                				break;
                			}
                			case 33390: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000381);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000441, EnemyMetis, "Metis_448");
                				break;
                			}
                			case 33420: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000382);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000442, EnemyMetis, "Metis_449");
                				break;
                			}
                			case 33450: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000383);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000443, EnemyMetis, "Metis_450");
                				break;
                			}
                			case 33480: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000384);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000444, EnemyMetis, "Metis_451");
                				break;
                			}
                			case 33510: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000385);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000445, EnemyMetis, "Metis_452");
                				break;
                			}
                			case 33540: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000386);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000446, EnemyMetis, "Metis_453");
                				break;
                			}
                			case 33570: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000387);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000447, EnemyMetis, "Metis_454");
                				break;
                			}
                			case 33600: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000388);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000448, EnemyMetis, "Metis_455");
                				break;
                			}
                			case 33630: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000389);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000449, EnemyMetis, "Metis_456");
                				break;
                			}
                			case 33660: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000390);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000450, EnemyMetis, "Metis_457");
                				break;
                			}
                			case 33690: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000391);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000451, EnemyMetis, "Metis_458");
                				break;
                			}
                			case 33720: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000392);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000452, EnemyMetis, "Metis_459");
                				break;
                			}
                			case 33750: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000393);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000453, EnemyMetis, "Metis_460");
                				break;
                			}
                			case 33780: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000394);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000454, EnemyMetis, "Metis_461");
                				break;
                			}
                			case 33810: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000395);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000455, EnemyMetis, "Metis_462");
                				break;
                			}
                			case 33840: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000396);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000456, EnemyMetis, "Metis_463");
                				break;
                			}
                			case 33870: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000397);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000457, EnemyMetis, "Metis_464");
                				break;
                			}
                			case 33900: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000398);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000458, EnemyMetis, "Metis_465");
                				break;
                			}
                			case 33930: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000399);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000459, EnemyMetis, "Metis_466");
                				break;
                			}
                			case 33960: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000400);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000460, EnemyMetis, "Metis_467");
                				break;
                			}
                			case 33990: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000401);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000461, EnemyMetis, "Metis_468");
                				break;
                			}
                			case 34020: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000402);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000462, EnemyMetis, "Metis_469");
                				break;
                			}
                			case 34050: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000403);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000463, EnemyMetis, "Metis_470");
                				break;
                			}
                			case 34080: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000404);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000464, EnemyMetis, "Metis_471");
                				break;
                			}
                			case 34110: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000405);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000465, EnemyMetis, "Metis_472");
                				break;
                			}
                			case 34140: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000406);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000466, EnemyMetis, "Metis_473");
                				break;
                			}
                			case 34170: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000407);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000467, EnemyMetis, "Metis_474");
                				break;
                			}
                			case 34200: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000408);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000468, EnemyMetis, "Metis_475");
                				break;
                			}
                			case 34230: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000409);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000469, EnemyMetis, "Metis_476");
                				break;
                			}
                			case 34260: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000410);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000470, EnemyMetis, "Metis_477");
                				break;
                			}
                			case 34290: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000411);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000471, EnemyMetis, "Metis_478");
                				break;
                			}
                			case 34320: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000412);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000472, EnemyMetis, "Metis_479");
                				break;
                			}
                			case 34350: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000413);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000473, EnemyMetis, "Metis_480");
                				break;
                			}
                			case 34380: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000414);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000474, EnemyMetis, "Metis_481");
                				break;
                			}
                			case 34410: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000415);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000475, EnemyMetis, "Metis_482");
                				break;
                			}
                			case 34440: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000416);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000476, EnemyMetis, "Metis_483");
                				break;
                			}
                			case 34470: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000417);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000477, EnemyMetis, "Metis_484");
                				break;
                			}
                			case 34500: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000418);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000478, EnemyMetis, "Metis_485");
                				break;
                			}
                			case 34530: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000419);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000479, EnemyMetis, "Metis_486");
                				break;
                			}
                			case 34560: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000420);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000480, EnemyMetis, "Metis_487");
                				break;
                			}
                			case 34590: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000421);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000481, EnemyMetis, "Metis_488");
                				break;
                			}
                			case 34620: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000422);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000482, EnemyMetis, "Metis_489");
                				break;
                			}
                			case 34650: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000423);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000483, EnemyMetis, "Metis_490");
                				break;
                			}
                			case 34680: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000424);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000484, EnemyMetis, "Metis_491");
                				break;
                			}
                			case 34710: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000425);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000485, EnemyMetis, "Metis_492");
                				break;
                			}
                			case 34740: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000426);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000486, EnemyMetis, "Metis_493");
                				break;
                			}
                			case 34770: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000427);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000487, EnemyMetis, "Metis_494");
                				break;
                			}
                			case 34800: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000428);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000488, EnemyMetis, "Metis_495");
                				break;
                			}
                			case 34830: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000429);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000489, EnemyMetis, "Metis_496");
                				break;
                			}
                			case 34860: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000430);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000490, EnemyMetis, "Metis_497");
                				break;
                			}
                			case 34890: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000431);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000491, EnemyMetis, "Metis_498");
                				break;
                			}
                			case 34920: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000432);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000492, EnemyMetis, "Metis_499");
                				break;
                			}
                			case 34950: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000433);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000493, EnemyMetis, "Metis_500");
                				break;
                			}
                			case 34980: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000434);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000494, EnemyMetis, "Metis_501");
                				break;
                			}
                			case 35010: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000435);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000495, EnemyMetis, "Metis_502");
                				break;
                			}
                			case 35040: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000436);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000496, EnemyMetis, "Metis_503");
                				break;
                			}
                			case 35070: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000437);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000497, EnemyMetis, "Metis_504");
                				break;
                			}
                			case 35100: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000438);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000498, EnemyMetis, "Metis_505");
                				break;
                			}
                			case 35130: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000439);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000499, EnemyMetis, "Metis_506");
                				break;
                			}
                			case 35160: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000440);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000500, EnemyMetis, "Metis_507");
                				break;
                			}
                			case 35190: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000441);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000501, EnemyMetis, "Metis_508");
                				break;
                			}
                			case 35220: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000442);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000502, EnemyMetis, "Metis_509");
                				break;
                			}
                			case 35250: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000443);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000503, EnemyMetis, "Metis_510");
                				break;
                			}
                			case 35280: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000444);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000504, EnemyMetis, "Metis_511");
                				break;
                			}
                			case 35310: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000445);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000505, EnemyMetis, "Metis_512");
                				break;
                			}
                			case 35340: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000446);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000506, EnemyMetis, "Metis_513");
                				break;
                			}
                			case 35370: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000447);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000507, EnemyMetis, "Metis_514");
                				break;
                			}
                			case 35400: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000448);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000508, EnemyMetis, "Metis_515");
                				break;
                			}
                			case 35430: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000449);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000509, EnemyMetis, "Metis_516");
                				break;
                			}
                			case 35460: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000450);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000510, EnemyMetis, "Metis_517");
                				break;
                			}
                			case 35490: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000451);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000511, EnemyMetis, "Metis_518");
                				break;
                			}
                			case 35520: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000452);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000512, EnemyMetis, "Metis_519");
                				break;
                			}
                			case 35550: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000453);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000513, EnemyMetis, "Metis_520");
                				break;
                			}
                			case 35580: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000454);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000514, EnemyMetis, "Metis_521");
                				break;
                			}
                			case 35610: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000455);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000515, EnemyMetis, "Metis_522");
                				break;
                			}
                			case 35640: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000456);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000516, EnemyMetis, "Metis_523");
                				break;
                			}
                			case 35670: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000457);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000517, EnemyMetis, "Metis_524");
                				break;
                			}
                			case 35700: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000458);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000518, EnemyMetis, "Metis_525");
                				break;
                			}
                			case 35730: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000459);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000519, EnemyMetis, "Metis_526");
                				break;
                			}
                			case 35760: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000460);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000520, EnemyMetis, "Metis_527");
                				break;
                			}
                			case 35790: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000461);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000521, EnemyMetis, "Metis_528");
                				break;
                			}
                			case 35820: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000462);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000522, EnemyMetis, "Metis_529");
                				break;
                			}
                			case 35850: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000463);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000523, EnemyMetis, "Metis_530");
                				break;
                			}
                			case 35880: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000464);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000524, EnemyMetis, "Metis_531");
                				break;
                			}
                			case 35910: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000465);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000525, EnemyMetis, "Metis_532");
                				break;
                			}
                			case 35940: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000466);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000526, EnemyMetis, "Metis_533");
                				break;
                			}
                			case 35970: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000467);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000527, EnemyMetis, "Metis_534");
                				break;
                			}
                			case 36000: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000468);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000528, EnemyMetis, "Metis_535");
                				break;
                			}
                			case 36030: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000469);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000529, EnemyMetis, "Metis_536");
                				break;
                			}
                			case 36060: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000470);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000530, EnemyMetis, "Metis_537");
                				break;
                			}
                			case 36090: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000471);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000531, EnemyMetis, "Metis_538");
                				break;
                			}
                			case 36120: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000472);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000532, EnemyMetis, "Metis_539");
                				break;
                			}
                			case 36150: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000473);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000533, EnemyMetis, "Metis_540");
                				break;
                			}
                			case 36180: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000474);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000534, EnemyMetis, "Metis_541");
                				break;
                			}
                			case 36210: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000475);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000535, EnemyMetis, "Metis_542");
                				break;
                			}
                			case 36240: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000476);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000536, EnemyMetis, "Metis_543");
                				break;
                			}
                			case 36270: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000477);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000537, EnemyMetis, "Metis_544");
                				break;
                			}
                			case 36300: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000478);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000538, EnemyMetis, "Metis_545");
                				break;
                			}
                			case 36330: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000479);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000539, EnemyMetis, "Metis_546");
                				break;
                			}
                			case 36360: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000480);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000540, EnemyMetis, "Metis_547");
                				break;
                			}
                			case 36390: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000481);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000541, EnemyMetis, "Metis_548");
                				break;
                			}
                			case 36420: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000482);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000542, EnemyMetis, "Metis_549");
                				break;
                			}
                			case 36450: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000483);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000543, EnemyMetis, "Metis_550");
                				break;
                			}
                			case 36480: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000484);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000544, EnemyMetis, "Metis_551");
                				break;
                			}
                			case 36510: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000485);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000545, EnemyMetis, "Metis_552");
                				break;
                			}
                			case 36540: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000486);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000546, EnemyMetis, "Metis_553");
                				break;
                			}
                			case 36570: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000487);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000547, EnemyMetis, "Metis_554");
                				break;
                			}
                			case 36600: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000488);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000548, EnemyMetis, "Metis_555");
                				break;
                			}
                			case 36630: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000489);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000549, EnemyMetis, "Metis_556");
                				break;
                			}
                			case 36660: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000490);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000550, EnemyMetis, "Metis_557");
                				break;
                			}
                			case 36690: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000491);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000551, EnemyMetis, "Metis_558");
                				break;
                			}
                			case 36720: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000492);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000552, EnemyMetis, "Metis_559");
                				break;
                			}
                			case 36750: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000493);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000553, EnemyMetis, "Metis_560");
                				break;
                			}
                			case 36780: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000494);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000554, EnemyMetis, "Metis_561");
                				break;
                			}
                			case 36810: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000495);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000555, EnemyMetis, "Metis_562");
                				break;
                			}
                			case 36840: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000496);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000556, EnemyMetis, "Metis_563");
                				break;
                			}
                			case 36870: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000497);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000557, EnemyMetis, "Metis_564");
                				break;
                			}
                			case 36900: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000498);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000558, EnemyMetis, "Metis_565");
                				break;
                			}
                			case 36930: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000499);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000559, EnemyMetis, "Metis_566");
                				break;
                			}
                			case 36960: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000500);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000560, EnemyMetis, "Metis_567");
                				break;
                			}
                			case 36990: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000501);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000561, EnemyMetis, "Metis_568");
                				break;
                			}
                			case 37020: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000502);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000562, EnemyMetis, "Metis_569");
                				break;
                			}
                			case 37050: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000503);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000563, EnemyMetis, "Metis_570");
                				break;
                			}
                			case 37080: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000504);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000564, EnemyMetis, "Metis_571");
                				break;
                			}
                			case 37110: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000505);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000565, EnemyMetis, "Metis_572");
                				break;
                			}
                			case 37140: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000506);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000566, EnemyMetis, "Metis_573");
                				break;
                			}
                			case 37170: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000507);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000567, EnemyMetis, "Metis_574");
                				break;
                			}
                			case 37200: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000508);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000568, EnemyMetis, "Metis_575");
                				break;
                			}
                			case 37230: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000509);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000569, EnemyMetis, "Metis_576");
                				break;
                			}
                			case 37260: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000510);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000570, EnemyMetis, "Metis_577");
                				break;
                			}
                			case 37290: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000511);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000571, EnemyMetis, "Metis_578");
                				break;
                			}
                			case 37320: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000512);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000572, EnemyMetis, "Metis_579");
                				break;
                			}
                			case 37350: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000513);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000573, EnemyMetis, "Metis_580");
                				break;
                			}
                			case 37380: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000514);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000574, EnemyMetis, "Metis_581");
                				break;
                			}
                			case 37410: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000515);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000575, EnemyMetis, "Metis_582");
                				break;
                			}
                			case 37440: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000516);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000576, EnemyMetis, "Metis_583");
                				break;
                			}
                			case 37470: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000517);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000577, EnemyMetis, "Metis_584");
                				break;
                			}
                			case 37500: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000518);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000578, EnemyMetis, "Metis_585");
                				break;
                			}
                			case 37530: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000519);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000579, EnemyMetis, "Metis_586");
                				break;
                			}
                			case 37560: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000520);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000580, EnemyMetis, "Metis_587");
                				break;
                			}
                			case 37590: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000521);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000581, EnemyMetis, "Metis_588");
                				break;
                			}
                			case 37620: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000522);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000582, EnemyMetis, "Metis_589");
                				break;
                			}
                			case 37650: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000523);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000583, EnemyMetis, "Metis_590");
                				break;
                			}
                			case 37680: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000524);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000584, EnemyMetis, "Metis_591");
                				break;
                			}
                			case 37710: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000525);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000585, EnemyMetis, "Metis_592");
                				break;
                			}
                			case 37740: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000526);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000586, EnemyMetis, "Metis_593");
                				break;
                			}
                			case 37770: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000527);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000587, EnemyMetis, "Metis_594");
                				break;
                			}
                			case 37800: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000528);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000588, EnemyMetis, "Metis_595");
                				break;
                			}
                			case 37830: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000529);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000589, EnemyMetis, "Metis_596");
                				break;
                			}
                			case 37860: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000530);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000590, EnemyMetis, "Metis_597");
                				break;
                			}
                			case 37890: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000531);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000591, EnemyMetis, "Metis_598");
                				break;
                			}
                			case 37920: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000532);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000592, EnemyMetis, "Metis_599");
                				break;
                			}
                			case 37950: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000533);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000593, EnemyMetis, "Metis_600");
                				break;
                			}
                			case 37980: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000534);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000594, EnemyMetis, "Metis_601");
                				break;
                			}
                			case 38010: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000535);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000595, EnemyMetis, "Metis_602");
                				break;
                			}
                			case 38040: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000536);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000596, EnemyMetis, "Metis_603");
                				break;
                			}
                			case 38070: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000537);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000597, EnemyMetis, "Metis_604");
                				break;
                			}
                			case 38100: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000538);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000598, EnemyMetis, "Metis_605");
                				break;
                			}
                			case 38130: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000539);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000599, EnemyMetis, "Metis_606");
                				break;
                			}
                			case 38160: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000540);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000600, EnemyMetis, "Metis_607");
                				break;
                			}
                			case 38190: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000541);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000601, EnemyMetis, "Metis_608");
                				break;
                			}
                			case 38220: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000542);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000602, EnemyMetis, "Metis_609");
                				break;
                			}
                			case 38250: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000543);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000603, EnemyMetis, "Metis_610");
                				break;
                			}
                			case 38280: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000544);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000604, EnemyMetis, "Metis_611");
                				break;
                			}
                			case 38310: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000545);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000605, EnemyMetis, "Metis_612");
                				break;
                			}
                			case 38340: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000546);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000606, EnemyMetis, "Metis_613");
                				break;
                			}
                			case 38370: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000547);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000607, EnemyMetis, "Metis_614");
                				break;
                			}
                			case 38400: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000548);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000608, EnemyMetis, "Metis_615");
                				break;
                			}
                			case 38430: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000549);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000609, EnemyMetis, "Metis_616");
                				break;
                			}
                			case 38460: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000550);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000610, EnemyMetis, "Metis_617");
                				break;
                			}
                			case 38490: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000551);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000611, EnemyMetis, "Metis_618");
                				break;
                			}
                			case 38520: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000552);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000612, EnemyMetis, "Metis_619");
                				break;
                			}
                			case 38550: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000553);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000613, EnemyMetis, "Metis_620");
                				break;
                			}
                			case 38580: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000554);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000614, EnemyMetis, "Metis_621");
                				break;
                			}
                			case 38610: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000555);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000615, EnemyMetis, "Metis_622");
                				break;
                			}
                			case 38640: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000556);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000616, EnemyMetis, "Metis_623");
                				break;
                			}
                			case 38670: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000557);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000617, EnemyMetis, "Metis_624");
                				break;
                			}
                			case 38700: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000558);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000618, EnemyMetis, "Metis_625");
                				break;
                			}
                			case 38730: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000559);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000619, EnemyMetis, "Metis_626");
                				break;
                			}
                			case 38760: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000560);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000620, EnemyMetis, "Metis_627");
                				break;
                			}
                			case 38790: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000561);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000621, EnemyMetis, "Metis_628");
                				break;
                			}
                			case 38820: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000562);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000622, EnemyMetis, "Metis_629");
                				break;
                			}
                			case 38850: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000563);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000623, EnemyMetis, "Metis_630");
                				break;
                			}
                			case 38880: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000564);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000624, EnemyMetis, "Metis_631");
                				break;
                			}
                			case 38910: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000565);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000625, EnemyMetis, "Metis_632");
                				break;
                			}
                			case 38940: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000566);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000626, EnemyMetis, "Metis_633");
                				break;
                			}
                			case 38970: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000567);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000627, EnemyMetis, "Metis_634");
                				break;
                			}
                			case 39000: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000568);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000628, EnemyMetis, "Metis_635");
                				break;
                			}
                			case 39030: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000569);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000629, EnemyMetis, "Metis_636");
                				break;
                			}
                			case 39060: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000570);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000630, EnemyMetis, "Metis_637");
                				break;
                			}
                			case 39090: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000571);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000631, EnemyMetis, "Metis_638");
                				break;
                			}
                			case 39120: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000572);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000632, EnemyMetis, "Metis_639");
                				break;
                			}
                			case 39150: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000573);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000633, EnemyMetis, "Metis_640");
                				break;
                			}
                			case 39180: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000574);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000634, EnemyMetis, "Metis_641");
                				break;
                			}
                			case 39210: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000575);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000635, EnemyMetis, "Metis_642");
                				break;
                			}
                			case 39240: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000576);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000636, EnemyMetis, "Metis_643");
                				break;
                			}
                			case 39270: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000577);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000637, EnemyMetis, "Metis_644");
                				break;
                			}
                			case 39300: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000578);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000638, EnemyMetis, "Metis_645");
                				break;
                			}
                			case 39330: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000579);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000639, EnemyMetis, "Metis_646");
                				break;
                			}
                			case 39360: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000580);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000640, EnemyMetis, "Metis_647");
                				break;
                			}
                			case 39390: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000581);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000641, EnemyMetis, "Metis_648");
                				break;
                			}
                			case 39420: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000582);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000642, EnemyMetis, "Metis_649");
                				break;
                			}
                			case 39450: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000583);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000643, EnemyMetis, "Metis_650");
                				break;
                			}
                			case 39480: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000584);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000644, EnemyMetis, "Metis_651");
                				break;
                			}
                			case 39510: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000585);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000645, EnemyMetis, "Metis_652");
                				break;
                			}
                			case 39540: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000586);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000646, EnemyMetis, "Metis_653");
                				break;
                			}
                			case 39570: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000587);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000647, EnemyMetis, "Metis_654");
                				break;
                			}
                			case 39600: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000588);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000648, EnemyMetis, "Metis_655");
                				break;
                			}
                			case 39630: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000589);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000649, EnemyMetis, "Metis_656");
                				break;
                			}
                			case 39660: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000590);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000650, EnemyMetis, "Metis_657");
                				break;
                			}
                			case 39690: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000591);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000651, EnemyMetis, "Metis_658");
                				break;
                			}
                			case 39720: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000592);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000652, EnemyMetis, "Metis_659");
                				break;
                			}
                			case 39750: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000593);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000653, EnemyMetis, "Metis_660");
                				break;
                			}
                			case 39780: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000594);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000654, EnemyMetis, "Metis_661");
                				break;
                			}
                			case 39810: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000595);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000655, EnemyMetis, "Metis_662");
                				break;
                			}
                			case 39840: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000596);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000656, EnemyMetis, "Metis_663");
                				break;
                			}
                			case 39870: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000597);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000657, EnemyMetis, "Metis_664");
                				break;
                			}
                			case 39900: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000598);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000658, EnemyMetis, "Metis_665");
                				break;
                			}
                			case 39930: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000599);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000659, EnemyMetis, "Metis_666");
                				break;
                			}
                			case 39960: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000600);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000660, EnemyMetis, "Metis_667");
                				break;
                			}
                			case 39990: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000601);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000661, EnemyMetis, "Metis_668");
                				break;
                			}
                			case 40020: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000602);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000662, EnemyMetis, "Metis_669");
                				break;
                			}
                			case 40050: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000603);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000663, EnemyMetis, "Metis_670");
                				break;
                			}
                			case 40080: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000604);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000664, EnemyMetis, "Metis_671");
                				break;
                			}
                			case 40110: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000605);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000665, EnemyMetis, "Metis_672");
                				break;
                			}
                			case 40140: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000606);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000666, EnemyMetis, "Metis_673");
                				break;
                			}
                			case 40170: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000607);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000667, EnemyMetis, "Metis_674");
                				break;
                			}
                			case 40200: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000608);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000668, EnemyMetis, "Metis_675");
                				break;
                			}
                			case 40230: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000609);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000669, EnemyMetis, "Metis_676");
                				break;
                			}
                			case 40260: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000610);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000670, EnemyMetis, "Metis_677");
                				break;
                			}
                			case 40290: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000611);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000671, EnemyMetis, "Metis_678");
                				break;
                			}
                			case 40320: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000612);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000672, EnemyMetis, "Metis_679");
                				break;
                			}
                			case 40350: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000613);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000673, EnemyMetis, "Metis_680");
                				break;
                			}
                			case 40380: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000614);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000674, EnemyMetis, "Metis_681");
                				break;
                			}
                			case 40410: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000615);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000675, EnemyMetis, "Metis_682");
                				break;
                			}
                			case 40440: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000616);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000676, EnemyMetis, "Metis_683");
                				break;
                			}
                			case 40470: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000617);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000677, EnemyMetis, "Metis_684");
                				break;
                			}
                			case 40500: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000618);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000678, EnemyMetis, "Metis_685");
                				break;
                			}
                			case 40530: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000619);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000679, EnemyMetis, "Metis_686");
                				break;
                			}
                			case 40560: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000620);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000680, EnemyMetis, "Metis_687");
                				break;
                			}
                			case 40590: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000621);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000681, EnemyMetis, "Metis_688");
                				break;
                			}
                			case 40620: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000622);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000682, EnemyMetis, "Metis_689");
                				break;
                			}
                			case 40650: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000623);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000683, EnemyMetis, "Metis_690");
                				break;
                			}
                			case 40680: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000624);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000684, EnemyMetis, "Metis_691");
                				break;
                			}
                			case 40710: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000625);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000685, EnemyMetis, "Metis_692");
                				break;
                			}
                			case 40740: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000626);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000686, EnemyMetis, "Metis_693");
                				break;
                			}
                			case 40770: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000627);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000687, EnemyMetis, "Metis_694");
                				break;
                			}
                			case 40800: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000628);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000688, EnemyMetis, "Metis_695");
                				break;
                			}
                			case 40830: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000629);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000689, EnemyMetis, "Metis_696");
                				break;
                			}
                			case 40860: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000630);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000690, EnemyMetis, "Metis_697");
                				break;
                			}
                			case 40890: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000631);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000691, EnemyMetis, "Metis_698");
                				break;
                			}
                			case 40920: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000632);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000692, EnemyMetis, "Metis_699");
                				break;
                			}
                			case 40950: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000633);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000693, EnemyMetis, "Metis_700");
                				break;
                			}
                			case 40980: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000634);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000694, EnemyMetis, "Metis_701");
                				break;
                			}
                			case 41010: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000635);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000695, EnemyMetis, "Metis_702");
                				break;
                			}
                			case 41040: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000636);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000696, EnemyMetis, "Metis_703");
                				break;
                			}
                			case 41070: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000637);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000697, EnemyMetis, "Metis_704");
                				break;
                			}
                			case 41100: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000638);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000698, EnemyMetis, "Metis_705");
                				break;
                			}
                			case 41130: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000639);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000699, EnemyMetis, "Metis_706");
                				break;
                			}
                			case 41160: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000640);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000700, EnemyMetis, "Metis_707");
                				break;
                			}
                			case 41190: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000641);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000701, EnemyMetis, "Metis_708");
                				break;
                			}
                			case 41220: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000642);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000702, EnemyMetis, "Metis_709");
                				break;
                			}
                			case 41250: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000643);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000703, EnemyMetis, "Metis_710");
                				break;
                			}
                			case 41280: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000644);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000704, EnemyMetis, "Metis_711");
                				break;
                			}
                			case 41310: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000645);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000705, EnemyMetis, "Metis_712");
                				break;
                			}
                			case 41340: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000646);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000706, EnemyMetis, "Metis_713");
                				break;
                			}
                			case 41370: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000647);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000707, EnemyMetis, "Metis_714");
                				break;
                			}
                			case 41400: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000648);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000708, EnemyMetis, "Metis_715");
                				break;
                			}
                			case 41430: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000649);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000709, EnemyMetis, "Metis_716");
                				break;
                			}
                			case 41460: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000650);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000710, EnemyMetis, "Metis_717");
                				break;
                			}
                			case 41490: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000651);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000711, EnemyMetis, "Metis_718");
                				break;
                			}
                			case 41520: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000652);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000712, EnemyMetis, "Metis_719");
                				break;
                			}
                			case 41550: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000653);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000713, EnemyMetis, "Metis_720");
                				break;
                			}
                			case 41580: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000654);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000714, EnemyMetis, "Metis_721");
                				break;
                			}
                			case 41610: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000655);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000715, EnemyMetis, "Metis_722");
                				break;
                			}
                			case 41640: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000656);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000716, EnemyMetis, "Metis_723");
                				break;
                			}
                			case 41670: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000657);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000717, EnemyMetis, "Metis_724");
                				break;
                			}
                			case 41700: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000658);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000718, EnemyMetis, "Metis_725");
                				break;
                			}
                			case 41730: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000659);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000719, EnemyMetis, "Metis_726");
                				break;
                			}
                			case 41760: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000660);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000720, EnemyMetis, "Metis_727");
                				break;
                			}
                			case 41790: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000661);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000721, EnemyMetis, "Metis_728");
                				break;
                			}
                			case 41820: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000662);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000722, EnemyMetis, "Metis_729");
                				break;
                			}
                			case 41850: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000663);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000723, EnemyMetis, "Metis_730");
                				break;
                			}
                			case 41880: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000664);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000724, EnemyMetis, "Metis_731");
                				break;
                			}
                			case 41910: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000665);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000725, EnemyMetis, "Metis_732");
                				break;
                			}
                			case 41940: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000666);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000726, EnemyMetis, "Metis_733");
                				break;
                			}
                			case 41970: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000667);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000727, EnemyMetis, "Metis_734");
                				break;
                			}
                			case 42000: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000668);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000728, EnemyMetis, "Metis_735");
                				break;
                			}
                			case 42030: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000669);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000729, EnemyMetis, "Metis_736");
                				break;
                			}
                			case 42060: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000670);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000730, EnemyMetis, "Metis_737");
                				break;
                			}
                			case 42090: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000671);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000731, EnemyMetis, "Metis_738");
                				break;
                			}
                			case 42120: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000672);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000732, EnemyMetis, "Metis_739");
                				break;
                			}
                			case 42150: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000673);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000733, EnemyMetis, "Metis_740");
                				break;
                			}
                			case 42180: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000674);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000734, EnemyMetis, "Metis_741");
                				break;
                			}
                			case 42210: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000675);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000735, EnemyMetis, "Metis_742");
                				break;
                			}
                			case 42240: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000676);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000736, EnemyMetis, "Metis_743");
                				break;
                			}
                			case 42270: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000677);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000737, EnemyMetis, "Metis_744");
                				break;
                			}
                			case 42300: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000678);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000738, EnemyMetis, "Metis_745");
                				break;
                			}
                			case 42330: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000679);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000739, EnemyMetis, "Metis_746");
                				break;
                			}
                			case 42360: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000680);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000740, EnemyMetis, "Metis_747");
                				break;
                			}
                			case 42390: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000681);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000741, EnemyMetis, "Metis_748");
                				break;
                			}
                			case 42420: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000682);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000742, EnemyMetis, "Metis_749");
                				break;
                			}
                			case 42450: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000683);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000743, EnemyMetis, "Metis_750");
                				break;
                			}
                			case 42480: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000684);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000744, EnemyMetis, "Metis_751");
                				break;
                			}
                			case 42510: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000685);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000745, EnemyMetis, "Metis_752");
                				break;
                			}
                			case 42540: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000686);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000746, EnemyMetis, "Metis_753");
                				break;
                			}
                			case 42570: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000687);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000747, EnemyMetis, "Metis_754");
                				break;
                			}
                			case 42600: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000688);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000748, EnemyMetis, "Metis_755");
                				break;
                			}
                			case 42630: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000689);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000749, EnemyMetis, "Metis_756");
                				break;
                			}
                			case 42660: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000690);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000750, EnemyMetis, "Metis_757");
                				break;
                			}
                			case 42690: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000691);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000751, EnemyMetis, "Metis_758");
                				break;
                			}
                			case 42720: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000692);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000752, EnemyMetis, "Metis_759");
                				break;
                			}
                			case 42750: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000693);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000753, EnemyMetis, "Metis_760");
                				break;
                			}
                			case 42780: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000694);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000754, EnemyMetis, "Metis_761");
                				break;
                			}
                			case 42810: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000695);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000755, EnemyMetis, "Metis_762");
                				break;
                			}
                			case 42840: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000696);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000756, EnemyMetis, "Metis_763");
                				break;
                			}
                			case 42870: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000697);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000757, EnemyMetis, "Metis_764");
                				break;
                			}
                			case 42900: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000698);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000758, EnemyMetis, "Metis_765");
                				break;
                			}
                			case 42930: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000699);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000759, EnemyMetis, "Metis_766");
                				break;
                			}
                			case 42960: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000700);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000760, EnemyMetis, "Metis_767");
                				break;
                			}
                			case 42990: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000701);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000761, EnemyMetis, "Metis_768");
                				break;
                			}
                			case 43020: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000702);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000762, EnemyMetis, "Metis_769");
                				break;
                			}
                			case 43050: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000703);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000763, EnemyMetis, "Metis_770");
                				break;
                			}
                			case 43080: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000704);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000764, EnemyMetis, "Metis_771");
                				break;
                			}
                			case 43110: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000705);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000765, EnemyMetis, "Metis_772");
                				break;
                			}
                			case 43140: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000706);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000766, EnemyMetis, "Metis_773");
                				break;
                			}
                			case 43170: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000707);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000767, EnemyMetis, "Metis_774");
                				break;
                			}
                			case 43200: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000708);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000768, EnemyMetis, "Metis_775");
                				break;
                			}
                			case 43230: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000709);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000769, EnemyMetis, "Metis_776");
                				break;
                			}
                			case 43260: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000710);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000770, EnemyMetis, "Metis_777");
                				break;
                			}
                			case 43290: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000711);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000771, EnemyMetis, "Metis_778");
                				break;
                			}
                			case 43320: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000712);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000772, EnemyMetis, "Metis_779");
                				break;
                			}
                			case 43350: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000713);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000773, EnemyMetis, "Metis_780");
                				break;
                			}
                			case 43380: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000714);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000774, EnemyMetis, "Metis_781");
                				break;
                			}
                			case 43410: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000715);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000775, EnemyMetis, "Metis_782");
                				break;
                			}
                			case 43440: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000716);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000776, EnemyMetis, "Metis_783");
                				break;
                			}
                			case 43470: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000717);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000777, EnemyMetis, "Metis_784");
                				break;
                			}
                			case 43500: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000718);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000778, EnemyMetis, "Metis_785");
                				break;
                			}
                			case 43530: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000719);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000779, EnemyMetis, "Metis_786");
                				break;
                			}
                			case 43560: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000720);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000780, EnemyMetis, "Metis_787");
                				break;
                			}
                			case 43590: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000721);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000781, EnemyMetis, "Metis_788");
                				break;
                			}
                			case 43620: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000722);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000782, EnemyMetis, "Metis_789");
                				break;
                			}
                			case 43650: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000723);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000783, EnemyMetis, "Metis_790");
                				break;
                			}
                			case 43680: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000724);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000784, EnemyMetis, "Metis_791");
                				break;
                			}
                			case 43710: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000725);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000785, EnemyMetis, "Metis_792");
                				break;
                			}
                			case 43740: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000726);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000786, EnemyMetis, "Metis_793");
                				break;
                			}
                			case 43770: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000727);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000787, EnemyMetis, "Metis_794");
                				break;
                			}
                			case 43800: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000728);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000788, EnemyMetis, "Metis_795");
                				break;
                			}
                			case 43830: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000729);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000789, EnemyMetis, "Metis_796");
                				break;
                			}
                			case 43860: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000730);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000790, EnemyMetis, "Metis_797");
                				break;
                			}
                			case 43890: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000731);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000791, EnemyMetis, "Metis_798");
                				break;
                			}
                			case 43920: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000732);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000792, EnemyMetis, "Metis_799");
                				break;
                			}
                			case 43950: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000733);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000793, EnemyMetis, "Metis_800");
                				break;
                			}
                			case 43980: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000734);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000794, EnemyMetis, "Metis_801");
                				break;
                			}
                			case 44010: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000735);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000795, EnemyMetis, "Metis_802");
                				break;
                			}
                			case 44040: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000736);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000796, EnemyMetis, "Metis_803");
                				break;
                			}
                			case 44070: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000737);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000797, EnemyMetis, "Metis_804");
                				break;
                			}
                			case 44100: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000738);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000798, EnemyMetis, "Metis_805");
                				break;
                			}
                			case 44130: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000739);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000799, EnemyMetis, "Metis_806");
                				break;
                			}
                			case 44160: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000740);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000800, EnemyMetis, "Metis_807");
                				break;
                			}
                			case 44190: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000741);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000801, EnemyMetis, "Metis_808");
                				break;
                			}
                			case 44220: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000742);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000802, EnemyMetis, "Metis_809");
                				break;
                			}
                			case 44250: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000743);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000803, EnemyMetis, "Metis_810");
                				break;
                			}
                			case 44280: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000744);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000804, EnemyMetis, "Metis_811");
                				break;
                			}
                			case 44310: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000745);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000805, EnemyMetis, "Metis_812");
                				break;
                			}
                			case 44340: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000746);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000806, EnemyMetis, "Metis_813");
                				break;
                			}
                			case 44370: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000747);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000807, EnemyMetis, "Metis_814");
                				break;
                			}
                			case 44400: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000748);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000808, EnemyMetis, "Metis_815");
                				break;
                			}
                			case 44430: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000749);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000809, EnemyMetis, "Metis_816");
                				break;
                			}
                			case 44460: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000750);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000810, EnemyMetis, "Metis_817");
                				break;
                			}
                			case 44490: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000751);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000811, EnemyMetis, "Metis_818");
                				break;
                			}
                			case 44520: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000752);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000812, EnemyMetis, "Metis_819");
                				break;
                			}
                			case 44550: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000753);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000813, EnemyMetis, "Metis_820");
                				break;
                			}
                			case 44580: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000754);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000814, EnemyMetis, "Metis_821");
                				break;
                			}
                			case 44610: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000755);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000815, EnemyMetis, "Metis_822");
                				break;
                			}
                			case 44640: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000756);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000816, EnemyMetis, "Metis_823");
                				break;
                			}
                			case 44670: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000757);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000817, EnemyMetis, "Metis_824");
                				break;
                			}
                			case 44700: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000758);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000818, EnemyMetis, "Metis_825");
                				break;
                			}
                			case 44730: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000759);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000819, EnemyMetis, "Metis_826");
                				break;
                			}
                			case 44760: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000760);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000820, EnemyMetis, "Metis_827");
                				break;
                			}
                			case 44790: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000761);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000821, EnemyMetis, "Metis_828");
                				break;
                			}
                			case 44820: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000762);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000822, EnemyMetis, "Metis_829");
                				break;
                			}
                			case 44850: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000763);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000823, EnemyMetis, "Metis_830");
                				break;
                			}
                			case 44880: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000764);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000824, EnemyMetis, "Metis_831");
                				break;
                			}
                			case 44910: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000765);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000825, EnemyMetis, "Metis_832");
                				break;
                			}
                			case 44940: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000766);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000826, EnemyMetis, "Metis_833");
                				break;
                			}
                			case 44970: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000767);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000827, EnemyMetis, "Metis_834");
                				break;
                			}
                			case 45000: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000768);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000828, EnemyMetis, "Metis_835");
                				break;
                			}
                			case 45030: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000769);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000829, EnemyMetis, "Metis_836");
                				break;
                			}
                			case 45060: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000770);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000830, EnemyMetis, "Metis_837");
                				break;
                			}
                			case 45090: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000771);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000831, EnemyMetis, "Metis_838");
                				break;
                			}
                			case 45120: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000772);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000832, EnemyMetis, "Metis_839");
                				break;
                			}
                			case 45150: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000773);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000833, EnemyMetis, "Metis_840");
                				break;
                			}
                			case 45180: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000774);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000834, EnemyMetis, "Metis_841");
                				break;
                			}
                			case 45210: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000775);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000835, EnemyMetis, "Metis_842");
                				break;
                			}
                			case 45240: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000776);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000836, EnemyMetis, "Metis_843");
                				break;
                			}
                			case 45270: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000777);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000837, EnemyMetis, "Metis_844");
                				break;
                			}
                			case 45300: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000778);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000838, EnemyMetis, "Metis_845");
                				break;
                			}
                			case 45330: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000779);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000839, EnemyMetis, "Metis_846");
                				break;
                			}
                			case 45360: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000780);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000840, EnemyMetis, "Metis_847");
                				break;
                			}
                			case 45390: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000781);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000841, EnemyMetis, "Metis_848");
                				break;
                			}
                			case 45420: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000782);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000842, EnemyMetis, "Metis_849");
                				break;
                			}
                			case 45450: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000783);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000843, EnemyMetis, "Metis_850");
                				break;
                			}
                			case 45480: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000784);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000844, EnemyMetis, "Metis_851");
                				break;
                			}
                			case 45510: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000785);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000845, EnemyMetis, "Metis_852");
                				break;
                			}
                			case 45540: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000786);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000846, EnemyMetis, "Metis_853");
                				break;
                			}
                			case 45570: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000787);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000847, EnemyMetis, "Metis_854");
                				break;
                			}
                			case 45600: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000788);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000848, EnemyMetis, "Metis_855");
                				break;
                			}
                			case 45630: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000789);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000849, EnemyMetis, "Metis_856");
                				break;
                			}
                			case 45660: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000790);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000850, EnemyMetis, "Metis_857");
                				break;
                			}
                			case 45690: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000791);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000851, EnemyMetis, "Metis_858");
                				break;
                			}
                			case 45720: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000792);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000852, EnemyMetis, "Metis_859");
                				break;
                			}
                			case 45750: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000793);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000853, EnemyMetis, "Metis_860");
                				break;
                			}
                			case 45780: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000794);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000854, EnemyMetis, "Metis_861");
                				break;
                			}
                			case 45810: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000795);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000855, EnemyMetis, "Metis_862");
                				break;
                			}
                			case 45840: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000796);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000856, EnemyMetis, "Metis_863");
                				break;
                			}
                			case 45870: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000797);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000857, EnemyMetis, "Metis_864");
                				break;
                			}
                			case 45900: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000798);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000858, EnemyMetis, "Metis_865");
                				break;
                			}
                			case 45930: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000799);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000859, EnemyMetis, "Metis_866");
                				break;
                			}
                			case 45960: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000800);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000860, EnemyMetis, "Metis_867");
                				break;
                			}
                			case 45990: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000801);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000861, EnemyMetis, "Metis_868");
                				break;
                			}
                			case 46020: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000802);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000862, EnemyMetis, "Metis_869");
                				break;
                			}
                			case 46050: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000803);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000863, EnemyMetis, "Metis_870");
                				break;
                			}
                			case 46080: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000804);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000864, EnemyMetis, "Metis_871");
                				break;
                			}
                			case 46110: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000805);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000865, EnemyMetis, "Metis_872");
                				break;
                			}
                			case 46140: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000806);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000866, EnemyMetis, "Metis_873");
                				break;
                			}
                			case 46170: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000807);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000867, EnemyMetis, "Metis_874");
                				break;
                			}
                			case 46200: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000808);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000868, EnemyMetis, "Metis_875");
                				break;
                			}
                			case 46230: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000809);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000869, EnemyMetis, "Metis_876");
                				break;
                			}
                			case 46260: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000810);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000870, EnemyMetis, "Metis_877");
                				break;
                			}
                			case 46290: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000811);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000871, EnemyMetis, "Metis_878");
                				break;
                			}
                			case 46320: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000812);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000872, EnemyMetis, "Metis_879");
                				break;
                			}
                			case 46350: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000813);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000873, EnemyMetis, "Metis_880");
                				break;
                			}
                			case 46380: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000814);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000874, EnemyMetis, "Metis_881");
                				break;
                			}
                			case 46410: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000815);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000875, EnemyMetis, "Metis_882");
                				break;
                			}
                			case 46440: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000816);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000876, EnemyMetis, "Metis_883");
                				break;
                			}
                			case 46470: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000817);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000877, EnemyMetis, "Metis_884");
                				break;
                			}
                			case 46500: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000818);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000878, EnemyMetis, "Metis_885");
                				break;
                			}
                			case 46530: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000819);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000879, EnemyMetis, "Metis_886");
                				break;
                			}
                			case 46560: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000820);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000880, EnemyMetis, "Metis_887");
                				break;
                			}
                			case 46590: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000821);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000881, EnemyMetis, "Metis_888");
                				break;
                			}
                			case 46620: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000822);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000882, EnemyMetis, "Metis_889");
                				break;
                			}
                			case 46650: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000823);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000883, EnemyMetis, "Metis_890");
                				break;
                			}
                			case 46680: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000824);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000884, EnemyMetis, "Metis_891");
                				break;
                			}
                			case 46710: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000825);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000885, EnemyMetis, "Metis_892");
                				break;
                			}
                			case 46740: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000826);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000886, EnemyMetis, "Metis_893");
                				break;
                			}
                			case 46770: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000827);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000887, EnemyMetis, "Metis_894");
                				break;
                			}
                			case 46800: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000828);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000888, EnemyMetis, "Metis_895");
                				break;
                			}
                			case 46830: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000829);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000889, EnemyMetis, "Metis_896");
                				break;
                			}
                			case 46860: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000830);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000890, EnemyMetis, "Metis_897");
                				break;
                			}
                			case 46890: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000831);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000891, EnemyMetis, "Metis_898");
                				break;
                			}
                			case 46920: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000832);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000892, EnemyMetis, "Metis_899");
                				break;
                			}
                			case 46950: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000833);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000893, EnemyMetis, "Metis_900");
                				break;
                			}
                			case 46980: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000834);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000894, EnemyMetis, "Metis_901");
                				break;
                			}
                			case 47010: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000835);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000895, EnemyMetis, "Metis_902");
                				break;
                			}
                			case 47040: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000836);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000896, EnemyMetis, "Metis_903");
                				break;
                			}
                			case 47070: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000837);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000897, EnemyMetis, "Metis_904");
                				break;
                			}
                			case 47100: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000838);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000898, EnemyMetis, "Metis_905");
                				break;
                			}
                			case 47130: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000839);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000899, EnemyMetis, "Metis_906");
                				break;
                			}
                			case 47160: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000840);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000900, EnemyMetis, "Metis_907");
                				break;
                			}
                			case 47190: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000841);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000901, EnemyMetis, "Metis_908");
                				break;
                			}
                			case 47220: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000842);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000902, EnemyMetis, "Metis_909");
                				break;
                			}
                			case 47250: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000843);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000903, EnemyMetis, "Metis_910");
                				break;
                			}
                			case 47280: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000844);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000904, EnemyMetis, "Metis_911");
                				break;
                			}
                			case 47310: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000845);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000905, EnemyMetis, "Metis_912");
                				break;
                			}
                			case 47340: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000846);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000906, EnemyMetis, "Metis_913");
                				break;
                			}
                			case 47370: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000847);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000907, EnemyMetis, "Metis_914");
                				break;
                			}
                			case 47400: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000848);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000908, EnemyMetis, "Metis_915");
                				break;
                			}
                			case 47430: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000849);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000909, EnemyMetis, "Metis_916");
                				break;
                			}
                			case 47460: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000850);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000910, EnemyMetis, "Metis_917");
                				break;
                			}
                			case 47490: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000851);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000911, EnemyMetis, "Metis_918");
                				break;
                			}
                			case 47520: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000852);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000912, EnemyMetis, "Metis_919");
                				break;
                			}
                			case 47550: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000853);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000913, EnemyMetis, "Metis_920");
                				break;
                			}
                			case 47580: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000854);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000914, EnemyMetis, "Metis_921");
                				break;
                			}
                			case 47610: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000855);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000915, EnemyMetis, "Metis_922");
                				break;
                			}
                			case 47640: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000856);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000916, EnemyMetis, "Metis_923");
                				break;
                			}
                			case 47670: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000857);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000917, EnemyMetis, "Metis_924");
                				break;
                			}
                			case 47700: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000858);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000918, EnemyMetis, "Metis_925");
                				break;
                			}
                			case 47730: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000859);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000919, EnemyMetis, "Metis_926");
                				break;
                			}
                			case 47760: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000860);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000920, EnemyMetis, "Metis_927");
                				break;
                			}
                			case 47790: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000861);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000921, EnemyMetis, "Metis_928");
                				break;
                			}
                			case 47820: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000862);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000922, EnemyMetis, "Metis_929");
                				break;
                			}
                			case 47850: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000863);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000923, EnemyMetis, "Metis_930");
                				break;
                			}
                			case 47880: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000864);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000924, EnemyMetis, "Metis_931");
                				break;
                			}
                			case 47910: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000865);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000925, EnemyMetis, "Metis_932");
                				break;
                			}
                			case 47940: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000866);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000926, EnemyMetis, "Metis_933");
                				break;
                			}
                			case 47970: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000867);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000927, EnemyMetis, "Metis_934");
                				break;
                			}
                			case 48000: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000868);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000928, EnemyMetis, "Metis_935");
                				break;
                			}
                			case 48030: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000869);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000929, EnemyMetis, "Metis_936");
                				break;
                			}
                			case 48060: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000870);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000930, EnemyMetis, "Metis_937");
                				break;
                			}
                			case 48090: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000871);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000931, EnemyMetis, "Metis_938");
                				break;
                			}
                			case 48120: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000872);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000932, EnemyMetis, "Metis_939");
                				break;
                			}
                			case 48150: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000873);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000933, EnemyMetis, "Metis_940");
                				break;
                			}
                			case 48180: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000874);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000934, EnemyMetis, "Metis_941");
                				break;
                			}
                			case 48210: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000875);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000935, EnemyMetis, "Metis_942");
                				break;
                			}
                			case 48240: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000876);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000936, EnemyMetis, "Metis_943");
                				break;
                			}
                			case 48270: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000877);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000937, EnemyMetis, "Metis_944");
                				break;
                			}
                			case 48300: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000878);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000938, EnemyMetis, "Metis_945");
                				break;
                			}
                			case 48330: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000879);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000939, EnemyMetis, "Metis_946");
                				break;
                			}
                			case 48360: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000880);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000940, EnemyMetis, "Metis_947");
                				break;
                			}
                			case 48390: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000881);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000941, EnemyMetis, "Metis_948");
                				break;
                			}
                			case 48420: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000882);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000942, EnemyMetis, "Metis_949");
                				break;
                			}
                			case 48450: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000883);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000943, EnemyMetis, "Metis_950");
                				break;
                			}
                			case 48480: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000884);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000944, EnemyMetis, "Metis_951");
                				break;
                			}
                			case 48510: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000885);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000945, EnemyMetis, "Metis_952");
                				break;
                			}
                			case 48540: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000886);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000946, EnemyMetis, "Metis_953");
                				break;
                			}
                			case 48570: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000887);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000947, EnemyMetis, "Metis_954");
                				break;
                			}
                			case 48600: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000888);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000948, EnemyMetis, "Metis_955");
                				break;
                			}
                			case 48630: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000889);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000949, EnemyMetis, "Metis_956");
                				break;
                			}
                			case 48660: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000890);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000950, EnemyMetis, "Metis_957");
                				break;
                			}
                			case 48690: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000891);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000951, EnemyMetis, "Metis_958");
                				break;
                			}
                			case 48720: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000892);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000952, EnemyMetis, "Metis_959");
                				break;
                			}
                			case 48750: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000893);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000953, EnemyMetis, "Metis_960");
                				break;
                			}
                			case 48780: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000894);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000954, EnemyMetis, "Metis_961");
                				break;
                			}
                			case 48810: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000895);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000955, EnemyMetis, "Metis_962");
                				break;
                			}
                			case 48840: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000896);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000956, EnemyMetis, "Metis_963");
                				break;
                			}
                			case 48870: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000897);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000957, EnemyMetis, "Metis_964");
                				break;
                			}
                			case 48900: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000898);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000958, EnemyMetis, "Metis_965");
                				break;
                			}
                			case 48930: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000899);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000959, EnemyMetis, "Metis_966");
                				break;
                			}
                			case 48960: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000900);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000960, EnemyMetis, "Metis_967");
                				break;
                			}
                			case 48990: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000901);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000961, EnemyMetis, "Metis_968");
                				break;
                			}
                			case 49020: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000902);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000962, EnemyMetis, "Metis_969");
                				break;
                			}
                			case 49050: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000903);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000963, EnemyMetis, "Metis_970");
                				break;
                			}
                			case 49080: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000904);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000964, EnemyMetis, "Metis_971");
                				break;
                			}
                			case 49110: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000905);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000965, EnemyMetis, "Metis_972");
                				break;
                			}
                			case 49140: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000906);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000966, EnemyMetis, "Metis_973");
                				break;
                			}
                			case 49170: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000907);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000967, EnemyMetis, "Metis_974");
                				break;
                			}
                			case 49200: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000908);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000968, EnemyMetis, "Metis_975");
                				break;
                			}
                			case 49230: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000909);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000969, EnemyMetis, "Metis_976");
                				break;
                			}
                			case 49260: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000910);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000970, EnemyMetis, "Metis_977");
                				break;
                			}
                			case 49290: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000911);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000971, EnemyMetis, "Metis_978");
                				break;
                			}
                			case 49320: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000912);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000972, EnemyMetis, "Metis_979");
                				break;
                			}
                			case 49350: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000913);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000973, EnemyMetis, "Metis_980");
                				break;
                			}
                			case 49380: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000914);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000974, EnemyMetis, "Metis_981");
                				break;
                			}
                			case 49410: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000915);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000975, EnemyMetis, "Metis_982");
                				break;
                			}
                			case 49440: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000916);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000976, EnemyMetis, "Metis_983");
                				break;
                			}
                			case 49470: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000917);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000977, EnemyMetis, "Metis_984");
                				break;
                			}
                			case 49500: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000918);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000978, EnemyMetis, "Metis_985");
                				break;
                			}
                			case 49530: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000919);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000979, EnemyMetis, "Metis_986");
                				break;
                			}
                			case 49560: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000920);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000980, EnemyMetis, "Metis_987");
                				break;
                			}
                			case 49590: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000921);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000981, EnemyMetis, "Metis_988");
                				break;
                			}
                			case 49620: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000922);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000982, EnemyMetis, "Metis_989");
                				break;
                			}
                			case 49650: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000923);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000983, EnemyMetis, "Metis_990");
                				break;
                			}
                			case 49680: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000924);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000984, EnemyMetis, "Metis_991");
                				break;
                			}
                			case 49710: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000925);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000985, EnemyMetis, "Metis_992");
                				break;
                			}
                			case 49740: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000926);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000986, EnemyMetis, "Metis_993");
                				break;
                			}
                			case 49770: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000927);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000987, EnemyMetis, "Metis_994");
                				break;
                			}
                			case 49800: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000928);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000988, EnemyMetis, "Metis_995");
                				break;
                			}
                			case 49830: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000929);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000989, EnemyMetis, "Metis_996");
                				break;
                			}
                			case 49860: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000930);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000990, EnemyMetis, "Metis_997");
                				break;
                			}
                			case 49890: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000931);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000991, EnemyMetis, "Metis_998");
                				break;
                			}
                			case 49920: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000932);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000992, EnemyMetis, "Metis_999");
                				break;
                			}
                			case 49950: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000933);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000993, EnemyMetis, "Metis_1000");
                				break;
                			}
                			case 49980: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000934);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000994, EnemyMetis, "Metis_1001");
                				break;
                			}
                			case 50010: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000935);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000995, EnemyMetis, "Metis_1002");
                				break;
                			}
                			case 50040: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000936);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000996, EnemyMetis, "Metis_1003");
                				break;
                			}
                			case 50070: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000937);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000997, EnemyMetis, "Metis_1004");
                				break;
                			}
                			case 50100: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000938);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000998, EnemyMetis, "Metis_1005");
                				break;
                			}
                			case 50130: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000939);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40000999, EnemyMetis, "Metis_1006");
                				break;
                			}
                			case 50160: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000940);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001000, EnemyMetis, "Metis_1007");
                				break;
                			}
                			case 50190: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000941);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001001, EnemyMetis, "Metis_1008");
                				break;
                			}
                			case 50220: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000942);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001002, EnemyMetis, "Metis_1009");
                				break;
                			}
                			case 50250: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000943);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001003, EnemyMetis, "Metis_1010");
                				break;
                			}
                			case 50280: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000944);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001004, EnemyMetis, "Metis_1011");
                				break;
                			}
                			case 50310: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000945);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001005, EnemyMetis, "Metis_1012");
                				break;
                			}
                			case 50340: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000946);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001006, EnemyMetis, "Metis_1013");
                				break;
                			}
                			case 50370: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000947);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001007, EnemyMetis, "Metis_1014");
                				break;
                			}
                			case 50400: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000948);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001008, EnemyMetis, "Metis_1015");
                				break;
                			}
                			case 50430: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000949);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001009, EnemyMetis, "Metis_1016");
                				break;
                			}
                			case 50460: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000950);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001010, EnemyMetis, "Metis_1017");
                				break;
                			}
                			case 50490: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000951);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001011, EnemyMetis, "Metis_1018");
                				break;
                			}
                			case 50520: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000952);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001012, EnemyMetis, "Metis_1019");
                				break;
                			}
                			case 50550: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000953);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001013, EnemyMetis, "Metis_1020");
                				break;
                			}
                			case 50580: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000954);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001014, EnemyMetis, "Metis_1021");
                				break;
                			}
                			case 50610: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000955);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001015, EnemyMetis, "Metis_1022");
                				break;
                			}
                			case 50640: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000956);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001016, EnemyMetis, "Metis_1023");
                				break;
                			}
                			case 50670: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000957);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001017, EnemyMetis, "Metis_1024");
                				break;
                			}
                			case 50700: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000958);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001018, EnemyMetis, "Metis_1025");
                				break;
                			}
                			case 50730: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000959);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001019, EnemyMetis, "Metis_1026");
                				break;
                			}
                			case 50760: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000960);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001020, EnemyMetis, "Metis_1027");
                				break;
                			}
                			case 50790: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000961);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001021, EnemyMetis, "Metis_1028");
                				break;
                			}
                			case 50820: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000962);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001022, EnemyMetis, "Metis_1029");
                				break;
                			}
                			case 50850: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000963);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001023, EnemyMetis, "Metis_1030");
                				break;
                			}
                			case 50880: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000964);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001024, EnemyMetis, "Metis_1031");
                				break;
                			}
                			case 50910: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000965);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001025, EnemyMetis, "Metis_1032");
                				break;
                			}
                			case 50940: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000966);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001026, EnemyMetis, "Metis_1033");
                				break;
                			}
                			case 50970: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000967);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001027, EnemyMetis, "Metis_1034");
                				break;
                			}
                			case 51000: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000968);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001028, EnemyMetis, "Metis_1035");
                				break;
                			}
                			case 51030: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000969);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001029, EnemyMetis, "Metis_1036");
                				break;
                			}
                			case 51060: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000970);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001030, EnemyMetis, "Metis_1037");
                				break;
                			}
                			case 51090: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000971);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001031, EnemyMetis, "Metis_1038");
                				break;
                			}
                			case 51120: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000972);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001032, EnemyMetis, "Metis_1039");
                				break;
                			}
                			case 51150: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000973);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001033, EnemyMetis, "Metis_1040");
                				break;
                			}
                			case 51180: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000974);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001034, EnemyMetis, "Metis_1041");
                				break;
                			}
                			case 51210: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000975);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001035, EnemyMetis, "Metis_1042");
                				break;
                			}
                			case 51240: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000976);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001036, EnemyMetis, "Metis_1043");
                				break;
                			}
                			case 51270: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000977);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001037, EnemyMetis, "Metis_1044");
                				break;
                			}
                			case 51300: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000978);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001038, EnemyMetis, "Metis_1045");
                				break;
                			}
                			case 51330: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000979);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001039, EnemyMetis, "Metis_1046");
                				break;
                			}
                			case 51360: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000980);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001040, EnemyMetis, "Metis_1047");
                				break;
                			}
                			case 51390: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000981);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001041, EnemyMetis, "Metis_1048");
                				break;
                			}
                			case 51420: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000982);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001042, EnemyMetis, "Metis_1049");
                				break;
                			}
                			case 51450: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000983);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001043, EnemyMetis, "Metis_1050");
                				break;
                			}
                			case 51480: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000984);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001044, EnemyMetis, "Metis_1051");
                				break;
                			}
                			case 51510: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000985);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001045, EnemyMetis, "Metis_1052");
                				break;
                			}
                			case 51540: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000986);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001046, EnemyMetis, "Metis_1053");
                				break;
                			}
                			case 51570: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000987);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001047, EnemyMetis, "Metis_1054");
                				break;
                			}
                			case 51600: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000988);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001048, EnemyMetis, "Metis_1055");
                				break;
                			}
                			case 51630: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000989);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001049, EnemyMetis, "Metis_1056");
                				break;
                			}
                			case 51660: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000990);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001050, EnemyMetis, "Metis_1057");
                				break;
                			}
                			case 51690: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000991);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001051, EnemyMetis, "Metis_1058");
                				break;
                			}
                			case 51720: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000992);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001052, EnemyMetis, "Metis_1059");
                				break;
                			}
                			case 51750: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000993);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001053, EnemyMetis, "Metis_1060");
                				break;
                			}
                			case 51780: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000994);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001054, EnemyMetis, "Metis_1061");
                				break;
                			}
                			case 51810: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000995);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001055, EnemyMetis, "Metis_1062");
                				break;
                			}
                			case 51840: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000996);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001056, EnemyMetis, "Metis_1063");
                				break;
                			}
                			case 51870: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000997);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001057, EnemyMetis, "Metis_1064");
                				break;
                			}
                			case 51900: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000998);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001058, EnemyMetis, "Metis_1065");
                				break;
                			}
                			case 51930: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40000999);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001059, EnemyMetis, "Metis_1066");
                				break;
                			}
                			case 51960: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001000);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001060, EnemyMetis, "Metis_1067");
                				break;
                			}
                			case 51990: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001001);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001061, EnemyMetis, "Metis_1068");
                				break;
                			}
                			case 52020: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001002);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001062, EnemyMetis, "Metis_1069");
                				break;
                			}
                			case 52050: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001003);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001063, EnemyMetis, "Metis_1070");
                				break;
                			}
                			case 52080: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001004);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001064, EnemyMetis, "Metis_1071");
                				break;
                			}
                			case 52110: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001005);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001065, EnemyMetis, "Metis_1072");
                				break;
                			}
                			case 52140: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001006);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001066, EnemyMetis, "Metis_1073");
                				break;
                			}
                			case 52170: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001007);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001067, EnemyMetis, "Metis_1074");
                				break;
                			}
                			case 52200: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001008);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001068, EnemyMetis, "Metis_1075");
                				break;
                			}
                			case 52230: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001009);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001069, EnemyMetis, "Metis_1076");
                				break;
                			}
                			case 52260: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001010);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001070, EnemyMetis, "Metis_1077");
                				break;
                			}
                			case 52290: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001011);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001071, EnemyMetis, "Metis_1078");
                				break;
                			}
                			case 52320: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001012);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001072, EnemyMetis, "Metis_1079");
                				break;
                			}
                			case 52350: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001013);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001073, EnemyMetis, "Metis_1080");
                				break;
                			}
                			case 52380: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001014);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001074, EnemyMetis, "Metis_1081");
                				break;
                			}
                			case 52410: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001015);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001075, EnemyMetis, "Metis_1082");
                				break;
                			}
                			case 52440: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001016);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001076, EnemyMetis, "Metis_1083");
                				break;
                			}
                			case 52470: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001017);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001077, EnemyMetis, "Metis_1084");
                				break;
                			}
                			case 52500: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001018);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001078, EnemyMetis, "Metis_1085");
                				break;
                			}
                			case 52530: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001019);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001079, EnemyMetis, "Metis_1086");
                				break;
                			}
                			case 52560: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001020);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001080, EnemyMetis, "Metis_1087");
                				break;
                			}
                			case 52590: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001021);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001081, EnemyMetis, "Metis_1088");
                				break;
                			}
                			case 52620: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001022);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001082, EnemyMetis, "Metis_1089");
                				break;
                			}
                			case 52650: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001023);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001083, EnemyMetis, "Metis_1090");
                				break;
                			}
                			case 52680: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001024);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001084, EnemyMetis, "Metis_1091");
                				break;
                			}
                			case 52710: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001025);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001085, EnemyMetis, "Metis_1092");
                				break;
                			}
                			case 52740: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001026);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001086, EnemyMetis, "Metis_1093");
                				break;
                			}
                			case 52770: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001027);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001087, EnemyMetis, "Metis_1094");
                				break;
                			}
                			case 52800: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001028);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001088, EnemyMetis, "Metis_1095");
                				break;
                			}
                			case 52830: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001029);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001089, EnemyMetis, "Metis_1096");
                				break;
                			}
                			case 52860: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001030);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001090, EnemyMetis, "Metis_1097");
                				break;
                			}
                			case 52890: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001031);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001091, EnemyMetis, "Metis_1098");
                				break;
                			}
                			case 52920: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001032);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001092, EnemyMetis, "Metis_1099");
                				break;
                			}
                			case 52950: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001033);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001093, EnemyMetis, "Metis_1100");
                				break;
                			}
                			case 52980: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001034);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001094, EnemyMetis, "Metis_1101");
                				break;
                			}
                			case 53010: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001035);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001095, EnemyMetis, "Metis_1102");
                				break;
                			}
                			case 53040: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001036);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001096, EnemyMetis, "Metis_1103");
                				break;
                			}
                			case 53070: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001037);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001097, EnemyMetis, "Metis_1104");
                				break;
                			}
                			case 53100: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001038);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001098, EnemyMetis, "Metis_1105");
                				break;
                			}
                			case 53130: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001039);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001099, EnemyMetis, "Metis_1106");
                				break;
                			}
                			case 53160: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001040);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001100, EnemyMetis, "Metis_1107");
                				break;
                			}
                			case 53190: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001041);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001101, EnemyMetis, "Metis_1108");
                				break;
                			}
                			case 53220: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001042);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001102, EnemyMetis, "Metis_1109");
                				break;
                			}
                			case 53250: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001043);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001103, EnemyMetis, "Metis_1110");
                				break;
                			}
                			case 53280: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001044);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001104, EnemyMetis, "Metis_1111");
                				break;
                			}
                			case 53310: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001045);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001105, EnemyMetis, "Metis_1112");
                				break;
                			}
                			case 53340: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001046);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001106, EnemyMetis, "Metis_1113");
                				break;
                			}
                			case 53370: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001047);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001107, EnemyMetis, "Metis_1114");
                				break;
                			}
                			case 53400: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001048);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001108, EnemyMetis, "Metis_1115");
                				break;
                			}
                			case 53430: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001049);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001109, EnemyMetis, "Metis_1116");
                				break;
                			}
                			case 53460: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001050);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001110, EnemyMetis, "Metis_1117");
                				break;
                			}
                			case 53490: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001051);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001111, EnemyMetis, "Metis_1118");
                				break;
                			}
                			case 53520: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001052);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001112, EnemyMetis, "Metis_1119");
                				break;
                			}
                			case 53550: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001053);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001113, EnemyMetis, "Metis_1120");
                				break;
                			}
                			case 53580: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001054);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001114, EnemyMetis, "Metis_1121");
                				break;
                			}
                			case 53610: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001055);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001115, EnemyMetis, "Metis_1122");
                				break;
                			}
                			case 53640: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001056);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001116, EnemyMetis, "Metis_1123");
                				break;
                			}
                			case 53670: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001057);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001117, EnemyMetis, "Metis_1124");
                				break;
                			}
                			case 53700: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001058);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001118, EnemyMetis, "Metis_1125");
                				break;
                			}
                			case 53730: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001059);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001119, EnemyMetis, "Metis_1126");
                				break;
                			}
                			case 53760: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001060);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001120, EnemyMetis, "Metis_1127");
                				break;
                			}
                			case 53790: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001061);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001121, EnemyMetis, "Metis_1128");
                				break;
                			}
                			case 53820: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001062);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001122, EnemyMetis, "Metis_1129");
                				break;
                			}
                			case 53850: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001063);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001123, EnemyMetis, "Metis_1130");
                				break;
                			}
                			case 53880: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001064);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001124, EnemyMetis, "Metis_1131");
                				break;
                			}
                			case 53910: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001065);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001125, EnemyMetis, "Metis_1132");
                				break;
                			}
                			case 53940: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001066);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001126, EnemyMetis, "Metis_1133");
                				break;
                			}
                			case 53970: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001067);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001127, EnemyMetis, "Metis_1134");
                				break;
                			}
                			case 54000: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001068);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001128, EnemyMetis, "Metis_1135");
                				break;
                			}
                			case 54030: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001069);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001129, EnemyMetis, "Metis_1136");
                				break;
                			}
                			case 54060: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001070);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001130, EnemyMetis, "Metis_1137");
                				break;
                			}
                			case 54090: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001071);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001131, EnemyMetis, "Metis_1138");
                				break;
                			}
                			case 54120: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001072);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001132, EnemyMetis, "Metis_1139");
                				break;
                			}
                			case 54150: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001073);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001133, EnemyMetis, "Metis_1140");
                				break;
                			}
                			case 54180: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001074);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001134, EnemyMetis, "Metis_1141");
                				break;
                			}
                			case 54210: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001075);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001135, EnemyMetis, "Metis_1142");
                				break;
                			}
                			case 54240: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001076);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001136, EnemyMetis, "Metis_1143");
                				break;
                			}
                			case 54270: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001077);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001137, EnemyMetis, "Metis_1144");
                				break;
                			}
                			case 54300: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001078);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001138, EnemyMetis, "Metis_1145");
                				break;
                			}
                			case 54330: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001079);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001139, EnemyMetis, "Metis_1146");
                				break;
                			}
                			case 54360: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001080);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001140, EnemyMetis, "Metis_1147");
                				break;
                			}
                			case 54390: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001081);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001141, EnemyMetis, "Metis_1148");
                				break;
                			}
                			case 54420: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001082);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001142, EnemyMetis, "Metis_1149");
                				break;
                			}
                			case 54450: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001083);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001143, EnemyMetis, "Metis_1150");
                				break;
                			}
                			case 54480: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001084);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001144, EnemyMetis, "Metis_1151");
                				break;
                			}
                			case 54510: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001085);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001145, EnemyMetis, "Metis_1152");
                				break;
                			}
                			case 54540: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001086);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001146, EnemyMetis, "Metis_1153");
                				break;
                			}
                			case 54570: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001087);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001147, EnemyMetis, "Metis_1154");
                				break;
                			}
                			case 54600: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001088);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001148, EnemyMetis, "Metis_1155");
                				break;
                			}
                			case 54630: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001089);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001149, EnemyMetis, "Metis_1156");
                				break;
                			}
                			case 54660: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001090);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001150, EnemyMetis, "Metis_1157");
                				break;
                			}
                			case 54690: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001091);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001151, EnemyMetis, "Metis_1158");
                				break;
                			}
                			case 54720: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001092);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001152, EnemyMetis, "Metis_1159");
                				break;
                			}
                			case 54750: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001093);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001153, EnemyMetis, "Metis_1160");
                				break;
                			}
                			case 54780: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001094);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001154, EnemyMetis, "Metis_1161");
                				break;
                			}
                			case 54810: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001095);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001155, EnemyMetis, "Metis_1162");
                				break;
                			}
                			case 54840: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001096);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001156, EnemyMetis, "Metis_1163");
                				break;
                			}
                			case 54870: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001097);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001157, EnemyMetis, "Metis_1164");
                				break;
                			}
                			case 54900: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001098);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001158, EnemyMetis, "Metis_1165");
                				break;
                			}
                			case 54930: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001099);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001159, EnemyMetis, "Metis_1166");
                				break;
                			}
                			case 54960: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001100);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001160, EnemyMetis, "Metis_1167");
                				break;
                			}
                			case 54990: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001101);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001161, EnemyMetis, "Metis_1168");
                				break;
                			}
                			case 55020: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001102);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001162, EnemyMetis, "Metis_1169");
                				break;
                			}
                			case 55050: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001103);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001163, EnemyMetis, "Metis_1170");
                				break;
                			}
                			case 55080: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001104);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001164, EnemyMetis, "Metis_1171");
                				break;
                			}
                			case 55110: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001105);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001165, EnemyMetis, "Metis_1172");
                				break;
                			}
                			case 55140: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001106);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001166, EnemyMetis, "Metis_1173");
                				break;
                			}
                			case 55170: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001107);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001167, EnemyMetis, "Metis_1174");
                				break;
                			}
                			case 55200: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001108);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001168, EnemyMetis, "Metis_1175");
                				break;
                			}
                			case 55230: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001109);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001169, EnemyMetis, "Metis_1176");
                				break;
                			}
                			case 55260: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001110);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001170, EnemyMetis, "Metis_1177");
                				break;
                			}
                			case 55290: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001111);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001171, EnemyMetis, "Metis_1178");
                				break;
                			}
                			case 55320: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001112);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001172, EnemyMetis, "Metis_1179");
                				break;
                			}
                			case 55350: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001113);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001173, EnemyMetis, "Metis_1180");
                				break;
                			}
                			case 55380: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001114);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001174, EnemyMetis, "Metis_1181");
                				break;
                			}
                			case 55410: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001115);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001175, EnemyMetis, "Metis_1182");
                				break;
                			}
                			case 55440: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001116);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001176, EnemyMetis, "Metis_1183");
                				break;
                			}
                			case 55470: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001117);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001177, EnemyMetis, "Metis_1184");
                				break;
                			}
                			case 55500: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001118);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001178, EnemyMetis, "Metis_1185");
                				break;
                			}
                			case 55530: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001119);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001179, EnemyMetis, "Metis_1186");
                				break;
                			}
                			case 55560: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001120);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001180, EnemyMetis, "Metis_1187");
                				break;
                			}
                			case 55590: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001121);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001181, EnemyMetis, "Metis_1188");
                				break;
                			}
                			case 55620: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001122);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001182, EnemyMetis, "Metis_1189");
                				break;
                			}
                			case 55650: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001123);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001183, EnemyMetis, "Metis_1190");
                				break;
                			}
                			case 55680: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001124);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001184, EnemyMetis, "Metis_1191");
                				break;
                			}
                			case 55710: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001125);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001185, EnemyMetis, "Metis_1192");
                				break;
                			}
                			case 55740: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001126);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001186, EnemyMetis, "Metis_1193");
                				break;
                			}
                			case 55770: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001127);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001187, EnemyMetis, "Metis_1194");
                				break;
                			}
                			case 55800: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001128);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001188, EnemyMetis, "Metis_1195");
                				break;
                			}
                			case 55830: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001129);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001189, EnemyMetis, "Metis_1196");
                				break;
                			}
                			case 55860: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001130);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001190, EnemyMetis, "Metis_1197");
                				break;
                			}
                			case 55890: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001131);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001191, EnemyMetis, "Metis_1198");
                				break;
                			}
                			case 55920: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001132);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001192, EnemyMetis, "Metis_1199");
                				break;
                			}
                			case 55950: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001133);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001193, EnemyMetis, "Metis_1200");
                				break;
                			}
                			case 55980: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001134);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001194, EnemyMetis, "Metis_1201");
                				break;
                			}
                			case 56010: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001135);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001195, EnemyMetis, "Metis_1202");
                				break;
                			}
                			case 56040: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001136);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001196, EnemyMetis, "Metis_1203");
                				break;
                			}
                			case 56070: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001137);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001197, EnemyMetis, "Metis_1204");
                				break;
                			}
                			case 56100: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001138);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001198, EnemyMetis, "Metis_1205");
                				break;
                			}
                			case 56130: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001139);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001199, EnemyMetis, "Metis_1206");
                				break;
                			}
                			case 56160: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001140);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001200, EnemyMetis, "Metis_1207");
                				break;
                			}
                			case 56190: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001141);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001201, EnemyMetis, "Metis_1208");
                				break;
                			}
                			case 56220: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001142);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001202, EnemyMetis, "Metis_1209");
                				break;
                			}
                			case 56250: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001143);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001203, EnemyMetis, "Metis_1210");
                				break;
                			}
                			case 56280: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001144);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001204, EnemyMetis, "Metis_1211");
                				break;
                			}
                			case 56310: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001145);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001205, EnemyMetis, "Metis_1212");
                				break;
                			}
                			case 56340: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001146);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001206, EnemyMetis, "Metis_1213");
                				break;
                			}
                			case 56370: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001147);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001207, EnemyMetis, "Metis_1214");
                				break;
                			}
                			case 56400: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001148);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001208, EnemyMetis, "Metis_1215");
                				break;
                			}
                			case 56430: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001149);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001209, EnemyMetis, "Metis_1216");
                				break;
                			}
                			case 56460: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001150);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001210, EnemyMetis, "Metis_1217");
                				break;
                			}
                			case 56490: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001151);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001211, EnemyMetis, "Metis_1218");
                				break;
                			}
                			case 56520: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001152);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001212, EnemyMetis, "Metis_1219");
                				break;
                			}
                			case 56550: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001153);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001213, EnemyMetis, "Metis_1220");
                				break;
                			}
                			case 56580: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001154);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001214, EnemyMetis, "Metis_1221");
                				break;
                			}
                			case 56610: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001155);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001215, EnemyMetis, "Metis_1222");
                				break;
                			}
                			case 56640: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001156);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001216, EnemyMetis, "Metis_1223");
                				break;
                			}
                			case 56670: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001157);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001217, EnemyMetis, "Metis_1224");
                				break;
                			}
                			case 56700: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001158);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001218, EnemyMetis, "Metis_1225");
                				break;
                			}
                			case 56730: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001159);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001219, EnemyMetis, "Metis_1226");
                				break;
                			}
                			case 56760: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001160);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001220, EnemyMetis, "Metis_1227");
                				break;
                			}
                			case 56790: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001161);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001221, EnemyMetis, "Metis_1228");
                				break;
                			}
                			case 56820: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001162);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001222, EnemyMetis, "Metis_1229");
                				break;
                			}
                			case 56850: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001163);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001223, EnemyMetis, "Metis_1230");
                				break;
                			}
                			case 56880: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001164);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001224, EnemyMetis, "Metis_1231");
                				break;
                			}
                			case 56910: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001165);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001225, EnemyMetis, "Metis_1232");
                				break;
                			}
                			case 56940: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001166);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001226, EnemyMetis, "Metis_1233");
                				break;
                			}
                			case 56970: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001167);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001227, EnemyMetis, "Metis_1234");
                				break;
                			}
                			case 57000: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001168);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001228, EnemyMetis, "Metis_1235");
                				break;
                			}
                			case 57030: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001169);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001229, EnemyMetis, "Metis_1236");
                				break;
                			}
                			case 57060: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001170);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001230, EnemyMetis, "Metis_1237");
                				break;
                			}
                			case 57090: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001171);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001231, EnemyMetis, "Metis_1238");
                				break;
                			}
                			case 57120: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001172);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001232, EnemyMetis, "Metis_1239");
                				break;
                			}
                			case 57150: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001173);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001233, EnemyMetis, "Metis_1240");
                				break;
                			}
                			case 57180: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001174);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001234, EnemyMetis, "Metis_1241");
                				break;
                			}
                			case 57210: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001175);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001235, EnemyMetis, "Metis_1242");
                				break;
                			}
                			case 57240: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001176);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001236, EnemyMetis, "Metis_1243");
                				break;
                			}
                			case 57270: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001177);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001237, EnemyMetis, "Metis_1244");
                				break;
                			}
                			case 57300: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001178);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001238, EnemyMetis, "Metis_1245");
                				break;
                			}
                			case 57330: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001179);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001239, EnemyMetis, "Metis_1246");
                				break;
                			}
                			case 57360: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001180);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001240, EnemyMetis, "Metis_1247");
                				break;
                			}
                			case 57390: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001181);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001241, EnemyMetis, "Metis_1248");
                				break;
                			}
                			case 57420: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001182);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001242, EnemyMetis, "Metis_1249");
                				break;
                			}
                			case 57450: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001183);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001243, EnemyMetis, "Metis_1250");
                				break;
                			}
                			case 57480: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001184);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001244, EnemyMetis, "Metis_1251");
                				break;
                			}
                			case 57510: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001185);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001245, EnemyMetis, "Metis_1252");
                				break;
                			}
                			case 57540: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001186);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001246, EnemyMetis, "Metis_1253");
                				break;
                			}
                			case 57570: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001187);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001247, EnemyMetis, "Metis_1254");
                				break;
                			}
                			case 57600: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001188);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001248, EnemyMetis, "Metis_1255");
                				break;
                			}
                			case 57630: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001189);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001249, EnemyMetis, "Metis_1256");
                				break;
                			}
                			case 57660: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001190);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001250, EnemyMetis, "Metis_1257");
                				break;
                			}
                			case 57690: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001191);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001251, EnemyMetis, "Metis_1258");
                				break;
                			}
                			case 57720: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001192);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001252, EnemyMetis, "Metis_1259");
                				break;
                			}
                			case 57750: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001193);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001253, EnemyMetis, "Metis_1260");
                				break;
                			}
                			case 57780: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001194);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001254, EnemyMetis, "Metis_1261");
                				break;
                			}
                			case 57810: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001195);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001255, EnemyMetis, "Metis_1262");
                				break;
                			}
                			case 57840: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001196);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001256, EnemyMetis, "Metis_1263");
                				break;
                			}
                			case 57870: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001197);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001257, EnemyMetis, "Metis_1264");
                				break;
                			}
                			case 57900: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001198);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001258, EnemyMetis, "Metis_1265");
                				break;
                			}
                			case 57930: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001199);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001259, EnemyMetis, "Metis_1266");
                				break;
                			}
                			case 57960: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001200);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001260, EnemyMetis, "Metis_1267");
                				break;
                			}
                			case 57990: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001201);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001261, EnemyMetis, "Metis_1268");
                				break;
                			}
                			case 58020: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001202);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001262, EnemyMetis, "Metis_1269");
                				break;
                			}
                			case 58050: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001203);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001263, EnemyMetis, "Metis_1270");
                				break;
                			}
                			case 58080: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001204);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001264, EnemyMetis, "Metis_1271");
                				break;
                			}
                			case 58110: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001205);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001265, EnemyMetis, "Metis_1272");
                				break;
                			}
                			case 58140: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001206);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001266, EnemyMetis, "Metis_1273");
                				break;
                			}
                			case 58170: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001207);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001267, EnemyMetis, "Metis_1274");
                				break;
                			}
                			case 58200: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001208);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001268, EnemyMetis, "Metis_1275");
                				break;
                			}
                			case 58230: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001209);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001269, EnemyMetis, "Metis_1276");
                				break;
                			}
                			case 58260: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001210);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001270, EnemyMetis, "Metis_1277");
                				break;
                			}
                			case 58290: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001211);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001271, EnemyMetis, "Metis_1278");
                				break;
                			}
                			case 58320: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001212);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001272, EnemyMetis, "Metis_1279");
                				break;
                			}
                			case 58350: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001213);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001273, EnemyMetis, "Metis_1280");
                				break;
                			}
                			case 58380: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001214);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001274, EnemyMetis, "Metis_1281");
                				break;
                			}
                			case 58410: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001215);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001275, EnemyMetis, "Metis_1282");
                				break;
                			}
                			case 58440: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001216);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001276, EnemyMetis, "Metis_1283");
                				break;
                			}
                			case 58470: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001217);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001277, EnemyMetis, "Metis_1284");
                				break;
                			}
                			case 58500: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001218);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001278, EnemyMetis, "Metis_1285");
                				break;
                			}
                			case 58530: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001219);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001279, EnemyMetis, "Metis_1286");
                				break;
                			}
                			case 58560: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001220);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001280, EnemyMetis, "Metis_1287");
                				break;
                			}
                			case 58590: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001221);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001281, EnemyMetis, "Metis_1288");
                				break;
                			}
                			case 58620: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001222);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001282, EnemyMetis, "Metis_1289");
                				break;
                			}
                			case 58650: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001223);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001283, EnemyMetis, "Metis_1290");
                				break;
                			}
                			case 58680: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001224);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001284, EnemyMetis, "Metis_1291");
                				break;
                			}
                			case 58710: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001225);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001285, EnemyMetis, "Metis_1292");
                				break;
                			}
                			case 58740: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001226);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001286, EnemyMetis, "Metis_1293");
                				break;
                			}
                			case 58770: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001227);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001287, EnemyMetis, "Metis_1294");
                				break;
                			}
                			case 58800: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001228);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001288, EnemyMetis, "Metis_1295");
                				break;
                			}
                			case 58830: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001229);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001289, EnemyMetis, "Metis_1296");
                				break;
                			}
                			case 58860: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001230);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001290, EnemyMetis, "Metis_1297");
                				break;
                			}
                			case 58890: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001231);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001291, EnemyMetis, "Metis_1298");
                				break;
                			}
                			case 58920: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001232);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001292, EnemyMetis, "Metis_1299");
                				break;
                			}
                			case 58950: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001233);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001293, EnemyMetis, "Metis_1300");
                				break;
                			}
                			case 58980: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001234);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001294, EnemyMetis, "Metis_1301");
                				break;
                			}
                			case 59010: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001235);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001295, EnemyMetis, "Metis_1302");
                				break;
                			}
                			case 59040: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001236);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001296, EnemyMetis, "Metis_1303");
                				break;
                			}
                			case 59070: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001237);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001297, EnemyMetis, "Metis_1304");
                				break;
                			}
                			case 59100: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001238);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001298, EnemyMetis, "Metis_1305");
                				break;
                			}
                			case 59130: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001239);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001299, EnemyMetis, "Metis_1306");
                				break;
                			}
                			case 59160: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001240);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001300, EnemyMetis, "Metis_1307");
                				break;
                			}
                			case 59190: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001241);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001301, EnemyMetis, "Metis_1308");
                				break;
                			}
                			case 59220: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001242);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001302, EnemyMetis, "Metis_1309");
                				break;
                			}
                			case 59250: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001243);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001303, EnemyMetis, "Metis_1310");
                				break;
                			}
                			case 59280: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001244);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001304, EnemyMetis, "Metis_1311");
                				break;
                			}
                			case 59310: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001245);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001305, EnemyMetis, "Metis_1312");
                				break;
                			}
                			case 59340: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001246);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001306, EnemyMetis, "Metis_1313");
                				break;
                			}
                			case 59370: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001247);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001307, EnemyMetis, "Metis_1314");
                				break;
                			}
                			case 59400: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001248);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001308, EnemyMetis, "Metis_1315");
                				break;
                			}
                			case 59430: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001249);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001309, EnemyMetis, "Metis_1316");
                				break;
                			}
                			case 59460: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001250);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001310, EnemyMetis, "Metis_1317");
                				break;
                			}
                			case 59490: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001251);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001311, EnemyMetis, "Metis_1318");
                				break;
                			}
                			case 59520: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001252);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001312, EnemyMetis, "Metis_1319");
                				break;
                			}
                			case 59550: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001253);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001313, EnemyMetis, "Metis_1320");
                				break;
                			}
                			case 59580: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001254);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001314, EnemyMetis, "Metis_1321");
                				break;
                			}
                			case 59610: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001255);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001315, EnemyMetis, "Metis_1322");
                				break;
                			}
                			case 59640: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001256);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001316, EnemyMetis, "Metis_1323");
                				break;
                			}
                			case 59670: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001257);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001317, EnemyMetis, "Metis_1324");
                				break;
                			}
                			case 59700: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001258);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001318, EnemyMetis, "Metis_1325");
                				break;
                			}
                			case 59730: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001259);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001319, EnemyMetis, "Metis_1326");
                				break;
                			}
                			case 59760: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001260);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001320, EnemyMetis, "Metis_1327");
                				break;
                			}
                			case 59790: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001261);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001321, EnemyMetis, "Metis_1328");
                				break;
                			}
                			case 59820: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001262);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001322, EnemyMetis, "Metis_1329");
                				break;
                			}
                			case 59850: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001263);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001323, EnemyMetis, "Metis_1330");
                				break;
                			}
                			case 59880: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001264);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001324, EnemyMetis, "Metis_1331");
                				break;
                			}
                			case 59910: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001265);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001325, EnemyMetis, "Metis_1332");
                				break;
                			}
                			case 59940: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001266);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001326, EnemyMetis, "Metis_1333");
                				break;
                			}
                			case 59970: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001267);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001327, EnemyMetis, "Metis_1334");
                				break;
                			}
                			case 60000: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001268);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001328, EnemyMetis, "Metis_1335");
                				break;
                			}
                			case 60030: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001269);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001329, EnemyMetis, "Metis_1336");
                				break;
                			}
                			case 60060: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001270);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001330, EnemyMetis, "Metis_1337");
                				break;
                			}
                			case 60090: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001271);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001331, EnemyMetis, "Metis_1338");
                				break;
                			}
                			case 60120: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001272);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001332, EnemyMetis, "Metis_1339");
                				break;
                			}
                			case 60150: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001273);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001333, EnemyMetis, "Metis_1340");
                				break;
                			}
                			case 60180: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001274);
                				getLordActor()->addSubGroup(pMetis2);
                				orderActorToFactory(40001334, EnemyMetis, "Metis_1341");
                				break;
                			}
                			case 60210: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001275);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60240: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001276);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60270: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001277);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60300: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001278);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60330: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001279);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60360: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001280);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60390: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001281);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60420: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001282);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60450: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001283);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60480: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001284);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60510: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001285);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60540: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001286);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60570: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001287);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60600: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001288);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60630: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001289);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60660: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001290);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60690: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001291);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60720: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001292);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60750: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001293);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60780: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001294);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60810: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001295);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60840: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001296);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60870: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001297);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60900: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001298);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60930: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001299);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60960: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001300);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 60990: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001301);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61020: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001302);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61050: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001303);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61080: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001304);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61110: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001305);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61140: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001306);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61170: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001307);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61200: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001308);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61230: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001309);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61260: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001310);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61290: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001311);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61320: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001312);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61350: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001313);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61380: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001314);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61410: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001315);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61440: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001316);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61470: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001317);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61500: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001318);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61530: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001319);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61560: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001320);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61590: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001321);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61620: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001322);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61650: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001323);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61680: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001324);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61710: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001325);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61740: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001326);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61770: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001327);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61800: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001328);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61830: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001329);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61860: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001330);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61890: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001331);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61920: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001332);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61950: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001333);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			case 61980: {
                				EnemyMetis* pMetis2 = (EnemyMetis*)obtainActorFromFactory(40001334);
                				getLordActor()->addSubGroup(pMetis2);
                				break;
                			}
                			default :
                				break;
                		}
                		_iCnt_Event = (_iCnt_Event < 1419-1 ? _iCnt_Event+1 : _iCnt_Event);
                	}
                    // gen02 end
                }
                
                void Stage01_02::processFinal() {
                }
                
           2 -> Stage01_02::~Stage01_02() {
                
                }


Top 10 Lines:

     Line      Count

     8323          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/scene/Universe/World/GameScene/GameMainScene/Stage01Scene.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> Stage01Scene::Stage01Scene(const char* prm_name) : StageScene(prm_name) {
                    _class_name = "Stage01Scene";
                
                    _pScene_Stage01Controller = NEW Stage01Controller("Stage01Ctrl");
                    _pScene_Stage01Controller->inactivate();
                    addSubLast(_pScene_Stage01Controller);
                    Sleep(2);
                    _pWorldBoundSpace  = NEW WorldBoundSpace001("BG_SPACE");
                    _pWorldBoundSpace->inactivateTree();
                    getLordActor()->addSubGroup(KIND_EFFECT, _pWorldBoundSpace);
                
                    _pHoshiBoshi = NEW HoshiBoshi001("HoshiBoshi001");
                    getLordActor()->addSubGroup(KIND_EFFECT, _pHoshiBoshi);
                
                    _pMessage = NEW LabelGecchi16Font("Stage01Msg");
                    getLordActor()->addSubGroup(KIND_EFFECT, _pMessage);
                    _pMessage->inactivate();
                
                    blindScene(); //\
                    useProgress(10);
                }
                
                void Stage01Scene::initialize() {
                    StageScene::initialize();
                }
                
                void Stage01Scene::processBehavior() {
                    StageScene::processBehavior();
                    if (_pPrg->get() == STAGE_SCENE_PROG_INIT) {
                       _pPrg->change(STAGE_SCENE_PROG_BEGIN);
                    }
                
                    if (_pPrg->get() == STAGE_SCENE_PROG_BEGIN) {
                        if (_frame_Begin == 180) { //Xe[WPJnI
                            _pMessage->activateImmediately();
                            _pMessage->update(300, 300, "SCENE 01 START!");
                            _pMessage->inactivateDelay(240);
                            _pWorldBoundSpace->activateTree();    //wiON
                            _pScene_Stage01Controller->activate();
                            fadeinScene(240);
                            _pPrg->change(STAGE_SCENE_PROG_PLAYING);
                        }
                    }
                
                    if (_pPrg->wasChangedTo(STAGE_SCENE_PROG_END)) {
                        _TRACE_("Stage01Scene::processBehavior()  STAGE_SCENE_PROG_ENDI");
                        _pMessage->activateImmediately();
                        _pMessage->update(300, 300, "SCENE 01 CLEAR!!");
                        _pMessage->inactivateDelay(120);
                        fadeoutScene(120);
                    }
                
                }
                
                void Stage01Scene::processJudgement() {
                }
                
                void Stage01Scene::processFinal() {
                
                }
                
                void Stage01Scene::onCatchEvent(UINT32 prm_no, void* prm_pSource) {
                    if (prm_no == EVENT_STAGE01CONTROLLER_WAS_END ) {
                        _TRACE_("Stage01Scene::onCatchEvent() STAGEXXCONTROLLER_ENDING Lb`BXe[^XSTAGE_SCENE_PROG_END");
                        _pPrg->change(STAGE_SCENE_PROG_END);
                    } else {
                
                    }
                }
                
                
           2 -> Stage01Scene::~Stage01Scene() {
                
                }


Top 10 Lines:

     Line      Count

       79          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/scene/Universe/World/GameScene/GameMainScene/StageScene.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
                bool StageScene::_pause = false;
                
           1 -> StageScene::StageScene(const char* prm_name) : DefaultScene(prm_name) {
                    _class_name = "StageScene";
                    useProgress(10);
                }
                
                void StageScene::initialize() {
                    _pPrg->change(STAGE_SCENE_PROG_INIT);
                }
                void StageScene::processBehavior() {
                    if (_pPrg->wasChangedTo(STAGE_SCENE_PROG_INIT)) {
                    } else if (_pPrg->get() == STAGE_SCENE_PROG_INIT) {
                    }
                
                    if (_pPrg->wasChangedTo(STAGE_SCENE_PROG_BEGIN)) {
                        _frame_Begin = 0;
                    } else if (_pPrg->get() == STAGE_SCENE_PROG_BEGIN) {
                        //[v
                        _frame_Begin++;
                    }
                
                    if (_pPrg->wasChangedTo(STAGE_SCENE_PROG_PLAYING)) {
                        _frame_Play = 0;
                    } else if (_pPrg->get() == STAGE_SCENE_PROG_PLAYING) {
                        _frame_Play++;
                    }
                
                    if (_pPrg->wasChangedTo(STAGE_SCENE_PROG_END)) {
                        _frame_End = 0;
                        throwEventToUpperTree(EVENT_PREPARE_NEXT_STAGE, this); //Xe[W
                    } else if (_pPrg->get() == STAGE_SCENE_PROG_END) {
                        _frame_End++;
                    }
                
                }
                
                void StageScene::onCatchEvent(UINT32 prm_no, void* prm_pSource) {
                    if (prm_no == EVENT_STAGE01CONTROLLER_WAS_END ||
                        prm_no == EVENT_STAGE02CONTROLLER_WAS_END
                    ) {
                        _TRACE_("StageScene::onCatchEvent() STAGEXXCONTROLLER_ENDING Lb`BXe[^XSTAGE_SCENE_PROG_END");
                        _pPrg->change(STAGE_SCENE_PROG_END);
                    } else {
                
                    }
                }
                
                
                //
                //void StageScene::initialize() {
                //}
                //
                //
                //void StageScene::processJudgement() {
                //}
                //
                //void StageScene::processFinal() {
                //    //~
                //    if (VB->isPushedDown(VB_UI_CANCEL)) {
                //        if (_pause) {
                //            pauseTree();
                //        } else {
                //            unpauseTree();
                //        }
                //    }
                //}
                
           1 -> StageScene::~StageScene() {
                }


Top 10 Lines:

     Line      Count

       10          1
       76          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        2   Total number of line executions
     0.67   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/scene/Universe/World/GameScene/GameMainScene.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
                #define ORDER_ID_STAGESCENE 11
                
                //GameMainScene* GameMainScene::_pGameMainScene = NULL;
                
           1 -> GameMainScene::GameMainScene(const char* prm_name) : DefaultScene(prm_name) {
                    _class_name = "GameMainScene";
                
                    _pFont16_SCORE = NEW LabelGecchi16Font("SCORE");
                    getLordActor()->addSubGroup(_pFont16_SCORE);
                    _pFont16_RANK = NEW LabelGecchi16Font("RANK");
                    getLordActor()->addSubGroup(_pFont16_RANK);
                    _pFont16_STAMINA = NEW LabelGecchi16Font("STAMINA");
                    getLordActor()->addSubGroup(_pFont16_STAMINA);
                    _pFont1601 = NEW LabelGecchi16Font("STR01");
                    getLordActor()->addSubGroup(_pFont1601);
                    _pFont1602 = NEW LabelGecchi16Font("STR02");
                    getLordActor()->addSubGroup(_pFont1602);
                    _pFont8_JIKI_X = NEW LabelGecchi8Font("JIKI_X");
                    getLordActor()->addSubGroup(_pFont8_JIKI_X);
                    _pFont8_JIKI_Y = NEW LabelGecchi8Font("JIKI_Y");
                    getLordActor()->addSubGroup(_pFont8_JIKI_Y);
                    _pFont8_JIKI_Z = NEW LabelGecchi8Font("JIKI_Z");
                    getLordActor()->addSubGroup(_pFont8_JIKI_Z);
                
                    _pSceneMainCannnel = NULL;
                    _had_ready_stage = false;
                //    GameMainScene::_pGameMainScene = this;
                    useProgress(10);
                }
                
                void GameMainScene::onReset() {
                //    VB_UI->clear();
                //    VB_PLAY->clear();
                //    P_GOD->setVB(VB_PLAY); //vCpX
                
                    _pFont1601->update("");
                    _pFont1602->update("");
                    if (_pSceneMainCannnel) {
                        _pSceneMainCannnel->inactivate();
                    }
                    _pPrg->set(GAMEMAIN_SCENE_PROG_INIT);
                }
                void GameMainScene::readyNextStage() {
                    _stage++;
                    readyStage(_stage);
                }
                
                void GameMainScene::readyStage(int prm_stage) {
                    if (_had_ready_stage) {
                        throwGgafCriticalException("GameMainScene::readyStage Xe[WB_stage="<<_stage<<" prm_stage="<<prm_stage);
                    }
                
                    _stage = prm_stage;
                    _had_ready_stage = true;
                //    _frame_ready_stage = 0;
                    switch (prm_stage) {
                        case 1:
                            orderSceneToFactory(ORDER_ID_STAGESCENE, Stage01Scene, "Stage01");
                            break;
                        case 2:
                            orderSceneToFactory(ORDER_ID_STAGESCENE, Stage02Scene, "Stage02");
                            break;
                        case 3:
                            orderSceneToFactory(ORDER_ID_STAGESCENE, Stage03Scene, "Stage03");
                            break;
                        case 4:
                            orderSceneToFactory(ORDER_ID_STAGESCENE, Stage04Scene, "Stage04");
                            break;
                        case 5:
                            orderSceneToFactory(ORDER_ID_STAGESCENE, Stage05Scene, "Stage05");
                            break;
                        default:
                            break;
                    }
                }
                
                void GameMainScene::initialize() {
                
                
                //    GgafScene* pCommon = P_COMMON_SCENE->extract();
                //    addSubLast(pCommon); // V[zi~Ij
                    //initialize()inactive()
                }
                
                void GameMainScene::processBehavior() {
                    //SCORE\
                    sprintf(_buf, "SCORE %07u", _SCORE_);
                    _pFont16_SCORE->update(550, 1, _buf);
                    sprintf(_buf, "RANK %.7f", _RANK_);
                    _pFont16_RANK->update(550, 20, _buf);
                    sprintf(_buf, "STAMINA %7d", P_MYSHIP->_pStatus->get(STAT_Stamina));
                    _pFont16_STAMINA->update(550, 40, _buf);
                
                    sprintf(_buf, "X:%8d", P_MYSHIP->_X);
                    _pFont8_JIKI_X->update(1, GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT) - 8*3-1, _buf);
                    sprintf(_buf, "Y:%8d", P_MYSHIP->_Y);
                    _pFont8_JIKI_Y->update(1, GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT) - 8*2-1, _buf);
                    sprintf(_buf, "Z:%8d", P_MYSHIP->_Z);
                    _pFont8_JIKI_Z->update(1, GGAFDX9_PROPERTY(GAME_BUFFER_HEIGHT) - 8*1-1, _buf);
                
                
                    switch (_pPrg->get()) {
                        case GAMEMAIN_SCENE_PROG_INIT: {
                            _pPrg->change(GAMEMAIN_SCENE_PROG_BEGIN);
                            break;
                        }
                
                        case GAMEMAIN_SCENE_PROG_BEGIN: {
                            if (_pPrg->isJustChanged()) {
                                if (_pSceneMainCannnel && !_pSceneMainCannnel->wasDeclaredEnd()) {
                                    //2~^C~OOXe[Wend
                                    _TRACE_("_pSceneMainCannnel="<<_pSceneMainCannnel->getName()<<" end()");
                                    _pSceneMainCannnel->end();
                                }
                            }
                            if (_pPrg->getFrameInProgress() == 120) { //deletelQbV
                                _pPrg->change(GAMEMAIN_SCENE_PROG_PLAY);
                            }
                            break;
                        }
                
                        case GAMEMAIN_SCENE_PROG_PLAY: {
                            if (_pPrg->isJustChanged()) {
                                if (_had_ready_stage) {
                                    _had_ready_stage = false;
                                    _pSceneMainCannnel = (StageScene*)obtainSceneFromFactory(ORDER_ID_STAGESCENE);
                                    addSubLast(_pSceneMainCannnel); //Xe[WV[
                                } else {
                                    throwGgafCriticalException("GameMainScene::processBehavior GAMEMAIN_SCENE_PROG_BEGIN Xe[WB_stage="<<_stage);
                                }
                            }
                            break;
                        }
                
                        case GAMEMAIN_SCENE_PROG_FINISH: {
                            if (_pPrg->isJustChanged()) {
                            }
                            break;
                        }
                
                        default:
                            break;
                    }
                
                }
                
                
                
                
                void GameMainScene::onCatchEvent(UINT32 prm_no, void* prm_pSource) {
                    if (prm_no == EVENT_PREPARE_NEXT_STAGE) {
                        //Xe[WHCxg
                        _TRACE_("GameMainScene::onCatchEvent() EVENT_PREPARE_NEXT_STAGE ");
                        if (_stage < 5) {
                            readyNextStage();
                        } else {
                //            _TRACE_("INA");
                //            _pPrg->change(GAMEMAIN_SCENE_PROG_END);
                            //TODO:GfjOH
                        }
                    }
                
                }
                
                void GameMainScene::processFinal() {
                }
                
           2 -> GameMainScene::~GameMainScene() {
                }
                


Top 10 Lines:

     Line      Count

      175          2
       12          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/scene/Universe/World/GameScene/GameOverScene.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> GameOverScene::GameOverScene(const char* prm_name) : DefaultScene(prm_name) {
                    _class_name = "GameOverScene";
                    _pStringBoard01 = NEW LabelGecchi16Font("STR01");
                    getLordActor()->addSubGroup(_pStringBoard01);
                    useProgress(10);
                }
                
                void GameOverScene::onReset() {
                    blindScene();
                    _pStringBoard01->update("");
                    _pPrg->change(GAMEOVER_SCENE_PROG_INIT);
                }
                void GameOverScene::initialize() {
                    _TRACE_("GameOverScene::initialize()");
                }
                
                void GameOverScene::processBehavior() {
                
                    switch (_pPrg->getFromChange()) {
                        case GAMEOVER_SCENE_PROG_DISP: {
                            fadeoutScene(FADE_FRAME);
                            inactivateDelay(FADE_FRAME);
                            break;
                        }
                
                        default:
                            break;
                    }
                
                
                    switch (_pPrg->get()) {
                        case GAMEOVER_SCENE_PROG_INIT: {
                            _pPrg->change(GAMEOVER_SCENE_PROG_DISP);
                            break;
                        }
                
                        case GAMEOVER_SCENE_PROG_DISP: {
                            if (_pPrg->isJustChanged()) {
                                _pStringBoard01->update(500, 500, "GAME OVER (-_-;)");
                                fadeinScene(FADE_FRAME);
                            }
                            if (VB->isPushedDown(VB_UI_EXECUTE) || _pPrg->getFrameInProgress() == 420) {
                                throwEventToUpperTree(EVENT_GAME_OVER_FINISH);
                                _pPrg->change(GAMEOVER_SCENE_PROG_FINISH);
                            }
                            break;
                        }
                
                        case GAMEOVER_SCENE_PROG_FINISH: {
                            if (_pPrg->isJustChanged()) {
                            }
                            break;
                        }
                
                        default:
                            break;
                     }
                }
                
                void GameOverScene::processFinal() {
                }
                
           2 -> GameOverScene::~GameOverScene() {
                }


Top 10 Lines:

     Line      Count

       70          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/scene/Universe/World/GameScene/GamePreTitleScene.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> GamePreTitleScene::GamePreTitleScene(const char* prm_name) : DefaultScene(prm_name) {
                    _class_name = "GamePreTitleScene";
                    useProgress(10);
                    _pPrg->change(GAMEDEMO_SCENE_PROG_INIT);
                    _pStringBoard01 = NEW LabelGecchi16Font("STR01");
                    getLordActor()->addSubGroup(_pStringBoard01);
                    _pStringBoard02 = NEW LabelGecchi16Font("STR02");
                    getLordActor()->addSubGroup(_pStringBoard02);
                    _pTitleBoard = NEW TitleBoard("TitleBoard");
                    getLordActor()->addSubGroup(_pTitleBoard);
                }
                void GamePreTitleScene::onReset() {
                    _TRACE_("GamePreTitleScene::onReset()");
                    _pTitleBoard->locate(200, 600);
                    _pStringBoard01->update("");
                    _pStringBoard02->update("");
                    blindScene();
                    _pPrg->change(GAMEPRETITLE_SCENE_PROG_INIT);
                }
                
                void GamePreTitleScene::onActive() {
                }
                
                void GamePreTitleScene::initialize() {
                    _TRACE_("GamePreTitleScene::initialize()");
                }
                
                void GamePreTitleScene::processBehavior() {
                
                    switch (_pPrg->get()) {
                        case GAMEPRETITLE_SCENE_PROG_INIT: {
                            _pPrg->change(GAMEPRETITLE_SCENE_PROG_EXEC);
                            break;
                        }
                
                        case GAMEPRETITLE_SCENE_PROG_EXEC: {
                            if (_pPrg->isJustChanged()) {
                                fadeinScene(FADE_FRAME);
                            }
                            if (_pPrg->getFrameInProgress() == 1) {
                                _pStringBoard01->update(100, 50, "[STORY]");
                            } else if (_pPrg->getFrameInProgress() == 120) {
                                _pStringBoard01->update(100, 50, "MUKASHI MUKASHI ARU TOKORONI.");
                            } else if (_pPrg->getFrameInProgress() == 240) {
                                _pStringBoard01->update(100, 50, "MA SORE HA OITOITE...");
                            } else if (_pPrg->getFrameInProgress() == 360) {
                                _pStringBoard01->update(100, 50, "TORIAEZU TEKI WO TAOSINI IKOUZE ! BY GECCHI");
                            } else if (_pPrg->getFrameInProgress() > 600) {
                                //^Cgj[
                                _pTitleBoard->_y -= 2;
                                if (_pTitleBoard->_y <= 150) {
                                    throwEventToUpperTree(EVENT_PREGAMETITLE_SCENE_FINISH);
                                    _pPrg->change(GAMEPRETITLE_SCENE_PROG_FINISH);
                                }
                            }
                            break;
                        }
                
                        case GAMEPRETITLE_SCENE_PROG_FINISH: {
                            if (_pPrg->isJustChanged()) {
                                inactivate();
                            }
                            //[v
                            break;
                        }
                
                        default:
                            break;
                     }
                }
                
                void GamePreTitleScene::processFinal() {
                
                }
                
           2 -> GamePreTitleScene::~GamePreTitleScene() {
                }


Top 10 Lines:

     Line      Count

       83          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/scene/Universe/World/GameScene/GameTitleScene.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> GameTitleScene::GameTitleScene(const char* prm_name) : DefaultScene(prm_name) {
                    _class_name = "GameTitleScene";
                    useProgress(10);
                    _pPrg->change(GAMEDEMO_SCENE_PROG_INIT);
                    _pStringBoard01 = NEW LabelGecchi16Font("STR01");
                    getLordActor()->addSubGroup(_pStringBoard01);
                    _pStringBoard02 = NEW LabelGecchi16Font("STR02");
                    getLordActor()->addSubGroup(_pStringBoard02);
                    _pTitleBoard = NEW TitleBoard("TitleBoard");
                    getLordActor()->addSubGroup(_pTitleBoard);
                
                    _max_menu_item = 4;
                    _papStringItem = NEW LabelGecchi16Font*[_max_menu_item];
                    for (int i = 0; i < _max_menu_item; i++) {
                        _papStringItem[i] = NEW LabelGecchi16Font("menu_item");
                        _papStringItem[i]->inactivateImmediately();
                        getLordActor()->addSubGroup(_papStringItem[i]);
                    }
                    _papStringItem[0]->update("GAME START");
                    _papStringItem[1]->update("CONFIG");
                    _papStringItem[2]->update("DEBUG");
                    _papStringItem[3]->update("HOGEHOGE");
                
                    _pCursor001= NEW Cursor001("Cursor001");
                    _pCursor001->inactivateImmediately();
                    getLordActor()->addSubGroup(_pCursor001);
                
                    LabelGecchi16Font("STR02");
                
                    _pSeCon_exec = (GgafDx9SeConnection*)GgafDx9Sound::_pSeManager->getConnection("yume_Sbend");
                
                    _pBgmPerformer->useBgm(1);
                    _pBgmPerformer->set(0, "BGM_DEMO");
                
                    _active_item = 0;
                
                }
                void GameTitleScene::onReset() {
                    _TRACE_("GameTitleScene::onReset()");
                    _pStringBoard01->update("");
                    _pStringBoard02->update("");
                    _pTitleBoard->locate(200, 150);
                    _pPrg->set(GAMETITLE_SCENE_PROG_INIT);
                    unblindScene();
                }
                
                void GameTitleScene::onActive() {
                }
                
                void GameTitleScene::initialize() {
                    _TRACE_("GameTitleScene::initialize()");
                }
                
                void GameTitleScene::processBehavior() {
                
                    switch (_pPrg->getFromChange()) {
                        default: {
                            break;
                        }
                    }
                
                
                    switch (_pPrg->get()) {
                        case GAMETITLE_SCENE_PROG_INIT: {
                            _pPrg->change(GAMETITLE_SCENE_PROG_TITLE);
                            break;
                        }
                
                        case GAMETITLE_SCENE_PROG_TITLE: {
                            if (_pPrg->isJustChanged()) {
                                _pStringBoard02->update(400, 500, "PUSH UI_EXECUTE TO BEGIN!");
                            }
                            if (VB->isPushedDown(VB_UI_EXECUTE)) {
                                _pSeCon_exec->refer()->play();
                                _pPrg->change(GAMETITLE_SCENE_PROG_SELECT);
                            } else if (_pPrg->getFrameInProgress() == GAMETITLE_TIMEOUT) {
                                //{[
                                _TRACE_("GameTitleScene throwEventToUpperTree(EVENT_GAMETITLE_SCENE_FINISH)");
                                throwEventToUpperTree(EVENT_GAMETITLE_SCENE_FINISH); //ICxg
                                _pPrg->change(GAMETITLE_SCENE_PROG_FINISH); //^CgV[I
                            }
                            break;
                        }
                
                        case GAMETITLE_SCENE_PROG_SELECT: {
                            if (_pPrg->isJustChanged()) {
                                _pStringBoard02->update("");
                                if (_pPrg->isJustChanged()) {
                                    for (int i = 0; i < _max_menu_item; i++) {
                                        _papStringItem[i]->update(200, 500+(i*20));
                                        _papStringItem[i]->activate();
                                    }
                                }
                                _active_item = 0;
                                _pCursor001->locateAs(_papStringItem[_active_item]);
                                _pCursor001->activate();
                                _frame_of_noinput = _pPrg->getFrameInProgress();
                            }
                            _pCursor001->locateAs(_papStringItem[_active_item]);
                
                            if (VB->isAutoRepeat(VB_UI_UP)) {
                                _active_item--;
                                if (_active_item < 0) {
                                    _active_item = _max_menu_item-1;
                                }
                                _frame_of_noinput = _pPrg->getFrameInProgress();
                            } else if (VB->isAutoRepeat(VB_UI_DOWN)) {
                                _active_item++;
                                if (_active_item > _max_menu_item-1) {
                                    _active_item = 0;
                                }
                                _frame_of_noinput = _pPrg->getFrameInProgress();
                            } if (VB->isPushedDown(VB_UI_EXECUTE)) {
                                _pSeCon_exec->refer()->play();
                                _pPrg->change(GAMETITLE_SCENE_PROG_GAMESTART);
                            } else if (_pPrg->getFrameInProgress() >= _frame_of_noinput + 300) {
                                //{[
                                _TRACE_("GameTitleScene throwEventToUpperTree(EVENT_GAMETITLE_SCENE_FINISH)");
                                throwEventToUpperTree(EVENT_GAMETITLE_SCENE_FINISH); //ICxg
                                _pPrg->change(GAMETITLE_SCENE_PROG_FINISH); //^CgV[I
                            }
                            break;
                        }
                
                        case GAMETITLE_SCENE_PROG_GAMESTART: {
                            if (_pPrg->isJustChanged()) {
                            }
                            if (_pPrg->getFrameInProgress() == 90) {
                                throwEventToUpperTree(EVENT_GAMESTART);      //X^[gICxg
                                _pPrg->change(GAMETITLE_SCENE_PROG_FINISH); //^CgV[I
                            }
                            //_
                            if (_pPrg->getFrameInProgress() % 10 < 5 ) {
                                _pStringBoard02->update(400, 500, "READY GO!");
                            } else {
                                _pStringBoard02->update(400, 500, "");
                            }
                            break;
                        }
                
                        case GAMETITLE_SCENE_PROG_FINISH: {
                            if (_pPrg->isJustChanged()) {
                                fadeoutSceneTree(FADE_FRAME);
                                inactivateDelay(FADE_FRAME);
                            }
                            //[v
                            break;
                        }
                
                        default:
                            break;
                    }
                }
                
                void GameTitleScene::processFinal() {
                
                }
                
           2 -> GameTitleScene::~GameTitleScene() {
                    DELETEARR_IMPOSSIBLE_NULL(_papStringItem);
                    _pSeCon_exec->close();
                }


Top 10 Lines:

     Line      Count

      166          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/scene/Universe/World/GameScene/MyShipScene.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> MyShipScene::MyShipScene(const char* prm_name) : DefaultScene(prm_name) ,
                _pMyShip(NULL),
                _pMyOptionController(NULL) {
                    _class_name = "MyShipScene";
                    _pMyShip = NEW MyShip("MYSHIP");
                    _pMyShip->inactivateImmediately(); //zo^AN^[
                    _pMyOptionController = NEW MyOptionController("MY_OPTION_PARENT");
                    getLordActor()->addSubLast(_pMyOptionController);
                
                    getLordActor()->addSubGroup(KIND_MY_BODY_NOMAL, _pMyShip);
                
                    _pEffectMyShipExplosion = NEW EffectMyShipExplosion("EffectMyShipExplosion");
                    _pEffectMyShipExplosion->inactivateImmediately();
                    getLordActor()->addSubGroup(_pEffectMyShipExplosion);
                    _pVamSysCamWorker = NULL;
                //    _pCon_VamSysCamWorker = (CameraWorkerConnection*)P_UNIVERSE->_pCameraWorkerManager->getConnection("VamSysCamWorker");
                //    _pCon_MyShipDivingCamWorker = (CameraWorkerConnection*)P_UNIVERSE->_pCameraWorkerManager->getConnection("MyShipDivingCamWorker");
                //    _pMyShipDivingCamWorker = (MyShipDivingCamWorker*)_pCon_MyShipDivingCamWorker->refer();
                    //_z = 0.99;//w i0 <= _z < 1.0jZ=(0`+1)
                    //_z = 0.9999999f;
                    //@[^[u
                    _pMagicMeter = NEW MagicMeter("MagicMeter");
                    _pMagicMeter->locate(100.0f, Properties::VIEW_SCREEN_HEIGHT - 100.0f,
                                                0.00000001f );
                    getLordActor()->addSubGroup(_pMagicMeter);
                
                    //GlM[o[u
                    _pEnagyBar = NEW EnagyBar("EnagyBar");
                    _pEnagyBar->locate(100.0f, Properties::VIEW_SCREEN_HEIGHT - 50.0f,
                                              0.00000001f );
                    getLordActor()->addSubGroup(_pEnagyBar);
                    _zanki = 3;
                    useProgress(10);
                
                }
                
                void MyShipScene::initialize() {
                    _TRACE_("MyShipScene initialize()");
                }
                
                void MyShipScene::onReset() {
                    _TRACE_("MyShipScene onReset()");
                    _zanki = 3;
                    _pMyShip->resetTree();
                    _pMyOptionController->resetTree();
                    unblindScene();
                    _pPrg->set(MYSHIPSCENE_SCENE_PROG_INIT);
                }
                
                void MyShipScene::onActive() {
                }
                
                void MyShipScene::processBehavior() {
                
                    switch (_pPrg->getFromChange()) {
                        case MYSHIPSCENE_SCENE_PROG_BEGIN: {
                                P_UNIVERSE->undoCameraWork();
                            break;
                        }
                        default:
                            break;
                    }
                
                    switch (_pPrg->get()) {
                        case MYSHIPSCENE_SCENE_PROG_INIT: {
                            _pVamSysCamWorker = (VamSysCamWorker*)P_UNIVERSE->switchCameraWork("VamSysCamWorker");
                            _pVamSysCamWorker->_pMyShip = _pMyShip;
                            _pPrg->change(MYSHIPSCENE_SCENE_PROG_BEGIN);
                            break;
                        }
                
                        case MYSHIPSCENE_SCENE_PROG_BEGIN: {
                            if (_pPrg->isJustChanged()) {
                                unblindScene();
                                _pMyShip->reset();
                                _pMyShip->activate();
                                _pMyShip->_can_control = true;
                                _pMyShip->_is_diving = true;
                                MyShipDivingCamWorker* pCamWorker = (MyShipDivingCamWorker*)P_UNIVERSE->switchCameraWork("MyShipDivingCamWorker");
                                pCamWorker->setMoveTargetCam(-1000000, 1000000, -1000000);
                                pCamWorker->lockCamVp(_pMyShip);
                            }
                            _pMyShip->_X += 30000;
                            if (_pMyShip->_X > 0) {
                                _pMyShip->_X = 0;
                                _pMyShip->_is_diving = false;
                                _pPrg->change(MYSHIPSCENE_SCENE_PROG_PLAY);
                            }
                            break;
                        }
                
                        case MYSHIPSCENE_SCENE_PROG_PLAY: {
                            if (_pPrg->isJustChanged()) {
                                _pMyShip->_can_control = true;
                            }
                            //Cxg EVENT_MY_SHIP_WAS_DESTROYED_BEGIN 
                            break;
                        }
                
                        case MYSHIPSCENE_SCENE_PROG_DESTROY: {
                            if (_pPrg->isJustChanged()) {
                                _pEffectMyShipExplosion->activate();
                                _pMyShip->inactivateDelay(60);
                                _pMyShip->_can_control = false;
                                _pMyOptionController->_is_free_from_myship_mode = true;
                                _zanki -= 1;
                            }
                            if (_pPrg->getFrameInProgress() == 120) {
                                if (_zanki == 0) {
                                   throwEventToUpperTree(EVENT_ALL_MY_SHIP_WAS_DESTROYED);
                                   _pPrg->change(PROG_NOTHING);
                                   P_UNIVERSE->undoCameraWork();
                                   inactivate();
                                } else {
                                   throwEventToUpperTree(EVENT_MY_SHIP_WAS_DESTROYED_FINISH);
                                   _pPrg->change(MYSHIPSCENE_SCENE_PROG_BEGIN);
                                }
                            }
                            break;
                        }
                
                        default:
                            break;
                    }
                
                }
                
                void MyShipScene::onCatchEvent(UINT32 prm_no, void* prm_pSource) {
                    if (prm_no == EVENT_MY_SHIP_WAS_DESTROYED_BEGIN) {
                        _TRACE_("MyShipScene EVENT_MY_SHIP_WAS_DESTROYED_BEGIN was Catch!!");
                       _pPrg->change(MYSHIPSCENE_SCENE_PROG_DESTROY);
                    }
                }
                
           2 -> MyShipScene::~MyShipScene() {
                    //P_UNIVERSE->undoCameraWork();
                //    _pCon_VamSysCamWorker->close();
                //    _pCon_MyShipDivingCamWorker->close();
                }


Top 10 Lines:

     Line      Count

      142          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/scene/Universe/World/GameScene.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> GameScene::GameScene(const char* prm_name) : DefaultScene(prm_name) ,
                _pCommonScene(NULL),
                _pMyShipScene(NULL),
                _pScene_GameTitle(NULL),
                _pScene_GameDemo(NULL),
                _pScene_GameBeginning(NULL),
                _pScene_GameMain(NULL),
                _pScene_GameEnding(NULL),
                _pScene_GameOver(NULL) {
                
                    _class_name = "GameScene";
                
                //    GameGlobal::_pSceneGame = this;
                
                    _pCommonScene = NEW CommonScene("Common");
                    addSubLast(_pCommonScene);
                
                    _pMyShipScene = NEW MyShipScene("MyShipScene");
                    addSubLast(_pMyShipScene);
                
                    _pScene_PreGameTitle = NEW GamePreTitleScene("PreGameTitle");
                    addSubLast(_pScene_PreGameTitle);
                
                    _pScene_GameTitle = NEW GameTitleScene("GameTitle");
                    addSubLast(_pScene_GameTitle);
                
                    _pScene_GameDemo = NEW GameDemoScene("GameDemo");
                    addSubLast(_pScene_GameDemo);
                
                    _pScene_GameBeginning = NEW GameBeginningScene("GameBeginning");
                    addSubLast(_pScene_GameBeginning);
                
                    _pScene_GameMain = NEW GameMainScene("GameMain");
                    addSubLast(_pScene_GameMain);
                
                    _pScene_GameEnding = NEW GameEndingScene("GameEnding");
                    addSubLast(_pScene_GameEnding);
                
                    _pScene_GameOver = NEW GameOverScene("GameOver");
                    addSubLast(_pScene_GameOver);
                
                    _pMyShipScene->inactivateImmediately();
                    _pScene_GameTitle->inactivateImmediately();
                    _pScene_GameDemo->inactivateImmediately();        //ANeBuTuV[fV[
                    _pScene_GameBeginning->inactivateImmediately();
                    _pScene_GameMain->inactivateImmediately();
                    _pScene_GameEnding->inactivateImmediately();
                    _pScene_GameOver->inactivateImmediately();
                    //
                    //addSubLast(NEW TamagoScene("TamagoScene"));
                    _is_frame_advance = false;
                
                    _stage = 1;
                    _was_paused_flg_GameMainScene_prev_frame = false;
                    useProgress(10);
                }
                
                void GameScene::initialize() {
                    _TRACE_("GameScene::initialize() DemoScene");
                
                //    _pScene_GameDemo->reset();
                //    _pScene_GameDemo->ready();
                //    _pSceneCannel = _pScene_GameDemo;
                }
                
                void GameScene::onReset() {
                    VB_UI->clear();
                    P_GOD->setVB(VB_UI);
                    _pMyShipScene->resetTree();
                    _pCommonScene->resetTree();
                    _pScene_PreGameTitle->resetTree();
                    _pScene_GameTitle->resetTree();
                    _pScene_GameDemo->resetTree();
                    _pScene_GameBeginning->resetTree();
                    _pScene_GameMain->resetTree();
                    _pScene_GameEnding->resetTree();
                    _pScene_GameOver->resetTree();
                
                    _pMyShipScene->unblindSceneTree();
                    _pCommonScene->unblindSceneTree();
                    _pScene_PreGameTitle->unblindSceneTree();
                    _pScene_GameTitle->unblindSceneTree();
                    _pScene_GameDemo->unblindSceneTree();
                    _pScene_GameBeginning->unblindSceneTree();
                    _pScene_GameMain->unblindSceneTree();
                    _pScene_GameEnding->unblindSceneTree();
                    _pScene_GameOver->unblindSceneTree();
                
                    _pMyShipScene->inactivate();
                    _pScene_PreGameTitle->inactivate();
                    _pScene_GameTitle->inactivate();
                    _pScene_GameDemo->inactivate();
                    _pScene_GameBeginning->inactivate();
                    _pScene_GameMain->inactivate();
                    _pScene_GameEnding->inactivate();
                    _pScene_GameOver->inactivate();
                
                    _pPrg->change(GAME_SCENE_PROG_INIT);
                }
                
                void GameScene::onActive() {
                }
                
                void GameScene::processBehavior() {
                #ifdef MY_DEBUG
                    //Ct[\
                    if (VB->isPushedDown(VB_UI_DEBUG)) {
                        if (GgafDx9God::_d3dfillmode == D3DFILL_WIREFRAME) {
                            GgafDx9God::_d3dfillmode = D3DFILL_SOLID;
                        } else {
                            GgafDx9God::_d3dfillmode = D3DFILL_WIREFRAME;
                        }
                    }
                #endif
                
                    switch (_pPrg->getFromChange()) {
                        case GAME_SCENE_PROG_MAIN: {
                            VB_UI->clear();
                            P_GOD->setVB(VB_UI);  //
                            break;
                        }
                
                        default:
                            break;
                    }
                
                
                    switch (_pPrg->get()) {
                        case GAME_SCENE_PROG_INIT: {
                            //s
                            if (!_pScene_GameMain->_had_ready_stage) {
                                _pScene_GameMain->readyStage(_stage);
                            }
                            _pPrg->change(GAME_SCENE_PROG_PRE_TITLE);
                            break;
                        }
                
                        case GAME_SCENE_PROG_PRE_TITLE: {
                            //##########  ^CgOo  ##########
                            if (_pPrg->isJustChanged()) {
                                P_GOD->syncTimeFrame();
                                _pScene_PreGameTitle->reset();
                                _pScene_PreGameTitle->activate();
                            }
                            //VB_UI_EXECUTE AXLbvTITLE
                            if (VB->isPushedDown(VB_UI_EXECUTE)) { //skip
                                _pScene_PreGameTitle->inactivate();
                                _pPrg->change(GAME_SCENE_PROG_TITLE);
                            }
                            // EVENT_PREGAMETITLE_SCENE_FINISH Cxgt
                            break;
                        }
                
                        case GAME_SCENE_PROG_TITLE: {
                            //##########  ^Cg  ##########
                            if (_pPrg->isJustChanged()) {
                                _pScene_GameTitle->reset();
                                _pScene_GameTitle->activate();
                            }
                            //Cxg EVENT_GAMETITLE_SCENE_FINISH or EVENT_GAMESTART
                            break;
                        }
                
                        case GAME_SCENE_PROG_DEMO: {
                            //##########  f  ##########
                            if (_pPrg->isJustChanged()) {
                                _pScene_GameDemo->reset();
                                _pScene_GameDemo->activate();
                            }
                            //VB_UI_EXECUTE AXLbvTITLE
                            if (VB->isPushedDown(VB_UI_EXECUTE)) {
                                _pPrg->change(GAME_SCENE_PROG_TITLE);
                                _pScene_GameDemo->inactivate();
                            }
                            // EVENT_GAMEDEMO_SCENE_FINISH Cxgt
                            break;
                        }
                
                        case GAME_SCENE_PROG_BEGINNING: {
                            //##########  Q[Jni[hIj  ##########
                            if (_pPrg->isJustChanged()) {
                                _pScene_GameBeginning->reset();
                                _pScene_GameBeginning->activate();
                            }
                            //Cxg EVENT_GAMEMODE_DECIDE
                            break;
                        }
                
                        case GAME_SCENE_PROG_MAIN: {
                            //##########  Q[C  ##########
                            if (_pPrg->isJustChanged()) {
                                VB_PLAY->clear();
                                P_GOD->setVB(VB_PLAY); //vCpX
                                _pScene_GameMain->reset();
                                _pScene_GameMain->activate();
                                _pMyShipScene->reset();
                                _pMyShipScene->activate();
                            }
                
                            if (!_pScene_GameMain->_was_paused_flg) {
                                if (_was_paused_flg_GameMainScene_prev_frame == true)  {
                                    P_UNIVERSE->undoCameraWork();
                                }
                                if (VB->isReleasedUp(VB_PAUSE) || _is_frame_advance) {
                                    _is_frame_advance = false;
                                    _TRACE_("PAUSE!");
                                    P_GOD->setVB(VB_UI);  //th
                
                                    _pScene_GameMain->pause();
                                    _pMyShipScene->pause();
                                    _pCommonScene->pause();
                                }
                            }
                            if (_pScene_GameMain->_was_paused_flg) {
                                if (_was_paused_flg_GameMainScene_prev_frame == false) {
                                    GgafDx9Input::updateMouseState();
                                    GgafDx9Input::updateMouseState(); //}EXWW0Qo
                                    P_UNIVERSE->switchCameraWork("PauseCamWorker");
                                }
                                if (VB->isReleasedUp(VB_PAUSE) || _is_frame_advance) {
                                    P_GOD->setVB(VB_PLAY);
                                    _pScene_GameMain->unpause();
                                    _pMyShipScene->unpause();
                                    _pCommonScene->unpause();
                                }
                            }
                            _was_paused_flg_GameMainScene_prev_frame = _pScene_GameMain->_was_paused_flg;
                            //Cxg EVENT_ALL_MY_SHIP_WAS_DESTROYED
                            break;
                        }
                
                        case GAME_SCENE_PROG_ENDING: {
                            if (_pPrg->isJustChanged()) {
                            }
                            break;
                        }
                
                        case GAME_SCENE_PROG_GAME_OVER: {
                            //##########  Q[I[o[  ##########
                            if (_pPrg->isJustChanged()) {
                                _pScene_GameOver->reset();
                                _pScene_GameOver->activate();
                            }
                            //Cxg EVENT_GAME_OVER_FINISH
                            break;
                        }
                
                        case GAME_SCENE_PROG_FINISH: {
                            //##########  Q[V[I  ##########
                            if (_pPrg->isJustChanged()) {
                                _pMyShipScene->fadeoutSceneTree(FADE_FRAME);
                                _pCommonScene->fadeoutSceneTree(FADE_FRAME);
                                _pScene_PreGameTitle->fadeoutSceneTree(FADE_FRAME);
                                _pScene_GameTitle->fadeoutSceneTree(FADE_FRAME);
                                _pScene_GameDemo->fadeoutSceneTree(FADE_FRAME);
                                _pScene_GameBeginning->fadeoutSceneTree(FADE_FRAME);
                                _pScene_GameMain->fadeoutSceneTree(FADE_FRAME);
                                _pScene_GameEnding->fadeoutSceneTree(FADE_FRAME);
                                _pScene_GameOver->fadeoutSceneTree(FADE_FRAME);
                            }
                            if (_pPrg->getFrameInProgress() == FADE_FRAME) {
                                reset(); //Zbgiij
                            }
                            break;
                        }
                
                        default:
                            break;
                    }
                }
                
                void GameScene::onCatchEvent(UINT32 prm_no, void* prm_pSource) {
                    if (prm_no == EVENT_PREGAMETITLE_SCENE_FINISH) {
                        //v^CgV[I
                        _TRACE_("GameScene::onCatchEvent(EVENT_GAMETITLE_SCENE_FINISH)");
                        _pPrg->change(GAME_SCENE_PROG_TITLE); //^Cg
                
                    } else if (prm_no == EVENT_GAMETITLE_SCENE_FINISH) {
                        //^CgV[I
                        _TRACE_("GameScene::onCatchEvent(EVENT_GAMETITLE_SCENE_FINISH)");
                        _pPrg->change(GAME_SCENE_PROG_DEMO); //f
                
                    } else if (prm_no == EVENT_GAMEDEMO_SCENE_FINISH) {
                        //fV[I
                        _TRACE_("GameScene::onCatchEvent(EVENT_GAMEDEMO_SCENE_FINISH)");
                        _pPrg->change(GAME_SCENE_PROG_INIT); //
                
                    } else if (prm_no == EVENT_GAMESTART) {
                        //X^[g
                        _TRACE_("GameScene::onCatchEvent(EVENT_GAMESTART)");
                        _pPrg->change(GAME_SCENE_PROG_BEGINNING); //I[vjOiQ[[hZNgj
                
                    } else if (prm_no == EVENT_GAMEMODE_DECIDE) {
                        //Q[[hZNg
                        _TRACE_("GameScene::onCatchEvent(EVENT_GAMEMODE_DECIDE)");
                        _stage = 1;
                        _pPrg->change(GAME_SCENE_PROG_MAIN); //C
                
                    } else if (prm_no == EVENT_GOTO_GAMETITLE) {
                        //^CgCxg
                        _TRACE_("GameScene::onCatchEvent(EVENT_GOTO_GAMETITLE)");
                        _pPrg->change(GAME_SCENE_PROG_TITLE); //^Cg
                    }
                
                
                
                    if (prm_no == EVENT_ALL_MY_SHIP_WAS_DESTROYED) {
                        _TRACE_("GameScene::onCatchEvent(EVENT_ALL_MY_SHIP_WAS_DESTROYED)");
                        _pPrg->change(GAME_SCENE_PROG_GAME_OVER); //Q[I[o[
                    } else if (prm_no == EVENT_GAME_OVER_FINISH) {
                        _TRACE_("GameScene::onCatchEvent(EVENT_GAME_OVER_FINISH)");
                        _pPrg->change(GAME_SCENE_PROG_FINISH);
                    }
                }
                
                
                void GameScene::processJudgement() {
                
                    if (getBehaveingFrame() >= 120) {
                        CollisionChecker::_num_check = 0;
                
                //        if (GgafDx9Input::isBeingPressedKey(DIK_I)) {
                //            CollisionChecker::_pLinearOctree->putTree();
                //        }
                
                        //ASYV[AN^[Sqbg`FbN
                        // uV[Creater.xlsv  uv V[gQ
                        CollisionChecker::_pLinearOctree->executeAllHitChk(
                        KIND_MY_BODY_NOMAL,
                        KIND_ITEM
                        );
                        CollisionChecker::_pLinearOctree->executeAllHitChk(
                        KIND_MY_SHOT|KIND_MY_BODY,
                        KIND_ENEMY_BODY|KIND_OTHER|KIND_CHIKEI
                        );
                        CollisionChecker::_pLinearOctree->executeAllHitChk(
                        KIND_ENEMY_SHOT,
                        KIND_MY_BODY|KIND_OTHER|KIND_CHIKEI
                        );
                        CollisionChecker::_pLinearOctree->executeAllHitChk(
                        KIND_ENEMY_BODY_NOMAL|KIND_ENEMY_BODY_GU|KIND_ENEMY_BODY_CHOKI|KIND_ENEMY_BODY_PA,
                        KIND_CHIKEI|KIND_OTHER
                        );
                        CollisionChecker::_pLinearOctree->executeAllHitChk(
                        KIND_ENEMY_BODY_CHIKEI_NOMAL|KIND_ENEMY_BODY_CHIKEI_GU|KIND_ENEMY_BODY_CHIKEI_CHOKI|KIND_ENEMY_BODY_CHIKEI_PA|KIND_CHIKEI|KIND_OTHER,
                        KIND_OTHER
                        );
                    }
                }
                
                
                
                
                
                void GameScene::processFinal() {
                }
                
                
                
           2 -> GameScene::~GameScene() {
                }


Top 10 Lines:

     Line      Count

      367          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/scene/Universe/World/PreDrawScene.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> PreDrawScene::PreDrawScene(const char* prm_name) : DefaultScene(prm_name) {
                    _class_name = "PreDrawScene";
                
                    //orderActorToFactory(10, LaserChipEffectActor, "LaserChipEffectActor");
                    //orderActorToFactory(11, DefaultMeshEffectActor, "DefaultMeshEffectActor");
                }
                
                void PreDrawScene::onReset() {
                }
                void PreDrawScene::ready() {
                }
                
                void PreDrawScene::initialize() {
                }
                
                void PreDrawScene::processBehavior() {
                    if (getActivePartFrame() == 1) {
                        //getLordActor()->addSubGroup(obtainActorFromFactory(10));
                        //getLordActor()->addSubGroup(obtainActorFromFactory(11));
                    }
                }
                
                void PreDrawScene::processFinal() {
                }
                
           2 -> PreDrawScene::~PreDrawScene() {
                }


Top 10 Lines:

     Line      Count

       33          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/scene/Universe/World.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
           1 -> World::World(const char* prm_name) : DefaultScene(prm_name) {
                    _class_name = "World";
                    _TRACE_("World::World");
                    _is_create_GameScene = false;
                    _pFont16_Debug = NULL;
                
                    //yz
                    //ActorSceneNEWB
                    //DAssB
                }
                
                void World::initialize() {
                    _TRACE_("World::initialize()");
                    _pStringBoard01 = NEW LabelGecchi16Font("STR01");
                    getLordActor()->addSubGroup(_pStringBoard01);
                    _pStringBoard01->update(0,50,"WATE A MOMENT PLASE...");
                #ifdef MY_DEBUG
                    ColliAABActor::get();   //\pAv[h
                    ColliAAPrismActor::get();   //\pAv[h
                    ColliSphereActor::get(); //\pAv[h
                #endif
                //#ifdef MY_DEBUG
                    orderActorToFactory(0, LabelGecchi16Font, "DebugStr");
                    _pFont16_Debug = (LabelGecchi16Font*)obtainActorFromFactory(0);
                    getLordActor()->addSubGroup(_pFont16_Debug);
                //    orderActorWithModelToFactory(3, DispFpsActor, "FPS_STRING", "28/GECCHI_16FONT");
                //    DispFpsActor* pDispFpsActor = (DispFpsActor*)obtainActorFromFactory(3);
                //    getLordActor()->addSubGroup(KIND_EFFECT, pDispFpsActor);
                //#endif
                
                    orderSceneToFactory(1, PreDrawScene, "PreDraw");
                    PreDrawScene* pPreDrawScene = (PreDrawScene*)obtainSceneFromFactory(1);
                    addSubLast(pPreDrawScene);
                    orderSceneToFactory(2, GameScene, "Game");
                
                    //GameScene* pGameScene = NEW GameScene("Game");
                    //addSubLast(pGameScene);
                //#ifdef MY_DEBUG
                //    DispFpsActor* pDispFpsActor = NEW DispFpsActor("FPS_STRING", "28/moji");
                //    getLordActor()->addSubGroup(KIND_EFFECT, pDispFpsActor);
                //#endif
                
                }
                
                void World::processBehavior() {
                    if (_is_create_GameScene) {
                        VB->update(); //XV
                        if (P_GOD->_sync_frame_time) {
                            _TEXT_("z");
                        }
                        if (GgafDx9Input::isBeingPressedKey(DIK_Q)) {
                            //TODO:I
                        }
                    } else {
                        //GameScene
                        if (MyFactory::chkProgress(2) == 2) {
                            _pGameScene = (GameScene*)obtainSceneFromFactory(2);
                            addSubLast(_pGameScene);
                            _is_create_GameScene = true;
                            _pStringBoard01->end();
                        }
                    }
                
                
                #ifdef MY_DEBUG
                    sprintf(_aBufDebug, "%05uDRAW / %06uCHK / %07uF /%.1fFPS", GgafGod::_num_actor_drawing, CollisionChecker::_num_check, (unsigned int)askGod()->_frame_of_God, askGod()->_fps);
                    _pFont16_Debug->update(1, 1, _aBufDebug);
                    if (getActivePartFrame() % 60 == 0) {
                        _TRACE_("_aBufDebug="<<_aBufDebug);
                    }
                #else
                    sprintf(_aBufDebug, "%05uDRAW / %.1fFPS", GgafGod::_num_actor_drawing, askGod()->_fps);
                    _pFont16_Debug->update(1, 1, _aBufDebug);
                #endif
                
                
                }
                
                void World::processJudgement() {
                }
                
           2 -> World::~World() {
                }
                


Top 10 Lines:

     Line      Count

       89          2
        8          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/scene/Universe.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
                
           1 -> Universe::Universe(const char* prm_name, GgafDx9Camera* prm_pCamera) : DefaultUniverse(prm_name, prm_pCamera) {
                    _class_name = "Universe";
                
                    _TRACE_("Universe::Universe()");
                    _pCameraWorkerManager = NEW CameraWorkerManager("CameraWorkerManager");
                
                    CameraWorkerConnection* pDefaultCameraWorkerCon = (CameraWorkerConnection*)_pCameraWorkerManager->getConnection("DefaultCamWorker");
                    _stack_CameraWorkerCon.push(pDefaultCameraWorkerCon);
                    _pActiveCameraWorker = pDefaultCameraWorkerCon->refer();
                    getLordActor()->addSubGroup(_pActiveCameraWorker); //ftHgJ[N
                
                
                    GgafRepeatSeq::create("CH_bomb1", 0, 20);
                    GgafRepeatSeq::create("CH_yume_Sbend", 0, 8);
                    GgafRepeatSeq::create("CH_MetisHit", 0, 20);
                    GgafRepeatSeq::create("CH_break_glass01", 0, 20);
                    GgafRepeatSeq::create("CH_a_shot", 0, 5);
                    GgafRepeatSeq::create("CH_laser001", 0, 8); //IvV[U[
                    GgafRepeatSeq::create("CH_cm-22", 0, 8); //Juno
                    GgafRepeatSeq::create("CH_MetisDestroy", 0, 20); //Metis
                    GgafRepeatSeq::create("CH_explos3", 0, 3); //Vesta
                    GgafRepeatSeq::create("CH_humei10", 0, 1); //Lockon
                    GgafRepeatSeq::create("CH_fire01", 0, 16); //@Vbg
                
                
                    //yz
                    //ActorSceneNEWB
                    //DAssB
                }
                
                void Universe::initialize() {
                    _pWorld = NEW World("WORLD");
                    addSubLast(_pWorld);
                
                    _TRACE_("Universe::initialize()");
                }
                
                void Universe::processBehavior() {
                    DefaultUniverse::processBehavior();
                }
                
                
                void Universe::processJudgement() {
                    DefaultUniverse::processJudgement();
                }
                
                CameraWorker* Universe::switchCameraWork(const char* prm_pID) {
                
                    //    |      |                             |      |
                    //    |      |                             +------+
                    //    |      |            push ConC        | ConC | Active(return)
                    //    +------+            --------->       +------+
                    //    | ConB | Active                    | ConB |
                    //    +------+                             +------+
                    //    | ConA |                             | ConA |
                    //    +------+                             +------+
                
                    CameraWorkerConnection* pCon = (CameraWorkerConnection*)_pCameraWorkerManager->getConnection(prm_pID);
                    CameraWorker* pCameraWorker = pCon->refer();
                    if (pCameraWorker != _pActiveCameraWorker) {
                        // CameraWork 
                        _pActiveCameraWorker->onSwitchToOherCameraWork(); //R[obN
                        _pActiveCameraWorker->inactivate();
                        //p[^ CameraWork 
                        pCameraWorker->activate();
                        pCameraWorker->onSwitchCameraWork(); //R[obN
                        if (getLordActor()->getSubFirst()->getSub(pCameraWorker)) {
                            //Q~
                        } else {
                            getLordActor()->addSubGroup(pCameraWorker); //c[
                        }
                        //X^bN
                        _stack_CameraWorkerCon.push(pCon);
                        _pActiveCameraWorker = pCameraWorker;
                    } else {
                        _stack_CameraWorkerCon.dump();
                        throwGgafCriticalException("Universe::switchCameraWork("<<prm_pID<<") J[NApush()B_pActiveCameraWorker="<<_pActiveCameraWorker->getName());
                    }
                    return pCameraWorker;
                
                }
                
                CameraWorker* Universe::undoCameraWork() {
                
                    //    |      |                       |      |
                    //    +------+                       |      |
                    //    | ConC | Active      pop     |      |
                    //    +------+           --------->  +------+
                    //    | ConB |                       | ConB | Active(return)
                    //    +------+                       +------+
                    //    | ConA |                       | ConA |
                    //    +------+                       +------+
                
                    //X^bNo
                    CameraWorkerConnection* pCon_now = _stack_CameraWorkerCon.pop(); //pCon_now}ConC
                    CameraWorkerConnection* pCon = _stack_CameraWorkerCon.getLast(); //pCon}ConB
                    if (pCon) {
                        CameraWorker* pCameraWorker = pCon->refer();
                        if (pCameraWorker != _pActiveCameraWorker) {
                            // CameraWork 
                            _pActiveCameraWorker->inactivate();
                            _pActiveCameraWorker->onUndoCameraWork();  //R[obN
                            _pActiveCameraWorker = pCameraWorker;
                            if (_pActiveCameraWorker) {
                                //PO CameraWork 
                                _pActiveCameraWorker->onCameBackFromOtherCameraWork();  //R[obN
                                _pActiveCameraWorker->activate();
                            } else {
                                _stack_CameraWorkerCon.dump();
                                throwGgafCriticalException("Universe::undoCameraWork()  _stack_CameraWorker  pop() B");
                            }
                            pCon_now->close();
                            return _pActiveCameraWorker;
                        } else {
                            _stack_CameraWorkerCon.dump();
                            throwGgafCriticalException("Universe::undoCameraWork() pop()J[NApop()OJ[NBpCameraWorker="<<pCameraWorker->getName());
                        }
                    } else {
                        _stack_CameraWorkerCon.dump();
                        throwGgafCriticalException("Universe::undoCameraWork()  _stack_CameraWorker  pop() ");
                    }
                }
                
                void Universe::resetCameraWork() {
                    //DefaultCamWorkerLC
                    for (int i = 0; i < 30; i++) {
                        if (_stack_CameraWorkerCon._p == 1) {
                            break;
                        } else {
                            CameraWorkerConnection* pCon = _stack_CameraWorkerCon.pop();
                            pCon->close();
                        }
                    }
                }
                
                
           2 -> Universe::~Universe() {
                    DELETE_IMPOSSIBLE_NULL(_pCameraWorkerManager);
                }


Top 10 Lines:

     Line      Count

      145          2
        9          1

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

        3   Total number of line executions
     1.00   Average executions per line


*** File C:/cygwin/workspace/_git_repos/MyStg2nd/src/gecchi/scene/Universe.h:
                #ifndef UNIVERSE_H_
                #define UNIVERSE_H_
                
                //getParent getSub  LXg}NB
                //L}NgpAIuWFNgA
                //NX"...Scene"O
                #define getParentScene(X) ((X##Scene*)getParent(#X))
                #define getSubScene(X) ((X##Scene*)getSub(#X))
                #define getParentActor(X) ((X##Actor*)getParent(#X))
                #define getSubActor(X) ((X##Actor*)getSub(#X))
                
                #ifdef P_UNIVERSE
                    #define P_CAM ((MyStg2nd::Camera*)(P_UNIVERSE->_pCamera))
                #else
                    #error P_UNIVERSE isnt define
                #endif
                
                
                namespace MyStg2nd {
                
                
                /**
                 * I .
                 * {NXAUB<BR>
                 * foJ(Camera)sB<BR>
                 * @version 1.00
                 * @since 2009/04/24
                 * @author Masatoshi Tsuge
                 */
                class Universe : public GgafDx9LibStg::DefaultUniverse {
                
                    class CameraWorkerConnectionStack {
                    public:
                        CameraWorkerConnection* _apCameraWorkerCon[30];
                        UINT32 _p;
           1 ->         CameraWorkerConnectionStack() {
                            _p = 0;
                            for (int i = 0; i < 30; i++) {
                                _apCameraWorkerCon[i] = NULL;
                            }
                        }
                        CameraWorkerConnection* getLast() {
                            if (_p == 0) {
                                return NULL;
                            } else {
                                return _apCameraWorkerCon[_p-1];
                            }
                        }
                        void push(CameraWorkerConnection* prm_pCameraWorkerCon) {
                            if (_p > 30-1) {
                                throwGgafCriticalException("CameraWorkerConnectionStack::push("<<prm_pCameraWorkerCon->getIdStr()<<") X^bNgB");
                            }
                            _apCameraWorkerCon[_p] = prm_pCameraWorkerCon;
                            _p++;
                        }
                        CameraWorkerConnection* pop() {
                            if (_p == 0) {
                                throwGgafCriticalException("CameraWorkerConnectionStack::pop() |bv");
                            } else {
                                _p--;
                                CameraWorkerConnection* r = _apCameraWorkerCon[_p];
                                _apCameraWorkerCon[_p] = NULL;
                                return r;
                            }
                        }
                        void clear() {
                            _p = 0;
                            for (int i = 0; i < 30; i++) {
                                _apCameraWorkerCon[i] = NULL;
                            }
                        }
                
                        void dump() {
                            _TRACE_("CameraWorkerConnectionStack _p="<<_p);
                            for (int i = 0; i < 30; i++) {
                                if (_apCameraWorkerCon[i]) {
                                    _TRACE_("_apCameraWorkerCon["<<i<<"]="<<(_apCameraWorkerCon[i]->getIdStr()));
                                }
                            }
                        }
           1 ->         ~CameraWorkerConnectionStack() {
                            clear();
                        }
                    };
                
                
                public:
                
                    CameraWorker* _pActiveCameraWorker;
                    CameraWorkerManager* _pCameraWorkerManager;
                    World* _pWorld;
                    CameraWorkerConnectionStack _stack_CameraWorkerCon;
                
                    Universe(const char* prm_name, GgafDx9Core::GgafDx9Camera* prm_pCamera);
                
                    void initialize() override;
                
                    void processBehavior() override;
                
                    void processJudgement() override;
                
                    CameraWorker* switchCameraWork(const char* prm_pID);
                
                    CameraWorker* undoCameraWork();
                
                    void resetCameraWork();
                
                    virtual ~Universe();
                };
                
                }
                #endif /*UNIVERSE_H_*/


Top 10 Lines:

     Line      Count

       36          1
       81          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     1.00   Average executions per line


*** File C:\cygwin\workspace\_git_repos\MyStg2nd\GprofCdt/../src/gecchi/util/SplineSource.cpp:
                #include "stdafx.h"
                using namespace std;
                using namespace GgafCore;
                using namespace GgafDx9Core;
                using namespace GgafDx9LibStg;
                using namespace MyStg2nd;
                
                
                #define MAX_SP_POINT 1000
                
           6 -> SplineSource::SplineSource(char* prm_idstr)  : GgafObject() {
                    _accuracy = 1.0;
                    _spent_frame = 1;
                    _angveloRzRyMv = 0;
                    _classname = "";
                    string data_filename = STG_PROPERTY(DIR_SPLINE_DATA) + string(prm_idstr) + ".spl";
                    ifstream ifs(data_filename.c_str());
                    if (ifs.fail()) {
                        throwGgafCriticalException("SplineSource::SplineSource "<<prm_idstr<<" J");
                    }
                    double p[MAX_SP_POINT][3];
                    string line;
                    int n = 0;
                    while( getline(ifs,line) ) {
                        if (line.size() == 0 ) continue;
                        if (line.c_str()[0] == '#') continue;
                
                        LOOP_SPLFILE:
                        if (line.find("[CLASS]") != string::npos) {
                            while( getline(ifs,line) ) {
                                if (line.size() == 0 ) break;
                                if (line.c_str()[0] == '#') continue;
                                if (line.c_str()[0] == '[') goto LOOP_SPLFILE;
                                istringstream iss(line);
                                iss >> _classname;
                                if (_classname == "GgafDx9FixedFrameSplineProgram") {
                                    iss >> _spent_frame;
                                    iss >> _angveloRzRyMv;
                                } else if (_classname == "GgafDx9FixedVelocitySplineProgram") {
                                    iss >> _angveloRzRyMv;
                                    _spent_frame = 0;
                                }
                            }
                        }
                        if (line.find("[BASEPOINT]") != string::npos) {
                            while( getline(ifs,line) ) {
                                if (line.size() == 0 ) break;
                                if (line.c_str()[0] == '#') continue;
                                if (line.c_str()[0] == '[') goto LOOP_SPLFILE;
                                istringstream iss(line);
                                iss >> p[n][0];
                                iss >> p[n][1];
                                iss >> p[n][2];
                                n++;
                #ifdef MY_DEBUG
                                if (n >= MAX_SP_POINT) {
                                    throwGgafCriticalException("SplineSource::SplineSource "<<prm_idstr<<" |Cg"<<MAX_SP_POINT<<"B");
                                }
                #endif
                            }
                        }
                        if (line.find("[ACCURACY]") != string::npos) {
                            while( getline(ifs,line) ) {
                                if (line.size() == 0 ) break;
                                if (line.c_str()[0] == '#') continue;
                                if (line.c_str()[0] == '[') goto LOOP_SPLFILE;
                                istringstream iss(line);
                                iss >> _accuracy;
                            }
                        }
                    }
                #ifdef MY_DEBUG
                    if (_classname.length() == 0) {
                        throwGgafCriticalException("SplineSource::SplineSource "<<prm_idstr<<" _classname wB");
                    }
                    if (n == 0) {
                        throwGgafCriticalException("SplineSource::SplineSource "<<prm_idstr<<" |CgB");
                    }
                #endif
                    //-1.0 ` 1.0  @\
                    for (int i = 0; i < n; i++) {
                        p[i][0] = p[i][0] * MyShip::_lim_front; //X
                        p[i][1] = p[i][1] * MyShip::_lim_top;   //Y
                        p[i][2] = p[i][2] * MyShip::_lim_zleft; //Z
                    }
                    _pSp = NEW GgafDx9Spline3D(p, n, _accuracy);
                
                }
                
                
                GgafDx9SplineProgram* SplineSource::makeSplineProgram(GgafDx9GeometricActor* prm_pForWhichActor) {
                    GgafDx9SplineProgram* pSpProg = NULL;
                    if (_classname.find("GgafDx9FixedFrameSplineProgram") != string::npos) {
                        pSpProg = NEW GgafDx9FixedFrameSplineProgram(prm_pForWhichActor, _pSp, _spent_frame, _angveloRzRyMv);
                    } else if (_classname.find("GgafDx9FixedVelocitySplineProgram") != string::npos) {
                        pSpProg = NEW GgafDx9FixedVelocitySplineProgram(prm_pForWhichActor, _pSp, _angveloRzRyMv);
                    } else {
                        throwGgafCriticalException("SplineSource::makeSplineProgram _classname="<<_classname<< "sNX");
                    }
                    return pSpProg;
                }
                
          12 -> SplineSource::~SplineSource() {
                    DELETE_IMPOSSIBLE_NULL(_pSp);
                }


Top 10 Lines:

     Line      Count

      103         12
       11          6

Execution Summary:

        3   Executable lines in this file
        2   Lines executed
    66.67   Percent of the file executed

       18   Total number of line executions
     6.00   Average executions per line
