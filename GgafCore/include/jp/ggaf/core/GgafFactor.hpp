#ifndef GGAFFACTOR_H_
#define GGAFFACTOR_H_


#define SUPER GgafTreeLinkedList<T>
#define HAPPEN_PLAY_BEGIN 1


/**
 * GgafTreeLinkedListに、様々な状態管理（フラグ管理）を追加
 * @version 1.00
 * @since 2008/06/20
 * @auther Masatoshi Tsuge
 */
template<class T>
class GgafFactor : public SUPER {

protected:

	/** 神様への近道 */
	GgafGod* _pGod;

	/** initializeフラグ */
	bool _wasInitialized;

	/** ループ用 */
	T* _pNodeTemp;

public:
	/** ノードが誕生(addSubされた）時からのフレーム */
	DWORD _dwFrame;
    /** 相対フレーム計算用 */
    DWORD _dwFrame_relative;
	/** ノード活動フラグ */
	bool _isPlaying;
	/** 一時停止フラグ */
	bool _wasPaused;
	/** 一時非表示フラグ */
	bool _wasBlinded;
	/** ノード生存フラグ */
	bool _isAlive;

	/** 次フレームのフレーム加算時に設定されるノード活動フラグ */
	bool _willPlayNextFrame;
	/** 次フレームのフレーム加算時に設定される一時停止フラグ */
	bool _willPauseNextFrame;
	/** 次フレームのフレーム加算時に設定される表示フラグ  */
	bool _willBlindNextFrame;
	/** 次フレームのフレーム加算時に設定される一時非表示フラグ */
	bool _willBeAliveNextFrame;

	/** 次フレームのフレーム加算時に、自ノードが先頭ノードに移動することを示したフラグ */
	bool _willMoveFirstNextFrame;
	/** 次フレームのフレーム加算時に、自ノードが末尾ノードに移動することを示したフラグ */
	bool _willMoveLastNextFrame;

	/** あとで活動フラグ */
	bool _willPlayAfterFrame;
	/** あとで活動残フレーム */
	DWORD _dwGodFremeWhenPlay;

	/** あとで停止フラグ */
	bool _willStopAfterFrame;
	/** あとで停止残フレーム */
	DWORD _dwGodFremeWhenStop;

	/**
	 * コンストラクタ
	 * @param prm_name ノード名称（ユニークにして下さい）
	 */
	GgafFactor(string prm_name);

	/**
	 * デストラクタ。自ツリーノードを解放します。 .
	 * 自ノードが子ノードを持つ場合、子ノードを解放してから自身を開放する。<BR>
	 * 自ノードが最終ノードだった場合、自ノードを連結から離脱し、前ノードを最終ノードフラグをセットして、自身を解放する。<BR>
	 * 自ノードが先頭ノードだった場合、自ノードを連結から離脱し、次ノードを親ノード の 子ノードの先頭ノード、さらに 先頭ノードフラグをセットし、自身を解放する。<BR>
	 * 自ノードが中間ノードだった場合、両隣のノードの連結を再構築した後解放する。<BR>
	 * 自ノードの連結が自身を指す（１人ぼっちだった）場合、親ノード の 子ノードの先頭ノード（自分を指していた）をNULLに変更してから解放する。<BR>
	 */
	virtual ~GgafFactor();

	/**
	 * ノード初期処理 .
	 * 生成後、nextFrame(),behave(),judge(),drawPrior(),drawMain(),drawTerminate(),happen(int),finally() の
	 * 何れかが呼び出された時、最初に必ず１回だけ呼び出されます。<BR>
	 */
	virtual void initialize();

	/**
	 * 掃除 .
	 * 配下ノードの中にノード生存フラグ(_isAlive)が false になっているノードがあれば１つだけ解放します。
	 */
	virtual void cleane();

	/**
	 * ノードのフレームを加算と、フレーム開始にあたってのいろいろな初期処理 .
	 * 活動フラグ、生存フラグがセットされている場合ノードのフレームを加算します。その直後に<BR>
	 * _willPlayNextFrame, _willPauseNextFrame, _willBlindNextFrame, _willBeAliveNextFrame を<BR>
	 * _isPlaying, _wasPaused, _wasBlinded, _isAlive に反映（コピー）します。<BR>
	 * また、_willMoveFirstNextFrame, _willMoveLastNextFrame が true の場合は、<BR>
	 * それぞれ、自ノードの先頭ノードへの移動、末尾ノードへの移動も実行されます。<BR>
	 * その後、配下ノード全てに nextFrame() を実行します。<BR>
	 * 神(GgafGod)は、世界(GgafWorld)に対して本メンバ関数実行後、behave()を実行します。<BR>
	 */
	virtual void nextFrame();

	/**
	 * ノードのフレーム毎の振る舞い処理 .
	 * 活動フラグ、生存フラグがセット、かつ一時停止フラグがアンセット<BR>
	 * （_isPlaying && !_wasPaused && _isAlive）の場合 <BR>
	 * processBehavior() をコールした後、配下のノード全てについて behave() を実行します。<BR>
	 * 神(GgafGod)は、世界(GgafWorld)に対して本メンバ関数実行後、judge()を実行します。<BR>
	 */
	virtual void behave();

	/**
	 * ノードのフレーム毎の判定処理 .
	 * 活動フラグ、生存フラグがセット、かつ一時停止フラグがアンセット<BR>
	 * (つまり _isPlaying && !_wasPaused && _isAlive)の場合 <BR>
	 * processJudgement() をコールした後、配下のノード全てについて judge() を実行します。<BR>
	 * 神(GgafGod)は、世界(GgafWorld)に対して本メンバ関数実行後、フレーム時間に余裕があれば drawPrior()、無ければ finally()を実行します。<BR>
	 */
	virtual void judge();

	/**
	 * ノードのフレーム毎の描画事前処理（但し高負荷時は、フレームスキップされて呼び出されないい場合もあります。） .
	 * 活動フラグ、生存フラグがセット、かつ一時非表示フラグがアンセット<BR>
	 * (つまり _isPlaying && !_wasBlinded && _isAlive)の場合 <BR>
	 * processDrawPrior() をコールした後、配下のノード全てについて drawPrior() を実行します。<BR>
	 * 神(GgafGod)は、世界(GgafWorld)に対して本メンバ関数実行後、drawMain() を実行します。<BR>
	 */
	virtual void drawPrior();

	/**
	 * ノードのフレーム毎の描画本処理（但し高負荷時は、フレームスキップされて呼び出されない場合もあります。） .
	 * 活動フラグ、生存フラグがセット、かつ一時非表示フラグがアンセット<BR>
	 * (つまり _isPlaying && !_wasBlinded && _isAlive)の場合 <BR>
	 * processDrawMain() をコールした後、配下のノード全てについて drawMain() を実行します。<BR>
	 * 神(GgafGod)は、世界(GgafWorld)に対して本メンバ関数実行後、drawTerminate() を実行します。<BR>
	 */
	virtual void drawMain();

	/**
	 * ノードのフレーム毎の描画事後処理（但し高負荷時は、フレームスキップされて呼び出されない場合もあります。） .
	 * 活動フラグ、生存フラグがセット、かつ一時非表示フラグがアンセット<BR>
	 * (つまり _isPlaying && !_wasBlinded && _isAlive)の場合 <BR>
	 * processTerminate() をコールした後、配下のノード全てについて drawTerminate() を実行します。<BR>
	 * 神(GgafGod)は、世界(GgafWorld)に対して本メンバ関数実行後、finally() を実行します。<BR>
	 */
	virtual void drawTerminate();

	/**
	 * ノードのフレーム毎の最終処理 .
	 * 活動フラグ、生存フラグがセット、かつ一時停止フラグがアンセット<BR>
	 * （_isPlaying && !_wasPaused && _isAlive）の場合 <BR>
	 * processFinally() をコールした後、配下のノード全てについて finally() を実行します。<BR>
	 * 神(GgafGod)は、世界(GgafWorld)に対して本メンバ関数実行後、フレーム時間に余裕があれば cleane() を実行します。<BR>
	 */
	virtual void finally();

	/**
	 * ノードの何かの処理(フレーム毎ではない) .
	 * 活動フラグがセット、(つまり _isPlaying)の場合 <BR>
	 * processHappen(int) をコールした後、配下のノード全てについて happen() を実行します。<BR>
	 * @param	prm_no 何かの番号
	 */
	virtual void happen(int prm_no);

	/**
	 * フレーム毎の個別振る舞い処理を実装。 .
	 * behave() 時の処理先頭でコールバックされます。<BR>
	 * このメンバ関数を下位クラスでオーバーライドして、ノード個別の振る舞いを処理を実装します。<BR>
	 * 想定している振る舞い処理とは、主に座標計算と移動処理等です。<BR>
	 * 本メンバ関数がコールバックされると言う事は、自ツリーノード全てに対して、nextFrame() が実行済みであることを保証します<BR>
	 */
	virtual void processBehavior() = 0;

	/**
	 * フレーム毎の個別判断処理を実装。 .
	 * judge() 時の処理先頭でコールバックされます。<BR>
	 * このメンバ関数をオーバーライドして、ノード個別判断処理を記述します。<BR>
	 * 本メンバ関数がコールバックされると言う事は、自ツリーノード全てに対して、behave() が実行済みであることを保証します。<BR>
	 * 本メンバ関数の存在意図として、processBehavior() で座標移動処理が全て完了した後､本メンバ関数で当たり判定処理を実装するといった使い方を想定しています。<BR>
	 */
	virtual void processJudgement() = 0;

	/**
	 * ノードのフレーム毎の個別描画事前処理を実装。 .
	 * drawPrior() 時の処理先頭でコールバックされます。 但し、神(GgafGod)が描画スキップした場合、フレーム内で呼び出されません。<BR>
	 * このメンバ関数をオーバーライドして、ノード個別描画事前処理を実装します。<BR>
	 * 個別描画事前処理とは、主に当たり背景描画などです。<BR>
	 * 本メンバ関数がコールバックされると言う事は、自ツリーノード全てに対して、judge() が実行済みであることも保証します<BR>
	 * さらに、本メンバ関数実行後、processDrawMain()、processDrawTerminate() が呼び出されることも保証されます。
	 */
	virtual void processDrawPrior() = 0;

	/**
	 * ノードのフレーム毎の個別描画本処理を実装。 .
	 * drawMain() 時の処理先頭でコールバックされます。 但し、drawPrior() と同様に神(GgafGod)が描画スキップされた場合は、フレーム内で呼び出されません。<BR>
	 * このメンバ関数をオーバーライドして、ノード個別描画本処理を実装します。<BR>
	 * 個別描画本処理とは主にキャラクタや、背景の描画を想定しています。
	 * 本メンバ関数がコールバックされると言う事は、自ツリーノード全てに対して、drawPrior() が実行済みであることを保証します<BR>
	 */
	virtual void processDrawMain() = 0;

	/**
	 * ノードのフレーム毎の個別表示事後処理を記述
	 * drawTerminate() 時の処理先頭でコールバックされます。 但し、drawPrior() と同様に神(GgafGod)が描画スキップされた場合は、フレーム内で呼び出されません。<BR>
	 * このメンバ関数をオーバーライドして、ノード個別表示事後処理を実装します。<BR>
	 * 個別表示事後処理とは、最前面レイヤーで実現するフェードエフェクトや、常に最前面に表示される情報表示などです。<BR>
	 * 本メンバがコールバックされると言う事は、自ツリーノード全てに対して、drawMain() が実行済みであることを保証します<BR>
	 */
	virtual void processDrawTerminate() = 0;


	/**
	 * ノードのフレーム毎の個別終端処理を実装。 .
	 * finally() 時の処理先頭でコールバックされます。<BR>
	 * このメンバ関数を下位クラスでオーバーライドして、ノード個別の終端処理を実装します。<BR>
	 * 終端処理とは、フラグ管理の実行などです。<BR>
	 * 想定している振る舞い処理とは、主に座標計算と移動処理です。その他なんでも良いです。<BR>
	 * 本メンバ関数がコールバックされると言う事は、自ツリーノード全てに対して、judge() が実行済みであることを保証します<BR>
	 */
	virtual void processFinal() = 0;

	/**
	 * ノードの個別何かの処理を記述
	 * happen() 時の処理先頭でコールバックされます。
	 * 利用目的不定の汎用イベント用メソッド
	 * @param	int prm_no 何かの番号
	 */
	virtual void processHappen(int prm_no) = 0;

    /**
	 * 神様に接見 .
	 * @return	呼ばれて出てきた神様
	 */
	virtual GgafGod* askGod() = 0;

	/**
	 * 自ツリーノードを次フレームから再生状態にする .
	 * 自身と自分より下位のノード全てに再生(declarePlay())が実行される。<BR>
	 * <B>[補足]</B>ノード生成直後は、再生状態となっている。<BR>
	 */
	virtual void declarePlay();

	/**
	 * 自ツリーノードを即座に再生状態にする .
	 * 自身と自分より下位のノード全てに再生(playImmediately())が実行される。<BR>
	 * <B>[補足]</B><BR>
	 * processFinal()以外に実装や、this 以外に実行する場合、そのノードの影響を良く考えて注意して使用すること。<BR>
	 */
	virtual void playImmediately();

	/**
	 * 自ツリーノードをNフレーム後に再生状態にする .
	 * @param prm_dwFrameOffset 遅延フレーム数
	 */
	virtual void playAfter(DWORD prm_dwFrameOffset);

	/**
	 * 自ツリーノードを次フレームから停止状態にする .
	 * 自身と自分より下位のノード全てに停止(declarePlay())が実行される。<BR>
	 */
	virtual void declareStop();

	/**
	 * 自ツリーノードを即座に停止状態にする .
	 * 自身と自分より下位のノード全てに停止(playImmediately())が実行される。<BR>
	 * <B>[補足]</B><BR>
	 * processFinal()以外に実装や、this 以外で実行する場合、そのノードの影響を良く考えて注意して使用すること。<BR>
	 */
	virtual void stopImmediately();

	/**
	 * 自ツリーノードをNフレーム後に停止状態にする .
	 * @param prm_dwFrameOffset 遅延フレーム数
	 */
	virtual void stopAfter(DWORD prm_dwFrameOffset);

	/**
	 * 自ツリーノードを次フレームから一時停止状態にする .
	 * 自身と自分より下位のノード全てに一時停止(declarePause())が実行される。<BR>
	 * <B>[補足]</B>再生中に本関数を実行すると静止画像表示状態となる。<BR>
	 */
	virtual void declarePause();

	/**
	 * 自ツリーノードを即座に一時停止状態にする .
	 * 自身と自分より下位のノード全てに一時停止状態(pauseImmediately())が実行される。<BR>
	 * <B>[補足]</B><BR>
	 * processFinal()以外に実装や、this 以外で実行する場合、そのノードの影響を良く考えて注意して使用すること。<BR>
	 */
	virtual void pauseImmediately();

	/**
	 * 自ツリーノードを次フレームから一時停止解除にする .
	 * 自身と自分より下位のノード全てに一時停止解除(declareUnpause())が実行される。<BR>
	 * <B>[補足]</B>declarePause()を行なわずに本メソッドを呼び出しても何も行いません。<BR>
	 */
	virtual void declareUnpause();

	/**
	 * 自ツリーノードを即座に一時停止解除にする .
	 * 自身と自分より下位のノード全てに一時停止状態(unpauseImmediately())が実行される。<BR>
	 * <B>[補足]</B><BR>
	 * processFinal()以外に実装や、this 以外で実行する場合、そのノードの影響を良く考えて注意して使用すること。<BR>
	 */
	virtual void unpauseImmediately();

	/**
	 * 自ツリーノードを次フレームから非表示状態にする .
	 * 自身と自分より下位のノード全てに非表示状態(declareBlind())が実行される。<BR>
	 * <B>[補足]</B>再生中に本関数を実行すると、オブジェクトは表示されないものの、内部的に座標移動、当たり判定などの活動は継続される。<BR>
	 */
	virtual void declareBlind();

	/**
	 * 自ツリーノードを即座に非表示状態にする .
	 * 自身と自分より下位のノード全てに非表示状態(blindImmediately())が実行される。<BR>
	 * <B>[補足]</B><BR>
	 * processFinal()以外に実装や、this 以外で実行する場合、そのノードの影響を良く考えて注意して使用すること。<BR>
	 */
	virtual void blindImmediately();

	/**
	 * 自ツリーノードを次フレームから非表示解除にする .
	 * 自身と自分より下位のノード全てに非表示解除(非表示())が実行される。<BR>
	 * <B>[補足]</B>declareBlind()を行なわずに本メソッドを呼び出しても何も行いません。<BR>
	 */
	virtual void declareUnblind();

	/**
	 * 自ツリーノードを即座に非表示解除にする .
	 * 自身と自分より下位のノード全てに非表示状態(unblindImmediately())が実行される。<BR>
	 * <B>[補足]</B><BR>
	 * processFinal()以外に実装や、this 以外で実行する場合、そのノードの影響を良く考えて注意して使用すること。<BR>
	 */
	virtual void unblindImmediately();

	/**
	 * 自ツリーノードを次フレームから絶命させる .
	 * 自身と自分より下位のノード全てに人生終了(declareFinishLife())がお知らせが届く。<BR>
	 * 絶命させるとは具体的には、表示フラグ(_wasBlinded)、振る舞いフラグ(_isPlaying)、生存フラグ(_isAlive) を <BR>
	 * 次フレームからアンセットする事である。<BR>
	 * これにより、神(GgafGod)が処理時間の余裕のあるフレームに実行する cleane()時に delete の対象となる。<BR>
	 * したがって、本メンバ関数を実行しても、フラグはアンセットされるため表面にはでませんが、インスタンスがすぐに解放されるとは限りません。<BR>
	 */
	virtual void declareFinishLife();

	/**
	 * 自ツリーノードを最終ノードに順繰りする .
	 * 次フレームの先頭処理(nextFrame())で自ツリーノードを兄弟ノードグループの最終にシフトします。<BR>
	 * <B>[注意]</B>即座に順繰り処理が実行されるわけではありません。<BR>
	 */
	virtual void declareMoveLast();

	/**
	 * 自ツリーノードを先頭ノードに順繰りする .
	 * 次フレームの先頭処理(nextFrame())で自ツリーノードを兄弟ノードグループの先頭にシフトします。<BR>
	 * <B>[注意]</B>即座に順繰り処理が実行されるわけではありません。<BR>
	 */
	virtual void declareMoveFirst();

	/**
	 * 所属ツリーから独立する
	 * @return	T* 脱退し独立した自ノードのポインタ
	 *
	 */
	virtual T* becomeIndependent();

	/**
	 * 生存可能か調べる
	 * @return	bool true:生存可能／false:生存不可
	 */
	virtual bool isAlive();

	/**
	 * 再生中か
	 * @return	bool true:再生中／false:停止中
	 */
	virtual bool isPlaying();

	/**
	 * 描画しているか
	 * @return	bool true:生存可能／false:生存不可
	 */
	virtual bool isBehaving();

	/**
	 * 描画できるか（非表示でないかどうか）
	 * @return	bool true:描画できる／false:描画はしない
	 */
	virtual bool canDraw();


	/**
	 * ノードの現在の経過フレームを取得する
	 */
	virtual DWORD getFrame();


	/**
	 * 相対経過フレームの判定。
	 * 直前の relativeFrame(int) 実行時（結果がtrue/falseに関わらず）のフレーム数からの経過フレーム数に達したか判定する。
	 * 注意：入れ子や条件分岐により、relativeFrame(int) が呼び出される回数が変化する場合、相対経過フレームも変化します。
	 * @param	prm_dwFrame_relative	経過フレーム数
	 * @return	bool	true:経過フレーム数に達した/false:達していない
	 */
	virtual bool relativeFrame(DWORD prm_dwFrame_relative);

};



//////////////////////////////////////////////////////////////////

/**
 * ここからは実装部
 */


template<class T>
GgafFactor<T>::GgafFactor(string prm_name) : SUPER (prm_name),
_pGod(NULL),
_wasInitialized(false),
_pNodeTemp(NULL),
_dwFrame(0),
_dwFrame_relative(0),
_isPlaying(true),
_wasPaused(false),
_wasBlinded(false),
_isAlive(true),
_willPlayNextFrame(true),
_willPauseNextFrame(false),
_willBlindNextFrame(false),
_willBeAliveNextFrame(true),
_willMoveFirstNextFrame(false),
_willMoveLastNextFrame(false),
_willPlayAfterFrame(false),
_dwGodFremeWhenPlay(0),
_willStopAfterFrame(false),
_dwGodFremeWhenStop(0)
{
}


template<class T>
void GgafFactor<T>::initialize() {
}

template<class T>
void GgafFactor<T>::nextFrame() {
	if (_willMoveLastNextFrame) {
		_willMoveLastNextFrame = false;
		SUPER::moveLast();
	} else {

		if(_wasInitialized == false) {
			initialize();
			_wasInitialized = true;
		}

		if (_isAlive) {
			if (_willPlayAfterFrame) {
				//遅延play処理
				if (askGod()->_dwFrame_God == _dwGodFremeWhenPlay) {
					playImmediately();
					_willPlayAfterFrame = false;
				}
			} else if (_willStopAfterFrame) {
				//遅延stop処理
				if (askGod()->_dwFrame_God == _dwGodFremeWhenPlay) {
					stopImmediately();
					_willStopAfterFrame = false;
				}
			}
			if (_isPlaying) {
				_dwFrame++;
			}
		}

		//フラグたちを反映
		if (_isPlaying == false && _willPlayNextFrame) {
			// not Play → Play 状態の場合呼び出す
			happen(HAPPEN_PLAY_BEGIN);
		}
		_isPlaying = _willPlayNextFrame;
		_wasPaused = _willPauseNextFrame;
		_wasBlinded = _willBlindNextFrame;
		_isAlive = _willBeAliveNextFrame;

		if (SUPER::_pSubFirst != NULL) {
			_pNodeTemp = SUPER::_pSubFirst;
			while(true) {
				if (_pNodeTemp -> _isLast) {
					_pNodeTemp -> nextFrame();
					break;
				} else {
					_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
					_pNodeTemp -> SUPER::_pPrev-> nextFrame();
				}
			}
		}

		if (_willMoveFirstNextFrame) {
			_willMoveFirstNextFrame = false;
			SUPER::moveFirst();
		}

	}
}

template<class T>
void GgafFactor<T>::behave() {
	if(_wasInitialized == false) {
		initialize();
		_wasInitialized = true;
	}

	if (_isPlaying && !_wasPaused && _isAlive) {
		_dwFrame_relative = 0;
		processBehavior();
		if (SUPER::_pSubFirst != NULL) {
			_pNodeTemp = SUPER::_pSubFirst;
			while(true) {
				_pNodeTemp -> behave();
				if (_pNodeTemp -> _isLast) {
					break;
				} else {
					_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
				}
			}
		}
	}
}

template<class T>
void GgafFactor<T>::judge() {
	if(_wasInitialized == false) {
		initialize();
		_wasInitialized = true;
	}

	if (_isPlaying && !_wasPaused && _isAlive) {
		_dwFrame_relative = 0;
		processJudgement();
		if (SUPER::_pSubFirst != NULL) {
			_pNodeTemp = SUPER::_pSubFirst;
			while(true) {
				_pNodeTemp -> judge();
				if (_pNodeTemp -> _isLast) {
					break;
				} else {
					_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
				}
			}
		}
	}
}


template<class T>
void GgafFactor<T>::drawPrior() {
	if(_wasInitialized == false) {
		initialize();
		_wasInitialized = true;
	}

	if (_isPlaying && !_wasBlinded && _isAlive) {
		_dwFrame_relative = 0;
		processDrawPrior();
		if (SUPER::_pSubFirst != NULL) {
			_pNodeTemp = SUPER::_pSubFirst;
			while(true) {
				_pNodeTemp -> drawPrior();
				if (_pNodeTemp -> _isLast) {
					break;
				} else {
					_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
				}
			}
		}
	}
}


template<class T>
void GgafFactor<T>::drawMain() {
	if(_wasInitialized == false) {
		initialize();
		_wasInitialized = true;
	}

	if (_isPlaying && !_wasBlinded && _isAlive) {
		_dwFrame_relative = 0;
		processDrawMain();
		if (SUPER::_pSubFirst != NULL) {
			_pNodeTemp = SUPER::_pSubFirst;
			while(true) {
				_pNodeTemp -> drawMain();
				if (_pNodeTemp -> _isLast) {
					break;
				} else {
					_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
				}
			}
		}
	}
}


template<class T>
void GgafFactor<T>::drawTerminate() {
	if(_wasInitialized == false) {
		initialize();
		_wasInitialized = true;
	}

	if (_isPlaying && !_wasBlinded && _isAlive) {
		_dwFrame_relative = 0;
		processDrawTerminate();
		if (SUPER::_pSubFirst != NULL) {
			_pNodeTemp = SUPER::_pSubFirst;
			while(true) {
				_pNodeTemp -> drawTerminate();
				if (_pNodeTemp -> _isLast) {
					break;
				} else {
					_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
				}
			}
		}
	}
}


template<class T>
void GgafFactor<T>::happen(int prm_no) {
	if(_wasInitialized == false) {
		initialize();
		_wasInitialized = true;
	}

	if (_isAlive) {
		_dwFrame_relative = 0;
		processHappen(prm_no);
		if (SUPER::_pSubFirst != NULL) {
			_pNodeTemp = SUPER::_pSubFirst;
			while(true) {
				_pNodeTemp -> happen(prm_no);
				if (_pNodeTemp -> _isLast) {
					break;
				} else {
					_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
				}
			}
		}
	}
}


template<class T>
void GgafFactor<T>::finally() {
	if(_wasInitialized == false) {
		initialize();
		_wasInitialized = true;
	}

	if (_isPlaying && !_wasPaused && _isAlive) {
		_dwFrame_relative = 0;
		processFinal();
		if (SUPER::_pSubFirst != NULL) {
			_pNodeTemp = SUPER::_pSubFirst;
			while(true) {
				_pNodeTemp -> finally();
				if (_pNodeTemp -> _isLast) {
					break;
				} else {
					_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
				}
			}
		}
	}
}


template<class T>
void GgafFactor<T>::declarePlay() {
	if (_isAlive) {
		_willPlayNextFrame = true;
		_willPauseNextFrame = false;
		_willBlindNextFrame = false;
		if (SUPER::_pSubFirst != NULL) {
			_pNodeTemp = SUPER::_pSubFirst;
			while(true) {
				_pNodeTemp -> declarePlay();
				if (_pNodeTemp -> _isLast) {
					break;
				} else {
					_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
				}
			}
		}
	}
}

template<class T>
void GgafFactor<T>::playImmediately() {
	if (_isAlive) {
		if (_isPlaying == false) {
			happen(HAPPEN_PLAY_BEGIN);
		}
		_isPlaying = true;
		_wasPaused = false;
		_wasBlinded = false;
		_willPlayNextFrame = true;
		_willPauseNextFrame = false;
		_willBlindNextFrame = false;
		if (SUPER::_pSubFirst != NULL) {
			_pNodeTemp = SUPER::_pSubFirst;
			while(true) {
				_pNodeTemp -> playImmediately();
				if (_pNodeTemp -> _isLast) {
					break;
				} else {
					_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
				}
			}
		}
	}
}

template<class T>
void GgafFactor<T>::playAfter(DWORD prm_dwFrameOffset) {
	_willPlayAfterFrame = true;
	_dwGodFremeWhenPlay = askGod()->_dwFrame_God + prm_dwFrameOffset;
}


template<class T>
void GgafFactor<T>::declareStop() {
	if (_isAlive) {
		_willPlayNextFrame = false;
		if (SUPER::_pSubFirst != NULL) {
			_pNodeTemp = SUPER::_pSubFirst;
			while(true) {
				_pNodeTemp -> declareStop();
				if (_pNodeTemp -> _isLast) {
					break;
				} else {
					_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
				}
			}
		}
	}
}

template<class T>
void GgafFactor<T>::stopAfter(DWORD prm_dwFrameOffset) {
	_willStopAfterFrame = true;
	_dwGodFremeWhenStop = askGod()->_dwFrame_God + prm_dwFrameOffset;
}

template<class T>
void GgafFactor<T>::stopImmediately() {
	if (_isAlive) {
		_isPlaying = false;
		_willPlayNextFrame = false;
		if (SUPER::_pSubFirst != NULL) {
			_pNodeTemp = SUPER::_pSubFirst;
			while(true) {
				_pNodeTemp -> stopImmediately();
				if (_pNodeTemp -> _isLast) {
					break;
				} else {
					_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
				}
			}
		}
	}
}


template<class T>
void GgafFactor<T>::declarePause() {
	if (_isAlive) {
		_willPauseNextFrame = true;
		_isPlaying = false;
		if (SUPER::_pSubFirst != NULL) {
			_pNodeTemp = SUPER::_pSubFirst;
			while(true) {
				_pNodeTemp -> declarePause();
				if (_pNodeTemp -> _isLast) {
					break;
				} else {
					_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
				}
			 }
		}
	}
}

template<class T>
void GgafFactor<T>::pauseImmediately() {
	if (_isAlive) {
		_wasPaused = true;
		_willPauseNextFrame = true;
		_isPlaying = false;
		if (SUPER::_pSubFirst != NULL) {
			_pNodeTemp = SUPER::_pSubFirst;
			while(true) {
				_pNodeTemp -> pauseImmediately();
				if (_pNodeTemp -> _isLast) {
					break;
				} else {
					_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
				}
			 }
		}
	}
}

template<class T>
void GgafFactor<T>::declareUnpause() {
	if (_isAlive) {
		_willPauseNextFrame = false;
		if (SUPER::_pSubFirst != NULL) {
			_pNodeTemp = SUPER::_pSubFirst;
			while(true) {
				_pNodeTemp -> declareUnpause();
				if (_pNodeTemp -> _isLast) {
					break;
				} else {
					_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
				}
			}
		}
	}
}

template<class T>
void GgafFactor<T>::unpauseImmediately() {
	if (_isAlive) {
		_wasPaused = false;
		_willPauseNextFrame = false;
		if (SUPER::_pSubFirst != NULL) {
			_pNodeTemp = SUPER::_pSubFirst;
			while(true) {
				_pNodeTemp -> unpauseImmediately();
				if (_pNodeTemp -> _isLast) {
					break;
				} else {
					_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
				}
			}
		}
	}
}

template<class T>
void GgafFactor<T>::declareBlind() {
	if (_isAlive) {
		_willBlindNextFrame = true;
		if (SUPER::_pSubFirst != NULL) {
			_pNodeTemp = SUPER::_pSubFirst;
			while(true) {
				_pNodeTemp -> declareBlind();
				if (_pNodeTemp -> _isLast) {
					break;
				} else {
					_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
				}
			}
		}
	}
}

template<class T>
void GgafFactor<T>::blindImmediately() {
	if (_isAlive) {
		_wasBlinded = true;
		_willBlindNextFrame = true;
		if (SUPER::_pSubFirst != NULL) {
			_pNodeTemp = SUPER::_pSubFirst;
			while(true) {
				_pNodeTemp -> blindImmediately();
				if (_pNodeTemp -> _isLast) {
					break;
				} else {
					_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
				}
			}
		}
	}
}

template<class T>
void GgafFactor<T>::declareUnblind() {
	if (_isAlive) {
		_willBlindNextFrame = false;
		if (SUPER::_pSubFirst != NULL) {
			_pNodeTemp = SUPER::_pSubFirst;
			while(true) {
				_pNodeTemp -> declareUnblind();
				if (_pNodeTemp -> _isLast) {
					break;
				} else {
					_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
				}
			}
		}
	}
}

template<class T>
void GgafFactor<T>::unblindImmediately() {
	if (_isAlive) {
		_wasBlinded = false;
		_willBlindNextFrame = false;
		if (SUPER::_pSubFirst != NULL) {
			_pNodeTemp = SUPER::_pSubFirst;
			while(true) {
				_pNodeTemp -> unblindImmediately();
				if (_pNodeTemp -> _isLast) {
					break;
				} else {
					_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
				}
			}
		}
	}
}

template<class T>
void GgafFactor<T>::declareFinishLife() {
	_TRACE_("GgafFactor<"<<SUPER::_class_name << ">::declareFinishLife() :"<< SUPER::getName());
	_willPlayNextFrame = false;
	_willBeAliveNextFrame = false;
	SUPER::_name = "_x_"+SUPER::_name;
	if (SUPER::_pSubFirst != NULL) {
		_pNodeTemp = SUPER::_pSubFirst;
		while(true) {
			_pNodeTemp -> declareFinishLife();
			if (_pNodeTemp -> _isLast) {
				break;
			} else {
				_pNodeTemp = _pNodeTemp -> SUPER::_pNext;
			}
		}
	}
}

template<class T>
DWORD GgafFactor<T>::getFrame() {
	return _dwFrame;
}

template<class T>
bool GgafFactor<T>::isAlive() {
	return _isAlive;
}

template<class T>
bool GgafFactor<T>::isPlaying() {
	if (_isAlive && _isPlaying) {
		return true;
	} else {
		return false;
	}
}

template<class T>
bool GgafFactor<T>::canDraw() {
	if (_isAlive && _isPlaying && !_wasBlinded) {
		return true;
	} else {
		return false;
	}
}

template<class T>
bool GgafFactor<T>::isBehaving() {
	if (_isAlive && _isPlaying && !_wasPaused) {
		return true;
	} else {
		return false;
	}
}

template<class T>
bool GgafFactor<T>::relativeFrame(DWORD prm_dwFrame_relative) {
	_dwFrame_relative += prm_dwFrame_relative;
	if (_dwFrame == _dwFrame_relative) {
		return true;
	} else {
		return false;
	}
}

template<class T>
void GgafFactor<T>::declareMoveLast() {
	_willMoveLastNextFrame = true;
}

template<class T>
void GgafFactor<T>::declareMoveFirst() {
	_willMoveFirstNextFrame = true;
}

template<class T>
T* GgafFactor<T>::becomeIndependent() {
	if (_isAlive) {
		return SUPER::tear();
	} else {
		throw_GgafCriticalException("[GgafTreeNode<"<<SUPER::_class_name<<">::becomeIndependent()] ＜警告＞ "<<SUPER::getName()<<"は、いずれ死に行く運命です。");
	}
}



template<class T>
void GgafFactor<T>::cleane() {
	if (SUPER::_pSubFirst == NULL || GgafGod::_iNumClean_Node != 0) {
		return;
	}

	if (_isAlive == false) {
		throw_GgafCriticalException("[GgafFactor<"<<SUPER::_class_name<<">::cleane()] Error! 自殺しなければいけません。その前に親にcleanされるはずです。おかしいです。(name="<<SUPER::getName()+")");
	}

	//子を調べてdeleteする
	_pNodeTemp = SUPER::_pSubFirst -> SUPER::_pPrev;
	while(GgafGod::_iNumClean_Node == 0) {
		if (_pNodeTemp->_isFirst) { //末尾から見て行き最後の一つ

			if (_pNodeTemp->_isAlive == false) {
				delete (_pNodeTemp);
				GgafGod::_iNumClean_Node++;
			}
			break;
		} else { //末尾から順に見ていく
			_pNodeTemp = _pNodeTemp -> SUPER::_pPrev;
			if (_pNodeTemp->SUPER::_pNext->_isAlive == false) {
				delete (_pNodeTemp->SUPER::_pNext);
				GgafGod::_iNumClean_Node++;
			}
		}
	}

	//子がまだのっている場合さらにもぐる
	if (SUPER::_pSubFirst != NULL) {
		_pNodeTemp = SUPER::_pSubFirst;
		while(true) {
			_pNodeTemp -> cleane();
			if (_pNodeTemp -> _isLast) {
				break;
			} else {
				_pNodeTemp = _pNodeTemp -> SUPER::_pNext;

			}
		}
	}
}



template<class T>
GgafFactor<T>::~GgafFactor() {
}

#endif /*GGAFFACTOR_H_*/
